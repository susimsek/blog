package graph

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.81

import (
	"context"
	"fmt"
	"strings"

	newslettersvc "suaybsimsek.com/blog-api/internal/newsletter"
	postsapi "suaybsimsek.com/blog-api/internal/posts"
	"suaybsimsek.com/blog-api/pkg/graph/generated"
	"suaybsimsek.com/blog-api/pkg/graph/model"
)

// Posts is the resolver for the posts field.
func (r *queryResolver) Posts(ctx context.Context, locale string, input *model.PostsQueryInput) (*model.PostConnection, error) {
	normalizedLocale := strings.TrimSpace(locale)
	if normalizedLocale == "" {
		return nil, fmt.Errorf("locale is required")
	}

	queryInput := postsapi.ContentQueryInput{
		Locale: normalizedLocale,
	}
	if input != nil {
		if input.Page != nil {
			queryInput.Page = input.Page
		}
		if input.Size != nil {
			queryInput.Size = input.Size
		}
		if sortOrder := mapSortOrder(input.Sort); sortOrder != "" {
			queryInput.Sort = sortOrder
		}
		queryInput.ScopeIDs = append([]string{}, input.ScopeIds...)
	}

	payload := postsapi.QueryContent(ctx, queryInput)
	status := strings.TrimSpace(payload.Status)
	if status == "" {
		status = "success"
	}

	total := payload.Total
	if total < 0 {
		total = 0
	}

	page := payload.Page
	if page <= 0 {
		page = 1
	}

	size := payload.Size
	if size <= 0 {
		size = len(payload.Posts)
		if size <= 0 {
			size = 1
		}
	}

	return &model.PostConnection{
		Status:     status,
		Locale:     toOptionalString(payload.Locale),
		Nodes:      mapPosts(payload.Posts),
		Engagement: mapEngagement(payload.LikesByPostID, payload.HitsByPostID),
		Total:      total,
		Page:       page,
		Size:       size,
		Sort:       toOptionalString(payload.Sort),
	}, nil
}

// Post is the resolver for the post field.
func (r *queryResolver) Post(ctx context.Context, locale string, id string) (*model.PostResult, error) {
	normalizedLocale := strings.TrimSpace(locale)
	if normalizedLocale == "" {
		return nil, fmt.Errorf("locale is required")
	}

	normalizedID := strings.TrimSpace(id)
	if normalizedID == "" {
		return nil, fmt.Errorf("id is required")
	}

	payload := postsapi.QueryPost(ctx, postsapi.PostQueryInput{
		Locale: normalizedLocale,
		PostID: normalizedID,
	})
	status := strings.TrimSpace(payload.Status)
	if status == "" {
		status = "failed"
	}

	var node *model.Post
	mappedNodes := mapPosts(payload.Posts)
	if len(mappedNodes) > 0 {
		node = mappedNodes[0]
	}

	var engagement *model.PostEngagement
	mappedEngagement := mapEngagement(payload.LikesByPostID, payload.HitsByPostID)
	if len(mappedEngagement) > 0 {
		engagement = mappedEngagement[0]
	}

	return &model.PostResult{
		Status:     status,
		Locale:     toOptionalString(payload.Locale),
		Node:       node,
		Engagement: engagement,
	}, nil
}

// IncrementPostLike is the resolver for the incrementPostLike field.
func (r *mutationResolver) IncrementPostLike(ctx context.Context, postID string) (*model.PostMetricResult, error) {
	payload := postsapi.IncrementLike(ctx, postID)
	resolvedPostID := strings.TrimSpace(payload.PostID)
	if resolvedPostID == "" {
		resolvedPostID = strings.TrimSpace(postID)
	}

	result := &model.PostMetricResult{
		Status: strings.TrimSpace(payload.Status),
		PostID: resolvedPostID,
	}
	if result.Status == "" {
		result.Status = "failed"
	}
	if payload.Likes > 0 || result.Status == "success" {
		likes := toGraphQLInt(payload.Likes)
		result.Likes = &likes
	}
	if payload.Hits > 0 || result.Status == "success" {
		hits := toGraphQLInt(payload.Hits)
		result.Hits = &hits
	}

	return result, nil
}

// IncrementPostHit is the resolver for the incrementPostHit field.
func (r *mutationResolver) IncrementPostHit(ctx context.Context, postID string) (*model.PostMetricResult, error) {
	payload := postsapi.IncrementHit(ctx, postID)
	resolvedPostID := strings.TrimSpace(payload.PostID)
	if resolvedPostID == "" {
		resolvedPostID = strings.TrimSpace(postID)
	}

	result := &model.PostMetricResult{
		Status: strings.TrimSpace(payload.Status),
		PostID: resolvedPostID,
	}
	if result.Status == "" {
		result.Status = "failed"
	}
	if payload.Likes > 0 || result.Status == "success" {
		likes := toGraphQLInt(payload.Likes)
		result.Likes = &likes
	}
	if payload.Hits > 0 || result.Status == "success" {
		hits := toGraphQLInt(payload.Hits)
		result.Hits = &hits
	}

	return result, nil
}

// SubscribeNewsletter is the resolver for the subscribeNewsletter field.
func (r *mutationResolver) SubscribeNewsletter(
	ctx context.Context,
	input model.NewsletterSubscribeInput,
) (*model.NewsletterMutationResult, error) {
	payload := newslettersvc.Subscribe(
		ctx,
		newslettersvc.SubscribeInput{
			Locale:   strings.TrimSpace(input.Locale),
			Email:    strings.TrimSpace(input.Email),
			Terms:    input.Terms,
			Tags:     append([]string{}, input.Tags...),
			FormName: strings.TrimSpace(toOptionalStringValue(input.FormName)),
		},
		getRequestMetadata(ctx),
	)

	return &model.NewsletterMutationResult{
		Status:    strings.TrimSpace(payload.Status),
		ForwardTo: toOptionalString(payload.ForwardTo),
	}, nil
}

// ResendNewsletterConfirmation is the resolver for the resendNewsletterConfirmation field.
func (r *mutationResolver) ResendNewsletterConfirmation(
	ctx context.Context,
	input model.NewsletterResendInput,
) (*model.NewsletterMutationResult, error) {
	payload := newslettersvc.Resend(
		ctx,
		newslettersvc.ResendInput{
			Locale: strings.TrimSpace(input.Locale),
			Email:  strings.TrimSpace(input.Email),
			Terms:  input.Terms,
		},
		getRequestMetadata(ctx),
	)

	return &model.NewsletterMutationResult{
		Status: strings.TrimSpace(payload.Status),
	}, nil
}

// ConfirmNewsletterSubscription is the resolver for the confirmNewsletterSubscription field.
func (r *mutationResolver) ConfirmNewsletterSubscription(
	ctx context.Context,
	token string,
) (*model.NewsletterMutationResult, error) {
	payload := newslettersvc.Confirm(ctx, strings.TrimSpace(token))
	return &model.NewsletterMutationResult{
		Status: strings.TrimSpace(payload.Status),
	}, nil
}

// UnsubscribeNewsletter is the resolver for the unsubscribeNewsletter field.
func (r *mutationResolver) UnsubscribeNewsletter(
	ctx context.Context,
	token string,
) (*model.NewsletterMutationResult, error) {
	payload := newslettersvc.Unsubscribe(ctx, strings.TrimSpace(token))
	return &model.NewsletterMutationResult{
		Status: strings.TrimSpace(payload.Status),
	}, nil
}

// Mutation returns generated.MutationResolver implementation.
func (r *Resolver) Mutation() generated.MutationResolver { return &mutationResolver{r} }

// Query returns generated.QueryResolver implementation.
func (r *Resolver) Query() generated.QueryResolver { return &queryResolver{r} }

type mutationResolver struct{ *Resolver }
type queryResolver struct{ *Resolver }

func toOptionalStringValue(value *string) string {
	if value == nil {
		return ""
	}
	return *value
}
