<?xml version="1.0" encoding="UTF-8"?>
<?xml-stylesheet type="text/xsl" href="/rss.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:media="http://search.yahoo.com/mrss/" xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title><![CDATA[≈ûuayb's Blog]]></title>
    <link>https://suaybsimsek.com/en</link>
    <description><![CDATA[Explore the latest articles, tutorials, and insights.]]></description>
    <docs>https://www.rssboard.org/rss-specification</docs>
    <generator><![CDATA[≈ûuayb's Blog RSS Generator]]></generator>
    <ttl>60</ttl>
    <pubDate>Wed, 04 Feb 2026 00:00:00 GMT</pubDate>
    <lastBuildDate>Wed, 11 Feb 2026 06:28:16 GMT</lastBuildDate>
    <language>en-US</language>
    <copyright><![CDATA[¬© 2024 ≈ûuayb ≈ûim≈üek. All rights reserved.]]></copyright>
    <image>
      <url>https://suaybsimsek.com/images/logo.webp</url>
      <title><![CDATA[≈ûuayb's Blog]]></title>
      <link>https://suaybsimsek.com/en</link>
    </image>
    <atom:link rel="self" type="application/rss+xml" href="https://suaybsimsek.com/en/rss.xml" />
    <atom:link rel="alternate" hreflang="tr" type="application/rss+xml" href="https://suaybsimsek.com/tr/rss.xml" />
    <item>
      <title><![CDATA[Spring Boot Configuration Properties]]></title>
      <link>https://suaybsimsek.com/en/posts/spring-boot-configuration-properties</link>
      <description><![CDATA[Learn how to use @ConfigurationProperties for type-safe configuration, validate settings with @Validated, and manage environment-specific values with profile-specific application-{profile}.yml files.]]></description>
      <pubDate>Wed, 04 Feb 2026 00:00:00 GMT</pubDate>
      <guid isPermaLink="true">https://suaybsimsek.com/en/posts/spring-boot-configuration-properties</guid>
      <content:encoded><![CDATA[<p>If you‚Äôve ever ended up with a dozen `@Value` annotations and no idea which settings are required, `@ConfigurationProperties` is the Spring Boot way to make configuration type-safe, structured, and validatable.</p>
<p>In this post, you‚Äôll learn:</p>
<ul>
<li>How to model configuration as a class (Java/Kotlin)</li>
<li>How to validate configuration at startup</li>
<li>How profile-specific config files (`application-{profile}.yml`) override defaults</li>
</ul>
<hr />
<h2>üåü Why `@ConfigurationProperties`?</h2>
<ul>
<li>‚úÖ Type-safe access to config (IDE autocomplete, refactoring-safe)</li>
<li>‚úÖ Group and document related settings under a single prefix</li>
<li>‚úÖ Validate misconfigurations early (fail fast on startup)</li>
</ul>
<hr />
<h2>üìã Prerequisites</h2>
<ul>
<li>Java 17+</li>
<li>Spring Boot 3.x</li>
<li>Maven or Gradle</li>
</ul>
<hr />
<h2>üõ†Ô∏è Step 1: Define configuration in `application.yml`</h2>
<p>Create a namespace (prefix) for your app config, for example `app`:</p>
<pre><code class="language-yaml">app:
  security:
    enabled: true
    token-expiry-seconds: 3600
  allowed-origins:
    - &#39;https://example.com&#39;
    - &#39;http://localhost:3000&#39;</code></pre>
<hr />
<h2>üõ†Ô∏è Step 2: Create a `@ConfigurationProperties` class</h2>
<h3>Java</h3>
<pre><code class="language-java">import java.util.List;

import org.springframework.boot.context.properties.ConfigurationProperties;

@ConfigurationProperties(prefix = &quot;app&quot;)
public class AppProperties {

  private Security security = new Security();
  private List&lt;String&gt; allowedOrigins = List.of();

  public Security getSecurity() {
    return security;
  }

  public void setSecurity(Security security) {
    this.security = security;
  }

  public List&lt;String&gt; getAllowedOrigins() {
    return allowedOrigins;
  }

  public void setAllowedOrigins(List&lt;String&gt; allowedOrigins) {
    this.allowedOrigins = allowedOrigins;
  }

  public static class Security {
    private boolean enabled = true;
    private int tokenExpirySeconds = 3600;

    public boolean isEnabled() {
      return enabled;
    }

    public void setEnabled(boolean enabled) {
      this.enabled = enabled;
    }

    public int getTokenExpirySeconds() {
      return tokenExpirySeconds;
    }

    public void setTokenExpirySeconds(int tokenExpirySeconds) {
      this.tokenExpirySeconds = tokenExpirySeconds;
    }
  }
}</code></pre>
<h3>Kotlin</h3>
<pre><code class="language-kotlin">import org.springframework.boot.context.properties.ConfigurationProperties

@ConfigurationProperties(prefix = &quot;app&quot;)
data class AppProperties(
  val security: Security = Security(),
  val allowedOrigins: List&lt;String&gt; = emptyList(),
) {
  data class Security(
    val enabled: Boolean = true,
    val tokenExpirySeconds: Int = 3600,
  )
}</code></pre>
<hr />
<h2>üõ†Ô∏è Step 3: Enable configuration properties</h2>
<p>You have two common options:</p>
<p>1. Scan for `@ConfigurationProperties` types:</p>
<pre><code class="language-java">import org.springframework.boot.autoconfigure.SpringBootApplication;
import org.springframework.boot.context.properties.ConfigurationPropertiesScan;

@SpringBootApplication
@ConfigurationPropertiesScan
public class DemoApplication {}</code></pre>
<p>2. Register specific classes explicitly:</p>
<pre><code class="language-java">import org.springframework.boot.autoconfigure.SpringBootApplication;
import org.springframework.boot.context.properties.EnableConfigurationProperties;

@SpringBootApplication
@EnableConfigurationProperties(AppProperties.class)
public class DemoApplication {}</code></pre>
<hr />
<h2>üõ†Ô∏è Step 4: Validate properties at startup (fail fast)</h2>
<p>Add validation constraints and annotate the class with `@Validated`.</p>
<h3>Java</h3>
<pre><code class="language-java">import java.util.List;

import jakarta.validation.Valid;
import jakarta.validation.constraints.Min;
import jakarta.validation.constraints.NotEmpty;

import org.springframework.boot.context.properties.ConfigurationProperties;
import org.springframework.validation.annotation.Validated;

@ConfigurationProperties(prefix = &quot;app&quot;)
@Validated
public class AppProperties {

  @Valid
  private Security security = new Security();

  @NotEmpty
  private List&lt;String&gt; allowedOrigins = List.of();

  public Security getSecurity() { return security; }
  public void setSecurity(Security security) { this.security = security; }

  public List&lt;String&gt; getAllowedOrigins() { return allowedOrigins; }
  public void setAllowedOrigins(List&lt;String&gt; allowedOrigins) { this.allowedOrigins = allowedOrigins; }

  public static class Security {
    private boolean enabled = true;

    @Min(60)
    private int tokenExpirySeconds = 3600;

    public boolean isEnabled() { return enabled; }
    public void setEnabled(boolean enabled) { this.enabled = enabled; }

    public int getTokenExpirySeconds() { return tokenExpirySeconds; }
    public void setTokenExpirySeconds(int tokenExpirySeconds) { this.tokenExpirySeconds = tokenExpirySeconds; }
  }
}</code></pre>
<h3>Kotlin</h3>
<pre><code class="language-kotlin">import jakarta.validation.Valid
import jakarta.validation.constraints.Min
import jakarta.validation.constraints.NotEmpty
import org.springframework.boot.context.properties.ConfigurationProperties
import org.springframework.validation.annotation.Validated

@ConfigurationProperties(prefix = &quot;app&quot;)
@Validated
data class AppProperties(
  @field:Valid
  val security: Security = Security(),

  @field:NotEmpty
  val allowedOrigins: List&lt;String&gt; = emptyList(),
) {
  data class Security(
    val enabled: Boolean = true,

    @field:Min(60)
    val tokenExpirySeconds: Int = 3600,
  )
}</code></pre>
<p>Note: you need a Bean Validation implementation on the classpath (e.g., `spring-boot-starter-validation`) for these constraints to be enforced.</p>
<hr />
<h2>üõ†Ô∏è Step 5: Use profile-specific files (`application-{profile}.yml`)</h2>
<p>Spring Boot loads `application.yml` and then applies profile-specific overrides.</p>
<p>Example:</p>
<ul>
<li>`application.yml` (defaults)</li>
<li>`application-prod.yml` (production overrides)</li>
</ul>
<pre><code class="language-yaml"># application-prod.yml
app:
  security:
    enabled: true
  allowed-origins:
    - &#39;https://mycompany.com&#39;</code></pre>
<p>When multiple profiles are active, profile files are applied with a ‚Äúlast wins‚Äù strategy (the last active profile can override earlier ones).</p>
<hr />
<h2>üåü Tips</h2>
<ul>
<li>Prefer `@ConfigurationProperties` over scattered `@Value` for anything non-trivial.</li>
<li>Keep a single `AppProperties` root per bounded domain (`security`, `mail`, `storage`, etc.).</li>
<li>Add validation constraints for anything that must not be empty or must be within a safe range.</li>
</ul>
<hr />
<h2>üèÅ Conclusion</h2>
<p>This setup delivers a robust, production-ready configuration layer in Spring Boot by combining @ConfigurationProperties, startup validation with @Validated, and profile-specific overrides‚Äîmaking your app safer to operate across environments.</p>]]></content:encoded>
      <category><![CDATA[Java]]></category>
      <category><![CDATA[Kotlin]]></category>
      <category><![CDATA[Spring Boot]]></category>
      <category><![CDATA[Configuration]]></category>
      <category><![CDATA[Programming]]></category>
      <media:thumbnail url="https://suaybsimsek.com/images/spring-boot-configuration-properties-thumbnail.webp" />
    </item>
    <item>
      <title><![CDATA[Spring Boot GraphQL JWE Authentication]]></title>
      <link>https://suaybsimsek.com/en/posts/spring-boot-graphql-jwe-authentication</link>
      <description><![CDATA[Learn how to secure your Spring Boot GraphQL APIs with stateless encrypted JWTs (JWE) while persisting user identities and roles in a JPA-backed database.]]></description>
      <pubDate>Sat, 17 May 2025 00:00:00 GMT</pubDate>
      <guid isPermaLink="true">https://suaybsimsek.com/en/posts/spring-boot-graphql-jwe-authentication</guid>
      <content:encoded><![CDATA[<p>Spring Boot GraphQL JWE Authentication combines the flexibility of GraphQL with stateless encrypted JWTs (JWE) and a JPA-backed user store to deliver a secure, scalable API.</p>
<hr />
<h2>üåü Why Use GraphQL + JWE Authentication?</h2>
<ul>
<li>Stateless Security: Tokens are self-contained and require no server-side storage.</li>
<li>GraphQL Flexibility: Secure any query or mutation uniformly.</li>
<li>Data Precision: Fetch exactly what clients request.</li>
<li>Integrity: Signed tokens ensure tamper evidence.</li>
<li>Confidentiality: Encrypted JWTs hide sensitive claims.</li>
<li>Standards-based: Leverage JOSE, Spring Security, and GraphQL.</li>
<li>Scalable: Scale horizontally without session replication or sticky sessions.</li>
</ul>
<hr />
<h2>üìã Prerequisites</h2>
<ul>
<li>‚òï Java Development Kit (JDK) 17 or higher</li>
<li>üì¶ Spring Boot 3.2+</li>
<li>üî§ IDE (IntelliJ IDEA, Eclipse)</li>
<li>üõ¢Ô∏è PostgreSQL (or H2 for dev)</li>
</ul>
<hr />
<h2>üõ†Ô∏è Step 1: Add Dependencies</h2>
<p>Include these in your `pom.xml` or `build.gradle` file.</p>
<p>Maven:</p>
<pre><code class="language-xml">&lt;dependencies&gt;
  &lt;dependency&gt;
    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
    &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;
  &lt;/dependency&gt;
  &lt;dependency&gt;
    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
    &lt;artifactId&gt;spring-boot-starter-websocket&lt;/artifactId&gt;
  &lt;/dependency&gt;
  &lt;dependency&gt;
    &lt;groupId&gt;org.springframework.security&lt;/groupId&gt;
    &lt;artifactId&gt;spring-security-oauth2-resource-server&lt;/artifactId&gt;
  &lt;/dependency&gt;
  &lt;dependency&gt;
    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
    &lt;artifactId&gt;spring-boot-starter-data-jpa&lt;/artifactId&gt;
  &lt;/dependency&gt;
  &lt;dependency&gt;
    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
    &lt;artifactId&gt;spring-boot-starter-graphql&lt;/artifactId&gt;
  &lt;/dependency&gt;
  &lt;dependency&gt;
    &lt;groupId&gt;com.graphql-java&lt;/groupId&gt;
    &lt;artifactId&gt;graphql-java-extended-scalars&lt;/artifactId&gt;
    &lt;version&gt;22.0&lt;/version&gt;
  &lt;/dependency&gt;
  &lt;dependency&gt;
    &lt;groupId&gt;org.liquibase&lt;/groupId&gt;
    &lt;artifactId&gt;liquibase-core&lt;/artifactId&gt;
  &lt;/dependency&gt;
  &lt;dependency&gt;
    &lt;groupId&gt;org.projectlombok&lt;/groupId&gt;
    &lt;artifactId&gt;lombok&lt;/artifactId&gt;
    &lt;optional&gt;true&lt;/optional&gt;
  &lt;/dependency&gt;
  &lt;dependency&gt;
    &lt;groupId&gt;com.h2database&lt;/groupId&gt;
    &lt;artifactId&gt;h2&lt;/artifactId&gt;
    &lt;scope&gt;runtime&lt;/scope&gt;
  &lt;/dependency&gt;
&lt;/dependencies&gt;

&lt;build&gt;
&lt;plugins&gt;
  &lt;plugin&gt;
    &lt;groupId&gt;org.hibernate.orm.tooling&lt;/groupId&gt;
    &lt;artifactId&gt;hibernate-enhance-maven-plugin&lt;/artifactId&gt;
    &lt;version&gt;${hibernate.version}&lt;/version&gt;
    &lt;executions&gt;
      &lt;execution&gt;
        &lt;id&gt;enhance&lt;/id&gt;
        &lt;goals&gt;
          &lt;goal&gt;enhance&lt;/goal&gt;
        &lt;/goals&gt;
        &lt;configuration&gt;
          &lt;enableLazyInitialization&gt;true&lt;/enableLazyInitialization&gt;
          &lt;enableDirtyTracking&gt;true&lt;/enableDirtyTracking&gt;
          &lt;enableAssociationManagement&gt;true&lt;/enableAssociationManagement&gt;
        &lt;/configuration&gt;
      &lt;/execution&gt;
    &lt;/executions&gt;
  &lt;/plugin&gt;
  &lt;plugin&gt;
    &lt;groupId&gt;org.graalvm.buildtools&lt;/groupId&gt;
    &lt;artifactId&gt;native-maven-plugin&lt;/artifactId&gt;
  &lt;/plugin&gt;
&lt;/plugins&gt;
&lt;/build&gt;</code></pre>
<p>Gradle:</p>
<pre><code class="language-groovy">dependencies {
  implementation &#39;org.springframework.boot:spring-boot-starter-web&#39;
  implementation &#39;org.springframework.boot:spring-boot-starter-websocket&#39;
  implementation &#39;org.springframework.security:spring-security-oauth2-resource-server&#39;
  implementation &#39;org.springframework.boot:spring-boot-starter-data-jpa&#39;
  implementation &#39;org.springframework.boot:spring-boot-starter-graphql&#39;
  implementation &#39;com.graphql-java:graphql-java-extended-scalars:22.0&#39;
  implementation &#39;org.liquibase:liquibase-core&#39;
  compileOnly &#39;org.projectlombok:lombok&#39;
  runtimeOnly &#39;com.h2database:h2&#39;
}

plugins {
  id &#39;org.hibernate.orm&#39; version &#39;6.6.13.Final&#39;
  id &#39;org.graalvm.buildtools.native&#39; version &#39;0.10.6&#39;
}

hibernate {
  enhancement {
    enableAssociationManagement = true
  }
}</code></pre>
<hr />
<h2>üõ†Ô∏è Step 2: Configuration Files</h2>
<p>In this section, we define all of the application- and database-level configuration files required to wire up our Spring Boot app with H2/PostgreSQL, JPA, Liquibase changelogs, initial data loads, JWE key properties and GraphQL schema definitions, and GraalVM native-image reflection config.</p>
<ul>
<li>`application.yml`</li>
<p>Holds Spring datasource, H2 console, JPA/Hibernate settings, Liquibase changelog path, GraphQL subscriptions path, and all JWT/JWE keys, issuer, and expiration configurations.</p>
</ul>
<ul>
<li>`liquibase/master.xml`</li>
<p>The Liquibase master changelog, with includes and DBMS-specific properties for H2 and PostgreSQL.</p>
</ul>
<ul>
<li>`liquibase/changelog/changelog-user.xml`</li>
<p>Your core schema changelog defining `user_identity`, `authority`, and `user_authority_mapping` tables, indexes, FKs, and initial `&lt;loadData&gt;` steps.</p>
</ul>
<ul>
<li>`liquibase/data/user.csv`</li>
<p>Initial user records (UUID, username, bcrypt-hashed password, email, enabled flag, timestamps, auditor).</p>
</ul>
<ul>
<li>`liquibase/data/authority.csv`</li>
<p>Initial authority records (UUID, name, description, timestamps, auditor).</p>
</ul>
<ul>
<li>`liquibase/data/user_authority_mapping.csv`</li>
<p>Initial mapping of users ‚Üî authorities (composite PK, timestamps, auditor).</p>
</ul>
<ul>
<li>`graphql/schema.graphqls`</li>
<p>GraphQL schema definitions for the API, including custom scalars, query, subscription and mutation types, and DTO definitions.</p>
</ul>
<ul>
<li>`META-INF/native-image/liquibase/reflect-config.json`</li>
<p>Native-image reflection configuration for Liquibase classes to ensure compatibility when building a GraalVM native image.</p>
</ul>
<h3>application.yml</h3>
<pre><code class="language-yaml">spring:
  datasource:
    url: jdbc:h2:mem:testdb;MODE=PostgreSQL;DB_CLOSE_DELAY=-1;DB_CLOSE_ON_EXIT=FALSE
    driver-class-name: org.h2.Driver
    username: sa
    password: password
  h2:
    console:
      enabled: true
  jpa:
    open-in-view: false
    hibernate:
      ddl-auto: none
    show-sql: true
    properties:
      hibernate.format_sql: true
  liquibase:
    change-log: classpath:liquibase/master.xml
  graphql:
    websocket:
      path: /subscriptions
    graphiql:
      enabled: true
security:
  admin:
    username: admin
    password: adminpass
  user:
    username: user
    password: userpass
  jwt:
    issuer: demo-issuer
    expiration-duration: 3600s
    signing:
      key-id: signing-key
      public-key: |-
        -----BEGIN PUBLIC KEY-----
        MIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEAjZEcz5itWkDGOSqZdB5P
        JE0ccOCckskp0hN3kQbT1qnv+9/k66jlWgVi4HSTppwdNF/Ylu5u541Qj+Okyg+u
        8o2PvKo5CfgvTDsFLTrZHUXU6hCSGatLAQoeN6lT8wzov2r4DFecXrIqcO6SvMB5
        ecPqsfiTi4trsNKgJ4cWS6gILH62ISd1ipUadfpnUzDMO1OulV0CJNV6bcBk7Es9
        RW6AHfg9j8osSanpwvRM4MJkB0SRxYUnrN9faGpkBZISZJ8TShhaTHEGfSNgKe5y
        8iu+AMGGZu8DYczVmqS3Ske1fq6y5HEGCma7Mo019GmwKeHBo1obuET6cZRygj4y
        twIDAQAB
        -----END PUBLIC KEY-----
      private-key: |-
        -----BEGIN PRIVATE KEY-----
        MIIEvAIBADANBgkqhkiG9w0BAQEFAASCBKYwggSiAgEAAoIBAQCNkRzPmK1aQMY5
        Kpl0Hk8kTRxw4JySySnSE3eRBtPWqe/73+TrqOVaBWLgdJOmnB00X9iW7m7njVCP
        46TKD67yjY+8qjkJ+C9MOwUtOtkdRdTqEJIZq0sBCh43qVPzDOi/avgMV5xesipw
        7pK8wHl5w+qx+JOLi2uw0qAnhxZLqAgsfrYhJ3WKlRp1+mdTMMw7U66VXQIk1Xpt
        wGTsSz1FboAd+D2PyixJqenC9EzgwmQHRJHFhSes319oamQFkhJknxNKGFpMcQZ9
        I2Ap7nLyK74AwYZm7wNhzNWapLdKR7V+rrLkcQYKZrsyjTX0abAp4cGjWhu4RPpx
        lHKCPjK3AgMBAAECggEABMo/sNCIMREXA/EqjxDFecN4LmOTOK5A0YBiH9Cc01sd
        qSaavtSQqhqbjV+0bUNEA7UohXbc3s3bx3qa5VFhiIh8sBQMaQdyRkCK/MxMc16d
        BSx5XQ/8MjVO73A1zHgH2g47BWPjgRrDL94KrgNPOO0FoG76QxL9GlcOHzhFa1rf
        xbb2auLBtflKy+5TZNnB/sbFC9ISpWywzfblD2Fsvxupl0vNWtA0Y2rPbKMZRnY+
        V6NC38yxW3HHAdWQRYLGOitM59I0HBgnjQKzTBNIsjPnJA2BSZvMBtQ1e3RQV0qE
        8VVoktZ8A0KDUxqdKWYlGYAY5hIw1y3UUsPRUbS3fQKBgQDAZehu+Kb5Sw+h00Qu
        vViNHDvi0PwmhQrHVpgjrppCnWsTk6FJFm+EBLY+87usXuRCnfZ1semb6P+yjLh2
        bJ9IXIrFAztcyE+7eZfn0H7mHA7E2ICKTjNdKbjy8kHViHpgdXREnAOrFTTk/BqW
        dq+weG2OuxYczWsY4XliWaVyiwKBgQC8XYExpSmoyI37o+jr9405k30tbGUw4X+/
        xYOvSUuafI8IOSLfKTpsvkMN3hxpJO6apIRAjOALbotKUA5FrHQPenuBWOr3mBJT
        euLiaWphqU8YN5dbNd+JhC/Jh5DLhY5FpB2Fv2MKSoF7+onpjDy9pEU5aReeBB0v
        ekUw4nWiBQKBgHxyrnjxP1frFG5xMB4nfZqw04+v7BmiXsl3mqsh6kgCeNtN17pl
        17YGMjfgAdnJ+02XzW5tqRSfDp3YZgy7z//HVD+BCqnGK8SxLu/ULfD73xW2kNZl
        JNYzAZ2r06eiQr4X2x/x5nGIIxGmfDAtDxFPpFX5b6ErwgVy+sgCAoFnAoGAWSpu
        EMEdQk+FnnwNsz2g9YNSuyDXmdb08SOfXWd1yXBzCLJ7RmYuyPEbrsHYcxFPfZap
        ICFPoTm35/qTdvnWiskxE56yw3eSHUBLjF/YQtixn0YZeMy8v0z6jgyFR0I2gdLZ
        QsnBKUrxlm2XwR1oV2Eef7m2u085PZNEk4pvor0CgYA6n060r48/CgRVslAeGder
        fZ3n+2ru8q2UVB38evepjLifn5+tKdFzZ7/NckXMC0NOVzm74qG46VFLMw5TtyT4
        /hRvGSYxA6dMjXy+tcrAns9Isrz2PnYFntlbhU6hw0um809tFunbvITfyeOjAsDW
        stC4thnhzXXT1Y3RfFtYEg==
        -----END PRIVATE KEY-----
    encryption:
      key-id: encryption-key
      public-key: |-
        -----BEGIN PUBLIC KEY-----
        MIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEAtU7Vu4tML8qg9BISaUH0
        BTU0+qkHJS3TUl3R0hEPttZJGf8EgT7bpWqRjdhMC2SYt2ifNF82EgMo/eva1rLn
        wYtCsxjJ7oB4U2m16/JKHtphmMUGhSLgbp+Y8pGAQ+P6u4HLlI0qbL92Syb6QCTr
        nYIlzZ2uUAvUQg/SbuAvdS4kdauZtpMNbhryusMVvILVBC5yUhfLJAkjbU3qWo/n
        2NKPr4kjwwFh6FaAf0HLsXCFmJbPPok6WMZeDqPORPZCt5gU2t04fS7s/2SSbhQ/
        i+7yyT4pl44cUlNLLN3Qo73sai5H90q7Dvmk3M5/YMJB0Ueyb705LHyOO5xA618s
        qQIDAQAB
        -----END PUBLIC KEY-----
      private-key: |-
        -----BEGIN PRIVATE KEY-----
        MIIEvgIBADANBgkqhkiG9w0BAQEFAASCBKgwggSkAgEAAoIBAQC1TtW7i0wvyqD0
        EhJpQfQFNTT6qQclLdNSXdHSEQ+21kkZ/wSBPtulapGN2EwLZJi3aJ80XzYSAyj9
        69rWsufBi0KzGMnugHhTabXr8koe2mGYxQaFIuBun5jykYBD4/q7gcuUjSpsv3ZL
        JvpAJOudgiXNna5QC9RCD9Ju4C91LiR1q5m2kw1uGvK6wxW8gtUELnJSF8skCSNt
        Tepaj+fY0o+viSPDAWHoVoB/QcuxcIWYls8+iTpYxl4Oo85E9kK3mBTa3Th9Luz/
        ZJJuFD+L7vLJPimXjhxSU0ss3dCjvexqLkf3SrsO+aTczn9gwkHRR7JvvTksfI47
        nEDrXyypAgMBAAECggEAREnJHrY8n9OGA+e6n4KD0mJT7gUz98Dm0yMbIC/k50yW
        hAAVRkjSmd8lq3NIURI2ov342NTznJ0sF1d6OVtxBujY2nP/uqEQsPoj1xaO7Ef8
        cnnjFsooFgJurQ44bVm02mLstqrky8jhWTT5FKfTRqP6cRNu0B9kdu1WqQQvW8a/
        C8xD8XUFzzJFQsEstJ076NjlZNH3EeqFiLxyVdV7tPEJRnOe2V2BAAgda3ByA6Jc
        Nd4xYHTVr5rZ+KES9gaAgb86+S7hNigsxz5Gp58NimLEyz1Qd+d9QCgPRgKOV5Uq
        0ci6c28ZrxW9wa/2CGCpoow1V7hRy1fZ24g2Tz91cQKBgQDbSdP/FQYuem0pUf8u
        mA/niEC8Jz30FW3ix5aqbQ8YRudK48Xy8F7AWnlS0wT2k/Xaeppn9YSPK4HlsNk2
        1gnpNfzdqXpJQtuxcPPeFNzUdXzBrsLXYqtlhOX/afrzqMhp73gkqoxXtqwD7BqN
        VfMcVXsWrEZQrRPBn/RUnnLdJwKBgQDTqUGupm93UlhoPgLXHGF/seQwPPHcU6lS
        SS9l512Ie21B+vZecgO4r77BXJwbY4rZVA5/m+wrsNmsT2f8yfdbs84cBDDWiKy5
        t2Um8zrus+BCIffxc9Fck9/htK33jLLcYwdSAm3a9pJxR9f/kAdredSTGBNJ3W/2
        rfh3cdNprwKBgDi7WfBFRSsjGzi0cPth9cNlubGzyVBrdtlT34PJ4Tzboxz53o1i
        aHEFNxwZYdBVKSbTzzyUBS5xCBMfdKK+LyQ5hmjmXq+zb1jxqvXKmfMRTixhhSDp
        8wO5pTM1/Omqwea+QGvj/5j1tnzxSVFFajbrWoPcH/jhPho6wqBducPDAoGBALOJ
        MEOavZXy7TaO0w3v7uvH0wzvxR/kfw1jMqc3l2j7ePOskmoOQAXaXO3bRjcdOlua
        Jyoq8islOZ4lRMlx7zWD0OKG035GNGzbmRtu2aA8R48RDSVr3jyu2gqznZULbXPv
        M/hmQxSmbhVUoW0PmJubnaqfk0zmXeBaNRXsIS3VAoGBALdsAtqR23PVeL6sYj2l
        dRNTDXpfvjFqJ5NThRO/4mT0CrPHQVj+Mz2bTc/Dxiwi8s8m3L+g23i3hodh/QMb
        Iz+UbcJZBGAKsFbPKGOtj6Bi07y/L11mcuNJzOWe61/JbVmJss0s+N/v3XucK/Ge
        CUaGOccsMO221v6JoBh9J3Hz
        -----END PRIVATE KEY-----</code></pre>
<h3>master.xml</h3>
<pre><code class="language-xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;databaseChangeLog
  xmlns=&quot;http://www.liquibase.org/xml/ns/dbchangelog&quot;
  xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
  xsi:schemaLocation=&quot;
      http://www.liquibase.org/xml/ns/dbchangelog
      http://www.liquibase.org/xml/ns/dbchangelog/dbchangelog-4.9.xsd&quot;&gt;

  &lt;!-- H2 defaults --&gt;
  &lt;property name=&quot;now&quot; value=&quot;now()&quot; dbms=&quot;h2&quot;/&gt;
  &lt;property name=&quot;floatType&quot; value=&quot;float4&quot; dbms=&quot;h2&quot;/&gt;
  &lt;property name=&quot;uuidType&quot; value=&quot;uuid&quot; dbms=&quot;h2&quot;/&gt;
  &lt;property name=&quot;datetimeType&quot; value=&quot;datetime(6)&quot; dbms=&quot;h2&quot;/&gt;
  &lt;property name=&quot;binaryType&quot; value=&quot;LONGVARBINARY&quot; dbms=&quot;h2&quot;/&gt;
  &lt;property name=&quot;clobType&quot; value=&quot;longvarchar&quot; dbms=&quot;h2&quot;/&gt;
  &lt;property name=&quot;blobType&quot; value=&quot;blob&quot; dbms=&quot;h2&quot;/&gt;

  &lt;!-- PostgreSQL overrides --&gt;
  &lt;property name=&quot;now&quot; value=&quot;current_timestamp&quot; dbms=&quot;postgresql&quot;/&gt;
  &lt;property name=&quot;floatType&quot; value=&quot;float4&quot; dbms=&quot;postgresql&quot;/&gt;
  &lt;property name=&quot;uuidType&quot; value=&quot;uuid&quot; dbms=&quot;postgresql&quot;/&gt;
  &lt;property name=&quot;datetimeType&quot; value=&quot;datetime&quot; dbms=&quot;postgresql&quot;/&gt;
  &lt;property name=&quot;binaryType&quot; value=&quot;BYTEA&quot; dbms=&quot;postgresql&quot;/&gt;
  &lt;property name=&quot;clobType&quot; value=&quot;clob&quot; dbms=&quot;postgresql&quot;/&gt;
  &lt;property name=&quot;blobType&quot; value=&quot;blob&quot; dbms=&quot;postgresql&quot;/&gt;

  &lt;!-- include the core auth changelog --&gt;
  &lt;include file=&quot;classpath:db/changelog/changelog-user.xml&quot;/&gt;

&lt;/databaseChangeLog&gt;</code></pre>
<h3>changelog-user.xml</h3>
<pre><code class="language-xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;databaseChangeLog
  xmlns=&quot;http://www.liquibase.org/xml/ns/dbchangelog&quot;
  xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
  xsi:schemaLocation=&quot;
      http://www.liquibase.org/xml/ns/dbchangelog
      http://www.liquibase.org/xml/ns/dbchangelog/dbchangelog-4.9.xsd&quot;&gt;

  &lt;changeSet id=&quot;20250510-1&quot; author=&quot;susimsek&quot;&gt;
    &lt;createTable tableName=&quot;user_identity&quot;&gt;
      &lt;column name=&quot;id&quot; type=&quot;varchar(36)&quot;&gt;
        &lt;constraints primaryKey=&quot;true&quot; primaryKeyName=&quot;pk_user_identity&quot; nullable=&quot;false&quot;/&gt;
      &lt;/column&gt;
      &lt;column name=&quot;username&quot; type=&quot;varchar(50)&quot;&gt;
        &lt;constraints nullable=&quot;false&quot; unique=&quot;true&quot;/&gt;
      &lt;/column&gt;
      &lt;column name=&quot;password&quot; type=&quot;varchar(100)&quot;&gt;
        &lt;constraints nullable=&quot;false&quot;/&gt;
      &lt;/column&gt;
      &lt;column name=&quot;email&quot; type=&quot;varchar(100)&quot;&gt;
        &lt;constraints nullable=&quot;false&quot; unique=&quot;true&quot;/&gt;
      &lt;/column&gt;
      &lt;column name=&quot;first_name&quot; type=&quot;varchar(50)&quot;/&gt;
      &lt;column name=&quot;last_name&quot; type=&quot;varchar(50)&quot;/&gt;
      &lt;column name=&quot;enabled&quot; type=&quot;boolean&quot;&gt;
        &lt;constraints nullable=&quot;false&quot;/&gt;
      &lt;/column&gt;
      &lt;column name=&quot;created_at&quot; type=&quot;datetime&quot;&gt;
        &lt;constraints nullable=&quot;false&quot;/&gt;
      &lt;/column&gt;
      &lt;column name=&quot;created_by&quot; type=&quot;varchar(50)&quot;&gt;
        &lt;constraints nullable=&quot;false&quot;/&gt;
      &lt;/column&gt;
      &lt;column name=&quot;updated_at&quot; type=&quot;datetime&quot;/&gt;
      &lt;column name=&quot;updated_by&quot; type=&quot;varchar(50)&quot;/&gt;
    &lt;/createTable&gt;

    &lt;createIndex indexName=&quot;idx_user_identity_username&quot; tableName=&quot;user_identity&quot;&gt;
      &lt;column name=&quot;username&quot;/&gt;
    &lt;/createIndex&gt;
    &lt;createIndex indexName=&quot;idx_user_identity_email&quot; tableName=&quot;user_identity&quot;&gt;
      &lt;column name=&quot;email&quot;/&gt;
    &lt;/createIndex&gt;
  &lt;/changeSet&gt;

  &lt;changeSet id=&quot;20250510-2&quot; author=&quot;susimsek&quot;&gt;
    &lt;createTable tableName=&quot;authority&quot;&gt;
      &lt;column name=&quot;id&quot; type=&quot;varchar(36)&quot;&gt;
        &lt;constraints primaryKey=&quot;true&quot; primaryKeyName=&quot;pk_authority&quot; nullable=&quot;false&quot;/&gt;
      &lt;/column&gt;
      &lt;column name=&quot;name&quot; type=&quot;varchar(50)&quot;&gt;
        &lt;constraints nullable=&quot;false&quot; unique=&quot;true&quot;/&gt;
      &lt;/column&gt;
      &lt;column name=&quot;description&quot; type=&quot;varchar(255)&quot;/&gt;
      &lt;column name=&quot;created_at&quot; type=&quot;datetime&quot;&gt;
        &lt;constraints nullable=&quot;false&quot;/&gt;
      &lt;/column&gt;
      &lt;column name=&quot;created_by&quot; type=&quot;varchar(50)&quot;&gt;
        &lt;constraints nullable=&quot;false&quot;/&gt;
      &lt;/column&gt;
      &lt;column name=&quot;updated_at&quot; type=&quot;datetime&quot;/&gt;
      &lt;column name=&quot;updated_by&quot; type=&quot;varchar(50)&quot;/&gt;
    &lt;/createTable&gt;

    &lt;createIndex indexName=&quot;idx_authority_name&quot; tableName=&quot;authority&quot;&gt;
      &lt;column name=&quot;name&quot;/&gt;
    &lt;/createIndex&gt;
  &lt;/changeSet&gt;

  &lt;changeSet id=&quot;20250510-3&quot; author=&quot;susimsek&quot;&gt;
    &lt;createTable tableName=&quot;user_authority_mapping&quot;&gt;
      &lt;column name=&quot;user_id&quot; type=&quot;varchar(36)&quot;&gt;
        &lt;constraints nullable=&quot;false&quot;/&gt;
      &lt;/column&gt;
      &lt;column name=&quot;authority_id&quot; type=&quot;varchar(36)&quot;&gt;
        &lt;constraints nullable=&quot;false&quot;/&gt;
      &lt;/column&gt;
      &lt;column name=&quot;created_at&quot; type=&quot;datetime&quot;&gt;
        &lt;constraints nullable=&quot;false&quot;/&gt;
      &lt;/column&gt;
      &lt;column name=&quot;created_by&quot; type=&quot;varchar(50)&quot;&gt;
        &lt;constraints nullable=&quot;false&quot;/&gt;
      &lt;/column&gt;
      &lt;column name=&quot;updated_at&quot; type=&quot;datetime&quot;/&gt;
      &lt;column name=&quot;updated_by&quot; type=&quot;varchar(50)&quot;/&gt;
    &lt;/createTable&gt;

    &lt;addPrimaryKey
      tableName=&quot;user_authority_mapping&quot;
      columnNames=&quot;user_id, authority_id&quot;
      constraintName=&quot;pk_user_authority_mapping&quot;/&gt;
  &lt;/changeSet&gt;

  &lt;changeSet id=&quot;20250510-4&quot; author=&quot;susimsek&quot;&gt;
    &lt;addForeignKeyConstraint
      baseTableName=&quot;user_authority_mapping&quot;
      baseColumnNames=&quot;user_id&quot;
      constraintName=&quot;fk_user_authority_user&quot;
      referencedTableName=&quot;user_identity&quot;
      referencedColumnNames=&quot;id&quot;/&gt;
  &lt;/changeSet&gt;

  &lt;changeSet id=&quot;20250510-5&quot; author=&quot;susimsek&quot;&gt;
    &lt;addForeignKeyConstraint
      baseTableName=&quot;user_authority_mapping&quot;
      baseColumnNames=&quot;authority_id&quot;
      constraintName=&quot;fk_user_authority_authority&quot;
      referencedTableName=&quot;authority&quot;
      referencedColumnNames=&quot;id&quot;/&gt;
  &lt;/changeSet&gt;

  &lt;changeSet id=&quot;20250510-1-data&quot; author=&quot;susimsek&quot;&gt;
    &lt;loadData
      file=&quot;db/data/user.csv&quot;
      separator=&quot;;&quot;
      tableName=&quot;user_identity&quot;&gt;
      &lt;column name=&quot;id&quot; type=&quot;string&quot;/&gt;
      &lt;column name=&quot;username&quot; type=&quot;string&quot;/&gt;
      &lt;column name=&quot;password&quot; type=&quot;string&quot;/&gt;
      &lt;column name=&quot;email&quot; type=&quot;string&quot;/&gt;
      &lt;column name=&quot;first_name&quot; type=&quot;string&quot;/&gt;
      &lt;column name=&quot;last_name&quot; type=&quot;string&quot;/&gt;
      &lt;column name=&quot;enabled&quot; type=&quot;boolean&quot;/&gt;
      &lt;column name=&quot;created_at&quot; type=&quot;datetime&quot;/&gt;
      &lt;column name=&quot;created_by&quot; type=&quot;string&quot;/&gt;
      &lt;column name=&quot;updated_at&quot; type=&quot;datetime&quot;/&gt;
      &lt;column name=&quot;updated_by&quot; type=&quot;string&quot;/&gt;
    &lt;/loadData&gt;
  &lt;/changeSet&gt;

  &lt;changeSet id=&quot;20250510-2-data&quot; author=&quot;susimsek&quot;&gt;
    &lt;loadData
      file=&quot;db/data/authority.csv&quot;
      separator=&quot;;&quot;
      tableName=&quot;authority&quot;&gt;
      &lt;column name=&quot;id&quot; type=&quot;string&quot;/&gt;
      &lt;column name=&quot;name&quot; type=&quot;string&quot;/&gt;
      &lt;column name=&quot;description&quot; type=&quot;string&quot;/&gt;
      &lt;column name=&quot;created_at&quot; type=&quot;datetime&quot;/&gt;
      &lt;column name=&quot;created_by&quot; type=&quot;string&quot;/&gt;
      &lt;column name=&quot;updated_at&quot; type=&quot;datetime&quot;/&gt;
      &lt;column name=&quot;updated_by&quot; type=&quot;string&quot;/&gt;
    &lt;/loadData&gt;
  &lt;/changeSet&gt;

  &lt;changeSet id=&quot;20250510-3-data&quot; author=&quot;susimsek&quot;&gt;
    &lt;loadData
      file=&quot;db/data/user_authority_mapping.csv&quot;
      separator=&quot;;&quot;
      tableName=&quot;user_authority_mapping&quot;&gt;
      &lt;column name=&quot;user_id&quot; type=&quot;string&quot;/&gt;
      &lt;column name=&quot;authority_id&quot; type=&quot;string&quot;/&gt;
      &lt;column name=&quot;created_at&quot; type=&quot;datetime&quot;/&gt;
      &lt;column name=&quot;created_by&quot; type=&quot;string&quot;/&gt;
      &lt;column name=&quot;updated_at&quot; type=&quot;datetime&quot;/&gt;
      &lt;column name=&quot;updated_by&quot; type=&quot;string&quot;/&gt;
    &lt;/loadData&gt;
  &lt;/changeSet&gt;

&lt;/databaseChangeLog&gt;</code></pre>
<h3>user.csv</h3>
<pre><code class="language-csv">id;username;password;email;first_name;last_name;enabled;created_at;created_by;updated_at;updated_by
a1b2c3d4-e5f6-7890-abcd-ef1234567890;admin;$2a$10$sva6wl8pmGKJE6NIWrxwcuJK1Jaa2I/LOI43iHVpbR4YB8KjGViiK;admin@example.com;Admin;User;true;2025-05-10 12:00:00;system;2025-05-10 12:00:00;system
09876543-21fe-dcba-0987-654321fedcba;user;$2a$10$5Py4PyteLuXEqnGpSigzfu0V55C7Hi7zX18lmh.J8Bpmft.h23voG;user@example.com;Normal;User;true;2025-05-10 12:00:00;system;2025-05-10 12:00:00;system</code></pre>
<h3>authority.csv</h3>
<pre><code class="language-csv">id;name;description;created_at;created_by;updated_at;updated_by
f47ac10b-58cc-4372-a567-0e02b2c3d479;ROLE_ADMIN;Administrator role;2025-05-10 12:00:00;system;2025-05-10 12:00:00;system
9c858901-8a57-4791-81fe-4c455b099bc9;ROLE_USER;User role;2025-05-10 12:00:00;system;2025-05-10 12:00:00;system</code></pre>
<h3>user_authority_mapping.csv</h3>
<pre><code class="language-csv">user_id;authority_id;created_at;created_by;updated_at;updated_by
a1b2c3d4-e5f6-7890-abcd-ef1234567890;9c858901-8a57-4791-81fe-4c455b099bc9;2025-05-10 12:00:00;system;2025-05-10 12:00:00;system
a1b2c3d4-e5f6-7890-abcd-ef1234567890;f47ac10b-58cc-4372-a567-0e02b2c3d479;2025-05-10 12:00:00;system;2025-05-10 12:00:00;system
09876543-21fe-dcba-0987-654321fedcba;9c858901-8a57-4791-81fe-4c455b099bc9;2025-05-10 12:00:00;system;2025-05-10 12:00:00;system</code></pre>
<h3>schema.graphqls</h3>
<pre><code class="language-graphql">scalar Long
scalar Date
scalar Instant

type Query {
  helloAll: String!
  helloAdmin: String!
}

type Mutation {
  login(input: LoginInput!): TokenDTO!
  logout: Boolean!
  greet(input: GreetInput!): GreetDTO!
}

type Subscription {
  greetStream(input: GreetInput!): GreetDTO!
  greetStreamAdmin(input: GreetInput!): GreetDTO!
}

input LoginInput {
  username: String!
  password: String!
}

input GreetInput {
  message: String!
}

type TokenDTO {
  accessToken: String!
  tokenType: String!
  accessTokenExpiresIn: Long!
}

type GreetDTO {
  greeting: String!
  timestamp: Instant!
}</code></pre>
<h3>reflect-config.json</h3>
<pre><code class="language-json">[
  {
    &quot;name&quot;: &quot;liquibase.logging.mdc.MdcManagerFactory&quot;,
    &quot;methods&quot;: [{ &quot;name&quot;: &quot;&lt;init&gt;&quot;, &quot;parameterTypes&quot;: [] }]
  },
  {
    &quot;name&quot;: &quot;liquibase.change.core.LoadDataColumnConfig&quot;,
    &quot;queryAllPublicMethods&quot;: true,
    &quot;allDeclaredMethods&quot;: true,
    &quot;methods&quot;: [{ &quot;name&quot;: &quot;&lt;init&gt;&quot;, &quot;parameterTypes&quot;: [] }]
  },
  {
    &quot;name&quot;: &quot;liquibase.command.CommandFactory&quot;,
    &quot;methods&quot;: [{ &quot;name&quot;: &quot;&lt;init&gt;&quot;, &quot;parameterTypes&quot;: [] }]
  },
  {
    &quot;name&quot;: &quot;liquibase.changelog.ChangeLogHistoryServiceFactory&quot;,
    &quot;methods&quot;: [{ &quot;name&quot;: &quot;&lt;init&gt;&quot;, &quot;parameterTypes&quot;: [] }]
  },
  {
    &quot;name&quot;: &quot;liquibase.datatype.core.BigIntType&quot;,
    &quot;allPublicMethods&quot;: true,
    &quot;methods&quot;: [{ &quot;name&quot;: &quot;&lt;init&gt;&quot;, &quot;parameterTypes&quot;: [] }]
  },
  {
    &quot;name&quot;: &quot;liquibase.datatype.core.BlobType&quot;,
    &quot;allPublicMethods&quot;: true,
    &quot;methods&quot;: [{ &quot;name&quot;: &quot;&lt;init&gt;&quot;, &quot;parameterTypes&quot;: [] }]
  },
  {
    &quot;name&quot;: &quot;liquibase.datatype.core.BooleanType&quot;,
    &quot;allPublicMethods&quot;: true,
    &quot;methods&quot;: [{ &quot;name&quot;: &quot;&lt;init&gt;&quot;, &quot;parameterTypes&quot;: [] }]
  },
  {
    &quot;name&quot;: &quot;liquibase.datatype.core.CharType&quot;,
    &quot;allPublicMethods&quot;: true,
    &quot;methods&quot;: [{ &quot;name&quot;: &quot;&lt;init&gt;&quot;, &quot;parameterTypes&quot;: [] }]
  },
  {
    &quot;name&quot;: &quot;liquibase.datatype.core.ClobType&quot;,
    &quot;allPublicMethods&quot;: true,
    &quot;methods&quot;: [{ &quot;name&quot;: &quot;&lt;init&gt;&quot;, &quot;parameterTypes&quot;: [] }]
  },
  {
    &quot;name&quot;: &quot;liquibase.datatype.core.CurrencyType&quot;,
    &quot;allPublicMethods&quot;: true,
    &quot;methods&quot;: [{ &quot;name&quot;: &quot;&lt;init&gt;&quot;, &quot;parameterTypes&quot;: [] }]
  },
  {
    &quot;name&quot;: &quot;liquibase.datatype.core.DatabaseFunctionType&quot;,
    &quot;allPublicMethods&quot;: true,
    &quot;methods&quot;: [{ &quot;name&quot;: &quot;&lt;init&gt;&quot;, &quot;parameterTypes&quot;: [] }]
  },
  {
    &quot;name&quot;: &quot;liquibase.datatype.core.DateTimeType&quot;,
    &quot;allPublicMethods&quot;: true,
    &quot;methods&quot;: [{ &quot;name&quot;: &quot;&lt;init&gt;&quot;, &quot;parameterTypes&quot;: [] }]
  },
  {
    &quot;name&quot;: &quot;liquibase.datatype.core.DateType&quot;,
    &quot;allPublicMethods&quot;: true,
    &quot;methods&quot;: [{ &quot;name&quot;: &quot;&lt;init&gt;&quot;, &quot;parameterTypes&quot;: [] }]
  },
  {
    &quot;name&quot;: &quot;liquibase.datatype.core.DecimalType&quot;,
    &quot;allPublicMethods&quot;: true,
    &quot;methods&quot;: [{ &quot;name&quot;: &quot;&lt;init&gt;&quot;, &quot;parameterTypes&quot;: [] }]
  },
  {
    &quot;name&quot;: &quot;liquibase.datatype.core.DoubleType&quot;,
    &quot;allPublicMethods&quot;: true,
    &quot;methods&quot;: [{ &quot;name&quot;: &quot;&lt;init&gt;&quot;, &quot;parameterTypes&quot;: [] }]
  },
  {
    &quot;name&quot;: &quot;liquibase.datatype.core.FloatType&quot;,
    &quot;allPublicMethods&quot;: true,
    &quot;methods&quot;: [{ &quot;name&quot;: &quot;&lt;init&gt;&quot;, &quot;parameterTypes&quot;: [] }]
  },
  {
    &quot;name&quot;: &quot;liquibase.datatype.core.IntType&quot;,
    &quot;allPublicMethods&quot;: true,
    &quot;methods&quot;: [{ &quot;name&quot;: &quot;&lt;init&gt;&quot;, &quot;parameterTypes&quot;: [] }]
  },
  {
    &quot;name&quot;: &quot;liquibase.datatype.core.MediumIntType&quot;,
    &quot;allPublicMethods&quot;: true,
    &quot;methods&quot;: [{ &quot;name&quot;: &quot;&lt;init&gt;&quot;, &quot;parameterTypes&quot;: [] }]
  },
  {
    &quot;name&quot;: &quot;liquibase.datatype.core.NCharType&quot;,
    &quot;allPublicMethods&quot;: true,
    &quot;methods&quot;: [{ &quot;name&quot;: &quot;&lt;init&gt;&quot;, &quot;parameterTypes&quot;: [] }]
  },
  {
    &quot;name&quot;: &quot;liquibase.datatype.core.NumberType&quot;,
    &quot;allPublicMethods&quot;: true,
    &quot;methods&quot;: [{ &quot;name&quot;: &quot;&lt;init&gt;&quot;, &quot;parameterTypes&quot;: [] }]
  },
  {
    &quot;name&quot;: &quot;liquibase.datatype.core.NVarcharType&quot;,
    &quot;allPublicMethods&quot;: true,
    &quot;methods&quot;: [{ &quot;name&quot;: &quot;&lt;init&gt;&quot;, &quot;parameterTypes&quot;: [] }]
  },
  {
    &quot;name&quot;: &quot;liquibase.datatype.core.SmallIntType&quot;,
    &quot;allPublicMethods&quot;: true,
    &quot;methods&quot;: [{ &quot;name&quot;: &quot;&lt;init&gt;&quot;, &quot;parameterTypes&quot;: [] }]
  },
  {
    &quot;name&quot;: &quot;liquibase.datatype.core.TimestampType&quot;,
    &quot;allPublicMethods&quot;: true,
    &quot;methods&quot;: [{ &quot;name&quot;: &quot;&lt;init&gt;&quot;, &quot;parameterTypes&quot;: [] }]
  },
  {
    &quot;name&quot;: &quot;liquibase.datatype.core.TimeType&quot;,
    &quot;allPublicMethods&quot;: true,
    &quot;methods&quot;: [{ &quot;name&quot;: &quot;&lt;init&gt;&quot;, &quot;parameterTypes&quot;: [] }]
  },
  {
    &quot;name&quot;: &quot;liquibase.datatype.core.TinyIntType&quot;,
    &quot;allPublicMethods&quot;: true,
    &quot;methods&quot;: [{ &quot;name&quot;: &quot;&lt;init&gt;&quot;, &quot;parameterTypes&quot;: [] }]
  },
  {
    &quot;name&quot;: &quot;liquibase.datatype.core.UnknownType&quot;,
    &quot;allPublicMethods&quot;: true,
    &quot;methods&quot;: [{ &quot;name&quot;: &quot;&lt;init&gt;&quot;, &quot;parameterTypes&quot;: [] }]
  },
  {
    &quot;name&quot;: &quot;liquibase.datatype.core.UUIDType&quot;,
    &quot;allPublicMethods&quot;: true,
    &quot;methods&quot;: [{ &quot;name&quot;: &quot;&lt;init&gt;&quot;, &quot;parameterTypes&quot;: [] }]
  },
  {
    &quot;name&quot;: &quot;liquibase.datatype.core.VarcharType&quot;,
    &quot;allPublicMethods&quot;: true,
    &quot;methods&quot;: [{ &quot;name&quot;: &quot;&lt;init&gt;&quot;, &quot;parameterTypes&quot;: [] }]
  },
  {
    &quot;name&quot;: &quot;liquibase.datatype.core.XMLType&quot;,
    &quot;allPublicMethods&quot;: true,
    &quot;methods&quot;: [{ &quot;name&quot;: &quot;&lt;init&gt;&quot;, &quot;parameterTypes&quot;: [] }]
  }
]</code></pre>
<hr />
<h2>üõ†Ô∏è Step 3: GraphQL &amp; Security &amp; Database Configuration</h2>
<p>In this section, we define the beans and properties RSA keys, HTTP security filters, and JPA repository/auditing setup for JWE‚Äëbased authentication, GraalVM native-image runtime hints, GraphQL wiring and custom scalars:</p>
<ul>
<li>JwtProperties: Configures JWT issuer, expiration, and signing/encryption key pairs.</li>
<li>SecurityJwtConfig: Builds RSA keys and JWK sources; configures JWT encoder/decoder, authentication converter, token resolver, and WebSocket interceptor beans.</li>
<li>SecurityConfig: Integrates `DomainUserDetailsService`, configures authentication manager, password encoder, and stateless security filter chain with JWE support.</li>
<li>DatabaseConfig: Enables JPA repositories, auditing, and transaction management.</li>
<li>GraphQLConfig: Registers custom scalars for GraphQL (`Long`, `Date`, `Instant`).</li>
<li>InstantScalar: Defines an ISO-8601 `Instant` scalar for GraphQL.</li>
<li>NativeConfig: Registers runtime hints for GraalVM native-image, including reflection and resource patterns.</li>
</ul>
<h3>SecurityJwtConfig</h3>
<h3>Java</h3>
<pre><code class="language-java">package io.github.susimsek.springbootgraphqljwedemo.config;

import com.nimbusds.jose.EncryptionMethod;
import com.nimbusds.jose.JWEAlgorithm;
import com.nimbusds.jose.JWSAlgorithm;
import com.nimbusds.jose.jwk.JWKSet;
import com.nimbusds.jose.jwk.RSAKey;
import com.nimbusds.jose.jwk.source.JWKSource;
import com.nimbusds.jose.proc.JWEDecryptionKeySelector;
import com.nimbusds.jose.proc.JWSVerificationKeySelector;
import com.nimbusds.jose.proc.SecurityContext;
import com.nimbusds.jwt.proc.DefaultJWTProcessor;
import io.github.susimsek.springbootgraphqljwedemo.security.CookieAuthenticationWebSocketInterceptor;
import io.github.susimsek.springbootgraphqljwedemo.security.CookieBearerTokenResolver;
import io.github.susimsek.springbootgraphqljwedemo.security.KeyUtils;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.graphql.server.WebSocketGraphQlInterceptor;
import org.springframework.graphql.server.support.BearerTokenAuthenticationExtractor;
import org.springframework.security.authentication.ProviderManager;
import org.springframework.security.oauth2.jwt.JwtDecoder;
import org.springframework.security.oauth2.jwt.JwtEncoder;
import org.springframework.security.oauth2.jwt.NimbusJwtDecoder;
import org.springframework.security.oauth2.jwt.NimbusJwtEncoder;
import org.springframework.security.oauth2.server.resource.authentication.JwtAuthenticationConverter;
import org.springframework.security.oauth2.server.resource.authentication.JwtGrantedAuthoritiesConverter;
import org.springframework.security.oauth2.server.resource.authentication.JwtAuthenticationProvider;
import org.springframework.security.oauth2.server.resource.web.BearerTokenResolver;

import java.util.List;

import static io.github.susimsek.springbootgraphqljwedemo.security.SecurityUtils.AUTHORITIES_KEY;

@Configuration
public class SecurityJwtConfig {

  private final JwtProperties props;

  public SecurityJwtConfig(JwtProperties props) {
    this.props = props;
  }

  @Bean
  public RSAKey signingKey() throws Exception {
    return KeyUtils.buildRsaKey(
      props.getSigning().getPublicKey(),
      props.getSigning().getPrivateKey(),
      props.getSigning().getKeyId(),
      true
    );
  }

  @Bean
  public RSAKey encryptionKey() throws Exception {
    return KeyUtils.buildRsaKey(
      props.getEncryption().getPublicKey(),
      props.getEncryption().getPrivateKey(),
      props.getEncryption().getKeyId(),
      false
    );
  }

  @Bean
  public JWKSource&lt;SecurityContext&gt; jwkSource(RSAKey signingKey, RSAKey encryptionKey) {
    JWKSet jwkSet = new JWKSet(List.of(signingKey, encryptionKey));
    return (jwkSelector, context) -&gt; jwkSelector.select(jwkSet);
  }

  @Bean
  public JwtDecoder jwtDecoder(JWKSource&lt;SecurityContext&gt; jwkSource) {
    DefaultJWTProcessor&lt;SecurityContext&gt; jwtProcessor = new DefaultJWTProcessor&lt;&gt;();

    jwtProcessor.setJWEKeySelector(new JWEDecryptionKeySelector&lt;&gt;(
      JWEAlgorithm.RSA_OAEP_256,
      EncryptionMethod.A128GCM,
      jwkSource
    ));
    jwtProcessor.setJWSKeySelector(new JWSVerificationKeySelector&lt;&gt;(
      JWSAlgorithm.RS256,
      jwkSource
    ));
    jwtProcessor.setJWTClaimsSetVerifier((claims, ctx) -&gt; {});

    return new NimbusJwtDecoder(jwtProcessor);
  }

  @Bean
  public JwtEncoder jwtEncoder(JWKSource&lt;SecurityContext&gt; jwkSource) {
    return new NimbusJwtEncoder(jwkSource);
  }

  @Bean
  public JwtAuthenticationConverter jwtAuthenticationConverter() {
    JwtGrantedAuthoritiesConverter converter = new JwtGrantedAuthoritiesConverter();
    converter.setAuthorityPrefix(&quot;&quot;);
    converter.setAuthoritiesClaimName(AUTHORITIES_KEY);

    JwtAuthenticationConverter authConverter = new JwtAuthenticationConverter();
    authConverter.setJwtGrantedAuthoritiesConverter(converter);
    return authConverter;
  }

  @Bean
  public BearerTokenResolver bearerTokenResolver() {
    CookieBearerTokenResolver resolver = new CookieBearerTokenResolver();
    resolver.setAllowUriQueryParameter(false);
    resolver.setAllowFormEncodedBodyParameter(false);
    resolver.setAllowCookie(true);
    return resolver;
  }

  @Bean
  public WebSocketGraphQlInterceptor authenticationInterceptor(JwtDecoder jwtDecoder) {
    return new CookieAuthenticationWebSocketInterceptor(
      new BearerTokenAuthenticationExtractor(),
      new ProviderManager(new JwtAuthenticationProvider(jwtDecoder))
    );
  }
}</code></pre>
<h3>Kotlin</h3>
<pre><code class="language-kotlin">package io.github.susimsek.springbootgraphqljwedemo.config

import com.nimbusds.jose.EncryptionMethod
import com.nimbusds.jose.JWEAlgorithm
import com.nimbusds.jose.JWSAlgorithm
import com.nimbusds.jose.jwk.JWKSet
import com.nimbusds.jose.jwk.RSAKey
import com.nimbusds.jose.jwk.source.JWKSource
import com.nimbusds.jose.proc.JWEDecryptionKeySelector
import com.nimbusds.jose.proc.JWSVerificationKeySelector
import com.nimbusds.jose.proc.SecurityContext
import com.nimbusds.jwt.proc.DefaultJWTProcessor
import io.github.susimsek.springbootgraphqljwedemo.security.CookieAuthenticationWebSocketInterceptor
import io.github.susimsek.springbootgraphqljwedemo.security.CookieBearerTokenResolver
import io.github.susimsek.springbootgraphqljwedemo.security.KeyUtils
import org.springframework.context.annotation.Bean
import org.springframework.context.annotation.Configuration
import org.springframework.graphql.server.WebSocketGraphQlInterceptor
import org.springframework.graphql.server.support.BearerTokenAuthenticationExtractor
import org.springframework.security.authentication.ProviderManager
import org.springframework.security.oauth2.jwt.JwtDecoder
import org.springframework.security.oauth2.jwt.JwtEncoder
import org.springframework.security.oauth2.jwt.NimbusJwtDecoder
import org.springframework.security.oauth2.jwt.NimbusJwtEncoder
import org.springframework.security.oauth2.server.resource.authentication.JwtAuthenticationConverter
import org.springframework.security.oauth2.server.resource.authentication.JwtGrantedAuthoritiesConverter
import org.springframework.security.oauth2.server.resource.authentication.JwtAuthenticationProvider
import org.springframework.security.oauth2.server.resource.web.BearerTokenResolver

@Configuration
class SecurityJwtConfig(
  private val props: JwtProperties
) {

  @Bean
  @Throws(Exception::class)
  fun signingKey(): RSAKey = KeyUtils.buildRsaKey(
    props.signing.publicKey,
    props.signing.privateKey,
    props.signing.keyId,
    true
  )

  @Bean
  @Throws(Exception::class)
  fun encryptionKey(): RSAKey = KeyUtils.buildRsaKey(
    props.encryption.publicKey,
    props.encryption.privateKey,
    props.encryption.keyId,
    false
  )

  @Bean
  fun jwkSource(
    signingKey: RSAKey,
    encryptionKey: RSAKey
  ): JWKSource&lt;SecurityContext&gt; {
    val jwkSet = JWKSet(listOf(signingKey, encryptionKey))
    return JWKSource { jwkSelector, _ -&gt; jwkSelector.select(jwkSet) }
  }

  @Bean
  fun jwtDecoder(jwkSource: JWKSource&lt;SecurityContext&gt;): JwtDecoder {
    val processor = DefaultJWTProcessor&lt;SecurityContext&gt;().apply {
      setJWEKeySelector(JWEDecryptionKeySelector(
        JWEAlgorithm.RSA_OAEP_256,
        EncryptionMethod.A128GCM,
        jwkSource
      ))
      setJWSKeySelector(JWSVerificationKeySelector(
        JWSAlgorithm.RS256,
        jwkSource
      ))
      setJWTClaimsSetVerifier { _, _ -&gt; }
    }
    return NimbusJwtDecoder(processor)
  }

  @Bean
  fun jwtEncoder(jwkSource: JWKSource&lt;SecurityContext&gt;): JwtEncoder =
    NimbusJwtEncoder(jwkSource)

  @Bean
  fun jwtAuthenticationConverter(): JwtAuthenticationConverter {
    val granted = JwtGrantedAuthoritiesConverter().apply {
      authorityPrefix = &quot;&quot;
      authoritiesClaimName = SecurityUtils.AUTHORITIES_KEY
    }
    return JwtAuthenticationConverter().apply {
      setJwtGrantedAuthoritiesConverter(granted)
    }
  }

  @Bean
  fun bearerTokenResolver(): BearerTokenResolver =
    CookieBearerTokenResolver().apply {
      setAllowUriQueryParameter(false)
      setAllowFormEncodedBodyParameter(false)
      setAllowCookie(true)
    }

  @Bean
  fun authenticationInterceptor(jwtDecoder: JwtDecoder): WebSocketGraphQlInterceptor =
    CookieAuthenticationWebSocketInterceptor(
      BearerTokenAuthenticationExtractor(),
      ProviderManager(JwtAuthenticationProvider(jwtDecoder))
    )
}</code></pre>
<h3>SecurityConfig</h3>
<h3>Java</h3>
<pre><code class="language-java">package io.github.susimsek.springbootgraphqljwedemo.config;

import io.github.susimsek.springbootgraphqljwedemo.repository.UserRepository;
import io.github.susimsek.springbootgraphqljwedemo.security.DomainUserDetailsService;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.security.authentication.AuthenticationManager;
import org.springframework.security.authentication.ProviderManager;
import org.springframework.security.authentication.dao.DaoAuthenticationProvider;
import org.springframework.security.config.annotation.method.configuration.EnableMethodSecurity;
import org.springframework.security.config.annotation.web.builders.HttpSecurity;
import org.springframework.security.config.annotation.web.configurers.AbstractHttpConfigurer;
import org.springframework.security.config.http.SessionCreationPolicy;
import org.springframework.security.core.userdetails.UserDetailsService;
import org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder;
import org.springframework.security.crypto.password.PasswordEncoder;
import org.springframework.security.web.SecurityFilterChain;
import org.springframework.security.web.servlet.util.matcher.MvcRequestMatcher;
import org.springframework.web.servlet.handler.HandlerMappingIntrospector;

import static org.springframework.security.config.Customizer.withDefaults;

@Configuration
@EnableMethodSecurity(securedEnabled = true)
public class SecurityConfig {

  @Bean
  public SecurityFilterChain securityFilterChain(HttpSecurity http,
                                                 MvcRequestMatcher.Builder mvc) throws Exception {
    http
      .cors(withDefaults())
      .csrf(AbstractHttpConfigurer::disable)
      .authorizeHttpRequests(authz -&gt;
        authz
          .requestMatchers(
            mvc.pattern(&quot;/webjars/**&quot;),
            mvc.pattern(&quot;/css/**&quot;),
            mvc.pattern(&quot;/js/**&quot;)
          ).permitAll()
          .requestMatchers(
            mvc.pattern(&quot;/*.ico&quot;),
            mvc.pattern(&quot;/*.png&quot;),
            mvc.pattern(&quot;/*.svg&quot;),
            mvc.pattern(&quot;/*.webapp&quot;)
          ).permitAll()
          .requestMatchers(&quot;/actuator/**&quot;).permitAll()
          .requestMatchers(
            &quot;/v3/api-docs/**&quot;,
            &quot;/swagger-ui.html&quot;,
            &quot;/swagger-ui/**&quot;
          ).permitAll()
          .requestMatchers(
            mvc.pattern(&quot;/graphql&quot;),
            mvc.pattern(&quot;/graphiql&quot;),
            mvc.pattern(&quot;/subscriptions&quot;)
          ).permitAll()
          .anyRequest().authenticated()
      )
      .sessionManagement(session -&gt;
        session.sessionCreationPolicy(SessionCreationPolicy.STATELESS))
      .oauth2ResourceServer(oauth2 -&gt; oauth2
        .jwt(withDefaults())
      );

    return http.build();
  }

  @Bean
  public UserDetailsService userDetailsService(UserRepository userRepository) {
    return new DomainUserDetailsService(userRepository);
  }

  @Bean
  public PasswordEncoder passwordEncoder() {
    return new BCryptPasswordEncoder();
  }

  @Bean
  public AuthenticationManager authenticationManager(
    UserDetailsService userDetailsService,
    PasswordEncoder passwordEncoder) {
    DaoAuthenticationProvider provider = new DaoAuthenticationProvider();
    provider.setUserDetailsService(userDetailsService);
    provider.setPasswordEncoder(passwordEncoder);
    return new ProviderManager(provider);
  }

  @Bean
  public MvcRequestMatcher.Builder mvc(HandlerMappingIntrospector introspector) {
    return new MvcRequestMatcher.Builder(introspector);
  }
}</code></pre>
<h3>Kotlin</h3>
<pre><code class="language-kotlin">package io.github.susimsek.springbootgraphqljwedemo.config

import io.github.susimsek.springbootgraphqljwedemo.repository.UserRepository
import io.github.susimsek.springbootgraphqljwedemo.security.DomainUserDetailsService
import org.springframework.context.annotation.Bean
import org.springframework.context.annotation.Configuration
import org.springframework.security.authentication.AuthenticationManager
import org.springframework.security.authentication.ProviderManager
import org.springframework.security.authentication.dao.DaoAuthenticationProvider
import org.springframework.security.config.annotation.method.configuration.EnableMethodSecurity
import org.springframework.security.config.annotation.web.builders.HttpSecurity
import org.springframework.security.config.annotation.web.configurers.AbstractHttpConfigurer
import org.springframework.security.config.http.SessionCreationPolicy
import org.springframework.security.core.userdetails.UserDetailsService
import org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder
import org.springframework.security.crypto.password.PasswordEncoder
import org.springframework.security.web.SecurityFilterChain
import org.springframework.security.web.servlet.util.matcher.MvcRequestMatcher
import org.springframework.web.servlet.handler.HandlerMappingIntrospector
import org.springframework.security.config.Customizer.withDefaults

@Configuration
@EnableMethodSecurity(securedEnabled = true)
class SecurityConfig {

  @Bean
  @Throws(Exception::class)
  fun securityFilterChain(
    http: HttpSecurity,
    mvc: MvcRequestMatcher.Builder
  ): SecurityFilterChain {
    http
      .cors(withDefaults())
      .csrf { it.disable() }
      .authorizeHttpRequests { authz -&gt;
        authz
          .requestMatchers(
            mvc.pattern(&quot;/webjars/**&quot;),
            mvc.pattern(&quot;/css/**&quot;),
            mvc.pattern(&quot;/js/**&quot;)
          ).permitAll()
          .requestMatchers(
            mvc.pattern(&quot;/*.ico&quot;),
            mvc.pattern(&quot;/*.png&quot;),
            mvc.pattern(&quot;/*.svg&quot;),
            mvc.pattern(&quot;/*.webapp&quot;)
          ).permitAll()
          .requestMatchers(&quot;/actuator/**&quot;).permitAll()
          .requestMatchers(
            &quot;/v3/api-docs/**&quot;,
            &quot;/swagger-ui.html&quot;,
            &quot;/swagger-ui/**&quot;
          ).permitAll()
          .requestMatchers(
            mvc.pattern(&quot;/graphql&quot;),
            mvc.pattern(&quot;/graphiql&quot;),
            mvc.pattern(&quot;/subscriptions&quot;)
          ).permitAll()
          .anyRequest().authenticated()
      }
      .sessionManagement {
        it.sessionCreationPolicy(SessionCreationPolicy.STATELESS)
      }
      .oauth2ResourceServer {
        it.jwt(withDefaults())
      }

    return http.build()
  }

  @Bean
  fun userDetailsService(userRepository: UserRepository): UserDetailsService =
    DomainUserDetailsService(userRepository)

  @Bean
  fun passwordEncoder(): PasswordEncoder = BCryptPasswordEncoder()

  @Bean
  fun authenticationManager(
    userDetailsService: UserDetailsService,
    passwordEncoder: PasswordEncoder
  ): AuthenticationManager {
    val provider = DaoAuthenticationProvider().apply {
      setUserDetailsService(userDetailsService)
      setPasswordEncoder(passwordEncoder)
    }
    return ProviderManager(provider)
  }

  @Bean
  fun mvc(introspector: HandlerMappingIntrospector): MvcRequestMatcher.Builder =
    MvcRequestMatcher.Builder(introspector)
}</code></pre>
<h3>JwtProperties</h3>
<h3>Java</h3>
<pre><code class="language-java">package io.github.susimsek.springbootgraphqljwedemo.config;

import lombok.Data;
import org.springframework.boot.context.properties.ConfigurationProperties;
import org.springframework.context.annotation.Configuration;

import java.time.Duration;

@Configuration
@ConfigurationProperties(prefix = &quot;security.jwt&quot;)
@Data
public class JwtProperties {

    @Data
    public static class Pair {
        private String publicKey;
        private String privateKey;
        private String keyId;
    }

    private Pair signing;
    private Pair encryption;
    private String issuer;
    private Duration expirationDuration;
}</code></pre>
<h3>Kotlin</h3>
<pre><code class="language-kotlin">package io.github.susimsek.springbootgraphqljwedemo.config

import org.springframework.boot.context.properties.ConfigurationProperties
import org.springframework.context.annotation.Configuration
import java.time.Duration

@Configuration
@ConfigurationProperties(prefix = &quot;security.jwt&quot;)
class JwtProperties {

  class Pair {
    lateinit var publicKey: String
    lateinit var privateKey: String
    lateinit var keyId: String
  }

  lateinit var signing: Pair
  lateinit var encryption: Pair
  lateinit var issuer: String
  lateinit var expirationDuration: Duration
}</code></pre>
<h3>DatabaseConfig</h3>
<h3>Java</h3>
<pre><code class="language-java">package io.github.susimsek.springbootgraphqljwedemo.config;

import org.springframework.context.annotation.Configuration;
import org.springframework.data.jpa.repository.config.EnableJpaAuditing;
import org.springframework.data.jpa.repository.config.EnableJpaRepositories;
import org.springframework.transaction.annotation.EnableTransactionManagement;

@Configuration
@EnableJpaRepositories(&quot;io.github.susimsek.springbootgraphqljwedemo.repository&quot;)
@EnableJpaAuditing(auditorAwareRef = &quot;springSecurityAuditorAware&quot;)
@EnableTransactionManagement
public class DatabaseConfig {

}</code></pre>
<h3>Kotlin</h3>
<pre><code class="language-kotlin">package io.github.susimsek.springbootgraphqljwedemo.config

import org.springframework.context.annotation.Configuration
import org.springframework.data.jpa.repository.config.EnableJpaAuditing
import org.springframework.data.jpa.repository.config.EnableJpaRepositories
import org.springframework.transaction.annotation.EnableTransactionManagement

@Configuration
@EnableJpaRepositories(&quot;io.github.susimsek.springbootgraphqljwedemo.repository&quot;)
@EnableJpaAuditing(auditorAwareRef = &quot;springSecurityAuditorAware&quot;)
@EnableTransactionManagement
class DatabaseConfig</code></pre>
<h3>GraphQLConfig</h3>
<h3>Java</h3>
<pre><code class="language-java">package io.github.susimsek.springbootgraphqljwedemo.config;

import graphql.scalars.ExtendedScalars;
import io.github.susimsek.springbootgraphqljwedemo.scalar.InstantScalar;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.graphql.execution.RuntimeWiringConfigurer;

@Configuration
public class GraphQLConfig {

  @Bean
  public RuntimeWiringConfigurer runtimeWiringConfigurer() {
    return wiring -&gt; wiring
      .scalar(ExtendedScalars.GraphQLLong)
      .scalar(ExtendedScalars.Date)
      .scalar(InstantScalar.INSTANCE);
  }
}</code></pre>
<h3>Kotlin</h3>
<pre><code class="language-kotlin">package io.github.susimsek.springbootgraphqljwedemo.config

import graphql.scalars.ExtendedScalars
import io.github.susimsek.springbootgraphqljwedemo.scalar.InstantScalar
import org.springframework.context.annotation.Bean
import org.springframework.context.annotation.Configuration
import org.springframework.graphql.execution.RuntimeWiringConfigurer

@Configuration
class GraphQLConfig {

  @Bean
  fun runtimeWiringConfigurer(): RuntimeWiringConfigurer {
    return RuntimeWiringConfigurer { wiring -&gt;
      wiring
        .scalar(ExtendedScalars.GraphQLLong)
        .scalar(ExtendedScalars.Date)
        .scalar(InstantScalar.INSTANCE)
    }
  }
}</code></pre>
<h3>InstantScalar</h3>
<h3>Java</h3>
<pre><code class="language-java">package io.github.susimsek.springbootgraphqljwedemo.scalar;

import graphql.GraphQLContext;
import graphql.execution.CoercedVariables;
import graphql.language.StringValue;
import graphql.language.Value;
import graphql.scalars.util.Kit;
import graphql.schema.Coercing;
import graphql.schema.CoercingParseLiteralException;
import graphql.schema.CoercingParseValueException;
import graphql.schema.CoercingSerializeException;
import graphql.schema.GraphQLScalarType;
import lombok.AccessLevel;
import lombok.NoArgsConstructor;
import org.springframework.lang.NonNull;

import java.time.Instant;
import java.time.format.DateTimeParseException;
import java.util.Locale;

@NoArgsConstructor(access = AccessLevel.PRIVATE)
public final class InstantScalar {

  public static final GraphQLScalarType INSTANCE;

  static {
    Coercing&lt;Instant, String&gt; coercing = new Coercing&lt;&gt;() {
      @Override
      public String serialize(
        @NonNull Object input,
        @NonNull GraphQLContext context,
        @NonNull Locale locale
      ) throws CoercingSerializeException {
        if (input instanceof Instant instant) {
          return instant.toString();
        }
        throw new CoercingSerializeException(
          &quot;Expected java.time.Instant but was: &quot; + Kit.typeName(input) + &quot;&#39;.&quot;
        );
      }

      @Override
      public Instant parseValue(
        @NonNull Object input,
        @NonNull GraphQLContext context,
        @NonNull Locale locale
      ) throws CoercingParseValueException {
        if (input instanceof String s) {
          try {
            return Instant.parse(s);
          } catch (DateTimeParseException e) {
            throw new CoercingParseValueException(&quot;Invalid Instant value: &quot; + e.getMessage() + &quot;&#39;.&quot;);
          }
        }
        throw new CoercingParseValueException(
          &quot;Expected a String for Instant but was: &quot; + Kit.typeName(input) + &quot;&#39;.&quot;
        );
      }

      @Override
      public Instant parseLiteral(
        @NonNull Value&lt;?&gt; input,
        @NonNull CoercedVariables variables,
        @NonNull GraphQLContext context,
        @NonNull Locale locale
      ) throws CoercingParseLiteralException {
        if (input instanceof StringValue sv) {
          String s = sv.getValue();
          try {
            return Instant.parse(s);
          } catch (DateTimeParseException e) {
            throw new CoercingParseLiteralException(&quot;Invalid Instant literal: &quot; + e.getMessage() + &quot;&#39;&quot;);
          }
        }
        throw new CoercingParseLiteralException(
          &quot;Expected AST type &#39;StringValue&#39; but was: &quot; + Kit.typeName(input) + &quot;&#39;.&quot;
        );
      }

      @Override
      @NonNull
      public Value&lt;?&gt; valueToLiteral(
        @NonNull Object input,
        @NonNull GraphQLContext context,
        @NonNull Locale locale
      ) {
        String serialized = serialize(input, context, locale);
        return StringValue.newStringValue(serialized).build();
      }
    };

    INSTANCE = GraphQLScalarType.newScalar()
      .name(&quot;Instant&quot;)
      .description(&quot;An ISO-8601 compliant java.time.Instant scalar&quot;)
      .specifiedByUrl(&quot;https://www.rfc-editor.org/rfc/rfc3339.html#section-5.6&quot;)
      .coercing(coercing)
      .build();
  }
}</code></pre>
<h3>Kotlin</h3>
<pre><code class="language-kotlin">package io.github.susimsek.springbootgraphqljwedemo.scalar

import graphql.GraphQLContext
import graphql.execution.CoercedVariables
import graphql.language.StringValue
import graphql.language.Value
import graphql.scalars.util.Kit
import graphql.schema.Coercing
import graphql.schema.CoercingParseLiteralException
import graphql.schema.CoercingParseValueException
import graphql.schema.CoercingSerializeException
import graphql.schema.GraphQLScalarType
import java.time.Instant
import java.time.format.DateTimeParseException
import java.util.Locale

object InstantScalar {

  @JvmField
  val INSTANCE: GraphQLScalarType = GraphQLScalarType.newScalar()
    .name(&quot;Instant&quot;)
    .description(&quot;An ISO-8601 compliant java.time.Instant scalar&quot;)
    .specifiedByUrl(&quot;https://www.rfc-editor.org/rfc/rfc3339.html#section-5.6&quot;)
    .coercing(object : Coercing&lt;Instant, String&gt; {
      override fun serialize(
        input: Any,
        context: GraphQLContext,
        locale: Locale
      ): String {
        return if (input is Instant) {
          input.toString()
        } else {
          throw CoercingSerializeException(&quot;Expected java.time.Instant but was: ${Kit.typeName(input)}&#39;.&quot;)
        }
      }

      override fun parseValue(
        input: Any,
        context: GraphQLContext,
        locale: Locale
      ): Instant {
        if (input is String) {
          return try {
            Instant.parse(input)
          } catch (e: DateTimeParseException) {
            throw CoercingParseValueException(&quot;Invalid Instant value: ${e.message}&#39;.&quot;)
          }
        }
        throw CoercingParseValueException(&quot;Expected a String for Instant but was: ${Kit.typeName(input)}&#39;.&quot;)
      }

      override fun parseLiteral(
        input: Value&lt;*&gt;,
        variables: CoercedVariables,
        context: GraphQLContext,
        locale: Locale
      ): Instant {
        if (input is StringValue) {
          return try {
            Instant.parse(input.value)
          } catch (e: DateTimeParseException) {
            throw CoercingParseLiteralException(&quot;Invalid Instant literal: ${e.message}&#39;&quot;)
          }
        }
        throw CoercingParseLiteralException(&quot;Expected AST type &#39;StringValue&#39; but was: ${Kit.typeName(input)}&#39;.&quot;)
      }

      override fun valueToLiteral(
        input: Any,
        context: GraphQLContext,
        locale: Locale
      ): Value&lt;*&gt; {
        val serialized = serialize(input, context, locale)
        return StringValue.newStringValue(serialized).build()
      }
    })
    .build()
}</code></pre>
<h3>NativeConfig</h3>
<h3>Java</h3>
<pre><code class="language-java">package io.github.susimsek.springbootgraphqljwedemo.config;

import org.springframework.aot.hint.MemberCategory;
import org.springframework.aot.hint.RuntimeHints;
import org.springframework.aot.hint.RuntimeHintsRegistrar;

public class NativeConfig {

  public static class AppNativeRuntimeHints implements RuntimeHintsRegistrar {

    @Override
    public void registerHints(RuntimeHints hints, ClassLoader classLoader) {
      hints.reflection()
        .registerType(sun.misc.Unsafe.class,
          hint -&gt; hint.withMembers(MemberCategory.INVOKE_PUBLIC_METHODS));
      hints.reflection()
        .registerType(java.util.Locale.class,
          hint -&gt; hint.withMembers(MemberCategory.INVOKE_PUBLIC_METHODS));
      hints.reflection()
        .registerType(org.hibernate.binder.internal.BatchSizeBinder.class,
          hint -&gt; hint.withMembers(MemberCategory.INVOKE_PUBLIC_CONSTRUCTORS));
      hints.resources().registerPattern(&quot;liquibase/*&quot;);
      hints.reflection()
        .registerType(liquibase.ui.LoggerUIService.class,
          hint -&gt; hint.withMembers(MemberCategory.INVOKE_PUBLIC_CONSTRUCTORS));
      hints.reflection()
        .registerType(liquibase.database.LiquibaseTableNamesFactory.class,
          hint -&gt; hint.withMembers(MemberCategory.INVOKE_DECLARED_CONSTRUCTORS));
      hints.reflection()
        .registerType(liquibase.report.ShowSummaryGeneratorFactory.class,
          hint -&gt; hint.withMembers(MemberCategory.INVOKE_DECLARED_CONSTRUCTORS));
      hints.reflection()
        .registerType(liquibase.changelog.FastCheckService.class,
          hint -&gt; hint.withMembers(MemberCategory.INVOKE_DECLARED_CONSTRUCTORS));
      hints.reflection()
        .registerType(liquibase.changelog.visitor.ValidatingVisitorGeneratorFactory.class,
          hint -&gt; hint.withMembers(MemberCategory.INVOKE_DECLARED_CONSTRUCTORS));
    }
  }
}</code></pre>
<h3>Kotlin</h3>
<pre><code class="language-kotlin">package io.github.susimsek.springbootgraphqljwedemo.config

import org.springframework.aot.hint.MemberCategory
import org.springframework.aot.hint.RuntimeHints
import org.springframework.aot.hint.RuntimeHintsRegistrar

class NativeConfig {

  class AppNativeRuntimeHints : RuntimeHintsRegistrar {
    override fun registerHints(hints: RuntimeHints, classLoader: ClassLoader) {
      hints.reflection().registerType(
        sun.misc.Unsafe::class.java,
        hint = hint@{ it.withMembers(MemberCategory.INVOKE_PUBLIC_METHODS) }
      )
      hints.reflection().registerType(
        java.util.Locale::class.java,
        hint = hint@{ it.withMembers(MemberCategory.INVOKE_PUBLIC_METHODS) }
      )
      hints.reflection().registerType(
        org.hibernate.binder.internal.BatchSizeBinder::class.java,
        hint = hint@{ it.withMembers(MemberCategory.INVOKE_PUBLIC_CONSTRUCTORS) }
      )
      hints.resources().registerPattern(&quot;liquibase/*&quot;)
      hints.reflection().registerType(
        liquibase.ui.LoggerUIService::class.java,
        hint = hint@{ it.withMembers(MemberCategory.INVOKE_PUBLIC_CONSTRUCTORS) }
      )
      hints.reflection().registerType(
        liquibase.database.LiquibaseTableNamesFactory::class.java,
        hint = hint@{ it.withMembers(MemberCategory.INVOKE_DECLARED_CONSTRUCTORS) }
      )
      hints.reflection().registerType(
        liquibase.report.ShowSummaryGeneratorFactory::class.java,
        hint = hint@{ it.withMembers(MemberCategory.INVOKE_DECLARED_CONSTRUCTORS) }
      )
      hints.reflection().registerType(
        liquibase.changelog.FastCheckService::class.java,
        hint = hint@{ it.withMembers(MemberCategory.INVOKE_DECLARED_CONSTRUCTORS) }
      )
      hints.reflection().registerType(
        liquibase.changelog.visitor.ValidatingVisitorGeneratorFactory::class.java,
        hint = hint@{ it.withMembers(MemberCategory.INVOKE_DECLARED_CONSTRUCTORS) }
      )
    }
  }
}</code></pre>
<h3>Main</h3>
<h3>Java</h3>
<pre><code class="language-java">package io.github.susimsek.springbootgraphqljwedemo;

import io.github.susimsek.springbootgraphqljwedemo.config.NativeConfig;
import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;
import org.springframework.context.annotation.ImportRuntimeHints;

@SpringBootApplication
@ImportRuntimeHints({ NativeConfig.AppNativeRuntimeHints.class })
public class SpringBootJweAuthJpaDemoApplication {

  public static void main(String[] args) {
    SpringApplication.run(SpringBootJweAuthJpaDemoApplication.class, args);
  }

}</code></pre>
<h3>Kotlin</h3>
<pre><code class="language-kotlin">package io.github.susimsek.springbootgraphqljwedemo

import io.github.susimsek.springbootgraphqljwedemo.config.NativeConfig
import org.springframework.boot.autoconfigure.SpringBootApplication
import org.springframework.boot.runApplication
import org.springframework.context.annotation.ImportRuntimeHints

@SpringBootApplication
@ImportRuntimeHints(NativeConfig.AppNativeRuntimeHints::class)
class SpringBootJweAuthJpaDemoApplication

fun main(args: Array&lt;String&gt;) {
  runApplication&lt;SpringBootJweAuthJpaDemoApplication&gt;(*args)
}</code></pre>
<hr />
<h2>üõ†Ô∏è Step 4: JPA Integration</h2>
<p>In this section, we define the JPA entities representing users, authorities, and their mappings, along with the Spring Data repository for loading users with their authorities.</p>
<ul>
<li>BaseEntity: Abstract superclass providing audit fields (`createdAt`, `createdBy`, `updatedAt`, `updatedBy`).</li>
<li>Authority: `authority` table entity storing role data.</li>
<li>User: `user_identity` table entity storing user credentials and profile.</li>
<li>UserAuthorityMapping: `user_authority_mapping` join table entity linking users and authorities.</li>
<li>UserAuthorityMappingId: Composite key class for `UserAuthorityMapping`.</li>
<li>UserRepository: Spring Data JPA repository for `User` with an entity graph to load authorities.</li>
</ul>
<h3>BaseEntity</h3>
<h3>Java</h3>
<pre><code class="language-java">package io.github.susimsek.springbootgraphqljwedemo.entity;

import jakarta.persistence.Column;
import jakarta.persistence.EntityListeners;
import jakarta.persistence.MappedSuperclass;
import lombok.Getter;
import lombok.Setter;
import org.springframework.data.annotation.CreatedBy;
import org.springframework.data.annotation.CreatedDate;
import org.springframework.data.annotation.LastModifiedBy;
import org.springframework.data.annotation.LastModifiedDate;
import org.springframework.data.jpa.domain.support.AuditingEntityListener;

import java.time.Instant;

@MappedSuperclass
@EntityListeners(AuditingEntityListener.class)
@Getter
@Setter
public abstract class BaseEntity {

  @CreatedDate
  @Column(name = &quot;created_at&quot;, nullable = false, updatable = false)
  private Instant createdAt;

  @CreatedBy
  @Column(name = &quot;created_by&quot;, nullable = false, updatable = false, length = 50)
  private String createdBy;

  @LastModifiedDate
  @Column(name = &quot;updated_at&quot;)
  private Instant updatedAt;

  @LastModifiedBy
  @Column(name = &quot;updated_by&quot;, length = 50)
  private String updatedBy;
}</code></pre>
<h3>Kotlin</h3>
<pre><code class="language-kotlin">package io.github.susimsek.springbootgraphqljwedemo.entity

import jakarta.persistence.Column
import jakarta.persistence.EntityListeners
import jakarta.persistence.MappedSuperclass
import org.springframework.data.annotation.CreatedBy
import org.springframework.data.annotation.CreatedDate
import org.springframework.data.annotation.LastModifiedBy
import org.springframework.data.annotation.LastModifiedDate
import org.springframework.data.jpa.domain.support.AuditingEntityListener
import java.time.Instant

@MappedSuperclass
@EntityListeners(AuditingEntityListener::class)
abstract class BaseEntity {

  @CreatedDate
  @Column(name = &quot;created_at&quot;, nullable = false, updatable = false)
  lateinit var createdAt: Instant

  @CreatedBy
  @Column(name = &quot;created_by&quot;, nullable = false, updatable = false, length = 50)
  lateinit var createdBy: String

  @LastModifiedDate
  @Column(name = &quot;updated_at&quot;)
  var updatedAt: Instant? = null

  @LastModifiedBy
  @Column(name = &quot;updated_by&quot;, length = 50)
  var updatedBy: String? = null
}</code></pre>
<h3>Authority</h3>
<h3>Java</h3>
<pre><code class="language-java">package io.github.susimsek.springbootgraphqljwedemo.entity;

import jakarta.persistence.Column;
import jakarta.persistence.Entity;
import jakarta.persistence.Id;
import jakarta.persistence.Table;
import lombok.AllArgsConstructor;
import lombok.Getter;
import lombok.NoArgsConstructor;
import lombok.Setter;
import org.hibernate.proxy.HibernateProxy;

import java.util.Objects;

@Entity
@Table(name = &quot;authority&quot;)
@Getter
@Setter
@NoArgsConstructor
@AllArgsConstructor
public class Authority extends BaseEntity {

  @Id
  @Column(length = 36, nullable = false)
  private String id;

  @Column(length = 50, nullable = false, unique = true)
  private String name;

  @Column(length = 255)
  private String description;

  @Override
  public final boolean equals(Object obj) {
    if (this == obj) {
      return true;
    }
    if (!(obj instanceof Authority other)) {
      return false;
    }
    Class&lt;?&gt; objClass = obj instanceof HibernateProxy proxy
      ? proxy.getHibernateLazyInitializer().getPersistentClass()
      : obj.getClass();
    Class&lt;?&gt; thisClass = this instanceof HibernateProxy proxy
      ? proxy.getHibernateLazyInitializer().getPersistentClass()
      : this.getClass();
    if (!thisClass.equals(objClass)) {
      return false;
    }
    return id != null &amp;&amp; Objects.equals(id, other.id);
  }

  @Override
  public final int hashCode() {
    return this instanceof HibernateProxy proxy
      ? proxy.getHibernateLazyInitializer().getPersistentClass().hashCode()
      : getClass().hashCode();
  }
}</code></pre>
<h3>Kotlin</h3>
<pre><code class="language-kotlin">package io.github.susimsek.springbootgraphqljwedemo.entity

import jakarta.persistence.Column
import jakarta.persistence.Entity
import jakarta.persistence.Id
import jakarta.persistence.Table
import org.hibernate.proxy.HibernateProxy
import java.util.Objects

@Entity
@Table(name = &quot;authority&quot;)
class Authority(
  @Id
  @Column(length = 36, nullable = false)
  var id: String,

  @Column(length = 50, nullable = false, unique = true)
  var name: String,

  @Column(length = 255)
  var description: String?
) : BaseEntity() {

  override fun equals(other: Any?): Boolean {
    if (this === other) return true
    if (other !is Authority) return false
    val objClass = (other as? HibernateProxy)?.hibernateLazyInitializer?.persistentClass ?: other::class.java
    val thisClass = (this as? HibernateProxy)?.hibernateLazyInitializer?.persistentClass ?: this::class.java
    if (thisClass != objClass) return false
    return id == other.id
  }

  override fun hashCode(): Int {
    return (this as? HibernateProxy)?.hibernateLazyInitializer?.persistentClass?.hashCode()
      ?: javaClass.hashCode()
  }
}</code></pre>
<h3>User</h3>
<h3>Java</h3>
<pre><code class="language-java">package io.github.susimsek.springbootgraphqljwedemo.entity;

import jakarta.persistence.CascadeType;
import jakarta.persistence.Column;
import jakarta.persistence.Entity;
import jakarta.persistence.FetchType;
import jakarta.persistence.Id;
import jakarta.persistence.NamedAttributeNode;
import jakarta.persistence.NamedEntityGraph;
import jakarta.persistence.NamedSubgraph;
import jakarta.persistence.OneToMany;
import jakarta.persistence.Table;
import lombok.AllArgsConstructor;
import lombok.Getter;
import lombok.NoArgsConstructor;
import lombok.Setter;
import org.hibernate.proxy.HibernateProxy;

import java.util.HashSet;
import java.util.Objects;
import java.util.Set;

@Entity
@Table(name = &quot;user_identity&quot;)
@Getter
@Setter
@NoArgsConstructor
@AllArgsConstructor
@NamedEntityGraph(
  name = &quot;User.withAuthorities&quot;,
  attributeNodes = @NamedAttributeNode(value = &quot;authorities&quot;, subgraph = &quot;auth-subgraph&quot;),
  subgraphs = @NamedSubgraph(
    name = &quot;auth-subgraph&quot;,
    attributeNodes = @NamedAttributeNode(&quot;authority&quot;)
  )
)
public class User extends BaseEntity {

  @Id
  @Column(name = &quot;id&quot;, length = 36, nullable = false, updatable = false)
  private String id;

  @Column(name = &quot;username&quot;, length = 50, nullable = false, unique = true)
  private String username;

  @Column(name = &quot;password&quot;, length = 100, nullable = false)
  private String password;

  @Column(name = &quot;email&quot;, length = 100, nullable = false, unique = true)
  private String email;

  @Column(name = &quot;first_name&quot;, length = 50)
  private String firstName;

  @Column(name = &quot;last_name&quot;, length = 50)
  private String lastName;

  @Column(name = &quot;enabled&quot;, nullable = false)
  private boolean enabled;

  @OneToMany(mappedBy = &quot;user&quot;, fetch = FetchType.LAZY,
    cascade = CascadeType.ALL, orphanRemoval = true)
  private Set&lt;UserAuthorityMapping&gt; authorities = new HashSet&lt;&gt;();

  @Override
  public final boolean equals(Object obj) {
    if (this == obj) return true;
    if (!(obj instanceof User other)) return false;
    Class&lt;?&gt; objClass = (obj instanceof HibernateProxy hp
      ? hp.getHibernateLazyInitializer().getPersistentClass()
      : obj.getClass());
    Class&lt;?&gt; thisClass = (this instanceof HibernateProxy hp
      ? hp.getHibernateLazyInitializer().getPersistentClass()
      : this.getClass());
    if (!thisClass.equals(objClass)) return false;
    return id != null &amp;&amp; id.equals(other.id);
  }

  @Override
  public final int hashCode() {
    return (this instanceof HibernateProxy hp
      ? hp.getHibernateLazyInitializer().getPersistentClass().hashCode()
      : getClass().hashCode());
  }
}</code></pre>
<h3>Kotlin</h3>
<pre><code class="language-kotlin">package io.github.susimsek.springbootgraphqljwedemo.entity

import jakarta.persistence.CascadeType
import jakarta.persistence.Column
import jakarta.persistence.Entity
import jakarta.persistence.FetchType
import jakarta.persistence.Id
import jakarta.persistence.NamedAttributeNode
import jakarta.persistence.NamedEntityGraph
import jakarta.persistence.NamedSubgraph
import jakarta.persistence.OneToMany
import jakarta.persistence.Table
import org.hibernate.proxy.HibernateProxy
import java.util.*

@Entity
@Table(name = &quot;user_identity&quot;)
@NamedEntityGraph(
  name = &quot;User.withAuthorities&quot;,
  attributeNodes = [NamedAttributeNode(value = &quot;authorities&quot;, subgraph = &quot;auth-subgraph&quot;)],
  subgraphs = [
    NamedSubgraph(
      name = &quot;auth-subgraph&quot;,
      attributeNodes = [NamedAttributeNode(&quot;authority&quot;)]
    )
  ]
)
class User(

  @Id
  @Column(name = &quot;id&quot;, length = 36, nullable = false, updatable = false)
  var id: String,

  @Column(name = &quot;username&quot;, length = 50, nullable = false, unique = true)
  var username: String,

  @Column(name = &quot;password&quot;, length = 100, nullable = false)
  var password: String,

  @Column(name = &quot;email&quot;, length = 100, nullable = false, unique = true)
  var email: String,

  @Column(name = &quot;first_name&quot;, length = 50)
  var firstName: String? = null,

  @Column(name = &quot;last_name&quot;, length = 50)
  var lastName: String? = null,

  @Column(name = &quot;enabled&quot;, nullable = false)
  var enabled: Boolean = true

) : BaseEntity() {

  @OneToMany(
    mappedBy = &quot;user&quot;,
    fetch = FetchType.LAZY,
    cascade = [CascadeType.ALL],
    orphanRemoval = true
  )
  var authorities: MutableSet&lt;UserAuthorityMapping&gt; = HashSet()

  override fun equals(other: Any?): Boolean {
    if (this === other) return true
    if (other !is User) return false
    val objClass = (other as? HibernateProxy)?.hibernateLazyInitializer?.persistentClass
      ?: other::class.java
    val thisClass = (this as? HibernateProxy)?.hibernateLazyInitializer?.persistentClass
      ?: this::class.java
    if (thisClass != objClass) return false
    return id == other.id
  }

  override fun hashCode(): Int =
    ((this as? HibernateProxy)?.hibernateLazyInitializer?.persistentClass?.hashCode()
      ?: javaClass.hashCode())
}</code></pre>
<h3>UserAuthorityMapping</h3>
<h3>Java</h3>
<pre><code class="language-java">package io.github.susimsek.springbootgraphqljwedemo.entity;

import jakarta.persistence.Column;
import jakarta.persistence.Entity;
import jakarta.persistence.FetchType;
import jakarta.persistence.Id;
import jakarta.persistence.IdClass;
import jakarta.persistence.JoinColumn;
import jakarta.persistence.ManyToOne;
import jakarta.persistence.Table;
import lombok.AllArgsConstructor;
import lombok.Getter;
import lombok.NoArgsConstructor;
import lombok.Setter;
import org.hibernate.proxy.HibernateProxy;

import java.util.Objects;

@Entity
@Table(name = &quot;user_authority_mapping&quot;)
@IdClass(UserAuthorityMappingId.class)
@Getter
@Setter
@NoArgsConstructor
@AllArgsConstructor
public class UserAuthorityMapping extends BaseEntity {

  @Id
  @Column(name = &quot;user_id&quot;, length = 36, nullable = false)
  private String userId;

  @Id
  @Column(name = &quot;authority_id&quot;, length = 36, nullable = false)
  private String authorityId;

  @ManyToOne(fetch = FetchType.LAZY)
  @JoinColumn(name = &quot;user_id&quot;, insertable = false, updatable = false)
  private User user;

  @ManyToOne(fetch = FetchType.LAZY)
  @JoinColumn(name = &quot;authority_id&quot;, insertable = false, updatable = false)
  private Authority authority;

  @Override
  public final boolean equals(Object obj) {
    if (this == obj) return true;
    if (!(obj instanceof UserAuthorityMapping other)) return false;
    Class&lt;?&gt; objCls = (obj instanceof HibernateProxy hp
      ? hp.getHibernateLazyInitializer().getPersistentClass()
      : obj.getClass());
    Class&lt;?&gt; thisCls = (this instanceof HibernateProxy hp
      ? hp.getHibernateLazyInitializer().getPersistentClass()
      : this.getClass());
    if (!thisCls.equals(objCls)) return false;
    return userId != null &amp;&amp; userId.equals(other.userId)
      &amp;&amp; authorityId != null &amp;&amp; authorityId.equals(other.authorityId);
  }

  @Override
  public final int hashCode() {
    return (this instanceof HibernateProxy hp
      ? hp.getHibernateLazyInitializer().getPersistentClass().hashCode()
      : Objects.hash(userId, authorityId));
  }
}</code></pre>
<h3>Kotlin</h3>
<pre><code class="language-kotlin">package io.github.susimsek.springbootgraphqljwedemo.entity

import jakarta.persistence.*
import org.hibernate.proxy.HibernateProxy
import java.util.*

@Entity
@Table(name = &quot;user_authority_mapping&quot;)
@IdClass(UserAuthorityMappingId::class)
data class UserAuthorityMapping(

  @Id
  @Column(name = &quot;user_id&quot;, length = 36, nullable = false)
  var userId: String = &quot;&quot;,

  @Id
  @Column(name = &quot;authority_id&quot;, length = 36, nullable = false)
  var authorityId: String = &quot;&quot;,

  @ManyToOne(fetch = FetchType.LAZY)
  @JoinColumn(name = &quot;user_id&quot;, insertable = false, updatable = false)
  var user: User? = null,

  @ManyToOne(fetch = FetchType.LAZY)
  @JoinColumn(name = &quot;authority_id&quot;, insertable = false, updatable = false)
  var authority: Authority? = null

) : BaseEntity() {

  override fun equals(other: Any?): Boolean {
    if (this === other) return true
    if (other !is UserAuthorityMapping) return false

    val objCls = (other as? HibernateProxy)?.hibernateLazyInitializer?.persistentClass
      ?: other::class.java
    val thisCls = (this as? HibernateProxy)?.hibernateLazyInitializer?.persistentClass
      ?: this::class.java

    if (thisCls != objCls) return false
    return userId == other.userId &amp;&amp; authorityId == other.authorityId
  }

  override fun hashCode(): Int {
    return (this as? HibernateProxy)?.hibernateLazyInitializer?.persistentClass?.hashCode()
      ?: Objects.hash(userId, authorityId)
  }
}</code></pre>
<h3>UserAuthorityMappingId</h3>
<h3>Java</h3>
<pre><code class="language-java">package io.github.susimsek.springbootgraphqljwedemo.entity;

import java.io.Serializable;
import java.util.Objects;
import lombok.AllArgsConstructor;
import lombok.Getter;
import lombok.NoArgsConstructor;
import lombok.Setter;

@Getter
@Setter
@NoArgsConstructor
@AllArgsConstructor
public class UserAuthorityMappingId implements Serializable {

  private String userId;
  private String authorityId;

  @Override
  public boolean equals(Object o) {
    if (this == o) return true;
    if (o == null || getClass() != o.getClass()) return false;
    UserAuthorityMappingId that = (UserAuthorityMappingId) o;
    return Objects.equals(userId, that.userId) &amp;&amp;
      Objects.equals(authorityId, that.authorityId);
  }

  @Override
  public int hashCode() {
    return Objects.hash(userId, authorityId);
  }
}</code></pre>
<h3>Kotlin</h3>
<pre><code class="language-kotlin">package io.github.susimsek.springbootgraphqljwedemo.entity

import java.io.Serializable
import java.util.Objects

data class UserAuthorityMappingId(
  var userId: String = &quot;&quot;,
  var authorityId: String = &quot;&quot;
) : Serializable {

  override fun equals(other: Any?): Boolean {
    if (this === other) return true
    if (other == null || this::class != other::class) return false
    other as UserAuthorityMappingId
    return userId == other.userId &amp;&amp; authorityId == other.authorityId
  }

  override fun hashCode(): Int {
    return Objects.hash(userId, authorityId)
  }
}</code></pre>
<h3>UserRepository</h3>
<h3>Java</h3>
<pre><code class="language-java">package io.github.susimsek.springbootgraphqljwedemo.repository;

import io.github.susimsek.springbootgraphqljwedemo.entity.User;
import org.springframework.data.jpa.repository.EntityGraph;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.stereotype.Repository;

import java.util.Optional;

@Repository
public interface UserRepository extends JpaRepository&lt;User, String&gt; {

  @EntityGraph(&quot;User.withAuthorities&quot;)
  Optional&lt;User&gt; findOneWithAuthoritiesByUsername(String username);
}</code></pre>
<h3>Kotlin</h3>
<pre><code class="language-kotlin">package io.github.susimsek.springbootgraphqljwedemo.repository

import io.github.susimsek.springbootgraphqljwedemo.entity.User
import org.springframework.data.jpa.repository.EntityGraph
import org.springframework.data.jpa.repository.JpaRepository
import org.springframework.stereotype.Repository
import java.util.Optional

@Repository
interface UserRepository : JpaRepository&lt;User, String&gt; {

  @EntityGraph(&quot;User.withAuthorities&quot;)
  fun findOneWithAuthoritiesByUsername(username: String): Optional&lt;User&gt;
}</code></pre>
<hr />
<h2>üõ†Ô∏è Step 5: Secure JWE Token Utilities</h2>
<p>In this section, we define the core utility classes and constants needed to generate, encrypt, and resolve JSON Web Encryption (JWE) tokens in your Spring Boot application, integrate auditing, and implement a JPA-based user details service:</p>
<ul>
<li>AuthoritiesConstants: Centralize role names with the `ROLE_` prefix.</li>
<li>CookieBearerTokenResolver: Resolve bearer tokens from Authorization headers or HTTP cookies.</li>
<li>CookieUtils: Generates HTTP-only, secure `ResponseCookie` for new or expired tokens, and extracts the raw `accessToken` from `HttpHeaders`</li>
<li>JweUtil: Sign (JWS) and encrypt (JWE) JWTs using RSA keys and Nimbus.</li>
<li>KeyUtils: Build RSA JWKs from PEM‚Äêencoded key material.</li>
<li>SecurityUtils: Extract the current user‚Äôs login from the security context.</li>
<li>SpringSecurityAuditorAware: Implement `AuditorAware` to provide the current user for auditing.</li>
<li>DomainUserDetailsService: JPA-based `UserDetailsService` loading user and authorities for authentication.</li>
<li>GraphQlTokenCookieInterceptor: Intercepts GraphQL responses to set or clear the access token cookie based on `accessToken` and `clearAccessToken` flags in the `GraphQLContext`.</li>
<li>CookieAuthenticationWebSocketInterceptor: Intercept WebSocket connections to authenticate using JWE tokens from headers or cookies.</li>
</ul>
<p>These utilities form the foundation for a stateless, JWE‚Äêbased authentication flow in Spring Security.</p>
<h3>AuthoritiesConstants</h3>
<h3>Java</h3>
<pre><code class="language-java">
package io.github.susimsek.springbootgraphqljwedemo.security;

import lombok.AccessLevel;
import lombok.NoArgsConstructor;

@NoArgsConstructor(access = AccessLevel.PRIVATE)
public final class AuthoritiesConstants {
    public static final String ADMIN = &quot;ROLE_ADMIN&quot;;
    public static final String USER = &quot;ROLE_USER&quot;;
    public static final String ANONYMOUS = &quot;ROLE_ANONYMOUS&quot;;
}</code></pre>
<h3>Kotlin</h3>
<pre><code class="language-kotlin">
package io.github.susimsek.springbootgraphqljwedemo.security

object AuthoritiesConstants {
  const val ADMIN = &quot;ROLE_ADMIN&quot;
  const val USER = &quot;ROLE_USER&quot;
  const val ANONYMOUS = &quot;ROLE_ANONYMOUS&quot;
}</code></pre>
<h3>CookieBearerTokenResolver</h3>
<h3>Java</h3>
<pre><code class="language-java">package io.github.susimsek.springbootgraphqljwedemo.security;

import jakarta.servlet.http.Cookie;
import jakarta.servlet.http.HttpServletRequest;
import lombok.Setter;
import org.springframework.http.HttpMethod;
import org.springframework.security.oauth2.core.OAuth2AuthenticationException;
import org.springframework.security.oauth2.server.resource.BearerTokenError;
import org.springframework.security.oauth2.server.resource.BearerTokenErrors;
import org.springframework.security.oauth2.server.resource.web.BearerTokenResolver;
import org.springframework.util.StringUtils;

import java.util.regex.Matcher;
import java.util.regex.Pattern;

@Setter
public class CookieBearerTokenResolver implements BearerTokenResolver {
    private static final String ACCESS_TOKEN_PARAMETER_NAME = &quot;access_token&quot;;
    private static final Pattern AUTHORIZATION_PATTERN =
        Pattern.compile(&quot;^Bearer (?&lt;token&gt;[A-Za-z0-9-._~+/]+=*)$&quot;, Pattern.CASE_INSENSITIVE);

    private boolean allowFormEncodedBodyParameter = false;
    private boolean allowUriQueryParameter       = false;
    private boolean allowCookie                  = true;
    private String  bearerTokenHeaderName       = &quot;Authorization&quot;;
    private String  cookieName                  = &quot;accessToken&quot;;

    @Override
    public String resolve(HttpServletRequest request) {
        String headerToken = resolveFromAuthorizationHeader(request);
        String queryToken  = resolveAccessTokenFromQueryString(request);
        String bodyToken   = resolveAccessTokenFromBody(request);
        String cookieToken = (headerToken == null &amp;&amp; queryToken == null &amp;&amp; bodyToken == null)
            ? resolveFromCookie(request)
            : null;

        return resolveToken(headerToken, queryToken, bodyToken, cookieToken);
    }

    private String resolveFromAuthorizationHeader(HttpServletRequest request) {
        String authorization = request.getHeader(this.bearerTokenHeaderName);
        if (!StringUtils.hasText(authorization) || !authorization.toLowerCase().startsWith(&quot;bearer&quot;)) {
            return null;
        }
        Matcher matcher = AUTHORIZATION_PATTERN.matcher(authorization.trim());
        if (!matcher.matches()) {
            BearerTokenError error = BearerTokenErrors.invalidToken(&quot;Bearer token is malformed&quot;);
            throw new OAuth2AuthenticationException(error);
        }
        return matcher.group(&quot;token&quot;);
    }

    private String resolveAccessTokenFromQueryString(HttpServletRequest request) {
        if (allowUriQueryParameter &amp;&amp; HttpMethod.GET.matches(request.getMethod())) {
            return resolveToken(request.getParameterValues(ACCESS_TOKEN_PARAMETER_NAME));
        }
        return null;
    }

    private String resolveAccessTokenFromBody(HttpServletRequest request) {
        if (allowFormEncodedBodyParameter
            &amp;&amp; HttpMethod.POST.matches(request.getMethod())
            &amp;&amp; &quot;application/x-www-form-urlencoded&quot;.equals(request.getContentType())) {
            return resolveToken(request.getParameterValues(ACCESS_TOKEN_PARAMETER_NAME));
        }
        return null;
    }

    private String resolveFromCookie(HttpServletRequest request) {
        if (!allowCookie || request.getCookies() == null) {
            return null;
        }
        for (Cookie cookie : request.getCookies()) {
            if (cookieName.equals(cookie.getName())) {
                String val = cookie.getValue();
                return StringUtils.hasText(val) ? val : null;
            }
        }
        return null;
    }

    private String resolveToken(String... tokens) {
        String found = null;
        for (String token : tokens) {
            if (token == null) continue;
            if (found != null) {
                BearerTokenError error = BearerTokenErrors.invalidRequest(&quot;Found multiple bearer tokens in the request&quot;);
                throw new OAuth2AuthenticationException(error);
            }
            found = token;
        }
        if (found != null &amp;&amp; found.isBlank()) {
            BearerTokenError error = BearerTokenErrors.invalidRequest(&quot;The requested token parameter is an empty string&quot;);
            throw new OAuth2AuthenticationException(error);
        }
        return found;
    }</code></pre>
<h3>Kotlin</h3>
<pre><code class="language-kotlin">package io.github.susimsek.springbootgraphqljwedemo.security

import jakarta.servlet.http.Cookie
import jakarta.servlet.http.HttpServletRequest
import org.springframework.http.HttpMethod
import org.springframework.security.oauth2.core.OAuth2AuthenticationException
import org.springframework.security.oauth2.server.resource.BearerTokenError
import org.springframework.security.oauth2.server.resource.BearerTokenErrors
import org.springframework.security.oauth2.server.resource.web.BearerTokenResolver
import org.springframework.util.StringUtils
import java.util.regex.Pattern

class CookieBearerTokenResolver {
    var allowFormEncodedBodyParameter: Boolean = false
    var allowUriQueryParameter: Boolean = false
    var allowCookie: Boolean = true
    var bearerTokenHeaderName: String = &quot;Authorization&quot;
    var cookieName: String = &quot;accessToken&quot;

    companion object {
        private const val ACCESS_TOKEN_PARAMETER_NAME = &quot;access_token&quot;
        private val AUTHORIZATION_PATTERN =
            Pattern.compile(&quot;^Bearer (?&lt;token&gt;[A-Za-z0-9-._~+/]+=*)$&quot;, Pattern.CASE_INSENSITIVE)
    }

    fun resolve(request: HttpServletRequest): String? {
        val header = resolveFromAuthorizationHeader(request)
        val query  = if (allowUriQueryParameter &amp;&amp; HttpMethod.GET.matches(request.method))
            request.getParameterValues(ACCESS_TOKEN_PARAMETER_NAME)?.let(::resolveToken)
        else null
        val body   = if (allowFormEncodedBodyParameter &amp;&amp; HttpMethod.POST.matches(request.method)
            &amp;&amp; request.contentType == &quot;application/x-www-form-urlencoded&quot;)
            request.getParameterValues(ACCESS_TOKEN_PARAMETER_NAME)?.let(::resolveToken)
        else null
        val cookie = if (header == null &amp;&amp; query == null &amp;&amp; body == null)
            resolveFromCookie(request)
        else null
      return listOf(header, query, body, cookie).filterNotNull().let {
            if (it.size &gt; 1) throw OAuth2AuthenticationException(BearerTokenErrors.invalidRequest(&quot;Found multiple bearer tokens&quot;))
            it.firstOrNull()?: null
        }
    }

    private fun resolveFromAuthorizationHeader(request: HttpServletRequest): String? {
        val auth = request.getHeader(bearerTokenHeaderName) ?: return null
        if (!auth.startsWith(&quot;Bearer &quot;, true)) return null
        val matcher = AUTHORIZATION_PATTERN.matcher(auth.trim())
        return if (matcher.matches()) matcher.group(&quot;token&quot;)
        else throw OAuth2AuthenticationException(BearerTokenErrors.invalidToken(&quot;Malformed token&quot;))
    }

    private fun resolveFromCookie(request: HttpServletRequest): String? {
        if (!allowCookie) return null
        return request.cookies?.firstOrNull { it.name == cookieName }?.value?.takeIf { it.isNotBlank() }
    }

    private fun resolveToken(tokens: Array&lt;String&gt;): String? {
        return tokens.filter { it.isNotBlank() }.let {
            when {
                it.isEmpty() -&gt; null
                it.size &gt; 1   -&gt; throw OAuth2AuthenticationException(BearerTokenErrors.invalidRequest(&quot;Multiple tokens&quot;))
                else          -&gt; it[0]
            }
        }
    }</code></pre>
<h3>CookieUtils</h3>
<h3>Java</h3>
<pre><code class="language-java">package io.github.susimsek.springbootjweauthjpademo.security;

import io.github.susimsek.springbootjweauthjpademo.dto.TokenDTO;
import lombok.experimental.UtilityClass;
import org.springframework.http.HttpHeaders;
import org.springframework.http.ResponseCookie;

import java.net.HttpCookie;
import java.util.Arrays;
import java.util.Optional;

@UtilityClass
public class CookieUtils {

  public static final String COOKIE_NAME = &quot;accessToken&quot;;

  public ResponseCookie createAccessTokenCookie(TokenDTO tokenDto) {
    return ResponseCookie.from(COOKIE_NAME, tokenDto.accessToken())
      .httpOnly(true)
      .secure(true)
      .path(&quot;/&quot;)
      .maxAge(tokenDto.accessTokenExpiresIn())
      .sameSite(&quot;Strict&quot;)
      .build();
  }

  public static ResponseCookie removeAccessTokenCookie() {
    return ResponseCookie.from(COOKIE_NAME, &quot;&quot;)
      .httpOnly(true)
      .secure(true)
      .path(&quot;/&quot;)
      .maxAge(0)
      .sameSite(&quot;Strict&quot;)
      .build();
  }

  public String resolveToken(HttpHeaders headers) {
    return Optional.ofNullable(headers.getFirst(HttpHeaders.COOKIE))
      .map(h -&gt; h.split(&quot;;&quot;))
      .stream()
      .flatMap(Arrays::stream)
      .flatMap(part -&gt; HttpCookie.parse(part).stream())
      .filter(c -&gt; COOKIE_NAME.equals(c.getName()))
      .map(HttpCookie::getValue)
      .findFirst()
      .orElse(null);
  }
}</code></pre>
<h3>Kotlin</h3>
<pre><code class="language-kotlin">package io.github.susimsek.springbootjweauthjpademo.security

import io.github.susimsek.springbootjweauthjpademo.dto.TokenDTO
import org.springframework.http.HttpHeaders
import org.springframework.http.ResponseCookie
import java.net.HttpCookie

object CookieUtils {

  const val COOKIE_NAME = &quot;accessToken&quot;

  fun createAccessTokenCookie(tokenDto: TokenDTO): ResponseCookie =
    ResponseCookie.from(COOKIE_NAME, tokenDto.accessToken())
      .httpOnly(true)
      .secure(true)
      .path(&quot;/&quot;)
      .maxAge(tokenDto.accessTokenExpiresIn())
      .sameSite(&quot;Strict&quot;)
      .build()

  fun removeAccessTokenCookie(): ResponseCookie =
    ResponseCookie.from(COOKIE_NAME, &quot;&quot;)
      .httpOnly(true)
      .secure(true)
      .path(&quot;/&quot;)
      .maxAge(0)
      .sameSite(&quot;Strict&quot;)
      .build()

  fun resolveToken(headers: HttpHeaders): String? =
    headers.getFirst(HttpHeaders.COOKIE)
      ?.split(&quot;;&quot;)
      .orEmpty()
      .asSequence()
      .flatMap { HttpCookie.parse(it).asSequence() }
      .firstOrNull { it.name == COOKIE_NAME }
      ?.value
}</code></pre>
<h3>JweUtil</h3>
<h3>Java</h3>
<pre><code class="language-java">package io.github.susimsek.springbootgraphqljwedemo.security;

import com.nimbusds.jose.EncryptionMethod;
import com.nimbusds.jose.JOSEException;
import com.nimbusds.jose.JWEAlgorithm;
import com.nimbusds.jose.JWEHeader;
import com.nimbusds.jose.JWEObject;
import com.nimbusds.jose.Payload;
import com.nimbusds.jose.crypto.RSAEncrypter;
import com.nimbusds.jose.jwk.RSAKey;
import io.github.susimsek.springbootgraphqljwedemo.config.JwtProperties;
import io.github.susimsek.springbootgraphqljwedemo.dto.TokenDTO;
import lombok.RequiredArgsConstructor;
import org.springframework.security.core.Authentication;
import org.springframework.security.core.GrantedAuthority;
import org.springframework.security.oauth2.jose.jws.SignatureAlgorithm;
import org.springframework.security.oauth2.jwt.*;
import org.springframework.stereotype.Component;

import java.time.Instant;
import java.util.List;

import static io.github.susimsek.springbootgraphqljwedemo.security.SecurityUtils.AUTHORITIES_KEY;

@Component
@RequiredArgsConstructor
public class JweUtil {

    private final JwtEncoder jwtEncoder;
    private final RSAKey signingKey;
    private final RSAKey encryptionKey;
    private final JwtProperties props;

    public TokenDTO generateToken(Authentication authentication) throws JOSEException {
        String subject = authentication.getName();
        List&lt;String&gt; roles = authentication.getAuthorities()
            .stream()
            .map(GrantedAuthority::getAuthority)
            .toList();

        Instant now = Instant.now();
        long expiresIn = props.getExpirationDuration().getSeconds();
        Instant exp = now.plusSeconds(expiresIn);

        JwtClaimsSet claims = JwtClaimsSet.builder()
            .issuer(props.getIssuer())
            .issuedAt(now)
            .expiresAt(exp)
            .subject(subject)
            .claim(AUTHORITIES_KEY, roles)
            .build();

        JwsHeader jwsHeader = JwsHeader.with(SignatureAlgorithm.RS256)
            .keyId(signingKey.getKeyID())
            .build();

        String jws = jwtEncoder
            .encode(JwtEncoderParameters.from(jwsHeader, claims))
            .getTokenValue();

        JWEHeader jweHeader = new JWEHeader.Builder(JWEAlgorithm.RSA_OAEP_256, EncryptionMethod.A128GCM)
            .contentType(&quot;JWT&quot;)
            .keyID(encryptionKey.getKeyID())
            .build();

        JWEObject jweObject = new JWEObject(jweHeader, new Payload(jws));
        jweObject.encrypt(new RSAEncrypter(encryptionKey.toRSAPublicKey()));
        String token = jweObject.serialize();

        return new TokenDTO(token, &quot;Bearer&quot;, expiresIn);
    }
}</code></pre>
<h3>Kotlin</h3>
<pre><code class="language-kotlin">package io.github.susimsek.springbootgraphqljwedemo.security

import com.nimbusds.jose.EncryptionMethod
import com.nimbusds.jose.JOSEException
import com.nimbusds.jose.JWEAlgorithm
import com.nimbusds.jose.JWEHeader
import com.nimbusds.jose.JWEObject
import com.nimbusds.jose.Payload
import com.nimbusds.jose.crypto.RSAEncrypter
import com.nimbusds.jose.jwk.RSAKey
import io.github.susimsek.springbootgraphqljwedemo.config.JwtProperties
import io.github.susimsek.springbootgraphqljwedemo.dto.TokenDTO
import lombok.RequiredArgsConstructor
import org.springframework.security.core.Authentication
import org.springframework.security.oauth2.jose.jws.SignatureAlgorithm
import org.springframework.security.oauth2.jwt.JwtClaimsSet
import org.springframework.security.oauth2.jwt.JwtEncoder
import org.springframework.security.oauth2.jwt.JwtEncoderParameters
import org.springframework.stereotype.Component

import java.time.Instant

@Component
@RequiredArgsConstructor
class JweUtil(
    private val jwtEncoder: JwtEncoder,
    private val signingKey: RSAKey,
    private val encryptionKey: RSAKey,
    private val props: JwtProperties
) {
    fun generateToken(authentication: Authentication): TokenDTO {
        val subject = authentication.name
        val roles = authentication.authorities.map { it.authority }

        val now = Instant.now()
        val expiresIn = props.expirationDuration.seconds
        val exp = now.plusSeconds(expiresIn)

        val claims = JwtClaimsSet.builder()
            .issuer(props.issuer)
            .issuedAt(now)
            .expiresAt(exp)
            .subject(subject)
            .claim(AUTHORITIES_KEY, roles)
            .build()

        val jwsHeader = org.springframework.security.oauth2.jwt.JwsHeader.with(SignatureAlgorithm.RS256)
            .keyId(signingKey.keyID)
            .build()

        val jws = jwtEncoder
            .encode(JwtEncoderParameters.from(jwsHeader, claims))
            .tokenValue

        val jweHeader = JWEHeader.Builder(JWEAlgorithm.RSA_OAEP_256, EncryptionMethod.A128GCM)
            .contentType(&quot;JWT&quot;)
            .keyID(encryptionKey.keyID)
            .build()

        val jweObject = JWEObject(jweHeader, Payload(jws))
        jweObject.encrypt(RSAEncrypter(encryptionKey.toRSAPublicKey()))
        val token = jweObject.serialize()

        return TokenDTO(token, &quot;Bearer&quot;, expiresIn)
    }
}</code></pre>
<h3>KeyUtils</h3>
<h3>Java</h3>
<pre><code class="language-java">package io.github.susimsek.springbootgraphqljwedemo.security;

import com.nimbusds.jose.JWEAlgorithm;
import com.nimbusds.jose.JWSAlgorithm;
import com.nimbusds.jose.jwk.KeyUse;
import com.nimbusds.jose.jwk.RSAKey;
import lombok.experimental.UtilityClass;

import java.security.KeyFactory;
import java.security.interfaces.RSAPrivateKey;
import java.security.interfaces.RSAPublicKey;
import java.security.spec.PKCS8EncodedKeySpec;
import java.security.spec.X509EncodedKeySpec;
import java.util.Base64;

@UtilityClass
public class KeyUtils {
    public RSAKey buildRsaKey(
            String pubPem,
            String privPem,
            String kid,
            boolean forSign
    ) throws Exception {
        String pubContent = pubPem
            .replace(&quot;-----BEGIN PUBLIC KEY-----&quot;, &quot;&quot;)
            .replace(&quot;-----END PUBLIC KEY-----&quot;, &quot;&quot;)
            .replaceAll(&quot;\\s&quot;, &quot;&quot;);
        String privContent = privPem
            .replace(&quot;-----BEGIN PRIVATE KEY-----&quot;, &quot;&quot;)
            .replace(&quot;-----END PRIVATE KEY-----&quot;, &quot;&quot;)
            .replaceAll(&quot;\\s&quot;, &quot;&quot;);

        byte[] decodedPub = Base64.getDecoder().decode(pubContent);
        byte[] decodedPriv = Base64.getDecoder().decode(privContent);

        KeyFactory kf = KeyFactory.getInstance(&quot;RSA&quot;);
        RSAPublicKey publicKey = (RSAPublicKey) kf.generatePublic(new X509EncodedKeySpec(decodedPub));
        RSAPrivateKey privateKey = (RSAPrivateKey) kf.generatePrivate(new PKCS8EncodedKeySpec(decodedPriv));

        RSAKey.Builder builder = new RSAKey.Builder(publicKey)
            .privateKey(privateKey)
            .keyID(kid);

        if (forSign) {
            builder
                .algorithm(JWSAlgorithm.RS256)
                .keyUse(KeyUse.SIGNATURE);
        } else {
            builder
                .algorithm(JWEAlgorithm.RSA_OAEP_256)
                .keyUse(KeyUse.ENCRYPTION);
        }

        return builder.build();
    }
}</code></pre>
<h3>Kotlin</h3>
<pre><code class="language-kotlin">package io.github.susimsek.springbootgraphqljwedemo.security

import com.nimbusds.jose.JWEAlgorithm
import com.nimbusds.jose.JWSAlgorithm
import com.nimbusds.jose.jwk.KeyUse
import com.nimbusds.jose.jwk.RSAKey
import java.security.KeyFactory
import java.security.interfaces.RSAPrivateKey
import java.security.interfaces.RSAPublicKey
import java.security.spec.PKCS8EncodedKeySpec
import java.security.spec.X509EncodedKeySpec
import java.util.Base64

object KeyUtils {
    @JvmStatic
    @Throws(Exception::class)
    fun buildRsaKey(
        pubPem: String,
        privPem: String,
        kid: String,
        forSign: Boolean
    ): RSAKey {
        val pubContent = pubPem
            .replace(&quot;-----BEGIN PUBLIC KEY-----&quot;, &quot;&quot;)
            .replace(&quot;-----END PUBLIC KEY-----&quot;, &quot;&quot;)
            .replace(Regex(&quot;\\s&quot;), &quot;&quot;)
        val privContent = privPem
            .replace(&quot;-----BEGIN PRIVATE KEY-----&quot;, &quot;&quot;)
            .replace(&quot;-----END PRIVATE KEY-----&quot;, &quot;&quot;)
            .replace(Regex(&quot;\\s&quot;), &quot;&quot;)

        val decodedPub = Base64.getDecoder().decode(pubContent)
        val decodedPriv = Base64.getDecoder().decode(privContent)

        val kf = KeyFactory.getInstance(&quot;RSA&quot;)
        val publicKey = kf.generatePublic(X509EncodedKeySpec(decodedPub)) as RSAPublicKey
        val privateKey = kf.generatePrivate(PKCS8EncodedKeySpec(decodedPriv)) as RSAPrivateKey

        val builder = RSAKey.Builder(publicKey)
            .privateKey(privateKey)
            .keyID(kid)

        if (forSign) {
            builder
                .algorithm(JWSAlgorithm.RS256)
                .keyUse(KeyUse.SIGNATURE)
        } else {
            builder
                .algorithm(JWEAlgorithm.RSA_OAEP_256)
                .keyUse(KeyUse.ENCRYPTION)
        }

        return builder.build()
    }
}</code></pre>
<h3>SecurityUtils</h3>
<h3>Java</h3>
<pre><code class="language-java">package io.github.susimsek.springbootgraphqljwedemo.security;

import lombok.experimental.UtilityClass;
import org.springframework.security.core.Authentication;
import org.springframework.security.core.context.SecurityContextHolder;
import org.springframework.security.core.userdetails.UserDetails;
import org.springframework.security.oauth2.jwt.Jwt;

import java.util.Optional;

@UtilityClass
public class SecurityUtils {

    public static final String AUTHORITIES_KEY = &quot;auth&quot;;

    public Optional&lt;String&gt; getCurrentUserLogin() {
        var ctx = SecurityContextHolder.getContext();
        return Optional.ofNullable(extractPrincipal(ctx.getAuthentication()));
    }

    private String extractPrincipal(Authentication authentication) {
        if (authentication == null) {
            return null;
        }
        Object principal = authentication.getPrincipal();
        if (principal instanceof Jwt jwt) {
            return jwt.getSubject();
        }
        if (principal instanceof UserDetails ud) {
            return ud.getUsername();
        }
        if (principal instanceof String username) {
            return username;
        }
        return null;
    }
}</code></pre>
<h3>Kotlin</h3>
<pre><code class="language-kotlin">package io.github.susimsek.springbootgraphqljwedemo.security

import org.springframework.security.core.Authentication
import org.springframework.security.core.context.SecurityContextHolder
import org.springframework.security.core.userdetails.UserDetails
import org.springframework.security.oauth2.jwt.Jwt
import java.util.Optional

object SecurityUtils {
  const val AUTHORITIES_KEY = &quot;auth&quot;

  fun getCurrentUserLogin(): Optional&lt;String&gt; {
    val authentication: Authentication? = SecurityContextHolder.getContext().authentication
    return Optional.ofNullable(extractPrincipal(authentication))
  }

  private fun extractPrincipal(authentication: Authentication?): String? {
    return when (val principal = authentication?.principal) {
      is Jwt -&gt; principal.subject
      is UserDetails -&gt; principal.username
      is String -&gt; principal
      else -&gt; null
    }
  }
}</code></pre>
<h3>DomainUserDetailsService</h3>
<h3>Java</h3>
<pre><code class="language-java">package io.github.susimsek.springbootgraphqljwedemo.security;

import io.github.susimsek.springbootgraphqljwedemo.entity.User;
import io.github.susimsek.springbootgraphqljwedemo.repository.UserRepository;
import lombok.RequiredArgsConstructor;
import org.springframework.security.core.GrantedAuthority;
import org.springframework.security.core.authority.SimpleGrantedAuthority;
import org.springframework.security.core.userdetails.UserDetails;
import org.springframework.security.core.userdetails.UserDetailsService;
import org.springframework.security.core.userdetails.UsernameNotFoundException;

import java.util.List;
import java.util.stream.Collectors;

@RequiredArgsConstructor
public class DomainUserDetailsService implements UserDetailsService {

  private final UserRepository userRepository;

  @Override
  public UserDetails loadUserByUsername(String username) throws UsernameNotFoundException {
    User user = userRepository.findOneWithAuthoritiesByUsername(username)
      .orElseThrow(() -&gt; new UsernameNotFoundException(&quot;User not found with username: &quot; + username));

    List&lt;GrantedAuthority&gt; authorities = user.getAuthorities().stream()
      .map(mapping -&gt; mapping.getAuthority().getName())
      .map(SimpleGrantedAuthority::new)
      .collect(Collectors.toList());

    return new org.springframework.security.core.userdetails.User(
      user.getUsername(),
      user.getPassword(),
      user.isEnabled(),  // enabled
      true,              // accountNonExpired
      true,              // credentialsNonExpired
      true,              // accountNonLocked
      authorities
    );
  }
}</code></pre>
<h3>Kotlin</h3>
<pre><code class="language-kotlin">package io.github.susimsek.springbootgraphqljwedemo.security

import io.github.susimsek.springbootgraphqljwedemo.repository.UserRepository
import org.springframework.security.core.GrantedAuthority
import org.springframework.security.core.authority.SimpleGrantedAuthority
import org.springframework.security.core.userdetails.UserDetails
import org.springframework.security.core.userdetails.UserDetailsService
import org.springframework.security.core.userdetails.UsernameNotFoundException
import java.util.stream.Collectors

class DomainUserDetailsService(
  private val userRepository: UserRepository
) : UserDetailsService {
  override fun loadUserByUsername(username: String): UserDetails {
    val user = userRepository.findOneWithAuthoritiesByUsername(username)
      .orElseThrow { UsernameNotFoundException(&quot;User not found with username: $username&quot;) }

    val authorities: List&lt;GrantedAuthority&gt; = user.authorities.stream()
      .map { SimpleGrantedAuthority(it.authority.name) }
      .collect(Collectors.toList())

    return org.springframework.security.core.userdetails.User(
      user.username,
      user.password,
      user.enabled,
      true,
      true,
      true,
      authorities
    )
  }
}</code></pre>
<h3>SpringSecurityAuditorAware</h3>
<h3>Java</h3>
<pre><code class="language-java">package io.github.susimsek.springbootgraphqljwedemo.security;

import org.springframework.data.domain.AuditorAware;
import org.springframework.lang.NonNull;
import org.springframework.stereotype.Component;

import java.util.Optional;

@Component
public class SpringSecurityAuditorAware implements AuditorAware&lt;String&gt; {

  @Override
  @NonNull
  public Optional&lt;String&gt; getCurrentAuditor() {
    return Optional.of(SecurityUtils.getCurrentUserLogin().orElse(&quot;system&quot;));
  }
}</code></pre>
<h3>Kotlin</h3>
<pre><code class="language-kotlin">package io.github.susimsek.springbootgraphqljwedemo.security

import org.springframework.data.domain.AuditorAware
import org.springframework.lang.NonNull
import org.springframework.stereotype.Component

@Component
class SpringSecurityAuditorAware : AuditorAware&lt;String&gt; {
    @NonNull
    override fun getCurrentAuditor(): Optional&lt;String&gt; =
        Optional.of(SecurityUtils.getCurrentUserLogin().orElse(&quot;system&quot;))
}</code></pre>
<h3>GraphQlTokenCookieInterceptor</h3>
<h3>Java</h3>
<pre><code class="language-java">package io.github.susimsek.springbootjweauthjpademo.security;

import graphql.GraphQLContext;
import io.github.susimsek.springbootjweauthjpademo.dto.TokenDTO;
import org.springframework.graphql.server.WebGraphQlInterceptor;
import org.springframework.graphql.server.WebGraphQlRequest;
import org.springframework.graphql.server.WebGraphQlResponse;
import org.springframework.http.HttpHeaders;
import org.springframework.http.ResponseCookie;
import org.springframework.lang.NonNull;
import org.springframework.stereotype.Component;
import reactor.core.publisher.Mono;

@Component
public class GraphQlTokenCookieInterceptor implements WebGraphQlInterceptor {

  @Override
  @NonNull
  public Mono&lt;WebGraphQlResponse&gt; intercept(@NonNull WebGraphQlRequest request, Chain chain) {
    return chain.next(request)
      .doOnNext(response -&gt; {
        GraphQLContext ctx = response.getExecutionInput().getGraphQLContext();

        if (Boolean.TRUE.equals(ctx.get(&quot;clearAccessToken&quot;))) {
          ResponseCookie expired = CookieUtils.removeAccessTokenCookie();
          response.getResponseHeaders().add(HttpHeaders.SET_COOKIE, expired.toString());
          return;
        }

        TokenDTO tokenDto = ctx.get(&quot;accessToken&quot;);
        if (tokenDto != null) {
          ResponseCookie cookie = CookieUtils.createAccessTokenCookie(tokenDto);
          response.getResponseHeaders()
            .add(HttpHeaders.SET_COOKIE, cookie.toString());
        }
      });
  }
}</code></pre>
<h3>Kotlin</h3>
<pre><code class="language-kotlin">package io.github.susimsek.springbootjweauthjpademo.security

import graphql.GraphQLContext
import io.github.susimsek.springbootjweauthjpademo.dto.TokenDTO
import org.springframework.graphql.server.WebGraphQlInterceptor
import org.springframework.graphql.server.WebGraphQlRequest
import org.springframework.graphql.server.WebGraphQlResponse
import org.springframework.http.HttpHeaders
import org.springframework.http.ResponseCookie
import org.springframework.stereotype.Component
import reactor.core.publisher.Mono

@Component
class GraphQlTokenCookieInterceptor : WebGraphQlInterceptor {

  override fun intercept(
    request: WebGraphQlRequest,
    chain: WebGraphQlInterceptor.Chain
  ): Mono&lt;WebGraphQlResponse&gt; {
    return chain.next(request)
      .doOnNext { response -&gt;
        val ctx: GraphQLContext = response.executionInput.graphQLContext

        if (ctx.get&lt;Boolean&gt;(&quot;clearAccessToken&quot;) == true) {
          val expired: ResponseCookie = CookieUtils.removeAccessTokenCookie()
          response.responseHeaders.add(HttpHeaders.SET_COOKIE, expired.toString())
          return@doOnNext
        }

        ctx.get&lt;TokenDTO&gt;(&quot;accessToken&quot;)?.let { tokenDto -&gt;
          val cookie: ResponseCookie = CookieUtils.createAccessTokenCookie(tokenDto)
          response.responseHeaders.add(HttpHeaders.SET_COOKIE, cookie.toString())
        }
      }
  }
}</code></pre>
<h3>CookieAuthenticationWebSocketInterceptor</h3>
<h3>Java</h3>
<pre><code class="language-java">package io.github.susimsek.springbootgraphqljwedemo.security;

import io.github.susimsek.springbootgraphqljwedemo.security.CookieUtils;
import lombok.RequiredArgsConstructor;
import org.springframework.graphql.server.WebGraphQlInterceptor;
import org.springframework.graphql.server.WebGraphQlRequest;
import org.springframework.graphql.server.WebGraphQlResponse;
import org.springframework.graphql.server.WebSocketGraphQlInterceptor;
import org.springframework.graphql.server.WebSocketGraphQlRequest;
import org.springframework.graphql.server.WebSocketSessionInfo;
import org.springframework.graphql.server.support.AuthenticationExtractor;
import org.springframework.lang.NonNull;
import org.springframework.security.authentication.AuthenticationManager;
import org.springframework.security.core.Authentication;
import org.springframework.security.core.context.SecurityContext;
import org.springframework.security.core.context.SecurityContextImpl;
import org.springframework.security.oauth2.server.resource.authentication.BearerTokenAuthenticationToken;
import reactor.core.publisher.Mono;
import reactor.util.context.Context;
import reactor.util.context.ContextView;

import java.util.Map;

@RequiredArgsConstructor
public class CookieAuthenticationWebSocketInterceptor implements WebSocketGraphQlInterceptor {

  private final String authenticationAttribute = this.getClass().getName() + &quot;.AUTHENTICATION&quot;;
  private final AuthenticationExtractor authExtractor;
  private final AuthenticationManager authenticationManager;

  @Override
  @NonNull
  public Mono&lt;Object&gt; handleConnectionInitialization(@NonNull WebSocketSessionInfo info,
                                                     @NonNull Map&lt;String, Object&gt; payload) {

    Mono&lt;Authentication&gt; headerAuth = authExtractor.getAuthentication(payload);

    Mono&lt;Authentication&gt; cookieAuth = Mono.defer(() -&gt; {
      String token = CookieUtils.resolveToken(info.getHeaders());
      return token != null
        ? Mono.just(new BearerTokenAuthenticationToken(token))
        : Mono.empty();
    });

    return headerAuth
      .switchIfEmpty(cookieAuth)
      .flatMap(this::authenticate)
      .doOnNext(auth -&gt; {
        SecurityContext securityContext = new SecurityContextImpl(auth);
        info.getAttributes().put(this.authenticationAttribute, securityContext);
      })
      .then(Mono.empty());
  }

  @Override
  @NonNull
  public Mono&lt;WebGraphQlResponse&gt; intercept(@NonNull WebGraphQlRequest request,
                                            @NonNull WebGraphQlInterceptor.Chain chain) {
    if (request instanceof WebSocketGraphQlRequest webSocketRequest) {
      Map&lt;String, Object&gt; attributes = webSocketRequest.getSessionInfo().getAttributes();
      SecurityContext securityContext = (SecurityContext) attributes.get(this.authenticationAttribute);
      ContextView contextView = this.getContextToWrite(securityContext);
      return chain.next(request).contextWrite(contextView);
    } else {
      return chain.next(request);
    }
  }

  protected Mono&lt;Authentication&gt; authenticate(Authentication authentication) {
    return Mono.just(this.authenticationManager.authenticate(authentication));
  }

  protected ContextView getContextToWrite(SecurityContext securityContext) {
    return Context.of(SecurityContext.class.getName(), securityContext);
  }
}</code></pre>
<h3>Kotlin</h3>
<pre><code class="language-kotlin">package io.github.susimsek.springbootgraphqljwedemo.security

import io.github.susimsek.springbootgraphqljwedemo.security.CookieUtils
import org.springframework.graphql.server.WebGraphQlInterceptor
import org.springframework.graphql.server.WebGraphQlRequest
import org.springframework.graphql.server.WebGraphQlResponse
import org.springframework.graphql.server.WebSocketGraphQlInterceptor
import org.springframework.graphql.server.WebSocketGraphQlRequest
import org.springframework.graphql.server.WebSocketSessionInfo
import org.springframework.graphql.server.support.AuthenticationExtractor
import org.springframework.lang.NonNull
import org.springframework.security.authentication.AuthenticationManager
import org.springframework.security.core.Authentication
import org.springframework.security.core.context.SecurityContext
import org.springframework.security.core.context.SecurityContextImpl
import org.springframework.security.oauth2.server.resource.authentication.BearerTokenAuthenticationToken
import reactor.core.publisher.Mono
import reactor.util.context.Context
import reactor.util.context.ContextView

class CookieAuthenticationWebSocketInterceptor(
  private val authExtractor: AuthenticationExtractor,
  private val authenticationManager: AuthenticationManager
) : WebSocketGraphQlInterceptor {

  private val authenticationAttribute: String = &quot;${this::class.java.name}.AUTHENTICATION&quot;

  @NonNull
  override fun handleConnectionInitialization(
    @NonNull info: WebSocketSessionInfo,
    @NonNull payload: Map&lt;String, Any&gt;
  ): Mono&lt;Any&gt; {
    val headerAuth: Mono&lt;Authentication&gt; = authExtractor.getAuthentication(payload)

    val cookieAuth: Mono&lt;Authentication&gt; = Mono.defer {
      val token = CookieUtils.resolveToken(info.headers)
      if (token != null) {
        Mono.just(BearerTokenAuthenticationToken(token))
      } else {
        Mono.empty()
      }
    }

    return headerAuth
      .switchIfEmpty(cookieAuth)
      .flatMap { authenticate(it) }
      .doOnNext { auth -&gt;
        val securityContext = SecurityContextImpl(auth)
        info.attributes[authenticationAttribute] = securityContext
      }
      .then(Mono.empty())
  }

  @NonNull
  override fun intercept(
    @NonNull request: WebGraphQlRequest,
    @NonNull chain: WebGraphQlInterceptor.Chain
  ): Mono&lt;WebGraphQlResponse&gt; {
    return if (request is WebSocketGraphQlRequest) {
      val attributes = request.sessionInfo.attributes
      val securityContext = attributes[authenticationAttribute] as SecurityContext
      val contextView: ContextView = getContextToWrite(securityContext)
      chain.next(request).contextWrite(contextView)
    } else {
      chain.next(request)
    }
  }

  protected fun authenticate(authentication: Authentication): Mono&lt;Authentication&gt; =
    Mono.just(authenticationManager.authenticate(authentication))

  protected fun getContextToWrite(securityContext: SecurityContext): ContextView =
    Context.of(SecurityContext::class.java.name, securityContext)
}</code></pre>
<hr />
<h2>üõ†Ô∏è Step 6: Authentication &amp; Protected Endpoints</h2>
<p>In this section, we define the GraphQL controllers and DTOs necessary for:</p>
<ul>
<li>AuthController: Authenticates users, issues JWE tokens via a GraphQL mutation, and places `accessToken` or `clearAccessToken` flags into the GraphQLContext.</li>
<li>HelloController: Expose protected GraphQL queries, subscriptions and mutations for authenticated users and admin-only operations.</li>
<li>LoginInput: GraphQL input type for login (username/password).</li>
<li>GreetInput &amp; GreetDTO: GraphQL mutation input and response for a greeting operation.</li>
<li>TokenDTO: Model the JWE token response including token, type, and expiration.</li>
</ul>
<p>These components complete the stateless authentication flow in a GraphQL API using JWE tokens and a JPA-backed user store.</p>
<h3>AuthController</h3>
<h3>Java</h3>
<pre><code class="language-java">package io.github.susimsek.springbootjweauthjpademo.controller;

import graphql.GraphQLContext;
import io.github.susimsek.springbootjweauthjpademo.dto.LoginInput;
import io.github.susimsek.springbootjweauthjpademo.dto.TokenDTO;
import io.github.susimsek.springbootjweauthjpademo.security.JweUtil;
import lombok.RequiredArgsConstructor;
import org.springframework.graphql.data.method.annotation.Argument;
import org.springframework.graphql.data.method.annotation.MutationMapping;
import org.springframework.security.access.prepost.PreAuthorize;
import org.springframework.security.authentication.AuthenticationManager;
import org.springframework.security.authentication.UsernamePasswordAuthenticationToken;
import org.springframework.security.core.Authentication;
import org.springframework.security.core.context.SecurityContextHolder;
import org.springframework.stereotype.Controller;

@Controller
@RequiredArgsConstructor
public class AuthController {

  private final AuthenticationManager authenticationManager;
  private final JweUtil jweUtil;

  @MutationMapping
  public TokenDTO login(@Argument LoginInput input,
                        GraphQLContext context) {
    // Authenticate user
    Authentication auth = authenticationManager.authenticate(
      new UsernamePasswordAuthenticationToken(input.username(), input.password())
    );
    SecurityContextHolder.getContext().setAuthentication(auth);

    // Generate JWE token
    TokenDTO tokenDto = jweUtil.generateToken(auth);

    // Store token in GraphQLContext for the interceptor to set cookie
    context.put(&quot;accessToken&quot;, tokenDto);

    return tokenDto;
  }

  @PreAuthorize(&quot;isAuthenticated()&quot;)
  @MutationMapping
  public Boolean logout(GraphQLContext context) {
    // Signal the interceptor to clear the cookie
    context.put(&quot;clearAccessToken&quot;, Boolean.TRUE);
    return true;
  }
}</code></pre>
<h3>Kotlin</h3>
<pre><code class="language-kotlin">package io.github.susimsek.springbootjweauthjpademo.controller

import graphql.GraphQLContext
import io.github.susimsek.springbootjweauthjpademo.dto.LoginInput
import io.github.susimsek.springbootjweauthjpademo.dto.TokenDTO
import io.github.susimsek.springbootjweauthjpademo.security.JweUtil
import org.springframework.graphql.data.method.annotation.Argument
import org.springframework.graphql.data.method.annotation.MutationMapping
import org.springframework.security.access.prepost.PreAuthorize
import org.springframework.security.authentication.AuthenticationManager
import org.springframework.security.authentication.UsernamePasswordAuthenticationToken
import org.springframework.security.core.context.SecurityContextHolder
import org.springframework.stereotype.Controller

@Controller
class AuthController(
  private val authenticationManager: AuthenticationManager,
  private val jweUtil: JweUtil
) {

  @MutationMapping
  fun login(
    @Argument input: LoginInput,
    context: GraphQLContext
  ): TokenDTO {
    // Authenticate user
    val auth = authenticationManager.authenticate(
      UsernamePasswordAuthenticationToken(input.username, input.password)
    )
    SecurityContextHolder.getContext().authentication = auth

    // Generate JWE token
    val tokenDto = jweUtil.generateToken(auth)

    // Store token in GraphQLContext for the interceptor to set cookie
    context.put(&quot;accessToken&quot;, tokenDto)

    return tokenDto
  }

  @PreAuthorize(&quot;isAuthenticated()&quot;)
  @MutationMapping
  fun logout(context: GraphQLContext): Boolean {
    // Signal the interceptor to clear the cookie
    context.put(&quot;clearAccessToken&quot;, true)
    return true
  }
}</code></pre>
<h3>HelloController</h3>
<h3>Java</h3>
<pre><code class="language-java">package io.github.susimsek.springbootgraphqljwedemo.controller;

import io.github.susimsek.springbootgraphqljwedemo.dto.GreetDTO;
import io.github.susimsek.springbootgraphqljwedemo.dto.GreetInput;
import lombok.RequiredArgsConstructor;
import org.springframework.graphql.data.method.annotation.Argument;
import org.springframework.graphql.data.method.annotation.MutationMapping;
import org.springframework.graphql.data.method.annotation.QueryMapping;
import org.springframework.graphql.data.method.annotation.SubscriptionMapping;
import org.springframework.security.access.prepost.PreAuthorize;
import org.springframework.security.core.annotation.AuthenticationPrincipal;
import org.springframework.security.oauth2.jwt.Jwt;
import org.springframework.stereotype.Controller;
import reactor.core.publisher.Flux;

import java.time.Duration;
import java.time.Instant;

import static io.github.susimsek.springbootgraphqljwedemo.security.SecurityUtils.AUTHORITIES_KEY;

@Controller
@RequiredArgsConstructor
@PreAuthorize(&quot;isAuthenticated()&quot;)
public class HelloController {

  @QueryMapping
  public String helloAll(@AuthenticationPrincipal Jwt jwt) {
    var roles = jwt.getClaimAsStringList(AUTHORITIES_KEY);
    return &quot;Hello, &quot; + jwt.getSubject() + &quot;! Your roles: &quot; + roles;
  }

  @PreAuthorize(&quot;hasAuthority(&#39;ROLE_ADMIN&#39;)&quot;)
  @QueryMapping
  public String helloAdmin(@AuthenticationPrincipal Jwt jwt) {
    return &quot;Hello Admin, &quot; + jwt.getSubject() + &quot;!&quot;;
  }

  @MutationMapping
  public GreetDTO greet(
    @Argument GreetInput input,
    @AuthenticationPrincipal Jwt jwt
  ) {
    String msg = &quot;Hello &quot; + jwt.getSubject() + &quot;, you said: &quot; + input.getMessage();
    return new GreetDTO(msg, Instant.now());
  }

  @SubscriptionMapping(&quot;greetStream&quot;)
  public Flux&lt;GreetDTO&gt; greetStream(
    @Argument GreetInput input,
    @AuthenticationPrincipal Jwt jwt
  ) {
    return Flux.interval(Duration.ofSeconds(1))
      .map(i -&gt; {
        String msg = &quot;Hello &quot; + jwt.getSubject()
          + &quot;, you said: &quot; + input.getMessage()
          + &quot; (event &quot; + (i + 1) + &quot;)&quot;;
        return new GreetDTO(msg, Instant.now());
      });
  }

  @PreAuthorize(&quot;hasAuthority(&#39;ROLE_ADMIN&#39;)&quot;)
  @SubscriptionMapping(&quot;greetStreamAdmin&quot;)
  public Flux&lt;GreetDTO&gt; greetStreamAdmin(
    @Argument GreetInput input,
    @AuthenticationPrincipal Jwt jwt
  ) {
    return Flux.interval(Duration.ofSeconds(2))
      .map(i -&gt; {
        String msg = &quot;Hello Admin &quot; + jwt.getSubject()
          + &quot;, you said: &quot; + input.getMessage()
          + &quot; (admin event &quot; + (i + 1) + &quot;)&quot;;
        return new GreetDTO(msg, Instant.now());
      });
  }
}</code></pre>
<h3>Kotlin</h3>
<pre><code class="language-kotlin"></code></pre>
<h3>LoginInput</h3>
<h3>Java</h3>
<pre><code class="language-java">package io.github.susimsek.springbootgraphqljwedemo.dto;

public record LoginInput(
  String username,
  String password
) {}</code></pre>
<h3>Kotlin</h3>
<pre><code class="language-kotlin">package io.github.susimsek.springbootgraphqljwedemo.dto

data class LoginInput(
  val username: String,
  val password: String
)</code></pre>
<h3>GreetInput</h3>
<h3>Java</h3>
<pre><code class="language-java">package io.github.susimsek.springbootgraphqljwedemo.dto;

public record GreetInput(
  String message
) {}</code></pre>
<h3>Kotlin</h3>
<pre><code class="language-kotlin">package io.github.susimsek.springbootgraphqljwedemo.dto

data class GreetInput(
  val message: String
)</code></pre>
<h3>GreetDTO</h3>
<h3>Java</h3>
<pre><code class="language-java">package io.github.susimsek.springbootgraphqljwedemo.dto;

import java.time.Instant;

public record GreetDTO(
  String greeting,
  Instant timestamp
) {}</code></pre>
<h3>Kotlin</h3>
<pre><code class="language-kotlin">package io.github.susimsek.springbootgraphqljwedemo.dto

import java.time.Instant

data class GreetDTO(
  val greeting: String,
  val timestamp: Instant
)</code></pre>
<h3>TokenDTO</h3>
<h3>Java</h3>
<pre><code class="language-java">package io.github.susimsek.springbootgraphqljwedemo.dto;

public record TokenDTO(
  String accessToken,
  String tokenType,
  long accessTokenExpiresIn
) {}</code></pre>
<h3>Kotlin</h3>
<pre><code class="language-kotlin">package io.github.susimsek.springbootgraphqljwedemo.dto

data class TokenDTO(
  val accessToken: String,
  val tokenType: String,
  val accessTokenExpiresIn: Long
)</code></pre>
<hr />
<h2>‚ñ∂Ô∏è Run the App</h2>
<pre><code class="language-bash">./mvnw spring-boot:run
# or
gradle bootRun</code></pre>
<p>If you have GraalVM 22.3+ installed, you can compile a native image with the `native` profile:</p>
<pre><code class="language-bash">./mvnw native:compile -Pnative</code></pre>
<p>After successful native-image compilation, the executable will be generated under `target/` (e.g., `target/spring-boot-graphql-jwe-auth-demo`). Run it directly:</p>
<pre><code class="language-bash">./target/spring-boot-graphql-jwe-auth-demo</code></pre>
<p>Optionally, compress the native executable using UPX for a smaller file size (if UPX is installed):</p>
<pre><code class="language-bash">upx --ultra-brute --lzma target/spring-boot-graphql-jwe-auth-demo</code></pre>
<hr />
<h2>üß™ Test GraphQL Endpoints</h2>
<h3>Admin Flow</h3>
<p>Login as admin and capture the JWE token from the `Set-Cookie` header:</p>
<pre><code class="language-bash">curl -i -X POST http://localhost:8080/graphql \
  -H &quot;Content-Type: application/json&quot; \
  -d &#39;{ &quot;query&quot;: &quot;mutation { login(input: { username: \&quot;admin\&quot;, password: \&quot;adminpass\&quot; }) { accessToken tokenType accessTokenExpiresIn } }&quot; }&#39;</code></pre>
<ul>
<li>Set-Cookie header contains `accessToken=&lt;jwe-token&gt;`</li>
<li>Response body:</li>
</ul>
<pre><code class="language-json">{
  &quot;data&quot;: {
    &quot;login&quot;: {
      &quot;accessToken&quot;: &quot;&lt;jwe-token&gt;&quot;,
      &quot;tokenType&quot;: &quot;Bearer&quot;,
      &quot;accessTokenExpiresIn&quot;: 3600
    }
  }
}</code></pre>
<p>Use cookie to access hello endpoint:</p>
<pre><code class="language-bash">curl -b &quot;accessToken=&lt;jwe-token&gt;&quot; \
  -H &quot;Content-Type: application/json&quot; \
  -d &#39;{ &quot;query&quot;: &quot;{ helloAll }&quot; }&#39; \
  http://localhost:8080/graphql</code></pre>
<p>Use Authorization header instead:</p>
<pre><code class="language-bash">curl -H &quot;Authorization: Bearer &lt;jwe-token&gt;&quot; \
  -H &quot;Content-Type: application/json&quot; \
  -d &#39;{ &quot;query&quot;: &quot;{ helloAll }&quot; }&#39; \
  http://localhost:8080/graphql</code></pre>
<p>Call the admin-restricted `helloAdmin` query:</p>
<pre><code class="language-bash">curl -H &quot;Authorization: Bearer &lt;jwe-token&gt;&quot; \
  -H &quot;Content-Type: application/json&quot; \
  -d &#39;{ &quot;query&quot;: &quot;{ helloAdmin }&quot; }&#39; \
  http://localhost:8080/graphql</code></pre>
<p>Execute the `logout` mutation to clear the session cookie:</p>
<pre><code class="language-bash">curl -H &quot;Authorization: Bearer &lt;jwe-token&gt;&quot; \
  -H &quot;Content-Type: application/json&quot; \
  -d &#39;{ &quot;query&quot;: &quot;mutation { logout }&quot; }&#39; \
  http://localhost:8080/graphql</code></pre>
<h3>User Flow</h3>
<p>Login as user and capture JWE token from cookie:</p>
<pre><code class="language-bash">curl -i -X POST http://localhost:8080/graphql \
  -H &quot;Content-Type: application/json&quot; \
  -d &#39;{ &quot;query&quot;: &quot;mutation { login(input: { username: \&quot;user\&quot;, password: \&quot;userpass\&quot; }) { accessToken tokenType accessTokenExpiresIn } }&quot; }&#39;</code></pre>
<ul>
<li>Set-Cookie header contains `accessToken=&lt;jwe-token&gt;`</li>
</ul>
<p>Use cookie to call `helloAll`:</p>
<pre><code class="language-bash">curl -b &quot;accessToken=&lt;jwe-token&gt;&quot; \
  -H &quot;Content-Type: application/json&quot; \
  -d &#39;{ &quot;query&quot;: &quot;{ helloAll }&quot; }&#39; \
  http://localhost:8080/graphql</code></pre>
<p>Use Authorization header:</p>
<pre><code class="language-bash">curl -H &quot;Authorization: Bearer &lt;jwe-token&gt;&quot; \
  -H &quot;Content-Type: application/json&quot; \
  -d &#39;{ &quot;query&quot;: &quot;{ helloAll }&quot; }&#39; \
  http://localhost:8080/graphql</code></pre>
<p>Attempt the `helloAdmin` query (should return errors with 403):</p>
<pre><code class="language-bash">curl -H &quot;Authorization: Bearer &lt;jwe-token&gt;&quot; \
  -H &quot;Content-Type: application/json&quot; \
  -d &#39;{ &quot;query&quot;: &quot;{ helloAdmin }&quot; }&#39; \
  http://localhost:8080/graphql</code></pre>
<h3>Subscription Test via GraphiQL</h3>
<p>Test subscriptions directly in the GraphiQL UI at `http://localhost:8080/graphiql`:</p>
<p>1. Token Retrieval in GraphiQL</p>
<p>1. In the Query pane, enter:</p>
<p>```graphql mutation Login($in: LoginInput!) { login(input: $in) { accessToken } } ```</p>
<p>1. Switch to the Variables pane and add:</p>
<p>```json { &quot;in&quot;: { &quot;username&quot;: &quot;admin&quot;, &quot;password&quot;: &quot;adminpass&quot; } } ```</p>
<p>1. Click ‚ñ∂Ô∏è to execute and copy the returned `accessToken` from the response.</p>
<p>2. Configure Headers</p>
<p>1. Click the Headers tab in the sidebar. 1. Add:</p>
<p>```json { &quot;Authorization&quot;: &quot;Bearer &lt;accessToken&gt;&quot; } ```</p>
<p>3. Subscribe as User</p>
<p>1. Switch to the Subscriptions pane. 1. Enter:</p>
<p>```graphql subscription UserSubscribe($in: GreetInput!) { greetStream(input: $in) { greeting timestamp } } ```</p>
<p>1. In Variables, set:</p>
<p>```json { &quot;in&quot;: { &quot;message&quot;: &quot;Hello via GraphiQL!&quot; } } ```</p>
<p>1. Click ‚ñ∂Ô∏è to start streaming messages from `greetStream`.</p>
<p>4. Subscribe as Admin</p>
<p>1. In the same Subscriptions pane, enter:</p>
<p>```graphql subscription AdminSubscribe($in: GreetInput!) { greetStreamAdmin(input: $in) { greeting timestamp } } ```</p>
<p>1. Use the same Variables panel. 1. Click ‚ñ∂Ô∏è. Only tokens with `ROLE_ADMIN` receive data; others see an authorization error.</p>
<hr />
<h2>üèÅ Conclusion</h2>
<p>This setup delivers a robust, production-ready Spring Boot GraphQL JWE Authentication solution in Spring Boot, combining best practices, clear structure, and practical examples you can adapt to your own project.</p>]]></content:encoded>
      <category><![CDATA[Java]]></category>
      <category><![CDATA[Kotlin]]></category>
      <category><![CDATA[Spring Boot]]></category>
      <category><![CDATA[Security]]></category>
      <category><![CDATA[JWT]]></category>
      <category><![CDATA[JWE]]></category>
      <category><![CDATA[GraphQL]]></category>
      <category><![CDATA[Programming]]></category>
      <media:thumbnail url="https://suaybsimsek.com/images/spring-boot-graphql-jwe-auth-thumbnail.webp" />
    </item>
    <item>
      <title><![CDATA[Spring Boot JWE Authentication with JPA]]></title>
      <link>https://suaybsimsek.com/en/posts/spring-boot-jwe-authentication-with-jpa</link>
      <description><![CDATA[Learn how to use stateless encrypted JWTs (JWE) to secure your Spring Boot APIs while persisting user identities and roles in a JPA-backed database.]]></description>
      <pubDate>Sun, 11 May 2025 00:00:00 GMT</pubDate>
      <guid isPermaLink="true">https://suaybsimsek.com/en/posts/spring-boot-jwe-authentication-with-jpa</guid>
      <content:encoded><![CDATA[<p>Spring Boot lets you use stateless encrypted JWTs (JWE) to secure your APIs, while persisting user identities and roles in a JPA-backed database.</p>
<hr />
<h2>üåü Why Use JWE + JPA Authentication?</h2>
<ul>
<li>Stateless Security: Tokens are self-contained and require no server-side storage.</li>
<li>Integrity: Signed tokens ensure tamper evidence.</li>
<li>Confidentiality: Encrypted JWTs hide sensitive claims.</li>
<li>User Management: Persist and manage users and roles via familiar JPA repositories.</li>
<li>Standards-based: Leverage JOSE, Spring Security, and Spring Data JPA.</li>
<li>Scalable: Scale horizontally without session replication or sticky sessions.</li>
</ul>
<hr />
<h2>üìã Prerequisites</h2>
<ul>
<li>‚òï Java Development Kit (JDK) 17 or higher</li>
<li>üì¶ Spring Boot 3.2+</li>
<li>üî§ IDE (IntelliJ IDEA, Eclipse)</li>
<li>üõ¢Ô∏è PostgreSQL (or H2 for dev)</li>
</ul>
<hr />
<h2>üõ†Ô∏è Step 1: Add Dependencies</h2>
<p>Include these in your `pom.xml` or `build.gradle` file.</p>
<p>Maven:</p>
<pre><code class="language-xml">&lt;dependency&gt;
  &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
  &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;
&lt;/dependency&gt;
&lt;dependency&gt;
  &lt;groupId&gt;org.springframework.security&lt;/groupId&gt;
  &lt;artifactId&gt;spring-security-oauth2-resource-server&lt;/artifactId&gt;
&lt;/dependency&gt;
&lt;dependency&gt;
  &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
  &lt;artifactId&gt;spring-boot-starter-data-jpa&lt;/artifactId&gt;
&lt;/dependency&gt;
&lt;dependency&gt;
  &lt;groupId&gt;org.liquibase&lt;/groupId&gt;
  &lt;artifactId&gt;liquibase-core&lt;/artifactId&gt;
&lt;/dependency&gt;
&lt;dependency&gt;
  &lt;groupId&gt;org.projectlombok&lt;/groupId&gt;
  &lt;artifactId&gt;lombok&lt;/artifactId&gt;
  &lt;optional&gt;true&lt;/optional&gt;
&lt;/dependency&gt;
&lt;dependency&gt;
  &lt;groupId&gt;com.h2database&lt;/groupId&gt;
  &lt;artifactId&gt;h2&lt;/artifactId&gt;
  &lt;scope&gt;runtime&lt;/scope&gt;
&lt;/dependency&gt;</code></pre>
<p>Gradle:</p>
<pre><code class="language-groovy">implementation &#39;org.springframework.boot:spring-boot-starter-web&#39;
implementation &#39;org.springframework.security:spring-security-oauth2-resource-server&#39;
implementation &#39;org.springframework.boot:spring-boot-starter-data-jpa&#39;
implementation &#39;org.liquibase:liquibase-core&#39;
compileOnly &#39;org.projectlombok:lombok&#39;
runtimeOnly &#39;com.h2database:h2&#39;</code></pre>
<hr />
<h2>üõ†Ô∏è Step 2: Configuration Files</h2>
<p>In this section, we define all of the application- and database-level configuration files required to wire up our Spring Boot app with H2/PostgreSQL, JPA, Liquibase changelogs, initial data loads, and JWE key properties.</p>
<ul>
<li>`application.yml`</li>
<p>Holds Spring datasource, H2 console, JPA/Hibernate, Liquibase changelog path, and all JWT/JWE key, issuer, and expiration settings.</p>
</ul>
<ul>
<li>`db/master.xml`</li>
<p>The Liquibase master changelog, with includes and DBMS-specific properties for H2 and PostgreSQL.</p>
</ul>
<ul>
<li>`db/changelog/changelog-user.xml`</li>
<p>Your core schema changelog defining `user_identity`, `authority`, and `user_authority_mapping` tables, indexes, FKs, and initial `&lt;loadData&gt;` steps.</p>
</ul>
<ul>
<li>`db/data/user.csv`</li>
<p>Initial user records (UUID, username, bcrypt-hashed password, email, enabled flag, timestamps, auditor).</p>
</ul>
<ul>
<li>`db/data/authority.csv`</li>
<p>Initial authority records (UUID, name, description, timestamps, auditor).</p>
</ul>
<ul>
<li>`db/data/user_authority_mapping.csv`</li>
<p>Initial mapping of users ‚Üî authorities (composite PK, timestamps, auditor).</p>
</ul>
<h3>application.yml</h3>
<pre><code class="language-yaml">spring:
  datasource:
    url: jdbc:h2:mem:testdb;MODE=PostgreSQL;DB_CLOSE_DELAY=-1;DB_CLOSE_ON_EXIT=FALSE
    driver-class-name: org.h2.Driver
    username: sa
    password: password
  h2:
    console:
      enabled: true
  jpa:
    open-in-view: false
    hibernate:
      ddl-auto: none
    show-sql: true
    properties:
      hibernate.format_sql: true
  liquibase:
    change-log: classpath:db/master.xml
security:
  admin:
    username: admin
    password: adminpass
  user:
    username: user
    password: userpass
  jwt:
    issuer: demo-issuer
    expiration-duration: 3600s
    signing:
      key-id: signing-key
      public-key: |-
        -----BEGIN PUBLIC KEY-----
        MIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEAjZEcz5itWkDGOSqZdB5P
        JE0ccOCckskp0hN3kQbT1qnv+9/k66jlWgVi4HSTppwdNF/Ylu5u541Qj+Okyg+u
        8o2PvKo5CfgvTDsFLTrZHUXU6hCSGatLAQoeN6lT8wzov2r4DFecXrIqcO6SvMB5
        ecPqsfiTi4trsNKgJ4cWS6gILH62ISd1ipUadfpnUzDMO1OulV0CJNV6bcBk7Es9
        RW6AHfg9j8osSanpwvRM4MJkB0SRxYUnrN9faGpkBZISZJ8TShhaTHEGfSNgKe5y
        8iu+AMGGZu8DYczVmqS3Ske1fq6y5HEGCma7Mo019GmwKeHBo1obuET6cZRygj4y
        twIDAQAB
        -----END PUBLIC KEY-----
      private-key: |-
        -----BEGIN PRIVATE KEY-----
        MIIEvAIBADANBgkqhkiG9w0BAQEFAASCBKYwggSiAgEAAoIBAQCNkRzPmK1aQMY5
        Kpl0Hk8kTRxw4JySySnSE3eRBtPWqe/73+TrqOVaBWLgdJOmnB00X9iW7m7njVCP
        46TKD67yjY+8qjkJ+C9MOwUtOtkdRdTqEJIZq0sBCh43qVPzDOi/avgMV5xesipw
        7pK8wHl5w+qx+JOLi2uw0qAnhxZLqAgsfrYhJ3WKlRp1+mdTMMw7U66VXQIk1Xpt
        wGTsSz1FboAd+D2PyixJqenC9EzgwmQHRJHFhSes319oamQFkhJknxNKGFpMcQZ9
        I2Ap7nLyK74AwYZm7wNhzNWapLdKR7V+rrLkcQYKZrsyjTX0abAp4cGjWhu4RPpx
        lHKCPjK3AgMBAAECggEABMo/sNCIMREXA/EqjxDFecN4LmOTOK5A0YBiH9Cc01sd
        qSaavtSQqhqbjV+0bUNEA7UohXbc3s3bx3qa5VFhiIh8sBQMaQdyRkCK/MxMc16d
        BSx5XQ/8MjVO73A1zHgH2g47BWPjgRrDL94KrgNPOO0FoG76QxL9GlcOHzhFa1rf
        xbb2auLBtflKy+5TZNnB/sbFC9ISpWywzfblD2Fsvxupl0vNWtA0Y2rPbKMZRnY+
        V6NC38yxW3HHAdWQRYLGOitM59I0HBgnjQKzTBNIsjPnJA2BSZvMBtQ1e3RQV0qE
        8VVoktZ8A0KDUxqdKWYlGYAY5hIw1y3UUsPRUbS3fQKBgQDAZehu+Kb5Sw+h00Qu
        vViNHDvi0PwmhQrHVpgjrppCnWsTk6FJFm+EBLY+87usXuRCnfZ1semb6P+yjLh2
        bJ9IXIrFAztcyE+7eZfn0H7mHA7E2ICKTjNdKbjy8kHViHpgdXREnAOrFTTk/BqW
        dq+weG2OuxYczWsY4XliWaVyiwKBgQC8XYExpSmoyI37o+jr9405k30tbGUw4X+/
        xYOvSUuafI8IOSLfKTpsvkMN3hxpJO6apIRAjOALbotKUA5FrHQPenuBWOr3mBJT
        euLiaWphqU8YN5dbNd+JhC/Jh5DLhY5FpB2Fv2MKSoF7+onpjDy9pEU5aReeBB0v
        ekUw4nWiBQKBgHxyrnjxP1frFG5xMB4nfZqw04+v7BmiXsl3mqsh6kgCeNtN17pl
        17YGMjfgAdnJ+02XzW5tqRSfDp3YZgy7z//HVD+BCqnGK8SxLu/ULfD73xW2kNZl
        JNYzAZ2r06eiQr4X2x/x5nGIIxGmfDAtDxFPpFX5b6ErwgVy+sgCAoFnAoGAWSpu
        EMEdQk+FnnwNsz2g9YNSuyDXmdb08SOfXWd1yXBzCLJ7RmYuyPEbrsHYcxFPfZap
        ICFPoTm35/qTdvnWiskxE56yw3eSHUBLjF/YQtixn0YZeMy8v0z6jgyFR0I2gdLZ
        QsnBKUrxlm2XwR1oV2Eef7m2u085PZNEk4pvor0CgYA6n060r48/CgRVslAeGder
        fZ3n+2ru8q2UVB38evepjLifn5+tKdFzZ7/NckXMC0NOVzm74qG46VFLMw5TtyT4
        /hRvGSYxA6dMjXy+tcrAns9Isrz2PnYFntlbhU6hw0um809tFunbvITfyeOjAsDW
        stC4thnhzXXT1Y3RfFtYEg==
        -----END PRIVATE KEY-----
    encryption:
      key-id: encryption-key
      public-key: |-
        -----BEGIN PUBLIC KEY-----
        MIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEAtU7Vu4tML8qg9BISaUH0
        BTU0+qkHJS3TUl3R0hEPttZJGf8EgT7bpWqRjdhMC2SYt2ifNF82EgMo/eva1rLn
        wYtCsxjJ7oB4U2m16/JKHtphmMUGhSLgbp+Y8pGAQ+P6u4HLlI0qbL92Syb6QCTr
        nYIlzZ2uUAvUQg/SbuAvdS4kdauZtpMNbhryusMVvILVBC5yUhfLJAkjbU3qWo/n
        2NKPr4kjwwFh6FaAf0HLsXCFmJbPPok6WMZeDqPORPZCt5gU2t04fS7s/2SSbhQ/
        i+7yyT4pl44cUlNLLN3Qo73sai5H90q7Dvmk3M5/YMJB0Ueyb705LHyOO5xA618s
        qQIDAQAB
        -----END PUBLIC KEY-----
      private-key: |-
        -----BEGIN PRIVATE KEY-----
        MIIEvgIBADANBgkqhkiG9w0BAQEFAASCBKgwggSkAgEAAoIBAQC1TtW7i0wvyqD0
        EhJpQfQFNTT6qQclLdNSXdHSEQ+21kkZ/wSBPtulapGN2EwLZJi3aJ80XzYSAyj9
        69rWsufBi0KzGMnugHhTabXr8koe2mGYxQaFIuBun5jykYBD4/q7gcuUjSpsv3ZL
        JvpAJOudgiXNna5QC9RCD9Ju4C91LiR1q5m2kw1uGvK6wxW8gtUELnJSF8skCSNt
        Tepaj+fY0o+viSPDAWHoVoB/QcuxcIWYls8+iTpYxl4Oo85E9kK3mBTa3Th9Luz/
        ZJJuFD+L7vLJPimXjhxSU0ss3dCjvexqLkf3SrsO+aTczn9gwkHRR7JvvTksfI47
        nEDrXyypAgMBAAECggEAREnJHrY8n9OGA+e6n4KD0mJT7gUz98Dm0yMbIC/k50yW
        hAAVRkjSmd8lq3NIURI2ov342NTznJ0sF1d6OVtxBujY2nP/uqEQsPoj1xaO7Ef8
        cnnjFsooFgJurQ44bVm02mLstqrky8jhWTT5FKfTRqP6cRNu0B9kdu1WqQQvW8a/
        C8xD8XUFzzJFQsEstJ076NjlZNH3EeqFiLxyVdV7tPEJRnOe2V2BAAgda3ByA6Jc
        Nd4xYHTVr5rZ+KES9gaAgb86+S7hNigsxz5Gp58NimLEyz1Qd+d9QCgPRgKOV5Uq
        0ci6c28ZrxW9wa/2CGCpoow1V7hRy1fZ24g2Tz91cQKBgQDbSdP/FQYuem0pUf8u
        mA/niEC8Jz30FW3ix5aqbQ8YRudK48Xy8F7AWnlS0wT2k/Xaeppn9YSPK4HlsNk2
        1gnpNfzdqXpJQtuxcPPeFNzUdXzBrsLXYqtlhOX/afrzqMhp73gkqoxXtqwD7BqN
        VfMcVXsWrEZQrRPBn/RUnnLdJwKBgQDTqUGupm93UlhoPgLXHGF/seQwPPHcU6lS
        SS9l512Ie21B+vZecgO4r77BXJwbY4rZVA5/m+wrsNmsT2f8yfdbs84cBDDWiKy5
        t2Um8zrus+BCIffxc9Fck9/htK33jLLcYwdSAm3a9pJxR9f/kAdredSTGBNJ3W/2
        rfh3cdNprwKBgDi7WfBFRSsjGzi0cPth9cNlubGzyVBrdtlT34PJ4Tzboxz53o1i
        aHEFNxwZYdBVKSbTzzyUBS5xCBMfdKK+LyQ5hmjmXq+zb1jxqvXKmfMRTixhhSDp
        8wO5pTM1/Omqwea+QGvj/5j1tnzxSVFFajbrWoPcH/jhPho6wqBducPDAoGBALOJ
        MEOavZXy7TaO0w3v7uvH0wzvxR/kfw1jMqc3l2j7ePOskmoOQAXaXO3bRjcdOlua
        Jyoq8islOZ4lRMlx7zWD0OKG035GNGzbmRtu2aA8R48RDSVr3jyu2gqznZULbXPv
        M/hmQxSmbhVUoW0PmJubnaqfk0zmXeBaNRXsIS3VAoGBALdsAtqR23PVeL6sYj2l
        dRNTDXpfvjFqJ5NThRO/4mT0CrPHQVj+Mz2bTc/Dxiwi8s8m3L+g23i3hodh/QMb
        Iz+UbcJZBGAKsFbPKGOtj6Bi07y/L11mcuNJzOWe61/JbVmJss0s+N/v3XucK/Ge
        CUaGOccsMO221v6JoBh9J3Hz
        -----END PRIVATE KEY-----</code></pre>
<h3>master.xml</h3>
<pre><code class="language-xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;databaseChangeLog
  xmlns=&quot;http://www.liquibase.org/xml/ns/dbchangelog&quot;
  xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
  xsi:schemaLocation=&quot;
      http://www.liquibase.org/xml/ns/dbchangelog
      http://www.liquibase.org/xml/ns/dbchangelog/dbchangelog-4.9.xsd&quot;&gt;

  &lt;!-- H2 defaults --&gt;
  &lt;property name=&quot;now&quot; value=&quot;now()&quot; dbms=&quot;h2&quot;/&gt;
  &lt;property name=&quot;floatType&quot; value=&quot;float4&quot; dbms=&quot;h2&quot;/&gt;
  &lt;property name=&quot;uuidType&quot; value=&quot;uuid&quot; dbms=&quot;h2&quot;/&gt;
  &lt;property name=&quot;datetimeType&quot; value=&quot;datetime(6)&quot; dbms=&quot;h2&quot;/&gt;
  &lt;property name=&quot;binaryType&quot; value=&quot;LONGVARBINARY&quot; dbms=&quot;h2&quot;/&gt;
  &lt;property name=&quot;clobType&quot; value=&quot;longvarchar&quot; dbms=&quot;h2&quot;/&gt;
  &lt;property name=&quot;blobType&quot; value=&quot;blob&quot; dbms=&quot;h2&quot;/&gt;

  &lt;!-- PostgreSQL overrides --&gt;
  &lt;property name=&quot;now&quot; value=&quot;current_timestamp&quot; dbms=&quot;postgresql&quot;/&gt;
  &lt;property name=&quot;floatType&quot; value=&quot;float4&quot; dbms=&quot;postgresql&quot;/&gt;
  &lt;property name=&quot;uuidType&quot; value=&quot;uuid&quot; dbms=&quot;postgresql&quot;/&gt;
  &lt;property name=&quot;datetimeType&quot; value=&quot;datetime&quot; dbms=&quot;postgresql&quot;/&gt;
  &lt;property name=&quot;binaryType&quot; value=&quot;BYTEA&quot; dbms=&quot;postgresql&quot;/&gt;
  &lt;property name=&quot;clobType&quot; value=&quot;clob&quot; dbms=&quot;postgresql&quot;/&gt;
  &lt;property name=&quot;blobType&quot; value=&quot;blob&quot; dbms=&quot;postgresql&quot;/&gt;

  &lt;!-- include the core auth changelog --&gt;
  &lt;include file=&quot;classpath:db/changelog/changelog-user.xml&quot;/&gt;

&lt;/databaseChangeLog&gt;</code></pre>
<h3>changelog-user.xml</h3>
<pre><code class="language-xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;databaseChangeLog
  xmlns=&quot;http://www.liquibase.org/xml/ns/dbchangelog&quot;
  xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
  xsi:schemaLocation=&quot;
      http://www.liquibase.org/xml/ns/dbchangelog
      http://www.liquibase.org/xml/ns/dbchangelog/dbchangelog-4.9.xsd&quot;&gt;

  &lt;changeSet id=&quot;20250510-1&quot; author=&quot;susimsek&quot;&gt;
    &lt;createTable tableName=&quot;user_identity&quot;&gt;
      &lt;column name=&quot;id&quot; type=&quot;varchar(36)&quot;&gt;
        &lt;constraints primaryKey=&quot;true&quot; primaryKeyName=&quot;pk_user_identity&quot; nullable=&quot;false&quot;/&gt;
      &lt;/column&gt;
      &lt;column name=&quot;username&quot; type=&quot;varchar(50)&quot;&gt;
        &lt;constraints nullable=&quot;false&quot; unique=&quot;true&quot;/&gt;
      &lt;/column&gt;
      &lt;column name=&quot;password&quot; type=&quot;varchar(100)&quot;&gt;
        &lt;constraints nullable=&quot;false&quot;/&gt;
      &lt;/column&gt;
      &lt;column name=&quot;email&quot; type=&quot;varchar(100)&quot;&gt;
        &lt;constraints nullable=&quot;false&quot; unique=&quot;true&quot;/&gt;
      &lt;/column&gt;
      &lt;column name=&quot;first_name&quot; type=&quot;varchar(50)&quot;/&gt;
      &lt;column name=&quot;last_name&quot; type=&quot;varchar(50)&quot;/&gt;
      &lt;column name=&quot;enabled&quot; type=&quot;boolean&quot;&gt;
        &lt;constraints nullable=&quot;false&quot;/&gt;
      &lt;/column&gt;
      &lt;column name=&quot;created_at&quot; type=&quot;datetime&quot;&gt;
        &lt;constraints nullable=&quot;false&quot;/&gt;
      &lt;/column&gt;
      &lt;column name=&quot;created_by&quot; type=&quot;varchar(50)&quot;&gt;
        &lt;constraints nullable=&quot;false&quot;/&gt;
      &lt;/column&gt;
      &lt;column name=&quot;updated_at&quot; type=&quot;datetime&quot;/&gt;
      &lt;column name=&quot;updated_by&quot; type=&quot;varchar(50)&quot;/&gt;
    &lt;/createTable&gt;

    &lt;createIndex indexName=&quot;idx_user_identity_username&quot; tableName=&quot;user_identity&quot;&gt;
      &lt;column name=&quot;username&quot;/&gt;
    &lt;/createIndex&gt;
    &lt;createIndex indexName=&quot;idx_user_identity_email&quot; tableName=&quot;user_identity&quot;&gt;
      &lt;column name=&quot;email&quot;/&gt;
    &lt;/createIndex&gt;
  &lt;/changeSet&gt;

  &lt;changeSet id=&quot;20250510-2&quot; author=&quot;susimsek&quot;&gt;
    &lt;createTable tableName=&quot;authority&quot;&gt;
      &lt;column name=&quot;id&quot; type=&quot;varchar(36)&quot;&gt;
        &lt;constraints primaryKey=&quot;true&quot; primaryKeyName=&quot;pk_authority&quot; nullable=&quot;false&quot;/&gt;
      &lt;/column&gt;
      &lt;column name=&quot;name&quot; type=&quot;varchar(50)&quot;&gt;
        &lt;constraints nullable=&quot;false&quot; unique=&quot;true&quot;/&gt;
      &lt;/column&gt;
      &lt;column name=&quot;description&quot; type=&quot;varchar(255)&quot;/&gt;
      &lt;column name=&quot;created_at&quot; type=&quot;datetime&quot;&gt;
        &lt;constraints nullable=&quot;false&quot;/&gt;
      &lt;/column&gt;
      &lt;column name=&quot;created_by&quot; type=&quot;varchar(50)&quot;&gt;
        &lt;constraints nullable=&quot;false&quot;/&gt;
      &lt;/column&gt;
      &lt;column name=&quot;updated_at&quot; type=&quot;datetime&quot;/&gt;
      &lt;column name=&quot;updated_by&quot; type=&quot;varchar(50)&quot;/&gt;
    &lt;/createTable&gt;

    &lt;createIndex indexName=&quot;idx_authority_name&quot; tableName=&quot;authority&quot;&gt;
      &lt;column name=&quot;name&quot;/&gt;
    &lt;/createIndex&gt;
  &lt;/changeSet&gt;

  &lt;changeSet id=&quot;20250510-3&quot; author=&quot;susimsek&quot;&gt;
    &lt;createTable tableName=&quot;user_authority_mapping&quot;&gt;
      &lt;column name=&quot;user_id&quot; type=&quot;varchar(36)&quot;&gt;
        &lt;constraints nullable=&quot;false&quot;/&gt;
      &lt;/column&gt;
      &lt;column name=&quot;authority_id&quot; type=&quot;varchar(36)&quot;&gt;
        &lt;constraints nullable=&quot;false&quot;/&gt;
      &lt;/column&gt;
      &lt;column name=&quot;created_at&quot; type=&quot;datetime&quot;&gt;
        &lt;constraints nullable=&quot;false&quot;/&gt;
      &lt;/column&gt;
      &lt;column name=&quot;created_by&quot; type=&quot;varchar(50)&quot;&gt;
        &lt;constraints nullable=&quot;false&quot;/&gt;
      &lt;/column&gt;
      &lt;column name=&quot;updated_at&quot; type=&quot;datetime&quot;/&gt;
      &lt;column name=&quot;updated_by&quot; type=&quot;varchar(50)&quot;/&gt;
    &lt;/createTable&gt;

    &lt;addPrimaryKey
      tableName=&quot;user_authority_mapping&quot;
      columnNames=&quot;user_id, authority_id&quot;
      constraintName=&quot;pk_user_authority_mapping&quot;/&gt;
  &lt;/changeSet&gt;

  &lt;changeSet id=&quot;20250510-4&quot; author=&quot;susimsek&quot;&gt;
    &lt;addForeignKeyConstraint
      baseTableName=&quot;user_authority_mapping&quot;
      baseColumnNames=&quot;user_id&quot;
      constraintName=&quot;fk_user_authority_user&quot;
      referencedTableName=&quot;user_identity&quot;
      referencedColumnNames=&quot;id&quot;/&gt;
  &lt;/changeSet&gt;

  &lt;changeSet id=&quot;20250510-5&quot; author=&quot;susimsek&quot;&gt;
    &lt;addForeignKeyConstraint
      baseTableName=&quot;user_authority_mapping&quot;
      baseColumnNames=&quot;authority_id&quot;
      constraintName=&quot;fk_user_authority_authority&quot;
      referencedTableName=&quot;authority&quot;
      referencedColumnNames=&quot;id&quot;/&gt;
  &lt;/changeSet&gt;

  &lt;changeSet id=&quot;20250510-1-data&quot; author=&quot;susimsek&quot;&gt;
    &lt;loadData
      file=&quot;db/data/user.csv&quot;
      separator=&quot;;&quot;
      tableName=&quot;user_identity&quot;&gt;
      &lt;column name=&quot;id&quot; type=&quot;string&quot;/&gt;
      &lt;column name=&quot;username&quot; type=&quot;string&quot;/&gt;
      &lt;column name=&quot;password&quot; type=&quot;string&quot;/&gt;
      &lt;column name=&quot;email&quot; type=&quot;string&quot;/&gt;
      &lt;column name=&quot;first_name&quot; type=&quot;string&quot;/&gt;
      &lt;column name=&quot;last_name&quot; type=&quot;string&quot;/&gt;
      &lt;column name=&quot;enabled&quot; type=&quot;boolean&quot;/&gt;
      &lt;column name=&quot;created_at&quot; type=&quot;datetime&quot;/&gt;
      &lt;column name=&quot;created_by&quot; type=&quot;string&quot;/&gt;
      &lt;column name=&quot;updated_at&quot; type=&quot;datetime&quot;/&gt;
      &lt;column name=&quot;updated_by&quot; type=&quot;string&quot;/&gt;
    &lt;/loadData&gt;
  &lt;/changeSet&gt;

  &lt;changeSet id=&quot;20250510-2-data&quot; author=&quot;susimsek&quot;&gt;
    &lt;loadData
      file=&quot;db/data/authority.csv&quot;
      separator=&quot;;&quot;
      tableName=&quot;authority&quot;&gt;
      &lt;column name=&quot;id&quot; type=&quot;string&quot;/&gt;
      &lt;column name=&quot;name&quot; type=&quot;string&quot;/&gt;
      &lt;column name=&quot;description&quot; type=&quot;string&quot;/&gt;
      &lt;column name=&quot;created_at&quot; type=&quot;datetime&quot;/&gt;
      &lt;column name=&quot;created_by&quot; type=&quot;string&quot;/&gt;
      &lt;column name=&quot;updated_at&quot; type=&quot;datetime&quot;/&gt;
      &lt;column name=&quot;updated_by&quot; type=&quot;string&quot;/&gt;
    &lt;/loadData&gt;
  &lt;/changeSet&gt;

  &lt;changeSet id=&quot;20250510-3-data&quot; author=&quot;susimsek&quot;&gt;
    &lt;loadData
      file=&quot;db/data/user_authority_mapping.csv&quot;
      separator=&quot;;&quot;
      tableName=&quot;user_authority_mapping&quot;&gt;
      &lt;column name=&quot;user_id&quot; type=&quot;string&quot;/&gt;
      &lt;column name=&quot;authority_id&quot; type=&quot;string&quot;/&gt;
      &lt;column name=&quot;created_at&quot; type=&quot;datetime&quot;/&gt;
      &lt;column name=&quot;created_by&quot; type=&quot;string&quot;/&gt;
      &lt;column name=&quot;updated_at&quot; type=&quot;datetime&quot;/&gt;
      &lt;column name=&quot;updated_by&quot; type=&quot;string&quot;/&gt;
    &lt;/loadData&gt;
  &lt;/changeSet&gt;

&lt;/databaseChangeLog&gt;</code></pre>
<h3>user.csv</h3>
<pre><code class="language-csv">id;username;password;email;first_name;last_name;enabled;created_at;created_by;updated_at;updated_by
a1b2c3d4-e5f6-7890-abcd-ef1234567890;admin;$2a$10$sva6wl8pmGKJE6NIWrxwcuJK1Jaa2I/LOI43iHVpbR4YB8KjGViiK;admin@example.com;Admin;User;true;2025-05-10 12:00:00;system;2025-05-10 12:00:00;system
09876543-21fe-dcba-0987-654321fedcba;user;$2a$10$5Py4PyteLuXEqnGpSigzfu0V55C7Hi7zX18lmh.J8Bpmft.h23voG;user@example.com;Normal;User;true;2025-05-10 12:00:00;system;2025-05-10 12:00:00;system</code></pre>
<h3>authority.csv</h3>
<pre><code class="language-csv">id;name;description;created_at;created_by;updated_at;updated_by
f47ac10b-58cc-4372-a567-0e02b2c3d479;ROLE_ADMIN;Administrator role;2025-05-10 12:00:00;system;2025-05-10 12:00:00;system
9c858901-8a57-4791-81fe-4c455b099bc9;ROLE_USER;User role;2025-05-10 12:00:00;system;2025-05-10 12:00:00;system</code></pre>
<h3>user_authority_mapping.csv</h3>
<pre><code class="language-csv">user_id;authority_id;created_at;created_by;updated_at;updated_by
a1b2c3d4-e5f6-7890-abcd-ef1234567890;9c858901-8a57-4791-81fe-4c455b099bc9;2025-05-10 12:00:00;system;2025-05-10 12:00:00;system
a1b2c3d4-e5f6-7890-abcd-ef1234567890;f47ac10b-58cc-4372-a567-0e02b2c3d479;2025-05-10 12:00:00;system;2025-05-10 12:00:00;system
09876543-21fe-dcba-0987-654321fedcba;9c858901-8a57-4791-81fe-4c455b099bc9;2025-05-10 12:00:00;system;2025-05-10 12:00:00;system</code></pre>
<hr />
<h2>üõ†Ô∏è Step 3: Security &amp; Database Configuration</h2>
<p>In this section, we define the beans and properties RSA keys, HTTP security filters, and JPA repository/auditing setup for JWE‚Äëbased authentication:</p>
<ul>
<li>JwtProperties: Configures JWT issuer, expiration, and signing/encryption key pairs.</li>
<li>SecurityJwtConfig: Builds RSA JWKs, JWT encoder/decoder, authentication converter, and token resolver.</li>
<li>SecurityConfig: Integrates `DomainUserDetailsService`, configures authentication manager, password encoder, and stateless security filter chain with JWE support.</li>
<li>DatabaseConfig: Enables JPA repositories, auditing, and transaction management.</li>
</ul>
<h3>SecurityJwtConfig</h3>
<h3>Java</h3>
<pre><code class="language-java">package io.github.susimsek.springbootjweauthjpademo.config;

import com.nimbusds.jose.EncryptionMethod;
import com.nimbusds.jose.JWEAlgorithm;
import com.nimbusds.jose.JWSAlgorithm;
import com.nimbusds.jose.jwk.JWKSet;
import com.nimbusds.jose.jwk.RSAKey;
import com.nimbusds.jose.jwk.source.JWKSource;
import com.nimbusds.jose.proc.JWEDecryptionKeySelector;
import com.nimbusds.jose.proc.JWSVerificationKeySelector;
import com.nimbusds.jose.proc.SecurityContext;
import com.nimbusds.jwt.proc.DefaultJWTProcessor;
import io.github.susimsek.springbootjweauthjpademo.security.CookieBearerTokenResolver;
import io.github.susimsek.springbootjweauthjpademo.security.KeyUtils;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.security.oauth2.jwt.JwtDecoder;
import org.springframework.security.oauth2.jwt.JwtEncoder;
import org.springframework.security.oauth2.jwt.NimbusJwtDecoder;
import org.springframework.security.oauth2.jwt.NimbusJwtEncoder;
import org.springframework.security.oauth2.server.resource.authentication.JwtAuthenticationConverter;
import org.springframework.security.oauth2.server.resource.authentication.JwtGrantedAuthoritiesConverter;
import org.springframework.security.oauth2.server.resource.web.BearerTokenResolver;

import java.util.List;

import static io.github.susimsek.springbootjweauthjpademo.security.SecurityUtils.AUTHORITIES_KEY;

@Configuration
public class SecurityJwtConfig {

    private final JwtProperties props;
    public SecurityJwtConfig(JwtProperties props) { this.props = props; }

    @Bean
    public RSAKey signingKey() throws Exception {
        return KeyUtils.buildRsaKey(
            props.getSigning().getPublicKey(),
            props.getSigning().getPrivateKey(),
            props.getSigning().getKeyId(),
            true
        );
    }

    @Bean
    public RSAKey encryptionKey() throws Exception {
        return KeyUtils.buildRsaKey(
            props.getEncryption().getPublicKey(),
            props.getEncryption().getPrivateKey(),
            props.getEncryption().getKeyId(),
            false
        );
    }

    @Bean
    public JWKSource&lt;SecurityContext&gt; jwkSource(RSAKey signingKey, RSAKey encryptionKey) {
        JWKSet jwkSet = new JWKSet(List.of(
            signingKey,
            encryptionKey
        ));
        return (jwkSelector, context) -&gt; jwkSelector.select(jwkSet);
    }

    @Bean
    public JwtDecoder jwtDecoder(JWKSource&lt;SecurityContext&gt; jwkSource) {
        DefaultJWTProcessor&lt;SecurityContext&gt; jwtProcessor = new DefaultJWTProcessor&lt;&gt;();
        JWEDecryptionKeySelector&lt;SecurityContext&gt; jweKeySelector =
            new JWEDecryptionKeySelector&lt;&gt;(
                JWEAlgorithm.RSA_OAEP_256,
                EncryptionMethod.A128GCM,
                jwkSource
            );
        jwtProcessor.setJWEKeySelector(jweKeySelector);

        JWSVerificationKeySelector&lt;SecurityContext&gt; jwsKeySelector =
            new JWSVerificationKeySelector&lt;&gt;(
                JWSAlgorithm.RS256,
                jwkSource
            );
        jwtProcessor.setJWSKeySelector(jwsKeySelector);
        jwtProcessor.setJWTClaimsSetVerifier((claims, context) -&gt; {});

        return new NimbusJwtDecoder(jwtProcessor);
    }

    @Bean
    public JwtEncoder jwtEncoder(JWKSource&lt;SecurityContext&gt; jwkSource) {
        return new NimbusJwtEncoder(jwkSource);
    }

    @Bean
    public JwtAuthenticationConverter jwtAuthenticationConverter() {
        JwtGrantedAuthoritiesConverter converter = new JwtGrantedAuthoritiesConverter();
        converter.setAuthorityPrefix(&quot;&quot;);
        converter.setAuthoritiesClaimName(AUTHORITIES_KEY);

        JwtAuthenticationConverter authConverter = new JwtAuthenticationConverter();
        authConverter.setJwtGrantedAuthoritiesConverter(converter);
        return authConverter;
    }

    @Bean
    public BearerTokenResolver bearerTokenResolver() {
        CookieBearerTokenResolver resolver = new CookieBearerTokenResolver();
        resolver.setAllowUriQueryParameter(false);
        resolver.setAllowFormEncodedBodyParameter(false);
        resolver.setAllowCookie(true);
        return resolver;
    }
}</code></pre>
<h3>Kotlin</h3>
<pre><code class="language-kotlin">package io.github.susimsek.springbootjweauthjpademo.config

import com.nimbusds.jose.EncryptionMethod
import com.nimbusds.jose.JWEAlgorithm
import com.nimbusds.jose.JWSAlgorithm
import com.nimbusds.jose.jwk.JWKSet
import com.nimbusds.jose.jwk.RSAKey
import com.nimbusds.jose.jwk.source.JWKSource
import com.nimbusds.jose.proc.JWEDecryptionKeySelector
import com.nimbusds.jose.proc.JWSVerificationKeySelector
import com.nimbusds.jose.proc.SecurityContext
import com.nimbusds.jwt.proc.DefaultJWTProcessor
import io.github.susimsek.springbootjweauthjpademo.security.CookieBearerTokenResolver
import io.github.susimsek.springbootjweauthjpademo.security.KeyUtils
import org.springframework.context.annotation.Bean
import org.springframework.context.annotation.Configuration
import org.springframework.security.oauth2.jwt.JwtDecoder
import org.springframework.security.oauth2.jwt.JwtEncoder
import org.springframework.security.oauth2.jwt.NimbusJwtDecoder
import org.springframework.security.oauth2.jwt.NimbusJwtEncoder
import org.springframework.security.oauth2.server.resource.authentication.JwtAuthenticationConverter
import org.springframework.security.oauth2.server.resource.authentication.JwtGrantedAuthoritiesConverter
import org.springframework.security.oauth2.server.resource.web.BearerTokenResolver

@Configuration
class SecurityJwtConfig(private val props: JwtProperties) {

    @Bean
    @Throws(Exception::class)
    fun signingKey(): RSAKey =
        KeyUtils.buildRsaKey(
            props.signing.publicKey,
            props.signing.privateKey,
            props.signing.keyId,
            true
        )

    @Bean
    @Throws(Exception::class)
    fun encryptionKey(): RSAKey =
        KeyUtils.buildRsaKey(
            props.encryption.publicKey,
            props.encryption.privateKey,
            props.encryption.keyId,
            false
        )

    @Bean
    fun jwkSource(signingKey: RSAKey, encryptionKey: RSAKey): JWKSource&lt;SecurityContext&gt; {
        val jwkSet = JWKSet(listOf(signingKey, encryptionKey))
        return JWKSource { jwkSelector, context -&gt; jwkSelector.select(jwkSet) }
    }

    @Bean
    fun jwtDecoder(jwkSource: JWKSource&lt;SecurityContext&gt;): JwtDecoder {
        val jwtProcessor = DefaultJWTProcessor&lt;SecurityContext&gt;()
        val jweKeySelector = JWEDecryptionKeySelector(
            JWEAlgorithm.RSA_OAEP_256,
            EncryptionMethod.A128GCM,
            jwkSource
        )
        jwtProcessor.jweKeySelector = jweKeySelector
        val jwsKeySelector = JWSVerificationKeySelector(
            JWSAlgorithm.RS256,
            jwkSource
        )
        jwtProcessor.jwsKeySelector = jwsKeySelector
        jwtProcessor.jwtClaimsSetVerifier = { _, _ -&gt; }
        return NimbusJwtDecoder(jwtProcessor)
    }

    @Bean
    fun jwtEncoder(jwkSource: JWKSource&lt;SecurityContext&gt;): JwtEncoder =
        NimbusJwtEncoder(jwkSource)

    @Bean
    fun jwtAuthenticationConverter(): JwtAuthenticationConverter {
        val converter = JwtGrantedAuthoritiesConverter().apply {
            setAuthorityPrefix(&quot;&quot;)
            setAuthoritiesClaimName(AUTHORITIES_KEY)
        }
        return JwtAuthenticationConverter().apply {
            setJwtGrantedAuthoritiesConverter(converter)
        }
    }

    @Bean
    fun bearerTokenResolver(): BearerTokenResolver =
        CookieBearerTokenResolver().apply {
            setAllowUriQueryParameter(false)
            setAllowFormEncodedBodyParameter(false)
            setAllowCookie(true)
        }
}</code></pre>
<h3>SecurityConfig</h3>
<h3>Java</h3>
<pre><code class="language-java">package io.github.susimsek.springbootjweauthjpademo.config;

import io.github.susimsek.springbootjweauthjpademo.repository.UserRepository;
import io.github.susimsek.springbootjweauthjpademo.security.AuthoritiesConstants;
import io.github.susimsek.springbootjweauthjpademo.security.DomainUserDetailsService;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.security.authentication.AuthenticationManager;
import org.springframework.security.authentication.ProviderManager;
import org.springframework.security.authentication.dao.DaoAuthenticationProvider;
import org.springframework.security.config.annotation.method.configuration.EnableMethodSecurity;
import org.springframework.security.config.annotation.web.builders.HttpSecurity;
import org.springframework.security.config.annotation.web.configurers.AbstractHttpConfigurer;
import org.springframework.security.config.http.SessionCreationPolicy;
import org.springframework.security.core.userdetails.UserDetailsService;
import org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder;
import org.springframework.security.crypto.password.PasswordEncoder;
import org.springframework.security.web.SecurityFilterChain;
import org.springframework.security.web.servlet.util.matcher.MvcRequestMatcher;
import org.springframework.web.servlet.handler.HandlerMappingIntrospector;

import static org.springframework.security.config.Customizer.withDefaults;

@Configuration
@EnableMethodSecurity(securedEnabled = true)
public class SecurityConfig {

  @Bean
  public SecurityFilterChain securityFilterChain(HttpSecurity http,
                                                 MvcRequestMatcher.Builder mvc) throws Exception {
    http
      .cors(withDefaults())
      .csrf(AbstractHttpConfigurer::disable)
      .authorizeHttpRequests(authz -&gt; authz
        .requestMatchers(
          mvc.pattern(&quot;/webjars/**&quot;),
          mvc.pattern(&quot;/css/**&quot;),
          mvc.pattern(&quot;/js/**&quot;)
        ).permitAll()
        .requestMatchers(
          mvc.pattern(&quot;/*.ico&quot;),
          mvc.pattern(&quot;/*.png&quot;),
          mvc.pattern(&quot;/*.svg&quot;),
          mvc.pattern(&quot;/*.webapp&quot;)
        ).permitAll()
        .requestMatchers(&quot;/actuator/**&quot;).permitAll()
        .requestMatchers(
          &quot;/v3/api-docs/**&quot;,
          &quot;/swagger-ui.html&quot;,
          &quot;/swagger-ui/**&quot;
        ).permitAll()
        .requestMatchers(mvc.pattern(&quot;/api/auth/login&quot;)).permitAll()
        .requestMatchers(mvc.pattern(&quot;/api/hello/admin&quot;)).hasAuthority(AuthoritiesConstants.ADMIN)
        .anyRequest().authenticated()
      )
      .sessionManagement(session -&gt;
        session.sessionCreationPolicy(SessionCreationPolicy.STATELESS)
      )
      .oauth2ResourceServer(oauth2 -&gt; oauth2.jwt(withDefaults()));

    return http.build();
  }

  @Bean
  public UserDetailsService userDetailsService(UserRepository userRepository) {
    return new DomainUserDetailsService(userRepository);
  }

  @Bean
  public PasswordEncoder passwordEncoder() {
    return new BCryptPasswordEncoder();
  }

  @Bean
  public AuthenticationManager authenticationManager(
    UserDetailsService userDetailsService,
    PasswordEncoder passwordEncoder) {
    DaoAuthenticationProvider authenticationProvider = new DaoAuthenticationProvider();
    authenticationProvider.setUserDetailsService(userDetailsService);
    authenticationProvider.setPasswordEncoder(passwordEncoder);

    return new ProviderManager(authenticationProvider);
  }

  @Bean
  public MvcRequestMatcher.Builder mvc(HandlerMappingIntrospector introspector) {
    return new MvcRequestMatcher.Builder(introspector);
  }
}</code></pre>
<h3>Kotlin</h3>
<pre><code class="language-kotlin">package io.github.susimsek.springbootjweauthjpademo.config

import io.github.susimsek.springbootjweauthjpademo.repository.UserRepository
import io.github.susimsek.springbootjweauthjpademo.security.AuthoritiesConstants
import io.github.susimsek.springbootjweauthjpademo.security.DomainUserDetailsService
import org.springframework.context.annotation.Bean
import org.springframework.context.annotation.Configuration
import org.springframework.security.authentication.AuthenticationManager
import org.springframework.security.authentication.ProviderManager
import org.springframework.security.authentication.dao.DaoAuthenticationProvider
import org.springframework.security.config.annotation.method.configuration.EnableMethodSecurity
import org.springframework.security.config.annotation.web.builders.HttpSecurity
import org.springframework.security.config.configurers.AbstractHttpConfigurer
import org.springframework.security.config.http.SessionCreationPolicy
import org.springframework.security.core.userdetails.UserDetailsService
import org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder
import org.springframework.security.crypto.password.PasswordEncoder
import org.springframework.security.web.SecurityFilterChain
import org.springframework.security.web.servlet.util.matcher.MvcRequestMatcher
import org.springframework.web.servlet.handler.HandlerMappingIntrospector

@Configuration
@EnableMethodSecurity(securedEnabled = true)
class SecurityConfig {

  @Bean
  @Throws(Exception::class)
  fun securityFilterChain(http: HttpSecurity,
                          mvc: MvcRequestMatcher.Builder): SecurityFilterChain {
    http
      .cors(withDefaults())
      .csrf { it.disable() }
      .authorizeHttpRequests { authz -&gt;
        authz
          .requestMatchers(
            mvc.pattern(&quot;/webjars/**&quot;),
            mvc.pattern(&quot;/css/**&quot;),
            mvc.pattern(&quot;/js/**&quot;)
          ).permitAll()
          .requestMatchers(
            mvc.pattern(&quot;/*.ico&quot;),
            mvc.pattern(&quot;/*.png&quot;),
            mvc.pattern(&quot;/*.svg&quot;),
            mvc.pattern(&quot;/*.webapp&quot;)
          ).permitAll()
          .requestMatchers(&quot;/actuator/**&quot;).permitAll()
          .requestMatchers(
            &quot;/v3/api-docs/**&quot;,
            &quot;/swagger-ui.html&quot;,
            &quot;/swagger-ui/**&quot;
          ).permitAll()
          .requestMatchers(mvc.pattern(&quot;/api/auth/login&quot;)).permitAll()
          .requestMatchers(mvc.pattern(&quot;/api/hello/admin&quot;)).hasAuthority(AuthoritiesConstants.ADMIN)
          .anyRequest().authenticated()
      }
      .sessionManagement { it.sessionCreationPolicy(SessionCreationPolicy.STATELESS) }
      .oauth2ResourceServer { it.jwt(withDefaults()) }

    return http.build()
  }

  @Bean
  fun userDetailsService(userRepository: UserRepository): UserDetailsService =
    DomainUserDetailsService(userRepository)

  @Bean
  fun passwordEncoder(): PasswordEncoder = BCryptPasswordEncoder()

  @Bean
  fun authenticationManager(
    userDetailsService: UserDetailsService,
    passwordEncoder: PasswordEncoder
  ): AuthenticationManager {
    val provider = DaoAuthenticationProvider().apply {
      setUserDetailsService(userDetailsService)
      setPasswordEncoder(passwordEncoder)
    }
    return ProviderManager(provider)
  }

  @Bean
  fun mvc(introspector: HandlerMappingIntrospector): MvcRequestMatcher.Builder =
    MvcRequestMatcher.Builder(introspector)
}</code></pre>
<h3>JwtProperties</h3>
<h3>Java</h3>
<pre><code class="language-java">package io.github.susimsek.springbootjweauthjpademo.config;

import lombok.Data;
import org.springframework.boot.context.properties.ConfigurationProperties;
import org.springframework.context.annotation.Configuration;

import java.time.Duration;

@Configuration
@ConfigurationProperties(prefix = &quot;security.jwt&quot;)
@Data
public class JwtProperties {

    @Data
    public static class Pair {
        private String publicKey;
        private String privateKey;
        private String keyId;
    }

    private Pair signing;
    private Pair encryption;
    private String issuer;
    private Duration expirationDuration;
}</code></pre>
<h3>Kotlin</h3>
<pre><code class="language-kotlin">package io.github.susimsek.springbootjweauthjpademo.config

import org.springframework.boot.context.properties.ConfigurationProperties
import org.springframework.context.annotation.Configuration
import java.time.Duration

@Configuration
@ConfigurationProperties(prefix = &quot;security.jwt&quot;)
class JwtProperties {

  class Pair {
    lateinit var publicKey: String
    lateinit var privateKey: String
    lateinit var keyId: String
  }

  lateinit var signing: Pair
  lateinit var encryption: Pair
  lateinit var issuer: String
  lateinit var expirationDuration: Duration
}</code></pre>
<h3>DatabaseConfig</h3>
<h3>Java</h3>
<pre><code class="language-java">package io.github.susimsek.springbootjweauthjpademo.config;

import org.springframework.context.annotation.Configuration;
import org.springframework.data.jpa.repository.config.EnableJpaAuditing;
import org.springframework.data.jpa.repository.config.EnableJpaRepositories;
import org.springframework.transaction.annotation.EnableTransactionManagement;

@Configuration
@EnableJpaRepositories(&quot;io.github.susimsek.springbootjweauthjpademo.repository&quot;)
@EnableJpaAuditing(auditorAwareRef = &quot;springSecurityAuditorAware&quot;)
@EnableTransactionManagement
public class DatabaseConfig {

}</code></pre>
<h3>Kotlin</h3>
<pre><code class="language-kotlin">package io.github.susimsek.springbootjweauthjpademo.config

import org.springframework.context.annotation.Configuration
import org.springframework.data.jpa.repository.config.EnableJpaAuditing
import org.springframework.data.jpa.repository.config.EnableJpaRepositories
import org.springframework.transaction.annotation.EnableTransactionManagement

@Configuration
@EnableJpaRepositories(&quot;io.github.susimsek.springbootjweauthjpademo.repository&quot;)
@EnableJpaAuditing(auditorAwareRef = &quot;springSecurityAuditorAware&quot;)
@EnableTransactionManagement
class DatabaseConfig</code></pre>
<hr />
<h2>üõ†Ô∏è Step 4: JPA Integration</h2>
<p>In this section, we define the JPA entities representing users, authorities, and their mappings, along with the Spring Data repository for loading users with their authorities.</p>
<ul>
<li>BaseEntity: Abstract superclass providing audit fields (`createdAt`, `createdBy`, `updatedAt`, `updatedBy`).</li>
<li>Authority: `authority` table entity storing role data.</li>
<li>User: `user_identity` table entity storing user credentials and profile.</li>
<li>UserAuthorityMapping: `user_authority_mapping` join table entity linking users and authorities.</li>
<li>UserAuthorityMappingId: Composite key class for `UserAuthorityMapping`.</li>
<li>UserRepository: Spring Data JPA repository for `User` with an entity graph to load authorities.</li>
</ul>
<h3>BaseEntity</h3>
<h3>Java</h3>
<pre><code class="language-java">package io.github.susimsek.springbootjweauthjpademo.entity;

import jakarta.persistence.Column;
import jakarta.persistence.EntityListeners;
import jakarta.persistence.MappedSuperclass;
import lombok.Getter;
import lombok.Setter;
import org.springframework.data.annotation.CreatedBy;
import org.springframework.data.annotation.CreatedDate;
import org.springframework.data.annotation.LastModifiedBy;
import org.springframework.data.annotation.LastModifiedDate;
import org.springframework.data.jpa.domain.support.AuditingEntityListener;

import java.time.Instant;

@MappedSuperclass
@EntityListeners(AuditingEntityListener.class)
@Getter
@Setter
public abstract class BaseEntity {

  @CreatedDate
  @Column(name = &quot;created_at&quot;, nullable = false, updatable = false)
  private Instant createdAt;

  @CreatedBy
  @Column(name = &quot;created_by&quot;, nullable = false, updatable = false, length = 50)
  private String createdBy;

  @LastModifiedDate
  @Column(name = &quot;updated_at&quot;)
  private Instant updatedAt;

  @LastModifiedBy
  @Column(name = &quot;updated_by&quot;, length = 50)
  private String updatedBy;
}</code></pre>
<h3>Kotlin</h3>
<pre><code class="language-kotlin">package io.github.susimsek.springbootjweauthjpademo.entity

import jakarta.persistence.Column
import jakarta.persistence.EntityListeners
import jakarta.persistence.MappedSuperclass
import org.springframework.data.annotation.CreatedBy
import org.springframework.data.annotation.CreatedDate
import org.springframework.data.annotation.LastModifiedBy
import org.springframework.data.annotation.LastModifiedDate
import org.springframework.data.jpa.domain.support.AuditingEntityListener
import java.time.Instant

@MappedSuperclass
@EntityListeners(AuditingEntityListener::class)
abstract class BaseEntity {

  @CreatedDate
  @Column(name = &quot;created_at&quot;, nullable = false, updatable = false)
  lateinit var createdAt: Instant

  @CreatedBy
  @Column(name = &quot;created_by&quot;, nullable = false, updatable = false, length = 50)
  lateinit var createdBy: String

  @LastModifiedDate
  @Column(name = &quot;updated_at&quot;)
  var updatedAt: Instant? = null

  @LastModifiedBy
  @Column(name = &quot;updated_by&quot;, length = 50)
  var updatedBy: String? = null
}</code></pre>
<h3>Authority</h3>
<h3>Java</h3>
<pre><code class="language-java">package io.github.susimsek.springbootjweauthjpademo.entity;

import jakarta.persistence.Column;
import jakarta.persistence.Entity;
import jakarta.persistence.Id;
import jakarta.persistence.Table;
import lombok.AllArgsConstructor;
import lombok.Getter;
import lombok.NoArgsConstructor;
import lombok.Setter;
import org.hibernate.proxy.HibernateProxy;

import java.util.Objects;

@Entity
@Table(name = &quot;authority&quot;)
@Getter
@Setter
@NoArgsConstructor
@AllArgsConstructor
public class Authority extends BaseEntity {

  @Id
  @Column(length = 36, nullable = false)
  private String id;

  @Column(length = 50, nullable = false, unique = true)
  private String name;

  @Column(length = 255)
  private String description;

  @Override
  public final boolean equals(Object obj) {
    if (this == obj) {
      return true;
    }
    if (!(obj instanceof Authority other)) {
      return false;
    }
    Class&lt;?&gt; objClass = obj instanceof HibernateProxy proxy
      ? proxy.getHibernateLazyInitializer().getPersistentClass()
      : obj.getClass();
    Class&lt;?&gt; thisClass = this instanceof HibernateProxy proxy
      ? proxy.getHibernateLazyInitializer().getPersistentClass()
      : this.getClass();
    if (!thisClass.equals(objClass)) {
      return false;
    }
    return id != null &amp;&amp; Objects.equals(id, other.id);
  }

  @Override
  public final int hashCode() {
    return this instanceof HibernateProxy proxy
      ? proxy.getHibernateLazyInitializer().getPersistentClass().hashCode()
      : getClass().hashCode();
  }
}</code></pre>
<h3>Kotlin</h3>
<pre><code class="language-kotlin">package io.github.susimsek.springbootjweauthjpademo.entity

import jakarta.persistence.Column
import jakarta.persistence.Entity
import jakarta.persistence.Id
import jakarta.persistence.Table
import org.hibernate.proxy.HibernateProxy
import java.util.Objects

@Entity
@Table(name = &quot;authority&quot;)
class Authority(
  @Id
  @Column(length = 36, nullable = false)
  var id: String,

  @Column(length = 50, nullable = false, unique = true)
  var name: String,

  @Column(length = 255)
  var description: String?
) : BaseEntity() {

  override fun equals(other: Any?): Boolean {
    if (this === other) return true
    if (other !is Authority) return false
    val objClass = (other as? HibernateProxy)?.hibernateLazyInitializer?.persistentClass ?: other::class.java
    val thisClass = (this as? HibernateProxy)?.hibernateLazyInitializer?.persistentClass ?: this::class.java
    if (thisClass != objClass) return false
    return id == other.id
  }

  override fun hashCode(): Int {
    return (this as? HibernateProxy)?.hibernateLazyInitializer?.persistentClass?.hashCode()
      ?: javaClass.hashCode()
  }
}</code></pre>
<h3>User</h3>
<h3>Java</h3>
<pre><code class="language-java">package io.github.susimsek.springbootjweauthjpademo.entity;

import jakarta.persistence.CascadeType;
import jakarta.persistence.Column;
import jakarta.persistence.Entity;
import jakarta.persistence.FetchType;
import jakarta.persistence.Id;
import jakarta.persistence.NamedAttributeNode;
import jakarta.persistence.NamedEntityGraph;
import jakarta.persistence.NamedSubgraph;
import jakarta.persistence.OneToMany;
import jakarta.persistence.Table;
import lombok.AllArgsConstructor;
import lombok.Getter;
import lombok.NoArgsConstructor;
import lombok.Setter;
import org.hibernate.proxy.HibernateProxy;

import java.util.HashSet;
import java.util.Objects;
import java.util.Set;

@Entity
@Table(name = &quot;user_identity&quot;)
@Getter
@Setter
@NoArgsConstructor
@AllArgsConstructor
@NamedEntityGraph(
  name = &quot;User.withAuthorities&quot;,
  attributeNodes = @NamedAttributeNode(value = &quot;authorities&quot;, subgraph = &quot;auth-subgraph&quot;),
  subgraphs = @NamedSubgraph(
    name = &quot;auth-subgraph&quot;,
    attributeNodes = @NamedAttributeNode(&quot;authority&quot;)
  )
)
public class User extends BaseEntity {

  @Id
  @Column(name = &quot;id&quot;, length = 36, nullable = false, updatable = false)
  private String id;

  @Column(name = &quot;username&quot;, length = 50, nullable = false, unique = true)
  private String username;

  @Column(name = &quot;password&quot;, length = 100, nullable = false)
  private String password;

  @Column(name = &quot;email&quot;, length = 100, nullable = false, unique = true)
  private String email;

  @Column(name = &quot;first_name&quot;, length = 50)
  private String firstName;

  @Column(name = &quot;last_name&quot;, length = 50)
  private String lastName;

  @Column(name = &quot;enabled&quot;, nullable = false)
  private boolean enabled;

  @OneToMany(mappedBy = &quot;user&quot;, fetch = FetchType.LAZY,
    cascade = CascadeType.ALL, orphanRemoval = true)
  private Set&lt;UserAuthorityMapping&gt; authorities = new HashSet&lt;&gt;();

  @Override
  public final boolean equals(Object obj) {
    if (this == obj) return true;
    if (!(obj instanceof User other)) return false;
    Class&lt;?&gt; objClass = (obj instanceof HibernateProxy hp
      ? hp.getHibernateLazyInitializer().getPersistentClass()
      : obj.getClass());
    Class&lt;?&gt; thisClass = (this instanceof HibernateProxy hp
      ? hp.getHibernateLazyInitializer().getPersistentClass()
      : this.getClass());
    if (!thisClass.equals(objClass)) return false;
    return id != null &amp;&amp; id.equals(other.id);
  }

  @Override
  public final int hashCode() {
    return (this instanceof HibernateProxy hp
      ? hp.getHibernateLazyInitializer().getPersistentClass().hashCode()
      : getClass().hashCode());
  }
}</code></pre>
<h3>Kotlin</h3>
<pre><code class="language-kotlin">package io.github.susimsek.springbootjweauthjpademo.entity

import jakarta.persistence.CascadeType
import jakarta.persistence.Column
import jakarta.persistence.Entity
import jakarta.persistence.FetchType
import jakarta.persistence.Id
import jakarta.persistence.NamedAttributeNode
import jakarta.persistence.NamedEntityGraph
import jakarta.persistence.NamedSubgraph
import jakarta.persistence.OneToMany
import jakarta.persistence.Table
import org.hibernate.proxy.HibernateProxy
import java.util.*

@Entity
@Table(name = &quot;user_identity&quot;)
@NamedEntityGraph(
  name = &quot;User.withAuthorities&quot;,
  attributeNodes = [NamedAttributeNode(value = &quot;authorities&quot;, subgraph = &quot;auth-subgraph&quot;)],
  subgraphs = [
    NamedSubgraph(
      name = &quot;auth-subgraph&quot;,
      attributeNodes = [NamedAttributeNode(&quot;authority&quot;)]
    )
  ]
)
class User(

  @Id
  @Column(name = &quot;id&quot;, length = 36, nullable = false, updatable = false)
  var id: String,

  @Column(name = &quot;username&quot;, length = 50, nullable = false, unique = true)
  var username: String,

  @Column(name = &quot;password&quot;, length = 100, nullable = false)
  var password: String,

  @Column(name = &quot;email&quot;, length = 100, nullable = false, unique = true)
  var email: String,

  @Column(name = &quot;first_name&quot;, length = 50)
  var firstName: String? = null,

  @Column(name = &quot;last_name&quot;, length = 50)
  var lastName: String? = null,

  @Column(name = &quot;enabled&quot;, nullable = false)
  var enabled: Boolean = true

) : BaseEntity() {

  @OneToMany(
    mappedBy = &quot;user&quot;,
    fetch = FetchType.LAZY,
    cascade = [CascadeType.ALL],
    orphanRemoval = true
  )
  var authorities: MutableSet&lt;UserAuthorityMapping&gt; = HashSet()

  override fun equals(other: Any?): Boolean {
    if (this === other) return true
    if (other !is User) return false
    val objClass = (other as? HibernateProxy)?.hibernateLazyInitializer?.persistentClass
      ?: other::class.java
    val thisClass = (this as? HibernateProxy)?.hibernateLazyInitializer?.persistentClass
      ?: this::class.java
    if (thisClass != objClass) return false
    return id == other.id
  }

  override fun hashCode(): Int =
    ((this as? HibernateProxy)?.hibernateLazyInitializer?.persistentClass?.hashCode()
      ?: javaClass.hashCode())
}</code></pre>
<h3>UserAuthorityMapping</h3>
<h3>Java</h3>
<pre><code class="language-java">package io.github.susimsek.springbootjweauthjpademo.entity;

import jakarta.persistence.Column;
import jakarta.persistence.Entity;
import jakarta.persistence.FetchType;
import jakarta.persistence.Id;
import jakarta.persistence.IdClass;
import jakarta.persistence.JoinColumn;
import jakarta.persistence.ManyToOne;
import jakarta.persistence.Table;
import lombok.AllArgsConstructor;
import lombok.Getter;
import lombok.NoArgsConstructor;
import lombok.Setter;
import org.hibernate.proxy.HibernateProxy;

import java.util.Objects;

@Entity
@Table(name = &quot;user_authority_mapping&quot;)
@IdClass(UserAuthorityMappingId.class)
@Getter
@Setter
@NoArgsConstructor
@AllArgsConstructor
public class UserAuthorityMapping extends BaseEntity {

  @Id
  @Column(name = &quot;user_id&quot;, length = 36, nullable = false)
  private String userId;

  @Id
  @Column(name = &quot;authority_id&quot;, length = 36, nullable = false)
  private String authorityId;

  @ManyToOne(fetch = FetchType.LAZY)
  @JoinColumn(name = &quot;user_id&quot;, insertable = false, updatable = false)
  private User user;

  @ManyToOne(fetch = FetchType.LAZY)
  @JoinColumn(name = &quot;authority_id&quot;, insertable = false, updatable = false)
  private Authority authority;

  @Override
  public final boolean equals(Object obj) {
    if (this == obj) return true;
    if (!(obj instanceof UserAuthorityMapping other)) return false;
    Class&lt;?&gt; objCls = (obj instanceof HibernateProxy hp
      ? hp.getHibernateLazyInitializer().getPersistentClass()
      : obj.getClass());
    Class&lt;?&gt; thisCls = (this instanceof HibernateProxy hp
      ? hp.getHibernateLazyInitializer().getPersistentClass()
      : this.getClass());
    if (!thisCls.equals(objCls)) return false;
    return userId != null &amp;&amp; userId.equals(other.userId)
      &amp;&amp; authorityId != null &amp;&amp; authorityId.equals(other.authorityId);
  }

  @Override
  public final int hashCode() {
    return (this instanceof HibernateProxy hp
      ? hp.getHibernateLazyInitializer().getPersistentClass().hashCode()
      : Objects.hash(userId, authorityId));
  }
}</code></pre>
<h3>Kotlin</h3>
<pre><code class="language-kotlin">package io.github.susimsek.springbootjweauthjpademo.entity

import jakarta.persistence.*
import org.hibernate.proxy.HibernateProxy
import java.util.*

@Entity
@Table(name = &quot;user_authority_mapping&quot;)
@IdClass(UserAuthorityMappingId::class)
data class UserAuthorityMapping(

  @Id
  @Column(name = &quot;user_id&quot;, length = 36, nullable = false)
  var userId: String = &quot;&quot;,

  @Id
  @Column(name = &quot;authority_id&quot;, length = 36, nullable = false)
  var authorityId: String = &quot;&quot;,

  @ManyToOne(fetch = FetchType.LAZY)
  @JoinColumn(name = &quot;user_id&quot;, insertable = false, updatable = false)
  var user: User? = null,

  @ManyToOne(fetch = FetchType.LAZY)
  @JoinColumn(name = &quot;authority_id&quot;, insertable = false, updatable = false)
  var authority: Authority? = null

) : BaseEntity() {

  override fun equals(other: Any?): Boolean {
    if (this === other) return true
    if (other !is UserAuthorityMapping) return false

    val objCls = (other as? HibernateProxy)?.hibernateLazyInitializer?.persistentClass
      ?: other::class.java
    val thisCls = (this as? HibernateProxy)?.hibernateLazyInitializer?.persistentClass
      ?: this::class.java

    if (thisCls != objCls) return false
    return userId == other.userId &amp;&amp; authorityId == other.authorityId
  }

  override fun hashCode(): Int {
    return (this as? HibernateProxy)?.hibernateLazyInitializer?.persistentClass?.hashCode()
      ?: Objects.hash(userId, authorityId)
  }
}</code></pre>
<h3>UserAuthorityMappingId</h3>
<h3>Java</h3>
<pre><code class="language-java">package io.github.susimsek.springbootjweauthjpademo.entity;

import java.io.Serializable;
import java.util.Objects;
import lombok.AllArgsConstructor;
import lombok.Getter;
import lombok.NoArgsConstructor;
import lombok.Setter;

@Getter
@Setter
@NoArgsConstructor
@AllArgsConstructor
public class UserAuthorityMappingId implements Serializable {

  private String userId;
  private String authorityId;

  @Override
  public boolean equals(Object o) {
    if (this == o) return true;
    if (o == null || getClass() != o.getClass()) return false;
    UserAuthorityMappingId that = (UserAuthorityMappingId) o;
    return Objects.equals(userId, that.userId) &amp;&amp;
      Objects.equals(authorityId, that.authorityId);
  }

  @Override
  public int hashCode() {
    return Objects.hash(userId, authorityId);
  }
}</code></pre>
<h3>Kotlin</h3>
<pre><code class="language-kotlin">package io.github.susimsek.springbootjweauthjpademo.entity

import java.io.Serializable
import java.util.Objects

data class UserAuthorityMappingId(
  var userId: String = &quot;&quot;,
  var authorityId: String = &quot;&quot;
) : Serializable {

  override fun equals(other: Any?): Boolean {
    if (this === other) return true
    if (other == null || this::class != other::class) return false
    other as UserAuthorityMappingId
    return userId == other.userId &amp;&amp; authorityId == other.authorityId
  }

  override fun hashCode(): Int {
    return Objects.hash(userId, authorityId)
  }
}</code></pre>
<h3>UserRepository</h3>
<h3>Java</h3>
<pre><code class="language-java">package io.github.susimsek.springbootjweauthjpademo.repository;

import io.github.susimsek.springbootjweauthjpademo.entity.User;
import org.springframework.data.jpa.repository.EntityGraph;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.stereotype.Repository;

import java.util.Optional;

@Repository
public interface UserRepository extends JpaRepository&lt;User, String&gt; {

  @EntityGraph(&quot;User.withAuthorities&quot;)
  Optional&lt;User&gt; findOneWithAuthoritiesByUsername(String username);
}</code></pre>
<h3>Kotlin</h3>
<pre><code class="language-kotlin">package io.github.susimsek.springbootjweauthjpademo.repository

import io.github.susimsek.springbootjweauthjpademo.entity.User
import org.springframework.data.jpa.repository.EntityGraph
import org.springframework.data.jpa.repository.JpaRepository
import org.springframework.stereotype.Repository
import java.util.Optional

@Repository
interface UserRepository : JpaRepository&lt;User, String&gt; {

  @EntityGraph(&quot;User.withAuthorities&quot;)
  fun findOneWithAuthoritiesByUsername(username: String): Optional&lt;User&gt;
}</code></pre>
<hr />
<h2>üõ†Ô∏è Step 5: Secure JWE Token Utilities</h2>
<p>In this section, we define the core utility classes and constants needed to generate, encrypt, and resolve JSON Web Encryption (JWE) tokens in your Spring Boot application, integrate auditing, and implement a JPA-based user details service:</p>
<ul>
<li>AuthoritiesConstants: Centralize role names with the `ROLE_` prefix.</li>
<li>CookieBearerTokenResolver: Resolve bearer tokens from Authorization headers or HTTP cookies.</li>
<li>CookieUtils: Create HTTP-only, secure cookies for access tokens.</li>
<li>JweUtil: Sign (JWS) and encrypt (JWE) JWTs using RSA keys and Nimbus.</li>
<li>KeyUtils: Build RSA JWKs from PEM‚Äêencoded key material.</li>
<li>SecurityUtils: Extract the current user‚Äôs login from the security context.</li>
<li>SpringSecurityAuditorAware: Implement `AuditorAware` to provide the current user for auditing.</li>
<li>DomainUserDetailsService: JPA-based `UserDetailsService` loading user and authorities for authentication.</li>
</ul>
<p>These utilities form the foundation for a stateless, JWE‚Äêbased authentication flow in Spring Security.</p>
<h3>AuthoritiesConstants</h3>
<h3>Java</h3>
<pre><code class="language-java">
package io.github.susimsek.springbootjweauthjpademo.security;

import lombok.AccessLevel;
import lombok.NoArgsConstructor;

@NoArgsConstructor(access = AccessLevel.PRIVATE)
public final class AuthoritiesConstants {
    public static final String ADMIN = &quot;ROLE_ADMIN&quot;;
    public static final String USER = &quot;ROLE_USER&quot;;
    public static final String ANONYMOUS = &quot;ROLE_ANONYMOUS&quot;;
}</code></pre>
<h3>Kotlin</h3>
<pre><code class="language-kotlin">
package io.github.susimsek.springbootjweauthjpademo.security

object AuthoritiesConstants {
  const val ADMIN = &quot;ROLE_ADMIN&quot;
  const val USER = &quot;ROLE_USER&quot;
  const val ANONYMOUS = &quot;ROLE_ANONYMOUS&quot;
}</code></pre>
<h3>CookieBearerTokenResolver</h3>
<h3>Java</h3>
<pre><code class="language-java">package io.github.susimsek.springbootjweauthjpademo.security;

import jakarta.servlet.http.Cookie;
import jakarta.servlet.http.HttpServletRequest;
import lombok.Setter;
import org.springframework.http.HttpMethod;
import org.springframework.security.oauth2.core.OAuth2AuthenticationException;
import org.springframework.security.oauth2.server.resource.BearerTokenError;
import org.springframework.security.oauth2.server.resource.BearerTokenErrors;
import org.springframework.security.oauth2.server.resource.web.BearerTokenResolver;
import org.springframework.util.StringUtils;

import java.util.regex.Matcher;
import java.util.regex.Pattern;

@Setter
public class CookieBearerTokenResolver implements BearerTokenResolver {
    private static final String ACCESS_TOKEN_PARAMETER_NAME = &quot;access_token&quot;;
    private static final Pattern AUTHORIZATION_PATTERN =
        Pattern.compile(&quot;^Bearer (?&lt;token&gt;[A-Za-z0-9-._~+/]+=*)$&quot;, Pattern.CASE_INSENSITIVE);

    private boolean allowFormEncodedBodyParameter = false;
    private boolean allowUriQueryParameter       = false;
    private boolean allowCookie                  = true;
    private String  bearerTokenHeaderName       = &quot;Authorization&quot;;
    private String  cookieName                  = &quot;accessToken&quot;;

    @Override
    public String resolve(HttpServletRequest request) {
        String headerToken = resolveFromAuthorizationHeader(request);
        String queryToken  = resolveAccessTokenFromQueryString(request);
        String bodyToken   = resolveAccessTokenFromBody(request);
        String cookieToken = (headerToken == null &amp;&amp; queryToken == null &amp;&amp; bodyToken == null)
            ? resolveFromCookie(request)
            : null;

        return resolveToken(headerToken, queryToken, bodyToken, cookieToken);
    }

    private String resolveFromAuthorizationHeader(HttpServletRequest request) {
        String authorization = request.getHeader(this.bearerTokenHeaderName);
        if (!StringUtils.hasText(authorization) || !authorization.toLowerCase().startsWith(&quot;bearer&quot;)) {
            return null;
        }
        Matcher matcher = AUTHORIZATION_PATTERN.matcher(authorization.trim());
        if (!matcher.matches()) {
            BearerTokenError error = BearerTokenErrors.invalidToken(&quot;Bearer token is malformed&quot;);
            throw new OAuth2AuthenticationException(error);
        }
        return matcher.group(&quot;token&quot;);
    }

    private String resolveAccessTokenFromQueryString(HttpServletRequest request) {
        if (allowUriQueryParameter &amp;&amp; HttpMethod.GET.matches(request.getMethod())) {
            return resolveToken(request.getParameterValues(ACCESS_TOKEN_PARAMETER_NAME));
        }
        return null;
    }

    private String resolveAccessTokenFromBody(HttpServletRequest request) {
        if (allowFormEncodedBodyParameter
            &amp;&amp; HttpMethod.POST.matches(request.getMethod())
            &amp;&amp; &quot;application/x-www-form-urlencoded&quot;.equals(request.getContentType())) {
            return resolveToken(request.getParameterValues(ACCESS_TOKEN_PARAMETER_NAME));
        }
        return null;
    }

    private String resolveFromCookie(HttpServletRequest request) {
        if (!allowCookie || request.getCookies() == null) {
            return null;
        }
        for (Cookie cookie : request.getCookies()) {
            if (cookieName.equals(cookie.getName())) {
                String val = cookie.getValue();
                return StringUtils.hasText(val) ? val : null;
            }
        }
        return null;
    }

    private String resolveToken(String... tokens) {
        String found = null;
        for (String token : tokens) {
            if (token == null) continue;
            if (found != null) {
                BearerTokenError error = BearerTokenErrors.invalidRequest(&quot;Found multiple bearer tokens in the request&quot;);
                throw new OAuth2AuthenticationException(error);
            }
            found = token;
        }
        if (found != null &amp;&amp; found.isBlank()) {
            BearerTokenError error = BearerTokenErrors.invalidRequest(&quot;The requested token parameter is an empty string&quot;);
            throw new OAuth2AuthenticationException(error);
        }
        return found;
    }</code></pre>
<h3>Kotlin</h3>
<pre><code class="language-kotlin">package io.github.susimsek.springbootjweauthjpademo.security

import jakarta.servlet.http.Cookie
import jakarta.servlet.http.HttpServletRequest
import org.springframework.http.HttpMethod
import org.springframework.security.oauth2.core.OAuth2AuthenticationException
import org.springframework.security.oauth2.server.resource.BearerTokenError
import org.springframework.security.oauth2.server.resource.BearerTokenErrors
import org.springframework.security.oauth2.server.resource.web.BearerTokenResolver
import org.springframework.util.StringUtils
import java.util.regex.Pattern

class CookieBearerTokenResolver {
    var allowFormEncodedBodyParameter: Boolean = false
    var allowUriQueryParameter: Boolean = false
    var allowCookie: Boolean = true
    var bearerTokenHeaderName: String = &quot;Authorization&quot;
    var cookieName: String = &quot;accessToken&quot;

    companion object {
        private const val ACCESS_TOKEN_PARAMETER_NAME = &quot;access_token&quot;
        private val AUTHORIZATION_PATTERN =
            Pattern.compile(&quot;^Bearer (?&lt;token&gt;[A-Za-z0-9-._~+/]+=*)$&quot;, Pattern.CASE_INSENSITIVE)
    }

    fun resolve(request: HttpServletRequest): String? {
        val header = resolveFromAuthorizationHeader(request)
        val query  = if (allowUriQueryParameter &amp;&amp; HttpMethod.GET.matches(request.method))
            request.getParameterValues(ACCESS_TOKEN_PARAMETER_NAME)?.let(::resolveToken)
        else null
        val body   = if (allowFormEncodedBodyParameter &amp;&amp; HttpMethod.POST.matches(request.method)
            &amp;&amp; request.contentType == &quot;application/x-www-form-urlencoded&quot;)
            request.getParameterValues(ACCESS_TOKEN_PARAMETER_NAME)?.let(::resolveToken)
        else null
        val cookie = if (header == null &amp;&amp; query == null &amp;&amp; body == null)
            resolveFromCookie(request)
        else null
      return listOf(header, query, body, cookie).filterNotNull().let {
            if (it.size &gt; 1) throw OAuth2AuthenticationException(BearerTokenErrors.invalidRequest(&quot;Found multiple bearer tokens&quot;))
            it.firstOrNull()?: null
        }
    }

    private fun resolveFromAuthorizationHeader(request: HttpServletRequest): String? {
        val auth = request.getHeader(bearerTokenHeaderName) ?: return null
        if (!auth.startsWith(&quot;Bearer &quot;, true)) return null
        val matcher = AUTHORIZATION_PATTERN.matcher(auth.trim())
        return if (matcher.matches()) matcher.group(&quot;token&quot;)
        else throw OAuth2AuthenticationException(BearerTokenErrors.invalidToken(&quot;Malformed token&quot;))
    }

    private fun resolveFromCookie(request: HttpServletRequest): String? {
        if (!allowCookie) return null
        return request.cookies?.firstOrNull { it.name == cookieName }?.value?.takeIf { it.isNotBlank() }
    }

    private fun resolveToken(tokens: Array&lt;String&gt;): String? {
        return tokens.filter { it.isNotBlank() }.let {
            when {
                it.isEmpty() -&gt; null
                it.size &gt; 1   -&gt; throw OAuth2AuthenticationException(BearerTokenErrors.invalidRequest(&quot;Multiple tokens&quot;))
                else          -&gt; it[0]
            }
        }
    }</code></pre>
<h3>CookieUtils</h3>
<h3>Java</h3>
<pre><code class="language-java">package io.github.susimsek.springbootjweauthjpademo.security;

import io.github.susimsek.springbootjweauthjpademo.dto.TokenDTO;
import lombok.experimental.UtilityClass;
import org.springframework.http.ResponseCookie;

@UtilityClass
public class CookieUtils {

    private static final String COOKIE_NAME = &quot;accessToken&quot;;

    public ResponseCookie createAccessTokenCookie(TokenDTO tokenDto) {
        return ResponseCookie.from(COOKIE_NAME, tokenDto.accessToken())
            .httpOnly(true)
            .secure(true)
            .path(&quot;/&quot;)
            .maxAge(tokenDto.accessTokenExpiresIn())
            .sameSite(&quot;Strict&quot;)
            .build();
    }
}</code></pre>
<h3>Kotlin</h3>
<pre><code class="language-kotlin">package io.github.susimsek.springbootjweauthjpademo.security

import io.github.susimsek.springbootjweauthjpademo.dto.TokenDTO
import org.springframework.http.ResponseCookie

object CookieUtils {

  private const val COOKIE_NAME = &quot;accessToken&quot;

  fun createAccessTokenCookie(tokenDto: TokenDTO): ResponseCookie {
    return ResponseCookie.from(COOKIE_NAME, tokenDto.accessToken())
      .httpOnly(true)
      .secure(true)
      .path(&quot;/&quot;)
      .maxAge(tokenDto.accessTokenExpiresIn())
      .sameSite(&quot;Strict&quot;)
      .build()
  }
}</code></pre>
<h3>JweUtil</h3>
<h3>Java</h3>
<pre><code class="language-java">package io.github.susimsek.springbootjweauthjpademo.security;

import com.nimbusds.jose.EncryptionMethod;
import com.nimbusds.jose.JOSEException;
import com.nimbusds.jose.JWEAlgorithm;
import com.nimbusds.jose.JWEHeader;
import com.nimbusds.jose.JWEObject;
import com.nimbusds.jose.Payload;
import com.nimbusds.jose.crypto.RSAEncrypter;
import com.nimbusds.jose.jwk.RSAKey;
import io.github.susimsek.springbootjweauthjpademo.config.JwtProperties;
import io.github.susimsek.springbootjweauthjpademo.dto.TokenDTO;
import lombok.RequiredArgsConstructor;
import org.springframework.security.core.Authentication;
import org.springframework.security.core.GrantedAuthority;
import org.springframework.security.oauth2.jose.jws.SignatureAlgorithm;
import org.springframework.security.oauth2.jwt.*;
import org.springframework.stereotype.Component;

import java.time.Instant;
import java.util.List;

import static io.github.susimsek.springbootjweauthjpademo.security.SecurityUtils.AUTHORITIES_KEY;

@Component
@RequiredArgsConstructor
public class JweUtil {

    private final JwtEncoder jwtEncoder;
    private final RSAKey signingKey;
    private final RSAKey encryptionKey;
    private final JwtProperties props;

    public TokenDTO generateToken(Authentication authentication) throws JOSEException {
        String subject = authentication.getName();
        List&lt;String&gt; roles = authentication.getAuthorities()
            .stream()
            .map(GrantedAuthority::getAuthority)
            .toList();

        Instant now = Instant.now();
        long expiresIn = props.getExpirationDuration().getSeconds();
        Instant exp = now.plusSeconds(expiresIn);

        JwtClaimsSet claims = JwtClaimsSet.builder()
            .issuer(props.getIssuer())
            .issuedAt(now)
            .expiresAt(exp)
            .subject(subject)
            .claim(AUTHORITIES_KEY, roles)
            .build();

        JwsHeader jwsHeader = JwsHeader.with(SignatureAlgorithm.RS256)
            .keyId(signingKey.getKeyID())
            .build();

        String jws = jwtEncoder
            .encode(JwtEncoderParameters.from(jwsHeader, claims))
            .getTokenValue();

        JWEHeader jweHeader = new JWEHeader.Builder(JWEAlgorithm.RSA_OAEP_256, EncryptionMethod.A128GCM)
            .contentType(&quot;JWT&quot;)
            .keyID(encryptionKey.getKeyID())
            .build();

        JWEObject jweObject = new JWEObject(jweHeader, new Payload(jws));
        jweObject.encrypt(new RSAEncrypter(encryptionKey.toRSAPublicKey()));
        String token = jweObject.serialize();

        return new TokenDTO(token, &quot;Bearer&quot;, expiresIn);
    }
}</code></pre>
<h3>Kotlin</h3>
<pre><code class="language-kotlin">package io.github.susimsek.springbootjweauthjpademo.security

import com.nimbusds.jose.EncryptionMethod
import com.nimbusds.jose.JOSEException
import com.nimbusds.jose.JWEAlgorithm
import com.nimbusds.jose.JWEHeader
import com.nimbusds.jose.JWEObject
import com.nimbusds.jose.Payload
import com.nimbusds.jose.crypto.RSAEncrypter
import com.nimbusds.jose.jwk.RSAKey
import io.github.susimsek.springbootjweauthjpademo.config.JwtProperties
import io.github.susimsek.springbootjweauthjpademo.dto.TokenDTO
import lombok.RequiredArgsConstructor
import org.springframework.security.core.Authentication
import org.springframework.security.oauth2.jose.jws.SignatureAlgorithm
import org.springframework.security.oauth2.jwt.JwtClaimsSet
import org.springframework.security.oauth2.jwt.JwtEncoder
import org.springframework.security.oauth2.jwt.JwtEncoderParameters
import org.springframework.stereotype.Component

import java.time.Instant

@Component
@RequiredArgsConstructor
class JweUtil(
    private val jwtEncoder: JwtEncoder,
    private val signingKey: RSAKey,
    private val encryptionKey: RSAKey,
    private val props: JwtProperties
) {
    fun generateToken(authentication: Authentication): TokenDTO {
        val subject = authentication.name
        val roles = authentication.authorities.map { it.authority }

        val now = Instant.now()
        val expiresIn = props.expirationDuration.seconds
        val exp = now.plusSeconds(expiresIn)

        val claims = JwtClaimsSet.builder()
            .issuer(props.issuer)
            .issuedAt(now)
            .expiresAt(exp)
            .subject(subject)
            .claim(AUTHORITIES_KEY, roles)
            .build()

        val jwsHeader = org.springframework.security.oauth2.jwt.JwsHeader.with(SignatureAlgorithm.RS256)
            .keyId(signingKey.keyID)
            .build()

        val jws = jwtEncoder
            .encode(JwtEncoderParameters.from(jwsHeader, claims))
            .tokenValue

        val jweHeader = JWEHeader.Builder(JWEAlgorithm.RSA_OAEP_256, EncryptionMethod.A128GCM)
            .contentType(&quot;JWT&quot;)
            .keyID(encryptionKey.keyID)
            .build()

        val jweObject = JWEObject(jweHeader, Payload(jws))
        jweObject.encrypt(RSAEncrypter(encryptionKey.toRSAPublicKey()))
        val token = jweObject.serialize()

        return TokenDTO(token, &quot;Bearer&quot;, expiresIn)
    }
}</code></pre>
<h3>KeyUtils</h3>
<h3>Java</h3>
<pre><code class="language-java">package io.github.susimsek.springbootjweauthjpademo.security;

import com.nimbusds.jose.JWEAlgorithm;
import com.nimbusds.jose.JWSAlgorithm;
import com.nimbusds.jose.jwk.KeyUse;
import com.nimbusds.jose.jwk.RSAKey;
import lombok.experimental.UtilityClass;

import java.security.KeyFactory;
import java.security.interfaces.RSAPrivateKey;
import java.security.interfaces.RSAPublicKey;
import java.security.spec.PKCS8EncodedKeySpec;
import java.security.spec.X509EncodedKeySpec;
import java.util.Base64;

@UtilityClass
public class KeyUtils {
    public RSAKey buildRsaKey(
            String pubPem,
            String privPem,
            String kid,
            boolean forSign
    ) throws Exception {
        String pubContent = pubPem
            .replace(&quot;-----BEGIN PUBLIC KEY-----&quot;, &quot;&quot;)
            .replace(&quot;-----END PUBLIC KEY-----&quot;, &quot;&quot;)
            .replaceAll(&quot;\\s&quot;, &quot;&quot;);
        String privContent = privPem
            .replace(&quot;-----BEGIN PRIVATE KEY-----&quot;, &quot;&quot;)
            .replace(&quot;-----END PRIVATE KEY-----&quot;, &quot;&quot;)
            .replaceAll(&quot;\\s&quot;, &quot;&quot;);

        byte[] decodedPub = Base64.getDecoder().decode(pubContent);
        byte[] decodedPriv = Base64.getDecoder().decode(privContent);

        KeyFactory kf = KeyFactory.getInstance(&quot;RSA&quot;);
        RSAPublicKey publicKey = (RSAPublicKey) kf.generatePublic(new X509EncodedKeySpec(decodedPub));
        RSAPrivateKey privateKey = (RSAPrivateKey) kf.generatePrivate(new PKCS8EncodedKeySpec(decodedPriv));

        RSAKey.Builder builder = new RSAKey.Builder(publicKey)
            .privateKey(privateKey)
            .keyID(kid);

        if (forSign) {
            builder
                .algorithm(JWSAlgorithm.RS256)
                .keyUse(KeyUse.SIGNATURE);
        } else {
            builder
                .algorithm(JWEAlgorithm.RSA_OAEP_256)
                .keyUse(KeyUse.ENCRYPTION);
        }

        return builder.build();
    }
}</code></pre>
<h3>Kotlin</h3>
<pre><code class="language-kotlin">package io.github.susimsek.springbootjweauthjpademo.security

import com.nimbusds.jose.JWEAlgorithm
import com.nimbusds.jose.JWSAlgorithm
import com.nimbusds.jose.jwk.KeyUse
import com.nimbusds.jose.jwk.RSAKey
import java.security.KeyFactory
import java.security.interfaces.RSAPrivateKey
import java.security.interfaces.RSAPublicKey
import java.security.spec.PKCS8EncodedKeySpec
import java.security.spec.X509EncodedKeySpec
import java.util.Base64

object KeyUtils {
    @JvmStatic
    @Throws(Exception::class)
    fun buildRsaKey(
        pubPem: String,
        privPem: String,
        kid: String,
        forSign: Boolean
    ): RSAKey {
        val pubContent = pubPem
            .replace(&quot;-----BEGIN PUBLIC KEY-----&quot;, &quot;&quot;)
            .replace(&quot;-----END PUBLIC KEY-----&quot;, &quot;&quot;)
            .replace(Regex(&quot;\\s&quot;), &quot;&quot;)
        val privContent = privPem
            .replace(&quot;-----BEGIN PRIVATE KEY-----&quot;, &quot;&quot;)
            .replace(&quot;-----END PRIVATE KEY-----&quot;, &quot;&quot;)
            .replace(Regex(&quot;\\s&quot;), &quot;&quot;)

        val decodedPub = Base64.getDecoder().decode(pubContent)
        val decodedPriv = Base64.getDecoder().decode(privContent)

        val kf = KeyFactory.getInstance(&quot;RSA&quot;)
        val publicKey = kf.generatePublic(X509EncodedKeySpec(decodedPub)) as RSAPublicKey
        val privateKey = kf.generatePrivate(PKCS8EncodedKeySpec(decodedPriv)) as RSAPrivateKey

        val builder = RSAKey.Builder(publicKey)
            .privateKey(privateKey)
            .keyID(kid)

        if (forSign) {
            builder
                .algorithm(JWSAlgorithm.RS256)
                .keyUse(KeyUse.SIGNATURE)
        } else {
            builder
                .algorithm(JWEAlgorithm.RSA_OAEP_256)
                .keyUse(KeyUse.ENCRYPTION)
        }

        return builder.build()
    }
}</code></pre>
<h3>SecurityUtils</h3>
<h3>Java</h3>
<pre><code class="language-java">package io.github.susimsek.springbootjweauthjpademo.security;

import lombok.experimental.UtilityClass;
import org.springframework.security.core.Authentication;
import org.springframework.security.core.context.SecurityContextHolder;
import org.springframework.security.core.userdetails.UserDetails;
import org.springframework.security.oauth2.jwt.Jwt;

import java.util.Optional;

@UtilityClass
public class SecurityUtils {

    public static final String AUTHORITIES_KEY = &quot;auth&quot;;

    public Optional&lt;String&gt; getCurrentUserLogin() {
        var ctx = SecurityContextHolder.getContext();
        return Optional.ofNullable(extractPrincipal(ctx.getAuthentication()));
    }

    private String extractPrincipal(Authentication authentication) {
        if (authentication == null) {
            return null;
        }
        Object principal = authentication.getPrincipal();
        if (principal instanceof Jwt jwt) {
            return jwt.getSubject();
        }
        if (principal instanceof UserDetails ud) {
            return ud.getUsername();
        }
        if (principal instanceof String username) {
            return username;
        }
        return null;
    }
}</code></pre>
<h3>Kotlin</h3>
<pre><code class="language-kotlin">package io.github.susimsek.springbootjweauthjpademo.security

import org.springframework.security.core.Authentication
import org.springframework.security.core.context.SecurityContextHolder
import org.springframework.security.core.userdetails.UserDetails
import org.springframework.security.oauth2.jwt.Jwt
import java.util.Optional

object SecurityUtils {
  const val AUTHORITIES_KEY = &quot;auth&quot;

  fun getCurrentUserLogin(): Optional&lt;String&gt; {
    val authentication: Authentication? = SecurityContextHolder.getContext().authentication
    return Optional.ofNullable(extractPrincipal(authentication))
  }

  private fun extractPrincipal(authentication: Authentication?): String? {
    return when (val principal = authentication?.principal) {
      is Jwt -&gt; principal.subject
      is UserDetails -&gt; principal.username
      is String -&gt; principal
      else -&gt; null
    }
  }
}</code></pre>
<h3>DomainUserDetailsService</h3>
<h3>Java</h3>
<pre><code class="language-java">package io.github.susimsek.springbootjweauthjpademo.security;

import io.github.susimsek.springbootjweauthjpademo.entity.User;
import io.github.susimsek.springbootjweauthjpademo.repository.UserRepository;
import lombok.RequiredArgsConstructor;
import org.springframework.security.core.GrantedAuthority;
import org.springframework.security.core.authority.SimpleGrantedAuthority;
import org.springframework.security.core.userdetails.UserDetails;
import org.springframework.security.core.userdetails.UserDetailsService;
import org.springframework.security.core.userdetails.UsernameNotFoundException;

import java.util.List;
import java.util.stream.Collectors;

@RequiredArgsConstructor
public class DomainUserDetailsService implements UserDetailsService {

  private final UserRepository userRepository;

  @Override
  public UserDetails loadUserByUsername(String username) throws UsernameNotFoundException {
    User user = userRepository.findOneWithAuthoritiesByUsername(username)
      .orElseThrow(() -&gt; new UsernameNotFoundException(&quot;User not found with username: &quot; + username));

    List&lt;GrantedAuthority&gt; authorities = user.getAuthorities().stream()
      .map(mapping -&gt; mapping.getAuthority().getName())
      .map(SimpleGrantedAuthority::new)
      .collect(Collectors.toList());

    return new org.springframework.security.core.userdetails.User(
      user.getUsername(),
      user.getPassword(),
      user.isEnabled(),  // enabled
      true,              // accountNonExpired
      true,              // credentialsNonExpired
      true,              // accountNonLocked
      authorities
    );
  }
}</code></pre>
<h3>Kotlin</h3>
<pre><code class="language-kotlin">package io.github.susimsek.springbootjweauthjpademo.security

import io.github.susimsek.springbootjweauthjpademo.repository.UserRepository
import org.springframework.security.core.GrantedAuthority
import org.springframework.security.core.authority.SimpleGrantedAuthority
import org.springframework.security.core.userdetails.UserDetails
import org.springframework.security.core.userdetails.UserDetailsService
import org.springframework.security.core.userdetails.UsernameNotFoundException
import java.util.stream.Collectors

class DomainUserDetailsService(
  private val userRepository: UserRepository
) : UserDetailsService {
  override fun loadUserByUsername(username: String): UserDetails {
    val user = userRepository.findOneWithAuthoritiesByUsername(username)
      .orElseThrow { UsernameNotFoundException(&quot;User not found with username: $username&quot;) }

    val authorities: List&lt;GrantedAuthority&gt; = user.authorities.stream()
      .map { SimpleGrantedAuthority(it.authority.name) }
      .collect(Collectors.toList())

    return org.springframework.security.core.userdetails.User(
      user.username,
      user.password,
      user.enabled,
      true,
      true,
      true,
      authorities
    )
  }
}</code></pre>
<h3>SpringSecurityAuditorAware</h3>
<h3>Java</h3>
<pre><code class="language-java">package io.github.susimsek.springbootjweauthjpademo.security;

import org.springframework.data.domain.AuditorAware;
import org.springframework.lang.NonNull;
import org.springframework.stereotype.Component;

import java.util.Optional;

@Component
public class SpringSecurityAuditorAware implements AuditorAware&lt;String&gt; {

  @Override
  @NonNull
  public Optional&lt;String&gt; getCurrentAuditor() {
    return Optional.of(SecurityUtils.getCurrentUserLogin().orElse(&quot;system&quot;));
  }
}</code></pre>
<h3>Kotlin</h3>
<pre><code class="language-kotlin">package io.github.susimsek.springbootjweauthjpademo.security

import org.springframework.data.domain.AuditorAware
import org.springframework.lang.NonNull
import org.springframework.stereotype.Component

@Component
class SpringSecurityAuditorAware : AuditorAware&lt;String&gt; {
    @NonNull
    override fun getCurrentAuditor(): Optional&lt;String&gt; =
        Optional.of(SecurityUtils.getCurrentUserLogin().orElse(&quot;system&quot;))
}</code></pre>
<hr />
<h2>üõ†Ô∏è Step 6: Authentication &amp; Protected Endpoints</h2>
<p>In this section, we define the REST controllers and DTOs necessary for:</p>
<ul>
<li>AuthController: Authenticate users, issue JWE tokens, and set secure cookies.</li>
<li>HelloController: Expose protected resource endpoints for authenticated users and admin-specific paths.</li>
<li>LoginRequestDTO: Model the login request payload (username/password).</li>
<li>TokenDTO: Model the authentication response including token and expiration.</li>
</ul>
<p>These components complete the stateless authentication flow by handling login, token issuance, cookie management, and resource protection.</p>
<p>In this section, we expose REST controllers and DTOs to handle user authentication, token issuance, and protected resource access.</p>
<h3>AuthController</h3>
<h3>Java</h3>
<pre><code class="language-java">package io.github.susimsek.springbootjweauthjpademo.controller;

import io.github.susimsek.springbootjweauthjpademo.dto.LoginRequestDTO;
import io.github.susimsek.springbootjweauthjpademo.dto.TokenDTO;
import io.github.susimsek.springbootjweauthjpademo.security.CookieUtils;
import io.github.susimsek.springbootjweauthjpademo.security.JweUtil;
import lombok.RequiredArgsConstructor;
import org.springframework.http.HttpHeaders;
import org.springframework.http.ResponseCookie;
import org.springframework.http.ResponseEntity;
import org.springframework.security.authentication.AuthenticationManager;
import org.springframework.security.authentication.UsernamePasswordAuthenticationToken;
import org.springframework.security.core.Authentication;
import org.springframework.security.core.context.SecurityContextHolder;
import org.springframework.web.bind.annotation.PostMapping;
import org.springframework.web.bind.annotation.RequestBody;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;

@RestController
@RequiredArgsConstructor
@RequestMapping(&quot;/api/auth&quot;)
public class AuthController {

    private final AuthenticationManager authenticationManager;
    private final JweUtil jweUtil;

    @PostMapping(&quot;/login&quot;)
    public ResponseEntity&lt;TokenDTO&gt; login(@RequestBody LoginRequestDTO loginRequest) throws Exception {
        // Authenticate user
        var authToken = new UsernamePasswordAuthenticationToken(
            loginRequest.username(), loginRequest.password()
        );
        Authentication auth = authenticationManager.authenticate(authToken);
        SecurityContextHolder.getContext().setAuthentication(auth);

        // Generate JWE token and cookie
        TokenDTO tokenDto = jweUtil.generateToken(auth);
        ResponseCookie cookie = CookieUtils.createAccessTokenCookie(tokenDto);

        return ResponseEntity.ok()
            .header(HttpHeaders.SET_COOKIE, cookie.toString())
            .body(tokenDto);
    }
}</code></pre>
<h3>Kotlin</h3>
<pre><code class="language-kotlin">package io.github.susimsek.springbootjweauthjpademo.controller

import io.github.susimsek.springbootjweauthjpademo.dto.LoginRequestDTO
import io.github.susimsek.springbootjweauthjpademo.dto.TokenDTO
import io.github.susimsek.springbootjweauthjpademo.security.CookieUtils
import io.github.susimsek.springbootjweauthjpademo.security.JweUtil
import lombok.RequiredArgsConstructor
import org.springframework.http.HttpHeaders
import org.springframework.http.ResponseCookie
import org.springframework.http.ResponseEntity
import org.springframework.security.authentication.AuthenticationManager
import org.springframework.security.authentication.UsernamePasswordAuthenticationToken
import org.springframework.security.core.Authentication
import org.springframework.security.core.context.SecurityContextHolder
import org.springframework.web.bind.annotation.PostMapping
import org.springframework.web.bind.annotation.RequestBody
import org.springframework.web.bind.annotation.RequestMapping
import org.springframework.web.bind.annotation.RestController

@RestController
@RequiredArgsConstructor
@RequestMapping(&quot;/api/auth&quot;)
class AuthController(
    private val authenticationManager: AuthenticationManager,
    private val jweUtil: JweUtil
) {

    @PostMapping(&quot;/login&quot;)
    fun login(@RequestBody loginRequest: LoginRequestDTO): ResponseEntity&lt;TokenDTO&gt; {
        val authToken = UsernamePasswordAuthenticationToken(
            loginRequest.username, loginRequest.password
        )
        val auth: Authentication = authenticationManager.authenticate(authToken)
        SecurityContextHolder.getContext().authentication = auth

        val tokenDto: TokenDTO = jweUtil.generateToken(auth)
        val cookie: ResponseCookie = CookieUtils.createAccessTokenCookie(tokenDto)

        return ResponseEntity.ok()
            .header(HttpHeaders.SET_COOKIE, cookie.toString())
            .body(tokenDto)
    }
}</code></pre>
<h3>HelloController</h3>
<h3>Java</h3>
<pre><code class="language-java">package io.github.susimsek.springbootjweauthjpademo.controller;

import org.springframework.security.core.annotation.AuthenticationPrincipal;
import org.springframework.security.oauth2.jwt.Jwt;
import org.springframework.web.bind.annotation.*;

import static io.github.susimsek.springbootjweauthjpademo.security.SecurityUtils.AUTHORITIES_KEY;

@RestController
@RequestMapping(&quot;/api/hello&quot;)
public class HelloController {

    @GetMapping
    public String helloAll(@AuthenticationPrincipal Jwt jwt) {
        String user = jwt.getSubject();
        var roles = jwt.getClaimAsStringList(AUTHORITIES_KEY);
        return &quot;Hello, &quot; + user + &quot;! Your roles: &quot; + roles;
    }

    @GetMapping(&quot;/admin&quot;)
    public String helloAdmin(@AuthenticationPrincipal Jwt jwt) {
        return &quot;Hello Admin, &quot; + jwt.getSubject() + &quot;!&quot;;
    }
}</code></pre>
<h3>Kotlin</h3>
<pre><code class="language-kotlin">package io.github.susimsek.springbootjweauthjpademo.controller

import org.springframework.security.core.annotation.AuthenticationPrincipal
import org.springframework.security.oauth2.jwt.Jwt
import org.springframework.web.bind.annotation.*

import io.github.susimsek.springbootjweauthjpademo.security.SecurityUtils.AUTHORITIES_KEY

@RestController
@RequestMapping(&quot;/api/hello&quot;)
class HelloController {

    @GetMapping
    fun helloAll(@AuthenticationPrincipal jwt: Jwt): String {
        val user = jwt.subject
        val roles = jwt.getClaimAsStringList(AUTHORITIES_KEY)
        return &quot;Hello, \$user! Your roles: \$roles&quot;
    }

    @GetMapping(&quot;/admin&quot;)
    fun helloAdmin(@AuthenticationPrincipal jwt: Jwt): String {
        return &quot;Hello Admin, \${jwt.subject}!&quot;
    }
}</code></pre>
<h3>LoginRequestDTO</h3>
<h3>Java</h3>
<pre><code class="language-java">package io.github.susimsek.springbootjweauthjpademo.dto;

public record LoginRequestDTO(
    String username,
    String password
) { }</code></pre>
<h3>Kotlin</h3>
<pre><code class="language-kotlin">package io.github.susimsek.springbootjweauthjpademo.dto

data class LoginRequestDTO(
    val username: String,
    val password: String
)</code></pre>
<h3>TokenDTO</h3>
<h3>Java</h3>
<pre><code class="language-java">package io.github.susimsek.springbootjweauthjpademo.dto;

public record TokenDTO(
    String accessToken,
    String tokenType,
    long accessTokenExpiresIn
) {}</code></pre>
<h3>Kotlin</h3>
<pre><code class="language-kotlin">package io.github.susimsek.springbootjweauthjpademo.dto

import kotlin.Long

data class TokenDTO(
    val accessToken: String,
    val tokenType: String,
    val accessTokenExpiresIn: Long
)</code></pre>
<hr />
<h2>‚ñ∂Ô∏è Run the App</h2>
<pre><code class="language-bash">./mvnw spring-boot:run
# or
gradle bootRun</code></pre>
<hr />
<h2>üß™ Test Endpoints</h2>
<h3>Admin Flow</h3>
<p>Login as admin and capture the JWE token from the `Set-Cookie` header:</p>
<pre><code class="language-bash">curl -i -X POST http://localhost:8080/api/auth/login \
  -H &quot;Content-Type: application/json&quot; \
  -d &#39;{&quot;username&quot;:&quot;admin&quot;,&quot;password&quot;:&quot;adminpass&quot;}&#39;</code></pre>
<ul>
<li>Set-Cookie header contains `accessToken=&lt;jwe-token&gt;`</li>
<li>Response body:</li>
</ul>
<pre><code class="language-json">{
  &quot;accessToken&quot;: &quot;&lt;jwe-token&gt;&quot;,
  &quot;tokenType&quot;: &quot;Bearer&quot;,
  &quot;accessTokenExpiresIn&quot;: 3600
}</code></pre>
<p>Use cookie to access hello endpoint:</p>
<pre><code class="language-bash">curl -b &quot;accessToken=&lt;jwe-token&gt;&quot; http://localhost:8080/api/hello</code></pre>
<p>Use Authorization header instead:</p>
<pre><code class="language-bash">curl -H &quot;Authorization: Bearer &lt;jwe-token&gt;&quot; http://localhost:8080/api/hello</code></pre>
<p>Access admin-only endpoint:</p>
<pre><code class="language-bash">curl -H &quot;Authorization: Bearer &lt;jwe-token&gt;&quot; http://localhost:8080/api/hello/admin</code></pre>
<h3>User Flow</h3>
<p>Login as user and capture JWE token from cookie:</p>
<pre><code class="language-bash">curl -i -X POST http://localhost:8080/api/auth/login \
  -H &quot;Content-Type: application/json&quot; \
  -d &#39;{&quot;username&quot;:&quot;user&quot;,&quot;password&quot;:&quot;userpass&quot;}&#39;</code></pre>
<ul>
<li>Set-Cookie header contains `accessToken=&lt;jwe-token&gt;`</li>
</ul>
<p>Use cookie to access hello endpoint:</p>
<pre><code class="language-bash">curl -b &quot;accessToken=&lt;jwe-token&gt;&quot; http://localhost:8080/api/hello</code></pre>
<p>Use Authorization header:</p>
<pre><code class="language-bash">curl -H &quot;Authorization: Bearer &lt;jwe-token&gt;&quot; http://localhost:8080/api/hello</code></pre>
<p>Attempt admin endpoint (should be 403 Forbidden):</p>
<pre><code class="language-bash">curl -H &quot;Authorization: Bearer &lt;jwe-token&gt;&quot; http://localhost:8080/api/hello/admin
# HTTP/1.1 403 Forbidden</code></pre>
<hr />
<h2>üèÅ Conclusion</h2>
<p>This setup delivers a robust, production-ready Spring Boot JWE Authentication with JPA solution in Spring Boot, combining best practices, clear structure, and practical examples you can adapt to your own project.</p>]]></content:encoded>
      <category><![CDATA[Java]]></category>
      <category><![CDATA[Kotlin]]></category>
      <category><![CDATA[Spring Boot]]></category>
      <category><![CDATA[Security]]></category>
      <category><![CDATA[JWT]]></category>
      <category><![CDATA[JWE]]></category>
      <category><![CDATA[JPA]]></category>
      <category><![CDATA[Programming]]></category>
      <media:thumbnail url="https://suaybsimsek.com/images/spring-boot-jwe-auth-with-jpa-thumbnail.webp" />
    </item>
    <item>
      <title><![CDATA[Spring Boot LDAP and JWE Authentication]]></title>
      <link>https://suaybsimsek.com/en/posts/spring-boot-ldap-jwe-authentication</link>
      <description><![CDATA[Learn how to use LDAP authentication with JWE-encrypted JWTs to secure your Spring Boot APIs with both external directory integration and token confidentiality.]]></description>
      <pubDate>Sat, 10 May 2025 00:00:00 GMT</pubDate>
      <guid isPermaLink="true">https://suaybsimsek.com/en/posts/spring-boot-ldap-jwe-authentication</guid>
      <content:encoded><![CDATA[<p>Spring Boot lets you combine LDAP authentication with JWE-encrypted JWTs to secure your Spring Boot APIs with both external directory integration and token confidentiality.</p>
<hr />
<h2>üåü Why Combine LDAP &amp; JWE?</h2>
<ul>
<li>External Directory: Centralize user management with LDAP (e.g., corporate or embedded directory).</li>
<li>Integrity &amp; Confidentiality: Sign tokens (JWS) and encrypt payloads (JWE) for secure claims transport.</li>
<li>Standards-based: Leverage JOSE (JWS &amp; JWE) and Spring Security‚Äôs OAuth2 Resource Server.</li>
<li>Role-based Access: Map LDAP groups to `ROLE_USER` / `ROLE_ADMIN` automatically.</li>
</ul>
<hr />
<h2>üìã Prerequisites</h2>
<ul>
<li>‚òï Java Development Kit (JDK) 17 or higher</li>
<li>üì¶ Spring Boot 3.2+</li>
<li>üóÑÔ∏è LDAP (Embedded via Spring Boot or external)</li>
<li>üî§ IDE (IntelliJ IDEA, Eclipse)</li>
</ul>
<hr />
<h2>üõ†Ô∏è Step 1: Add Dependencies</h2>
<p>Include these in your `pom.xml` or `build.gradle` file.</p>
<p>Maven:</p>
<pre><code class="language-xml">&lt;dependency&gt;
  &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
  &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;
&lt;/dependency&gt;
&lt;dependency&gt;
  &lt;groupId&gt;org.springframework.security&lt;/groupId&gt;
  &lt;artifactId&gt;spring-security-oauth2-resource-server&lt;/artifactId&gt;
&lt;/dependency&gt;
&lt;dependency&gt;
  &lt;groupId&gt;org.springframework.security&lt;/groupId&gt;
  &lt;artifactId&gt;spring-security-ldap&lt;/artifactId&gt;
&lt;/dependency&gt;
&lt;dependency&gt;
  &lt;groupId&gt;com.unboundid&lt;/groupId&gt;
  &lt;artifactId&gt;unboundid-ldapsdk&lt;/artifactId&gt;
&lt;/dependency&gt;
&lt;dependency&gt;
  &lt;groupId&gt;org.projectlombok&lt;/groupId&gt;
  &lt;artifactId&gt;lombok&lt;/artifactId&gt;
  &lt;optional&gt;true&lt;/optional&gt;
&lt;/dependency&gt;</code></pre>
<p>Gradle:</p>
<pre><code class="language-groovy">implementation &#39;org.springframework.boot:spring-boot-starter-web&#39;
implementation &#39;org.springframework.security:spring-security-oauth2-resource-server&#39;
implementation &#39;org.springframework.security:spring-security-ldap&#39;
implementation &#39;com.unboundid:unboundid-ldapsdk&#39;
compileOnly &#39;org.projectlombok:lombok&#39;</code></pre>
<hr />
<h2>üõ†Ô∏è Step 2: LDAP and Keys Configuration</h2>
<p>Define your embedded LDAP directory, user/group structure, and RSA key properties in your `application.yml` and `schema.ldif`:</p>
<h3>application.yml</h3>
<pre><code class="language-yaml">spring:
  ldap:
    embedded:
      ldif: classpath:schema.ldif
      base-dn: dc=suaybsimsek,dc=com
      port: 8389
    urls: ldap://localhost:8389
    base: dc=suaybsimsek,dc=com
security:
  jwt:
    issuer: demo-issuer
    expiration-duration: 3600s
    signing:
      key-id: signing-key
      public-key: |-
        -----BEGIN PUBLIC KEY-----
        MIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEAjZEcz5itWkDGOSqZdB5P
        JE0ccOCckskp0hN3kQbT1qnv+9/k66jlWgVi4HSTppwdNF/Ylu5u541Qj+Okyg+u
        8o2PvKo5CfgvTDsFLTrZHUXU6hCSGatLAQoeN6lT8wzov2r4DFecXrIqcO6SvMB5
        ecPqsfiTi4trsNKgJ4cWS6gILH62ISd1ipUadfpnUzDMO1OulV0CJNV6bcBk7Es9
        RW6AHfg9j8osSanpwvRM4MJkB0SRxYUnrN9faGpkBZISZJ8TShhaTHEGfSNgKe5y
        8iu+AMGGZu8DYczVmqS3Ske1fq6y5HEGCma7Mo019GmwKeHBo1obuET6cZRygj4y
        twIDAQAB
        -----END PUBLIC KEY-----
      private-key: |-
        -----BEGIN PRIVATE KEY-----
        MIIEvAIBADANBgkqhkiG9w0BAQEFAASCBKYwggSiAgEAAoIBAQCNkRzPmK1aQMY5
        Kpl0Hk8kTRxw4JySySnSE3eRBtPWqe/73+TrqOVaBWLgdJOmnB00X9iW7m7njVCP
        46TKD67yjY+8qjkJ+C9MOwUtOtkdRdTqEJIZq0sBCh43qVPzDOi/avgMV5xesipw
        7pK8wHl5w+qx+JOLi2uw0qAnhxZLqAgsfrYhJ3WKlRp1+mdTMMw7U66VXQIk1Xpt
        wGTsSz1FboAd+D2PyixJqenC9EzgwmQHRJHFhSes319oamQFkhJknxNKGFpMcQZ9
        I2Ap7nLyK74AwYZm7wNhzNWapLdKR7V+rrLkcQYKZrsyjTX0abAp4cGjWhu4RPpx
        lHKCPjK3AgMBAAECggEABMo/sNCIMREXA/EqjxDFecN4LmOTOK5A0YBiH9Cc01sd
        qSaavtSQqhqbjV+0bUNEA7UohXbc3s3bx3qa5VFhiIh8sBQMaQdyRkCK/MxMc16d
        BSx5XQ/8MjVO73A1zHgH2g47BWPjgRrDL94KrgNPOO0FoG76QxL9GlcOHzhFa1rf
        xbb2auLBtflKy+5TZNnB/sbFC9ISpWywzfblD2Fsvxupl0vNWtA0Y2rPbKMZRnY+
        V6NC38yxW3HHAdWQRYLGOitM59I0HBgnjQKzTBNIsjPnJA2BSZvMBtQ1e3RQV0qE
        8VVoktZ8A0KDUxqdKWYlGYAY5hIw1y3UUsPRUbS3fQKBgQDAZehu+Kb5Sw+h00Qu
        vViNHDvi0PwmhQrHVpgjrppCnWsTk6FJFm+EBLY+87usXuRCnfZ1semb6P+yjLh2
        bJ9IXIrFAztcyE+7eZfn0H7mHA7E2ICKTjNdKbjy8kHViHpgdXREnAOrFTTk/BqW
        dq+weG2OuxYczWsY4XliWaVyiwKBgQC8XYExpSmoyI37o+jr9405k30tbGUw4X+/
        xYOvSUuafI8IOSLfKTpsvkMN3hxpJO6apIRAjOALbotKUA5FrHQPenuBWOr3mBJT
        euLiaWphqU8YN5dbNd+JhC/Jh5DLhY5FpB2Fv2MKSoF7+onpjDy9pEU5aReeBB0v
        ekUw4nWiBQKBgHxyrnjxP1frFG5xMB4nfZqw04+v7BmiXsl3mqsh6kgCeNtN17pl
        17YGMjfgAdnJ+02XzW5tqRSfDp3YZgy7z//HVD+BCqnGK8SxLu/ULfD73xW2kNZl
        JNYzAZ2r06eiQr4X2x/x5nGIIxGmfDAtDxFPpFX5b6ErwgVy+sgCAoFnAoGAWSpu
        EMEdQk+FnnwNsz2g9YNSuyDXmdb08SOfXWd1yXBzCLJ7RmYuyPEbrsHYcxFPfZap
        ICFPoTm35/qTdvnWiskxE56yw3eSHUBLjF/YQtixn0YZeMy8v0z6jgyFR0I2gdLZ
        QsnBKUrxlm2XwR1oV2Eef7m2u085PZNEk4pvor0CgYA6n060r48/CgRVslAeGder
        fZ3n+2ru8q2UVB38evepjLifn5+tKdFzZ7/NckXMC0NOVzm74qG46VFLMw5TtyT4
        /hRvGSYxA6dMjXy+tcrAns9Isrz2PnYFntlbhU6hw0um809tFunbvITfyeOjAsDW
        stC4thnhzXXT1Y3RfFtYEg==
        -----END PRIVATE KEY-----
    encryption:
      key-id: encryption-key
      public-key: |-
        -----BEGIN PUBLIC KEY-----
        MIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEAtU7Vu4tML8qg9BISaUH0
        BTU0+qkHJS3TUl3R0hEPttZJGf8EgT7bpWqRjdhMC2SYt2ifNF82EgMo/eva1rLn
        wYtCsxjJ7oB4U2m16/JKHtphmMUGhSLgbp+Y8pGAQ+P6u4HLlI0qbL92Syb6QCTr
        nYIlzZ2uUAvUQg/SbuAvdS4kdauZtpMNbhryusMVvILVBC5yUhfLJAkjbU3qWo/n
        2NKPr4kjwwFh6FaAf0HLsXCFmJbPPok6WMZeDqPORPZCt5gU2t04fS7s/2SSbhQ/
        i+7yyT4pl44cUlNLLN3Qo73sai5H90q7Dvmk3M5/YMJB0Ueyb705LHyOO5xA618s
        qQIDAQAB
        -----END PUBLIC KEY-----
      private-key: |-
        -----BEGIN PRIVATE KEY-----
        MIIEvgIBADANBgkqhkiG9w0BAQEFAASCBKgwggSkAgEAAoIBAQC1TtW7i0wvyqD0
        EhJpQfQFNTT6qQclLdNSXdHSEQ+21kkZ/wSBPtulapGN2EwLZJi3aJ80XzYSAyj9
        69rWsufBi0KzGMnugHhTabXr8koe2mGYxQaFIuBun5jykYBD4/q7gcuUjSpsv3ZL
        JvpAJOudgiXNna5QC9RCD9Ju4C91LiR1q5m2kw1uGvK6wxW8gtUELnJSF8skCSNt
        Tepaj+fY0o+viSPDAWHoVoB/QcuxcIWYls8+iTpYxl4Oo85E9kK3mBTa3Th9Luz/
        ZJJuFD+L7vLJPimXjhxSU0ss3dCjvexqLkf3SrsO+aTczn9gwkHRR7JvvTksfI47
        nEDrXyypAgMBAAECggEAREnJHrY8n9OGA+e6n4KD0mJT7gUz98Dm0yMbIC/k50yW
        hAAVRkjSmd8lq3NIURI2ov342NTznJ0sF1d6OVtxBujY2nP/uqEQsPoj1xaO7Ef8
        cnnjFsooFgJurQ44bVm02mLstqrky8jhWTT5FKfTRqP6cRNu0B9kdu1WqQQvW8a/
        C8xD8XUFzzJFQsEstJ076NjlZNH3EeqFiLxyVdV7tPEJRnOe2V2BAAgda3ByA6Jc
        Nd4xYHTVr5rZ+KES9gaAgb86+S7hNigsxz5Gp58NimLEyz1Qd+d9QCgPRgKOV5Uq
        0ci6c28ZrxW9wa/2CGCpoow1V7hRy1fZ24g2Tz91cQKBgQDbSdP/FQYuem0pUf8u
        mA/niEC8Jz30FW3ix5aqbQ8YRudK48Xy8F7AWnlS0wT2k/Xaeppn9YSPK4HlsNk2
        1gnpNfzdqXpJQtuxcPPeFNzUdXzBrsLXYqtlhOX/afrzqMhp73gkqoxXtqwD7BqN
        VfMcVXsWrEZQrRPBn/RUnnLdJwKBgQDTqUGupm93UlhoPgLXHGF/seQwPPHcU6lS
        SS9l512Ie21B+vZecgO4r77BXJwbY4rZVA5/m+wrsNmsT2f8yfdbs84cBDDWiKy5
        t2Um8zrus+BCIffxc9Fck9/htK33jLLcYwdSAm3a9pJxR9f/kAdredSTGBNJ3W/2
        rfh3cdNprwKBgDi7WfBFRSsjGzi0cPth9cNlubGzyVBrdtlT34PJ4Tzboxz53o1i
        aHEFNxwZYdBVKSbTzzyUBS5xCBMfdKK+LyQ5hmjmXq+zb1jxqvXKmfMRTixhhSDp
        8wO5pTM1/Omqwea+QGvj/5j1tnzxSVFFajbrWoPcH/jhPho6wqBducPDAoGBALOJ
        MEOavZXy7TaO0w3v7uvH0wzvxR/kfw1jMqc3l2j7ePOskmoOQAXaXO3bRjcdOlua
        Jyoq8islOZ4lRMlx7zWD0OKG035GNGzbmRtu2aA8R48RDSVr3jyu2gqznZULbXPv
        M/hmQxSmbhVUoW0PmJubnaqfk0zmXeBaNRXsIS3VAoGBALdsAtqR23PVeL6sYj2l
        dRNTDXpfvjFqJ5NThRO/4mT0CrPHQVj+Mz2bTc/Dxiwi8s8m3L+g23i3hodh/QMb
        Iz+UbcJZBGAKsFbPKGOtj6Bi07y/L11mcuNJzOWe61/JbVmJss0s+N/v3XucK/Ge
        CUaGOccsMO221v6JoBh9J3Hz
        -----END PRIVATE KEY-----</code></pre>
<h3>LDAP Schema (schema.ldif)</h3>
<pre><code class="language-ldif"># 1) Root DN
 dn: dc=suaybsimsek,dc=com
 objectClass: top
 objectClass: domain
 objectClass: extensibleObject
 dc: suaybsimsek

# 2) People OU
 dn: ou=people,dc=suaybsimsek,dc=com
 objectClass: top
 objectClass: organizationalUnit
 ou: people

# 3) Admin user
 dn: uid=admin,ou=people,dc=suaybsimsek,dc=com
 objectClass: top
 objectClass: person
 objectClass: inetOrgPerson
 cn: Admin User
 sn: User
 uid: admin
 userPassword: $2a$10$sva6wl8pmGKJE6NIWrxwcuJK1Jaa2I/LOI43iHVpbR4YB8KjGViiK

# 4) Normal user
 dn: uid=user,ou=people,dc=suaybsimsek,dc=com
 objectClass: top
 objectClass: person
 objectClass: inetOrgPerson
 cn: Normal User
 sn: User
 uid: user
 userPassword: $2a$10$5Py4PyteLuXEqnGpSigzfu0V55C7Hi7zX18lmh.J8Bpmft.h23voG

# 5) Groups OU
 dn: ou=groups,dc=suaybsimsek,dc=com
 objectClass: top
 objectClass: organizationalUnit
 ou: groups

# 6) USER group ‚Üí maps to ROLE_USER
 dn: cn=USER,ou=groups,dc=suaybsimsek,dc=com
 objectClass: top
 objectClass: groupOfUniqueNames
 cn: USER
 uniqueMember: uid=user,ou=people,dc=suaybsimsek,dc=com
 uniqueMember: uid=admin,ou=people,dc=suaybsimsek,dc=com

# 7) ADMIN group ‚Üí maps to ROLE_ADMIN
 dn: cn=ADMIN,ou=groups,dc=suaybsimsek,dc=com
 objectClass: top
 objectClass: groupOfUniqueNames
 cn: ADMIN
 uniqueMember: uid=admin,ou=people,dc=suaybsimsek,dc=com</code></pre>
<p>This combined configuration ensures your application boots an embedded LDAP server with the defined schema, and loads RSA keys for JWE signing and encryption. You can now proceed to configure Spring Security to use LDAP for authentication and JWE for token issuance.</p>
<hr />
<h2>üõ†Ô∏è Step 3: Security Configuration</h2>
<p>In this section, we define the beans and properties configure LDAP authentication, set up RSA keys, and enforce HTTP security filters for a JWE-based authentication:</p>
<ul>
<li>JwtProperties: Configures JWT issuer, expiration, and signing/encryption key pairs.</li>
<li>SecurityJwtConfig: Builds RSA JWKs, JWT encoder/decoder, authentication converter, and token resolver.</li>
<li>SecurityConfig: Defines embedded LDAP authentication, JWE resource server, and stateless security filter chain with route authorization.</li>
</ul>
<h3>SecurityJwtConfig</h3>
<h3>Java</h3>
<pre><code class="language-java">package io.github.susimsek.springbootldapjwedemo.config;

import com.nimbusds.jose.EncryptionMethod;
import com.nimbusds.jose.JWEAlgorithm;
import com.nimbusds.jose.JWSAlgorithm;
import com.nimbusds.jose.jwk.JWKSet;
import com.nimbusds.jose.jwk.RSAKey;
import com.nimbusds.jose.jwk.source.JWKSource;
import com.nimbusds.jose.proc.JWEDecryptionKeySelector;
import com.nimbusds.jose.proc.JWSVerificationKeySelector;
import com.nimbusds.jose.proc.SecurityContext;
import com.nimbusds.jwt.proc.DefaultJWTProcessor;
import io.github.susimsek.springbootldapjwedemo.security.CookieBearerTokenResolver;
import io.github.susimsek.springbootldapjwedemo.security.KeyUtils;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.security.oauth2.jwt.JwtDecoder;
import org.springframework.security.oauth2.jwt.JwtEncoder;
import org.springframework.security.oauth2.jwt.NimbusJwtDecoder;
import org.springframework.security.oauth2.jwt.NimbusJwtEncoder;
import org.springframework.security.oauth2.server.resource.authentication.JwtAuthenticationConverter;
import org.springframework.security.oauth2.server.resource.authentication.JwtGrantedAuthoritiesConverter;
import org.springframework.security.oauth2.server.resource.web.BearerTokenResolver;

import java.util.List;

import static io.github.susimsek.springbootldapjwedemo.security.SecurityUtils.AUTHORITIES_KEY;

@Configuration
public class SecurityJwtConfig {

    private final JwtProperties props;
    public SecurityJwtConfig(JwtProperties props) { this.props = props; }

    @Bean
    public RSAKey signingKey() throws Exception {
        return KeyUtils.buildRsaKey(
            props.getSigning().getPublicKey(),
            props.getSigning().getPrivateKey(),
            props.getSigning().getKeyId(),
            true
        );
    }

    @Bean
    public RSAKey encryptionKey() throws Exception {
        return KeyUtils.buildRsaKey(
            props.getEncryption().getPublicKey(),
            props.getEncryption().getPrivateKey(),
            props.getEncryption().getKeyId(),
            false
        );
    }

    @Bean
    public JWKSource&lt;SecurityContext&gt; jwkSource(RSAKey signingKey, RSAKey encryptionKey) {
        JWKSet jwkSet = new JWKSet(List.of(
            signingKey,
            encryptionKey
        ));
        return (jwkSelector, context) -&gt; jwkSelector.select(jwkSet);
    }

    @Bean
    public JwtDecoder jwtDecoder(JWKSource&lt;SecurityContext&gt; jwkSource) {
        DefaultJWTProcessor&lt;SecurityContext&gt; jwtProcessor = new DefaultJWTProcessor&lt;&gt;();
        JWEDecryptionKeySelector&lt;SecurityContext&gt; jweKeySelector =
            new JWEDecryptionKeySelector&lt;&gt;(
                JWEAlgorithm.RSA_OAEP_256,
                EncryptionMethod.A128GCM,
                jwkSource
            );
        jwtProcessor.setJWEKeySelector(jweKeySelector);

        JWSVerificationKeySelector&lt;SecurityContext&gt; jwsKeySelector =
            new JWSVerificationKeySelector&lt;&gt;(
                JWSAlgorithm.RS256,
                jwkSource
            );
        jwtProcessor.setJWSKeySelector(jwsKeySelector);
        jwtProcessor.setJWTClaimsSetVerifier((claims, context) -&gt; {});

        return new NimbusJwtDecoder(jwtProcessor);
    }

    @Bean
    public JwtEncoder jwtEncoder(JWKSource&lt;SecurityContext&gt; jwkSource) {
        return new NimbusJwtEncoder(jwkSource);
    }

    @Bean
    public JwtAuthenticationConverter jwtAuthenticationConverter() {
        JwtGrantedAuthoritiesConverter converter = new JwtGrantedAuthoritiesConverter();
        converter.setAuthorityPrefix(&quot;&quot;);
        converter.setAuthoritiesClaimName(AUTHORITIES_KEY);

        JwtAuthenticationConverter authConverter = new JwtAuthenticationConverter();
        authConverter.setJwtGrantedAuthoritiesConverter(converter);
        return authConverter;
    }

    @Bean
    public BearerTokenResolver bearerTokenResolver() {
        CookieBearerTokenResolver resolver = new CookieBearerTokenResolver();
        resolver.setAllowUriQueryParameter(false);
        resolver.setAllowFormEncodedBodyParameter(false);
        resolver.setAllowCookie(true);
        return resolver;
    }
}</code></pre>
<h3>Kotlin</h3>
<pre><code class="language-kotlin">package io.github.susimsek.springbootldapjwedemo.config

import com.nimbusds.jose.EncryptionMethod
import com.nimbusds.jose.JWEAlgorithm
import com.nimbusds.jose.JWSAlgorithm
import com.nimbusds.jose.jwk.JWKSet
import com.nimbusds.jose.jwk.RSAKey
import com.nimbusds.jose.jwk.source.JWKSource
import com.nimbusds.jose.proc.JWEDecryptionKeySelector
import com.nimbusds.jose.proc.JWSVerificationKeySelector
import com.nimbusds.jose.proc.SecurityContext
import com.nimbusds.jwt.proc.DefaultJWTProcessor
import io.github.susimsek.springbootldapjwedemo.security.CookieBearerTokenResolver
import io.github.susimsek.springbootldapjwedemo.security.KeyUtils
import org.springframework.context.annotation.Bean
import org.springframework.context.annotation.Configuration
import org.springframework.security.oauth2.jwt.JwtDecoder
import org.springframework.security.oauth2.jwt.JwtEncoder
import org.springframework.security.oauth2.jwt.NimbusJwtDecoder
import org.springframework.security.oauth2.jwt.NimbusJwtEncoder
import org.springframework.security.oauth2.server.resource.authentication.JwtAuthenticationConverter
import org.springframework.security.oauth2.server.resource.authentication.JwtGrantedAuthoritiesConverter
import org.springframework.security.oauth2.server.resource.web.BearerTokenResolver

@Configuration
class SecurityJwtConfig(private val props: JwtProperties) {

    @Bean
    @Throws(Exception::class)
    fun signingKey(): RSAKey =
        KeyUtils.buildRsaKey(
            props.signing.publicKey,
            props.signing.privateKey,
            props.signing.keyId,
            true
        )

    @Bean
    @Throws(Exception::class)
    fun encryptionKey(): RSAKey =
        KeyUtils.buildRsaKey(
            props.encryption.publicKey,
            props.encryption.privateKey,
            props.encryption.keyId,
            false
        )

    @Bean
    fun jwkSource(signingKey: RSAKey, encryptionKey: RSAKey): JWKSource&lt;SecurityContext&gt; {
        val jwkSet = JWKSet(listOf(signingKey, encryptionKey))
        return JWKSource { jwkSelector, context -&gt; jwkSelector.select(jwkSet) }
    }

    @Bean
    fun jwtDecoder(jwkSource: JWKSource&lt;SecurityContext&gt;): JwtDecoder {
        val jwtProcessor = DefaultJWTProcessor&lt;SecurityContext&gt;()
        val jweKeySelector = JWEDecryptionKeySelector(
            JWEAlgorithm.RSA_OAEP_256,
            EncryptionMethod.A128GCM,
            jwkSource
        )
        jwtProcessor.jweKeySelector = jweKeySelector
        val jwsKeySelector = JWSVerificationKeySelector(
            JWSAlgorithm.RS256,
            jwkSource
        )
        jwtProcessor.jwsKeySelector = jwsKeySelector
        jwtProcessor.jwtClaimsSetVerifier = { _, _ -&gt; }
        return NimbusJwtDecoder(jwtProcessor)
    }

    @Bean
    fun jwtEncoder(jwkSource: JWKSource&lt;SecurityContext&gt;): JwtEncoder =
        NimbusJwtEncoder(jwkSource)

    @Bean
    fun jwtAuthenticationConverter(): JwtAuthenticationConverter {
        val converter = JwtGrantedAuthoritiesConverter().apply {
            setAuthorityPrefix(&quot;&quot;)
            setAuthoritiesClaimName(AUTHORITIES_KEY)
        }
        return JwtAuthenticationConverter().apply {
            setJwtGrantedAuthoritiesConverter(converter)
        }
    }

    @Bean
    fun bearerTokenResolver(): BearerTokenResolver =
        CookieBearerTokenResolver().apply {
            setAllowUriQueryParameter(false)
            setAllowFormEncodedBodyParameter(false)
            setAllowCookie(true)
        }
}</code></pre>
<h3>SecurityConfig</h3>
<h3>Java</h3>
<pre><code class="language-java">package io.github.susimsek.springbootldapjwedemo.config;

import io.github.susimsek.springbootldapjwedemo.security.AuthoritiesConstants;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.ldap.core.support.BaseLdapPathContextSource;
import org.springframework.security.authentication.AuthenticationManager;
import org.springframework.security.config.annotation.method.configuration.EnableMethodSecurity;
import org.springframework.security.config.annotation.web.builders.HttpSecurity;
import org.springframework.security.config.annotation.web.configurers.AbstractHttpConfigurer;
import org.springframework.security.config.http.SessionCreationPolicy;
import org.springframework.security.config.ldap.LdapPasswordComparisonAuthenticationManagerFactory;
import org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder;
import org.springframework.security.crypto.password.PasswordEncoder;
import org.springframework.security.ldap.userdetails.DefaultLdapAuthoritiesPopulator;
import org.springframework.security.ldap.userdetails.LdapAuthoritiesPopulator;
import org.springframework.security.web.SecurityFilterChain;
import org.springframework.security.web.servlet.util.matcher.MvcRequestMatcher;
import org.springframework.web.servlet.handler.HandlerMappingIntrospector;

import static org.springframework.security.config.Customizer.withDefaults;

@Configuration
@EnableMethodSecurity(securedEnabled = true)
public class SecurityConfig {

  @Bean
  public SecurityFilterChain securityFilterChain(HttpSecurity http,
                                                 MvcRequestMatcher.Builder mvc) throws Exception {
    http
      .cors(withDefaults())
      .csrf(AbstractHttpConfigurer::disable)
      .authorizeHttpRequests(authz -&gt;
        authz
          .requestMatchers(
            mvc.pattern(&quot;/webjars/**&quot;),
            mvc.pattern(&quot;/css/**&quot;),
            mvc.pattern(&quot;/js/**&quot;)
          ).permitAll()
          .requestMatchers(
            mvc.pattern(&quot;/*.ico&quot;),
            mvc.pattern(&quot;/*.png&quot;),
            mvc.pattern(&quot;/*.svg&quot;),
            mvc.pattern(&quot;/*.webapp&quot;)
          ).permitAll()
          .requestMatchers(&quot;/actuator/**&quot;).permitAll()
          .requestMatchers(
            &quot;/v3/api-docs/**&quot;,
            &quot;/swagger-ui.html&quot;,
            &quot;/swagger-ui/**&quot;
          ).permitAll()
          .requestMatchers(mvc.pattern(&quot;/api/auth/login&quot;)).permitAll()
          .requestMatchers(mvc.pattern(&quot;/api/hello/admin&quot;))
          .hasAuthority(AuthoritiesConstants.ADMIN)
          .anyRequest().authenticated()
      )
      .sessionManagement(session -&gt;
        session.sessionCreationPolicy(SessionCreationPolicy.STATELESS))
      .oauth2ResourceServer(oauth2 -&gt; oauth2
        .jwt(withDefaults())
      );
    return http.build();
  }

  @Bean
  public PasswordEncoder passwordEncoder() {
    return new BCryptPasswordEncoder();
  }

  @Bean
  public LdapAuthoritiesPopulator authorities(BaseLdapPathContextSource contextSource) {
    DefaultLdapAuthoritiesPopulator populator =
      new DefaultLdapAuthoritiesPopulator(contextSource, &quot;ou=groups&quot;);
    populator.setGroupSearchFilter(&quot;uniqueMember={0}&quot;);
    populator.setGroupRoleAttribute(&quot;cn&quot;);
    populator.setRolePrefix(&quot;ROLE_&quot;);
    return populator;
  }

  @Bean
  public AuthenticationManager authenticationManager(
    BaseLdapPathContextSource contextSource,
    PasswordEncoder passwordEncoder,
    LdapAuthoritiesPopulator authorities
  ) {
    LdapPasswordComparisonAuthenticationManagerFactory factory =
      new LdapPasswordComparisonAuthenticationManagerFactory(contextSource, passwordEncoder);
    factory.setUserDnPatterns(&quot;uid={0},ou=people&quot;);
    factory.setPasswordAttribute(&quot;userPassword&quot;);
    factory.setLdapAuthoritiesPopulator(authorities);
    return factory.createAuthenticationManager();
  }

  @Bean
  public MvcRequestMatcher.Builder mvc(HandlerMappingIntrospector introspector) {
    return new MvcRequestMatcher.Builder(introspector);
  }
}</code></pre>
<h3>Kotlin</h3>
<pre><code class="language-kotlin">package io.github.susimsek.springbootldapjwedemo.config

import io.github.susimsek.springbootldapjwedemo.security.AuthoritiesConstants
import org.springframework.context.annotation.Bean
import org.springframework.context.annotation.Configuration
import org.springframework.ldap.core.support.BaseLdapPathContextSource
import org.springframework.security.authentication.AuthenticationManager
import org.springframework.security.config.annotation.method.configuration.EnableMethodSecurity
import org.springframework.security.config.annotation.web.builders.HttpSecurity
import org.springframework.security.config.annotation.web.configurers.AbstractHttpConfigurer
import org.springframework.security.config.http.SessionCreationPolicy
import org.springframework.security.config.ldap.LdapPasswordComparisonAuthenticationManagerFactory
import org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder
import org.springframework.security.crypto.password.PasswordEncoder
import org.springframework.security.ldap.userdetails.DefaultLdapAuthoritiesPopulator
import org.springframework.security.ldap.userdetails.LdapAuthoritiesPopulator
import org.springframework.security.web.SecurityFilterChain
import org.springframework.security.web.servlet.util.matcher.MvcRequestMatcher
import org.springframework.web.servlet.handler.HandlerMappingIntrospector
import org.springframework.security.config.Customizer.withDefaults

@Configuration
@EnableMethodSecurity(securedEnabled = true)
class SecurityConfig {

  @Bean
  fun securityFilterChain(
    http: HttpSecurity,
    mvc: MvcRequestMatcher.Builder
  ): SecurityFilterChain = http
    .cors(withDefaults())
    .csrf { it.disable() }
    .authorizeHttpRequests { authz -&gt;
      authz
        .requestMatchers(
          mvc.pattern(&quot;/webjars/**&quot;),
          mvc.pattern(&quot;/css/**&quot;),
          mvc.pattern(&quot;/js/**&quot;)
        ).permitAll()
        .requestMatchers(
          mvc.pattern(&quot;/*.ico&quot;),
          mvc.pattern(&quot;/*.png&quot;),
          mvc.pattern(&quot;/*.svg&quot;),
          mvc.pattern(&quot;/*.webapp&quot;)
        ).permitAll()
        .requestMatchers(&quot;/actuator/**&quot;).permitAll()
        .requestMatchers(&quot;/v3/api-docs/**&quot;, &quot;/swagger-ui.html&quot;, &quot;/swagger-ui/**&quot;)
        .permitAll()
        .requestMatchers(mvc.pattern(&quot;/api/auth/login&quot;)).permitAll()
        .requestMatchers(mvc.pattern(&quot;/api/hello/admin&quot;))
        .hasAuthority(AuthoritiesConstants.ADMIN)
        .anyRequest().authenticated()
    }
    .sessionManagement { it.sessionCreationPolicy(SessionCreationPolicy.STATELESS) }
    .oauth2ResourceServer { it.jwt(withDefaults()) }
    .build()

  @Bean
  fun passwordEncoder(): PasswordEncoder = BCryptPasswordEncoder()

  @Bean
  fun authorities(contextSource: BaseLdapPathContextSource): LdapAuthoritiesPopulator {
    return DefaultLdapAuthoritiesPopulator(contextSource, &quot;ou=groups&quot;).apply {
      setGroupSearchFilter(&quot;uniqueMember={0}&quot;)
      setGroupRoleAttribute(&quot;cn&quot;)
      setRolePrefix(&quot;ROLE_&quot;)
    }
  }

  @Bean
  fun authenticationManager(
    contextSource: BaseLdapPathContextSource,
    passwordEncoder: PasswordEncoder,
    authorities: LdapAuthoritiesPopulator
  ): AuthenticationManager {
    return LdapPasswordComparisonAuthenticationManagerFactory(contextSource, passwordEncoder).apply {
      setUserDnPatterns(&quot;uid={0},ou=people&quot;)
      setPasswordAttribute(&quot;userPassword&quot;)
      setLdapAuthoritiesPopulator(authorities)
    }.createAuthenticationManager()
  }

  @Bean
  fun mvc(introspector: HandlerMappingIntrospector): MvcRequestMatcher.Builder =
    MvcRequestMatcher.Builder(introspector)
}</code></pre>
<h3>JwtProperties</h3>
<h3>Java</h3>
<pre><code class="language-java">package io.github.susimsek.springbootldapjwedemo.config;

import lombok.Data;
import org.springframework.boot.context.properties.ConfigurationProperties;
import org.springframework.context.annotation.Configuration;

import java.time.Duration;

@Configuration
@ConfigurationProperties(prefix = &quot;security.jwt&quot;)
@Data
public class JwtProperties {

    @Data
    public static class Pair {
        private String publicKey;
        private String privateKey;
        private String keyId;
    }

    private Pair signing;
    private Pair encryption;
    private String issuer;
    private Duration expirationDuration;
}</code></pre>
<h3>Kotlin</h3>
<pre><code class="language-kotlin">package io.github.susimsek.springbootldapjwedemo.config

import org.springframework.boot.context.properties.ConfigurationProperties
import org.springframework.context.annotation.Configuration
import java.time.Duration

@Configuration
@ConfigurationProperties(prefix = &quot;security.jwt&quot;)
class JwtProperties {

  class Pair {
    lateinit var publicKey: String
    lateinit var privateKey: String
    lateinit var keyId: String
  }

  lateinit var signing: Pair
  lateinit var encryption: Pair
  lateinit var issuer: String
  lateinit var expirationDuration: Duration
}</code></pre>
<hr />
<h2>üõ†Ô∏è Step 4: Secure JWE Token Utilities</h2>
<p>In this section, we define the core utility classes and constants needed to generate, encrypt, and resolve JSON Web Encryption (JWE) tokens in your Spring Boot application. These components work together to:</p>
<ul>
<li>AuthoritiesConstants: Centralize role names with the `ROLE_` prefix.</li>
<li>CookieBearerTokenResolver: Resolve bearer tokens from Authorization headers or HTTP cookies.</li>
<li>CookieUtils: Create HTTP-only, secure cookies for access tokens.</li>
<li>JweUtil: Sign (JWS) and encrypt (JWE) JWTs using RSA keys and Nimbus.</li>
<li>KeyUtils: Build RSA JWKs from PEM‚Äêencoded key material.</li>
<li>SecurityUtils: Extract the current user‚Äôs login from the security context.</li>
</ul>
<p>These utilities form the foundation for a stateless, JWE‚Äêbased authentication flow in Spring Security.</p>
<h3>AuthoritiesConstants</h3>
<h3>Java</h3>
<pre><code class="language-java">
package io.github.susimsek.springbootldapjwedemo.security;

import lombok.AccessLevel;
import lombok.NoArgsConstructor;

@NoArgsConstructor(access = AccessLevel.PRIVATE)
public final class AuthoritiesConstants {
    public static final String ADMIN = &quot;ROLE_ADMIN&quot;;
    public static final String USER = &quot;ROLE_USER&quot;;
    public static final String ANONYMOUS = &quot;ROLE_ANONYMOUS&quot;;
}</code></pre>
<h3>Kotlin</h3>
<pre><code class="language-kotlin">
package io.github.susimsek.springbootldapjwedemo.security

object AuthoritiesConstants {
  const val ADMIN = &quot;ROLE_ADMIN&quot;
  const val USER = &quot;ROLE_USER&quot;
  const val ANONYMOUS = &quot;ROLE_ANONYMOUS&quot;
}</code></pre>
<h3>CookieBearerTokenResolver</h3>
<h3>Java</h3>
<pre><code class="language-java">package io.github.susimsek.springbootldapjwedemo.security;

import jakarta.servlet.http.Cookie;
import jakarta.servlet.http.HttpServletRequest;
import lombok.Setter;
import org.springframework.http.HttpMethod;
import org.springframework.security.oauth2.core.OAuth2AuthenticationException;
import org.springframework.security.oauth2.server.resource.BearerTokenError;
import org.springframework.security.oauth2.server.resource.BearerTokenErrors;
import org.springframework.security.oauth2.server.resource.web.BearerTokenResolver;
import org.springframework.util.StringUtils;

import java.util.regex.Matcher;
import java.util.regex.Pattern;

@Setter
public class CookieBearerTokenResolver implements BearerTokenResolver {
    private static final String ACCESS_TOKEN_PARAMETER_NAME = &quot;access_token&quot;;
    private static final Pattern AUTHORIZATION_PATTERN =
        Pattern.compile(&quot;^Bearer (?&lt;token&gt;[A-Za-z0-9-._~+/]+=*)$&quot;, Pattern.CASE_INSENSITIVE);

    private boolean allowFormEncodedBodyParameter = false;
    private boolean allowUriQueryParameter       = false;
    private boolean allowCookie                  = true;
    private String  bearerTokenHeaderName       = &quot;Authorization&quot;;
    private String  cookieName                  = &quot;accessToken&quot;;

    @Override
    public String resolve(HttpServletRequest request) {
        String headerToken = resolveFromAuthorizationHeader(request);
        String queryToken  = resolveAccessTokenFromQueryString(request);
        String bodyToken   = resolveAccessTokenFromBody(request);
        String cookieToken = (headerToken == null &amp;&amp; queryToken == null &amp;&amp; bodyToken == null)
            ? resolveFromCookie(request)
            : null;

        return resolveToken(headerToken, queryToken, bodyToken, cookieToken);
    }

    private String resolveFromAuthorizationHeader(HttpServletRequest request) {
        String authorization = request.getHeader(this.bearerTokenHeaderName);
        if (!StringUtils.hasText(authorization) || !authorization.toLowerCase().startsWith(&quot;bearer&quot;)) {
            return null;
        }
        Matcher matcher = AUTHORIZATION_PATTERN.matcher(authorization.trim());
        if (!matcher.matches()) {
            BearerTokenError error = BearerTokenErrors.invalidToken(&quot;Bearer token is malformed&quot;);
            throw new OAuth2AuthenticationException(error);
        }
        return matcher.group(&quot;token&quot;);
    }

    private String resolveAccessTokenFromQueryString(HttpServletRequest request) {
        if (allowUriQueryParameter &amp;&amp; HttpMethod.GET.matches(request.getMethod())) {
            return resolveToken(request.getParameterValues(ACCESS_TOKEN_PARAMETER_NAME));
        }
        return null;
    }

    private String resolveAccessTokenFromBody(HttpServletRequest request) {
        if (allowFormEncodedBodyParameter
            &amp;&amp; HttpMethod.POST.matches(request.getMethod())
            &amp;&amp; &quot;application/x-www-form-urlencoded&quot;.equals(request.getContentType())) {
            return resolveToken(request.getParameterValues(ACCESS_TOKEN_PARAMETER_NAME));
        }
        return null;
    }

    private String resolveFromCookie(HttpServletRequest request) {
        if (!allowCookie || request.getCookies() == null) {
            return null;
        }
        for (Cookie cookie : request.getCookies()) {
            if (cookieName.equals(cookie.getName())) {
                String val = cookie.getValue();
                return StringUtils.hasText(val) ? val : null;
            }
        }
        return null;
    }

    private String resolveToken(String... tokens) {
        String found = null;
        for (String token : tokens) {
            if (token == null) continue;
            if (found != null) {
                BearerTokenError error = BearerTokenErrors.invalidRequest(&quot;Found multiple bearer tokens in the request&quot;);
                throw new OAuth2AuthenticationException(error);
            }
            found = token;
        }
        if (found != null &amp;&amp; found.isBlank()) {
            BearerTokenError error = BearerTokenErrors.invalidRequest(&quot;The requested token parameter is an empty string&quot;);
            throw new OAuth2AuthenticationException(error);
        }
        return found;
    }</code></pre>
<h3>Kotlin</h3>
<pre><code class="language-kotlin">package io.github.susimsek.springbootldapjwedemo.security

import jakarta.servlet.http.Cookie
import jakarta.servlet.http.HttpServletRequest
import org.springframework.http.HttpMethod
import org.springframework.security.oauth2.core.OAuth2AuthenticationException
import org.springframework.security.oauth2.server.resource.BearerTokenError
import org.springframework.security.oauth2.server.resource.BearerTokenErrors
import org.springframework.security.oauth2.server.resource.web.BearerTokenResolver
import org.springframework.util.StringUtils
import java.util.regex.Pattern

class CookieBearerTokenResolver {
    var allowFormEncodedBodyParameter: Boolean = false
    var allowUriQueryParameter: Boolean = false
    var allowCookie: Boolean = true
    var bearerTokenHeaderName: String = &quot;Authorization&quot;
    var cookieName: String = &quot;accessToken&quot;

    companion object {
        private const val ACCESS_TOKEN_PARAMETER_NAME = &quot;access_token&quot;
        private val AUTHORIZATION_PATTERN =
            Pattern.compile(&quot;^Bearer (?&lt;token&gt;[A-Za-z0-9-._~+/]+=*)$&quot;, Pattern.CASE_INSENSITIVE)
    }

    fun resolve(request: HttpServletRequest): String? {
        val header = resolveFromAuthorizationHeader(request)
        val query  = if (allowUriQueryParameter &amp;&amp; HttpMethod.GET.matches(request.method))
            request.getParameterValues(ACCESS_TOKEN_PARAMETER_NAME)?.let(::resolveToken)
        else null
        val body   = if (allowFormEncodedBodyParameter &amp;&amp; HttpMethod.POST.matches(request.method)
            &amp;&amp; request.contentType == &quot;application/x-www-form-urlencoded&quot;)
            request.getParameterValues(ACCESS_TOKEN_PARAMETER_NAME)?.let(::resolveToken)
        else null
        val cookie = if (header == null &amp;&amp; query == null &amp;&amp; body == null)
            resolveFromCookie(request)
        else null
      return listOf(header, query, body, cookie).filterNotNull().let {
            if (it.size &gt; 1) throw OAuth2AuthenticationException(BearerTokenErrors.invalidRequest(&quot;Found multiple bearer tokens&quot;))
            it.firstOrNull()?: null
        }
    }

    private fun resolveFromAuthorizationHeader(request: HttpServletRequest): String? {
        val auth = request.getHeader(bearerTokenHeaderName) ?: return null
        if (!auth.startsWith(&quot;Bearer &quot;, true)) return null
        val matcher = AUTHORIZATION_PATTERN.matcher(auth.trim())
        return if (matcher.matches()) matcher.group(&quot;token&quot;)
        else throw OAuth2AuthenticationException(BearerTokenErrors.invalidToken(&quot;Malformed token&quot;))
    }

    private fun resolveFromCookie(request: HttpServletRequest): String? {
        if (!allowCookie) return null
        return request.cookies?.firstOrNull { it.name == cookieName }?.value?.takeIf { it.isNotBlank() }
    }

    private fun resolveToken(tokens: Array&lt;String&gt;): String? {
        return tokens.filter { it.isNotBlank() }.let {
            when {
                it.isEmpty() -&gt; null
                it.size &gt; 1   -&gt; throw OAuth2AuthenticationException(BearerTokenErrors.invalidRequest(&quot;Multiple tokens&quot;))
                else          -&gt; it[0]
            }
        }
    }</code></pre>
<h3>CookieUtils</h3>
<h3>Java</h3>
<pre><code class="language-java">package io.github.susimsek.springbootldapjwedemo.security;

import io.github.susimsek.springbootldapjwedemo.dto.TokenDTO;
import lombok.experimental.UtilityClass;
import org.springframework.http.ResponseCookie;

@UtilityClass
public class CookieUtils {

    private static final String COOKIE_NAME = &quot;accessToken&quot;;

    public ResponseCookie createAccessTokenCookie(TokenDTO tokenDto) {
        return ResponseCookie.from(COOKIE_NAME, tokenDto.accessToken())
            .httpOnly(true)
            .secure(true)
            .path(&quot;/&quot;)
            .maxAge(tokenDto.accessTokenExpiresIn())
            .sameSite(&quot;Strict&quot;)
            .build();
    }
}</code></pre>
<h3>Kotlin</h3>
<pre><code class="language-kotlin">package io.github.susimsek.springbootldapjwedemo.security

import io.github.susimsek.springbootldapjwedemo.dto.TokenDTO
import org.springframework.http.ResponseCookie

object CookieUtils {

  private const val COOKIE_NAME = &quot;accessToken&quot;

  fun createAccessTokenCookie(tokenDto: TokenDTO): ResponseCookie {
    return ResponseCookie.from(COOKIE_NAME, tokenDto.accessToken())
      .httpOnly(true)
      .secure(true)
      .path(&quot;/&quot;)
      .maxAge(tokenDto.accessTokenExpiresIn())
      .sameSite(&quot;Strict&quot;)
      .build()
  }
}</code></pre>
<h3>JweUtil</h3>
<h3>Java</h3>
<pre><code class="language-java">package io.github.susimsek.springbootldapjwedemo.security;

import com.nimbusds.jose.EncryptionMethod;
import com.nimbusds.jose.JOSEException;
import com.nimbusds.jose.JWEAlgorithm;
import com.nimbusds.jose.JWEHeader;
import com.nimbusds.jose.JWEObject;
import com.nimbusds.jose.Payload;
import com.nimbusds.jose.crypto.RSAEncrypter;
import com.nimbusds.jose.jwk.RSAKey;
import io.github.susimsek.springbootldapjwedemo.config.JwtProperties;
import io.github.susimsek.springbootldapjwedemo.dto.TokenDTO;
import lombok.RequiredArgsConstructor;
import org.springframework.security.core.Authentication;
import org.springframework.security.core.GrantedAuthority;
import org.springframework.security.oauth2.jose.jws.SignatureAlgorithm;
import org.springframework.security.oauth2.jwt.*;
import org.springframework.stereotype.Component;

import java.time.Instant;
import java.util.List;

import static io.github.susimsek.springbootldapjwedemo.security.SecurityUtils.AUTHORITIES_KEY;

@Component
@RequiredArgsConstructor
public class JweUtil {

    private final JwtEncoder jwtEncoder;
    private final RSAKey signingKey;
    private final RSAKey encryptionKey;
    private final JwtProperties props;

    public TokenDTO generateToken(Authentication authentication) throws JOSEException {
        String subject = authentication.getName();
        List&lt;String&gt; roles = authentication.getAuthorities()
            .stream()
            .map(GrantedAuthority::getAuthority)
            .toList();

        Instant now = Instant.now();
        long expiresIn = props.getExpirationDuration().getSeconds();
        Instant exp = now.plusSeconds(expiresIn);

        JwtClaimsSet claims = JwtClaimsSet.builder()
            .issuer(props.getIssuer())
            .issuedAt(now)
            .expiresAt(exp)
            .subject(subject)
            .claim(AUTHORITIES_KEY, roles)
            .build();

        JwsHeader jwsHeader = JwsHeader.with(SignatureAlgorithm.RS256)
            .keyId(signingKey.getKeyID())
            .build();

        String jws = jwtEncoder
            .encode(JwtEncoderParameters.from(jwsHeader, claims))
            .getTokenValue();

        JWEHeader jweHeader = new JWEHeader.Builder(JWEAlgorithm.RSA_OAEP_256, EncryptionMethod.A128GCM)
            .contentType(&quot;JWT&quot;)
            .keyID(encryptionKey.getKeyID())
            .build();

        JWEObject jweObject = new JWEObject(jweHeader, new Payload(jws));
        jweObject.encrypt(new RSAEncrypter(encryptionKey.toRSAPublicKey()));
        String token = jweObject.serialize();

        return new TokenDTO(token, &quot;Bearer&quot;, expiresIn);
    }
}</code></pre>
<h3>Kotlin</h3>
<pre><code class="language-kotlin">package io.github.susimsek.springbootldapjwedemo.security

import com.nimbusds.jose.EncryptionMethod
import com.nimbusds.jose.JOSEException
import com.nimbusds.jose.JWEAlgorithm
import com.nimbusds.jose.JWEHeader
import com.nimbusds.jose.JWEObject
import com.nimbusds.jose.Payload
import com.nimbusds.jose.crypto.RSAEncrypter
import com.nimbusds.jose.jwk.RSAKey
import io.github.susimsek.springbootldapjwedemo.config.JwtProperties
import io.github.susimsek.springbootldapjwedemo.dto.TokenDTO
import lombok.RequiredArgsConstructor
import org.springframework.security.core.Authentication
import org.springframework.security.oauth2.jose.jws.SignatureAlgorithm
import org.springframework.security.oauth2.jwt.JwtClaimsSet
import org.springframework.security.oauth2.jwt.JwtEncoder
import org.springframework.security.oauth2.jwt.JwtEncoderParameters
import org.springframework.stereotype.Component

import java.time.Instant

@Component
@RequiredArgsConstructor
class JweUtil(
    private val jwtEncoder: JwtEncoder,
    private val signingKey: RSAKey,
    private val encryptionKey: RSAKey,
    private val props: JwtProperties
) {
    fun generateToken(authentication: Authentication): TokenDTO {
        val subject = authentication.name
        val roles = authentication.authorities.map { it.authority }

        val now = Instant.now()
        val expiresIn = props.expirationDuration.seconds
        val exp = now.plusSeconds(expiresIn)

        val claims = JwtClaimsSet.builder()
            .issuer(props.issuer)
            .issuedAt(now)
            .expiresAt(exp)
            .subject(subject)
            .claim(AUTHORITIES_KEY, roles)
            .build()

        val jwsHeader = org.springframework.security.oauth2.jwt.JwsHeader.with(SignatureAlgorithm.RS256)
            .keyId(signingKey.keyID)
            .build()

        val jws = jwtEncoder
            .encode(JwtEncoderParameters.from(jwsHeader, claims))
            .tokenValue

        val jweHeader = JWEHeader.Builder(JWEAlgorithm.RSA_OAEP_256, EncryptionMethod.A128GCM)
            .contentType(&quot;JWT&quot;)
            .keyID(encryptionKey.keyID)
            .build()

        val jweObject = JWEObject(jweHeader, Payload(jws))
        jweObject.encrypt(RSAEncrypter(encryptionKey.toRSAPublicKey()))
        val token = jweObject.serialize()

        return TokenDTO(token, &quot;Bearer&quot;, expiresIn)
    }
}</code></pre>
<h3>KeyUtils</h3>
<h3>Java</h3>
<pre><code class="language-java">package io.github.susimsek.springbootldapjwedemo.security;

import com.nimbusds.jose.JWEAlgorithm;
import com.nimbusds.jose.JWSAlgorithm;
import com.nimbusds.jose.jwk.KeyUse;
import com.nimbusds.jose.jwk.RSAKey;
import lombok.experimental.UtilityClass;

import java.security.KeyFactory;
import java.security.interfaces.RSAPrivateKey;
import java.security.interfaces.RSAPublicKey;
import java.security.spec.PKCS8EncodedKeySpec;
import java.security.spec.X509EncodedKeySpec;
import java.util.Base64;

@UtilityClass
public class KeyUtils {
    public RSAKey buildRsaKey(
            String pubPem,
            String privPem,
            String kid,
            boolean forSign
    ) throws Exception {
        String pubContent = pubPem
            .replace(&quot;-----BEGIN PUBLIC KEY-----&quot;, &quot;&quot;)
            .replace(&quot;-----END PUBLIC KEY-----&quot;, &quot;&quot;)
            .replaceAll(&quot;\\s&quot;, &quot;&quot;);
        String privContent = privPem
            .replace(&quot;-----BEGIN PRIVATE KEY-----&quot;, &quot;&quot;)
            .replace(&quot;-----END PRIVATE KEY-----&quot;, &quot;&quot;)
            .replaceAll(&quot;\\s&quot;, &quot;&quot;);

        byte[] decodedPub = Base64.getDecoder().decode(pubContent);
        byte[] decodedPriv = Base64.getDecoder().decode(privContent);

        KeyFactory kf = KeyFactory.getInstance(&quot;RSA&quot;);
        RSAPublicKey publicKey = (RSAPublicKey) kf.generatePublic(new X509EncodedKeySpec(decodedPub));
        RSAPrivateKey privateKey = (RSAPrivateKey) kf.generatePrivate(new PKCS8EncodedKeySpec(decodedPriv));

        RSAKey.Builder builder = new RSAKey.Builder(publicKey)
            .privateKey(privateKey)
            .keyID(kid);

        if (forSign) {
            builder
                .algorithm(JWSAlgorithm.RS256)
                .keyUse(KeyUse.SIGNATURE);
        } else {
            builder
                .algorithm(JWEAlgorithm.RSA_OAEP_256)
                .keyUse(KeyUse.ENCRYPTION);
        }

        return builder.build();
    }
}</code></pre>
<h3>Kotlin</h3>
<pre><code class="language-kotlin">package io.github.susimsek.springbootldapjwedemo.security

import com.nimbusds.jose.JWEAlgorithm
import com.nimbusds.jose.JWSAlgorithm
import com.nimbusds.jose.jwk.KeyUse
import com.nimbusds.jose.jwk.RSAKey
import java.security.KeyFactory
import java.security.interfaces.RSAPrivateKey
import java.security.interfaces.RSAPublicKey
import java.security.spec.PKCS8EncodedKeySpec
import java.security.spec.X509EncodedKeySpec
import java.util.Base64

object KeyUtils {
    @JvmStatic
    @Throws(Exception::class)
    fun buildRsaKey(
        pubPem: String,
        privPem: String,
        kid: String,
        forSign: Boolean
    ): RSAKey {
        val pubContent = pubPem
            .replace(&quot;-----BEGIN PUBLIC KEY-----&quot;, &quot;&quot;)
            .replace(&quot;-----END PUBLIC KEY-----&quot;, &quot;&quot;)
            .replace(Regex(&quot;\\s&quot;), &quot;&quot;)
        val privContent = privPem
            .replace(&quot;-----BEGIN PRIVATE KEY-----&quot;, &quot;&quot;)
            .replace(&quot;-----END PRIVATE KEY-----&quot;, &quot;&quot;)
            .replace(Regex(&quot;\\s&quot;), &quot;&quot;)

        val decodedPub = Base64.getDecoder().decode(pubContent)
        val decodedPriv = Base64.getDecoder().decode(privContent)

        val kf = KeyFactory.getInstance(&quot;RSA&quot;)
        val publicKey = kf.generatePublic(X509EncodedKeySpec(decodedPub)) as RSAPublicKey
        val privateKey = kf.generatePrivate(PKCS8EncodedKeySpec(decodedPriv)) as RSAPrivateKey

        val builder = RSAKey.Builder(publicKey)
            .privateKey(privateKey)
            .keyID(kid)

        if (forSign) {
            builder
                .algorithm(JWSAlgorithm.RS256)
                .keyUse(KeyUse.SIGNATURE)
        } else {
            builder
                .algorithm(JWEAlgorithm.RSA_OAEP_256)
                .keyUse(KeyUse.ENCRYPTION)
        }

        return builder.build()
    }
}</code></pre>
<h3>SecurityUtils</h3>
<h3>Java</h3>
<pre><code class="language-java">package io.github.susimsek.springbootldapjwedemo.security;

import lombok.experimental.UtilityClass;
import org.springframework.security.core.Authentication;
import org.springframework.security.core.context.SecurityContextHolder;
import org.springframework.security.core.userdetails.UserDetails;
import org.springframework.security.oauth2.jwt.Jwt;

import java.util.Optional;

@UtilityClass
public class SecurityUtils {

    public static final String AUTHORITIES_KEY = &quot;auth&quot;;

    public Optional&lt;String&gt; getCurrentUserLogin() {
        var ctx = SecurityContextHolder.getContext();
        return Optional.ofNullable(extractPrincipal(ctx.getAuthentication()));
    }

    private String extractPrincipal(Authentication authentication) {
        if (authentication == null) {
            return null;
        }
        Object principal = authentication.getPrincipal();
        if (principal instanceof Jwt jwt) {
            return jwt.getSubject();
        }
        if (principal instanceof UserDetails ud) {
            return ud.getUsername();
        }
        if (principal instanceof String username) {
            return username;
        }
        return null;
    }
}</code></pre>
<h3>Kotlin</h3>
<pre><code class="language-kotlin">package io.github.susimsek.springbootldapjwedemo.security

import org.springframework.security.core.Authentication
import org.springframework.security.core.context.SecurityContextHolder
import org.springframework.security.core.userdetails.UserDetails
import org.springframework.security.oauth2.jwt.Jwt
import java.util.Optional

object SecurityUtils {
  const val AUTHORITIES_KEY = &quot;auth&quot;

  fun getCurrentUserLogin(): Optional&lt;String&gt; {
    val authentication: Authentication? = SecurityContextHolder.getContext().authentication
    return Optional.ofNullable(extractPrincipal(authentication))
  }

  private fun extractPrincipal(authentication: Authentication?): String? {
    return when (val principal = authentication?.principal) {
      is Jwt -&gt; principal.subject
      is UserDetails -&gt; principal.username
      is String -&gt; principal
      else -&gt; null
    }
  }
}</code></pre>
<hr />
<h2>üõ†Ô∏è Step 5: Authentication &amp; Protected Endpoints</h2>
<p>In this section, we define the REST controllers and DTOs necessary for:</p>
<ul>
<li>AuthController: Authenticate users, issue JWE tokens, and set secure cookies.</li>
<li>HelloController: Expose protected resource endpoints for authenticated users and admin-specific paths.</li>
<li>LoginRequestDTO: Model the login request payload (username/password).</li>
<li>TokenDTO: Model the authentication response including token and expiration.</li>
</ul>
<p>These components complete the stateless authentication flow by handling login, token issuance, cookie management, and resource protection.</p>
<p>In this section, we expose REST controllers and DTOs to handle user authentication, token issuance, and protected resource access.</p>
<h3>AuthController</h3>
<h3>Java</h3>
<pre><code class="language-java">package io.github.susimsek.springbootldapjwedemo.controller;

import io.github.susimsek.springbootldapjwedemo.dto.LoginRequestDTO;
import io.github.susimsek.springbootldapjwedemo.dto.TokenDTO;
import io.github.susimsek.springbootldapjwedemo.security.CookieUtils;
import io.github.susimsek.springbootldapjwedemo.security.JweUtil;
import lombok.RequiredArgsConstructor;
import org.springframework.http.HttpHeaders;
import org.springframework.http.ResponseCookie;
import org.springframework.http.ResponseEntity;
import org.springframework.security.authentication.AuthenticationManager;
import org.springframework.security.authentication.UsernamePasswordAuthenticationToken;
import org.springframework.security.core.Authentication;
import org.springframework.security.core.context.SecurityContextHolder;
import org.springframework.web.bind.annotation.PostMapping;
import org.springframework.web.bind.annotation.RequestBody;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;

@RestController
@RequiredArgsConstructor
@RequestMapping(&quot;/api/auth&quot;)
public class AuthController {

    private final AuthenticationManager authenticationManager;
    private final JweUtil jweUtil;

    @PostMapping(&quot;/login&quot;)
    public ResponseEntity&lt;TokenDTO&gt; login(@RequestBody LoginRequestDTO loginRequest) throws Exception {
        // Authenticate user
        var authToken = new UsernamePasswordAuthenticationToken(
            loginRequest.username(), loginRequest.password()
        );
        Authentication auth = authenticationManager.authenticate(authToken);
        SecurityContextHolder.getContext().setAuthentication(auth);

        // Generate JWE token and cookie
        TokenDTO tokenDto = jweUtil.generateToken(auth);
        ResponseCookie cookie = CookieUtils.createAccessTokenCookie(tokenDto);

        return ResponseEntity.ok()
            .header(HttpHeaders.SET_COOKIE, cookie.toString())
            .body(tokenDto);
    }
}</code></pre>
<h3>Kotlin</h3>
<pre><code class="language-kotlin">package io.github.susimsek.springbootldapjwedemo.controller

import io.github.susimsek.springbootldapjwedemo.dto.LoginRequestDTO
import io.github.susimsek.springbootldapjwedemo.dto.TokenDTO
import io.github.susimsek.springbootldapjwedemo.security.CookieUtils
import io.github.susimsek.springbootldapjwedemo.security.JweUtil
import lombok.RequiredArgsConstructor
import org.springframework.http.HttpHeaders
import org.springframework.http.ResponseCookie
import org.springframework.http.ResponseEntity
import org.springframework.security.authentication.AuthenticationManager
import org.springframework.security.authentication.UsernamePasswordAuthenticationToken
import org.springframework.security.core.Authentication
import org.springframework.security.core.context.SecurityContextHolder
import org.springframework.web.bind.annotation.PostMapping
import org.springframework.web.bind.annotation.RequestBody
import org.springframework.web.bind.annotation.RequestMapping
import org.springframework.web.bind.annotation.RestController

@RestController
@RequiredArgsConstructor
@RequestMapping(&quot;/api/auth&quot;)
class AuthController(
    private val authenticationManager: AuthenticationManager,
    private val jweUtil: JweUtil
) {

    @PostMapping(&quot;/login&quot;)
    fun login(@RequestBody loginRequest: LoginRequestDTO): ResponseEntity&lt;TokenDTO&gt; {
        val authToken = UsernamePasswordAuthenticationToken(
            loginRequest.username, loginRequest.password
        )
        val auth: Authentication = authenticationManager.authenticate(authToken)
        SecurityContextHolder.getContext().authentication = auth

        val tokenDto: TokenDTO = jweUtil.generateToken(auth)
        val cookie: ResponseCookie = CookieUtils.createAccessTokenCookie(tokenDto)

        return ResponseEntity.ok()
            .header(HttpHeaders.SET_COOKIE, cookie.toString())
            .body(tokenDto)
    }
}</code></pre>
<h3>HelloController</h3>
<h3>Java</h3>
<pre><code class="language-java">package io.github.susimsek.springbootldapjwedemo.controller;

import org.springframework.security.core.annotation.AuthenticationPrincipal;
import org.springframework.security.oauth2.jwt.Jwt;
import org.springframework.web.bind.annotation.*;

import static io.github.susimsek.springbootldapjwedemo.security.SecurityUtils.AUTHORITIES_KEY;

@RestController
@RequestMapping(&quot;/api/hello&quot;)
public class HelloController {

    @GetMapping
    public String helloAll(@AuthenticationPrincipal Jwt jwt) {
        String user = jwt.getSubject();
        var roles = jwt.getClaimAsStringList(AUTHORITIES_KEY);
        return &quot;Hello, &quot; + user + &quot;! Your roles: &quot; + roles;
    }

    @GetMapping(&quot;/admin&quot;)
    public String helloAdmin(@AuthenticationPrincipal Jwt jwt) {
        return &quot;Hello Admin, &quot; + jwt.getSubject() + &quot;!&quot;;
    }
}</code></pre>
<h3>Kotlin</h3>
<pre><code class="language-kotlin">package io.github.susimsek.springbootldapjwedemo.controller

import org.springframework.security.core.annotation.AuthenticationPrincipal
import org.springframework.security.oauth2.jwt.Jwt
import org.springframework.web.bind.annotation.*

import io.github.susimsek.springbootldapjwedemo.security.SecurityUtils.AUTHORITIES_KEY

@RestController
@RequestMapping(&quot;/api/hello&quot;)
class HelloController {

    @GetMapping
    fun helloAll(@AuthenticationPrincipal jwt: Jwt): String {
        val user = jwt.subject
        val roles = jwt.getClaimAsStringList(AUTHORITIES_KEY)
        return &quot;Hello, \$user! Your roles: \$roles&quot;
    }

    @GetMapping(&quot;/admin&quot;)
    fun helloAdmin(@AuthenticationPrincipal jwt: Jwt): String {
        return &quot;Hello Admin, \${jwt.subject}!&quot;
    }
}</code></pre>
<h3>LoginRequestDTO</h3>
<h3>Java</h3>
<pre><code class="language-java">package io.github.susimsek.springbootldapjwedemo.dto;

public record LoginRequestDTO(
    String username,
    String password
) { }</code></pre>
<h3>Kotlin</h3>
<pre><code class="language-kotlin">package io.github.susimsek.springbootldapjwedemo.dto

data class LoginRequestDTO(
    val username: String,
    val password: String
)</code></pre>
<h3>TokenDTO</h3>
<h3>Java</h3>
<pre><code class="language-java">package io.github.susimsek.springbootldapjwedemo.dto;

public record TokenDTO(
    String accessToken,
    String tokenType,
    long accessTokenExpiresIn
) {}</code></pre>
<h3>Kotlin</h3>
<pre><code class="language-kotlin">package io.github.susimsek.springbootldapjwedemo.dto

import kotlin.Long

data class TokenDTO(
    val accessToken: String,
    val tokenType: String,
    val accessTokenExpiresIn: Long
)</code></pre>
<hr />
<h2>‚ñ∂Ô∏è Run the App</h2>
<pre><code class="language-bash">./mvnw spring-boot:run
# or
gradle bootRun</code></pre>
<hr />
<h2>üß™ Test Endpoints</h2>
<h3>Admin Flow</h3>
<p>Login as admin and capture the JWE token from the `Set-Cookie` header:</p>
<pre><code class="language-bash">curl -i -X POST http://localhost:8080/api/auth/login \
  -H &quot;Content-Type: application/json&quot; \
  -d &#39;{&quot;username&quot;:&quot;admin&quot;,&quot;password&quot;:&quot;adminpass&quot;}&#39;</code></pre>
<ul>
<li>Set-Cookie header contains `accessToken=&lt;jwe-token&gt;`</li>
<li>Response body:</li>
</ul>
<pre><code class="language-json">{
  &quot;accessToken&quot;: &quot;&lt;jwe-token&gt;&quot;,
  &quot;tokenType&quot;: &quot;Bearer&quot;,
  &quot;accessTokenExpiresIn&quot;: 3600
}</code></pre>
<p>Use cookie to access hello endpoint:</p>
<pre><code class="language-bash">curl -b &quot;accessToken=&lt;jwe-token&gt;&quot; http://localhost:8080/api/hello</code></pre>
<p>Use Authorization header instead:</p>
<pre><code class="language-bash">curl -H &quot;Authorization: Bearer &lt;jwe-token&gt;&quot; http://localhost:8080/api/hello</code></pre>
<p>Access admin-only endpoint:</p>
<pre><code class="language-bash">curl -H &quot;Authorization: Bearer &lt;jwe-token&gt;&quot; http://localhost:8080/api/hello/admin</code></pre>
<h3>User Flow</h3>
<p>Login as user and capture JWE token from cookie:</p>
<pre><code class="language-bash">curl -i -X POST http://localhost:8080/api/auth/login \
  -H &quot;Content-Type: application/json&quot; \
  -d &#39;{&quot;username&quot;:&quot;user&quot;,&quot;password&quot;:&quot;userpass&quot;}&#39;</code></pre>
<ul>
<li>Set-Cookie header contains `accessToken=&lt;jwe-token&gt;`</li>
</ul>
<p>Use cookie to access hello endpoint:</p>
<pre><code class="language-bash">curl -b &quot;accessToken=&lt;jwe-token&gt;&quot; http://localhost:8080/api/hello</code></pre>
<p>Use Authorization header:</p>
<pre><code class="language-bash">curl -H &quot;Authorization: Bearer &lt;jwe-token&gt;&quot; http://localhost:8080/api/hello</code></pre>
<p>Attempt admin endpoint (should be 403 Forbidden):</p>
<pre><code class="language-bash">curl -H &quot;Authorization: Bearer &lt;jwe-token&gt;&quot; http://localhost:8080/api/hello/admin
# HTTP/1.1 403 Forbidden</code></pre>
<hr />
<h2>üèÅ Conclusion</h2>
<p>This setup delivers a robust, production-ready Spring Boot LDAP and JWE Authentication solution in Spring Boot, combining best practices, clear structure, and practical examples you can adapt to your own project.</p>]]></content:encoded>
      <category><![CDATA[Java]]></category>
      <category><![CDATA[Kotlin]]></category>
      <category><![CDATA[Spring Boot]]></category>
      <category><![CDATA[Security]]></category>
      <category><![CDATA[JWT]]></category>
      <category><![CDATA[JWE]]></category>
      <category><![CDATA[LDAP]]></category>
      <category><![CDATA[Programming]]></category>
      <media:thumbnail url="https://suaybsimsek.com/images/spring-boot-ldap-jwe-auth-thumbnail.webp" />
    </item>
    <item>
      <title><![CDATA[Spring Boot JWE Authentication]]></title>
      <link>https://suaybsimsek.com/en/posts/spring-boot-jwe-authentication</link>
      <description><![CDATA[Learn how to use JWE to encrypt your JWTs and secure your Spring Boot APIs for confidentiality and integrity.]]></description>
      <pubDate>Sat, 03 May 2025 00:00:00 GMT</pubDate>
      <guid isPermaLink="true">https://suaybsimsek.com/en/posts/spring-boot-jwe-authentication</guid>
      <content:encoded><![CDATA[<p>Spring Boot lets you combine JWS signing with JWE encryption to protect both the integrity and confidentiality of your JWTs in Spring-powered microservices.</p>
<hr />
<h2>üåü Why Use JWE Authentication?</h2>
<ul>
<li>Integrity: Ensure tokens are signed (JWS) and tamper-evident.</li>
<li>Confidentiality: Encrypt sensitive claims so only holders of the private key can read them (JWE).</li>
<li>Standards-based: Built on the JOSE (JWS, JWE) specifications.</li>
<li>Spring Support: Spring Security‚Äôs OAuth2 Resource Server handles JWE+JWS seamlessly.</li>
</ul>
<hr />
<h2>üìã Prerequisites</h2>
<ul>
<li>‚òï Java Development Kit (JDK) 17 or higher</li>
<li>üì¶ Spring Boot 3.2+</li>
<li>üî§ IDE (IntelliJ IDEA, Eclipse)</li>
</ul>
<hr />
<h2>üõ†Ô∏è Step 1: Add Dependencies</h2>
<p>Include these in your `pom.xml` or `build.gradle` file.</p>
<p>Maven:</p>
<pre><code class="language-xml">&lt;dependency&gt;
  &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
  &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;
&lt;/dependency&gt;
&lt;dependency&gt;
  &lt;groupId&gt;org.springframework.security&lt;/groupId&gt;
  &lt;artifactId&gt;spring-security-oauth2-resource-server&lt;/artifactId&gt;
&lt;/dependency&gt;
&lt;dependency&gt;
  &lt;groupId&gt;org.projectlombok&lt;/groupId&gt;
  &lt;artifactId&gt;lombok&lt;/artifactId&gt;
  &lt;optional&gt;true&lt;/optional&gt;
&lt;/dependency&gt;</code></pre>
<p>Gradle:</p>
<pre><code class="language-groovy">implementation &#39;org.springframework.boot:spring-boot-starter-web&#39;
implementation &#39;org.springframework.security:spring-security-oauth2-resource-server&#39;
compileOnly &#39;org.projectlombok:lombok&#39;</code></pre>
<hr />
<h2>üõ†Ô∏è Step 2: Keys Configuration</h2>
<p>Define RSA keys and user credentials in `application.yml`:</p>
<pre><code class="language-yaml">security:
  admin:
    username: admin
    password: adminpass
  user:
    username: user
    password: userpass
  jwt:
    issuer: demo-issuer
    expiration-duration: 3600s
    signing:
      key-id: signing-key
      public-key: |-
        -----BEGIN PUBLIC KEY-----
        MIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEAjZEcz5itWkDGOSqZdB5P
        JE0ccOCckskp0hN3kQbT1qnv+9/k66jlWgVi4HSTppwdNF/Ylu5u541Qj+Okyg+u
        8o2PvKo5CfgvTDsFLTrZHUXU6hCSGatLAQoeN6lT8wzov2r4DFecXrIqcO6SvMB5
        ecPqsfiTi4trsNKgJ4cWS6gILH62ISd1ipUadfpnUzDMO1OulV0CJNV6bcBk7Es9
        RW6AHfg9j8osSanpwvRM4MJkB0SRxYUnrN9faGpkBZISZJ8TShhaTHEGfSNgKe5y
        8iu+AMGGZu8DYczVmqS3Ske1fq6y5HEGCma7Mo019GmwKeHBo1obuET6cZRygj4y
        twIDAQAB
        -----END PUBLIC KEY-----
      private-key: |-
        -----BEGIN PRIVATE KEY-----
        MIIEvAIBADANBgkqhkiG9w0BAQEFAASCBKYwggSiAgEAAoIBAQCNkRzPmK1aQMY5
        Kpl0Hk8kTRxw4JySySnSE3eRBtPWqe/73+TrqOVaBWLgdJOmnB00X9iW7m7njVCP
        46TKD67yjY+8qjkJ+C9MOwUtOtkdRdTqEJIZq0sBCh43qVPzDOi/avgMV5xesipw
        7pK8wHl5w+qx+JOLi2uw0qAnhxZLqAgsfrYhJ3WKlRp1+mdTMMw7U66VXQIk1Xpt
        wGTsSz1FboAd+D2PyixJqenC9EzgwmQHRJHFhSes319oamQFkhJknxNKGFpMcQZ9
        I2Ap7nLyK74AwYZm7wNhzNWapLdKR7V+rrLkcQYKZrsyjTX0abAp4cGjWhu4RPpx
        lHKCPjK3AgMBAAECggEABMo/sNCIMREXA/EqjxDFecN4LmOTOK5A0YBiH9Cc01sd
        qSaavtSQqhqbjV+0bUNEA7UohXbc3s3bx3qa5VFhiIh8sBQMaQdyRkCK/MxMc16d
        BSx5XQ/8MjVO73A1zHgH2g47BWPjgRrDL94KrgNPOO0FoG76QxL9GlcOHzhFa1rf
        xbb2auLBtflKy+5TZNnB/sbFC9ISpWywzfblD2Fsvxupl0vNWtA0Y2rPbKMZRnY+
        V6NC38yxW3HHAdWQRYLGOitM59I0HBgnjQKzTBNIsjPnJA2BSZvMBtQ1e3RQV0qE
        8VVoktZ8A0KDUxqdKWYlGYAY5hIw1y3UUsPRUbS3fQKBgQDAZehu+Kb5Sw+h00Qu
        vViNHDvi0PwmhQrHVpgjrppCnWsTk6FJFm+EBLY+87usXuRCnfZ1semb6P+yjLh2
        bJ9IXIrFAztcyE+7eZfn0H7mHA7E2ICKTjNdKbjy8kHViHpgdXREnAOrFTTk/BqW
        dq+weG2OuxYczWsY4XliWaVyiwKBgQC8XYExpSmoyI37o+jr9405k30tbGUw4X+/
        xYOvSUuafI8IOSLfKTpsvkMN3hxpJO6apIRAjOALbotKUA5FrHQPenuBWOr3mBJT
        euLiaWphqU8YN5dbNd+JhC/Jh5DLhY5FpB2Fv2MKSoF7+onpjDy9pEU5aReeBB0v
        ekUw4nWiBQKBgHxyrnjxP1frFG5xMB4nfZqw04+v7BmiXsl3mqsh6kgCeNtN17pl
        17YGMjfgAdnJ+02XzW5tqRSfDp3YZgy7z//HVD+BCqnGK8SxLu/ULfD73xW2kNZl
        JNYzAZ2r06eiQr4X2x/x5nGIIxGmfDAtDxFPpFX5b6ErwgVy+sgCAoFnAoGAWSpu
        EMEdQk+FnnwNsz2g9YNSuyDXmdb08SOfXWd1yXBzCLJ7RmYuyPEbrsHYcxFPfZap
        ICFPoTm35/qTdvnWiskxE56yw3eSHUBLjF/YQtixn0YZeMy8v0z6jgyFR0I2gdLZ
        QsnBKUrxlm2XwR1oV2Eef7m2u085PZNEk4pvor0CgYA6n060r48/CgRVslAeGder
        fZ3n+2ru8q2UVB38evepjLifn5+tKdFzZ7/NckXMC0NOVzm74qG46VFLMw5TtyT4
        /hRvGSYxA6dMjXy+tcrAns9Isrz2PnYFntlbhU6hw0um809tFunbvITfyeOjAsDW
        stC4thnhzXXT1Y3RfFtYEg==
        -----END PRIVATE KEY-----
    encryption:
      key-id: encryption-key
      public-key: |-
        -----BEGIN PUBLIC KEY-----
        MIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEAtU7Vu4tML8qg9BISaUH0
        BTU0+qkHJS3TUl3R0hEPttZJGf8EgT7bpWqRjdhMC2SYt2ifNF82EgMo/eva1rLn
        wYtCsxjJ7oB4U2m16/JKHtphmMUGhSLgbp+Y8pGAQ+P6u4HLlI0qbL92Syb6QCTr
        nYIlzZ2uUAvUQg/SbuAvdS4kdauZtpMNbhryusMVvILVBC5yUhfLJAkjbU3qWo/n
        2NKPr4kjwwFh6FaAf0HLsXCFmJbPPok6WMZeDqPORPZCt5gU2t04fS7s/2SSbhQ/
        i+7yyT4pl44cUlNLLN3Qo73sai5H90q7Dvmk3M5/YMJB0Ueyb705LHyOO5xA618s
        qQIDAQAB
        -----END PUBLIC KEY-----
      private-key: |-
        -----BEGIN PRIVATE KEY-----
        MIIEvgIBADANBgkqhkiG9w0BAQEFAASCBKgwggSkAgEAAoIBAQC1TtW7i0wvyqD0
        EhJpQfQFNTT6qQclLdNSXdHSEQ+21kkZ/wSBPtulapGN2EwLZJi3aJ80XzYSAyj9
        69rWsufBi0KzGMnugHhTabXr8koe2mGYxQaFIuBun5jykYBD4/q7gcuUjSpsv3ZL
        JvpAJOudgiXNna5QC9RCD9Ju4C91LiR1q5m2kw1uGvK6wxW8gtUELnJSF8skCSNt
        Tepaj+fY0o+viSPDAWHoVoB/QcuxcIWYls8+iTpYxl4Oo85E9kK3mBTa3Th9Luz/
        ZJJuFD+L7vLJPimXjhxSU0ss3dCjvexqLkf3SrsO+aTczn9gwkHRR7JvvTksfI47
        nEDrXyypAgMBAAECggEAREnJHrY8n9OGA+e6n4KD0mJT7gUz98Dm0yMbIC/k50yW
        hAAVRkjSmd8lq3NIURI2ov342NTznJ0sF1d6OVtxBujY2nP/uqEQsPoj1xaO7Ef8
        cnnjFsooFgJurQ44bVm02mLstqrky8jhWTT5FKfTRqP6cRNu0B9kdu1WqQQvW8a/
        C8xD8XUFzzJFQsEstJ076NjlZNH3EeqFiLxyVdV7tPEJRnOe2V2BAAgda3ByA6Jc
        Nd4xYHTVr5rZ+KES9gaAgb86+S7hNigsxz5Gp58NimLEyz1Qd+d9QCgPRgKOV5Uq
        0ci6c28ZrxW9wa/2CGCpoow1V7hRy1fZ24g2Tz91cQKBgQDbSdP/FQYuem0pUf8u
        mA/niEC8Jz30FW3ix5aqbQ8YRudK48Xy8F7AWnlS0wT2k/Xaeppn9YSPK4HlsNk2
        1gnpNfzdqXpJQtuxcPPeFNzUdXzBrsLXYqtlhOX/afrzqMhp73gkqoxXtqwD7BqN
        VfMcVXsWrEZQrRPBn/RUnnLdJwKBgQDTqUGupm93UlhoPgLXHGF/seQwPPHcU6lS
        SS9l512Ie21B+vZecgO4r77BXJwbY4rZVA5/m+wrsNmsT2f8yfdbs84cBDDWiKy5
        t2Um8zrus+BCIffxc9Fck9/htK33jLLcYwdSAm3a9pJxR9f/kAdredSTGBNJ3W/2
        rfh3cdNprwKBgDi7WfBFRSsjGzi0cPth9cNlubGzyVBrdtlT34PJ4Tzboxz53o1i
        aHEFNxwZYdBVKSbTzzyUBS5xCBMfdKK+LyQ5hmjmXq+zb1jxqvXKmfMRTixhhSDp
        8wO5pTM1/Omqwea+QGvj/5j1tnzxSVFFajbrWoPcH/jhPho6wqBducPDAoGBALOJ
        MEOavZXy7TaO0w3v7uvH0wzvxR/kfw1jMqc3l2j7ePOskmoOQAXaXO3bRjcdOlua
        Jyoq8islOZ4lRMlx7zWD0OKG035GNGzbmRtu2aA8R48RDSVr3jyu2gqznZULbXPv
        M/hmQxSmbhVUoW0PmJubnaqfk0zmXeBaNRXsIS3VAoGBALdsAtqR23PVeL6sYj2l
        dRNTDXpfvjFqJ5NThRO/4mT0CrPHQVj+Mz2bTc/Dxiwi8s8m3L+g23i3hodh/QMb
        Iz+UbcJZBGAKsFbPKGOtj6Bi07y/L11mcuNJzOWe61/JbVmJss0s+N/v3XucK/Ge
        CUaGOccsMO221v6JoBh9J3Hz
        -----END PRIVATE KEY-----</code></pre>
<hr />
<h2>üõ†Ô∏è Step 3: Security Configuration</h2>
<p>In this section, we define the beans and properties required to load credentials, RSA keys, and HTTP security filters for JWE-based authentication:</p>
<ul>
<li>AdminProperties: Loads admin username and password from application properties.</li>
<li>UserProperties: Loads normal user credentials from application properties.</li>
<li>JwtProperties: Configures JWT issuer, expiration, and signing/encryption key pairs.</li>
<li>SecurityJwtConfig: Builds RSA JWKs, JWT encoder/decoder, authentication converter, and token resolver.</li>
<li>SecurityConfig: Defines in-memory users and the stateless security filter chain with route authorization.</li>
</ul>
<h3>AdminProperties</h3>
<h3>Java</h3>
<pre><code class="language-java">package io.github.susimsek.springbootjwedemo.config;

import lombok.Data;
import org.springframework.boot.context.properties.ConfigurationProperties;
import org.springframework.context.annotation.Configuration;

@Configuration
@ConfigurationProperties(prefix = &quot;security.admin&quot;)
@Data
public class AdminProperties {
    private String username;
    private String password;
}</code></pre>
<h3>Kotlin</h3>
<pre><code class="language-kotlin">package io.github.susimsek.springbootjwedemo.config

import org.springframework.boot.context.properties.ConfigurationProperties
import org.springframework.context.annotation.Configuration

@Configuration
@ConfigurationProperties(prefix = &quot;security.admin&quot;)
class AdminProperties {
  lateinit var username: String
  lateinit var password: String
}</code></pre>
<h3>SecurityJwtConfig</h3>
<h3>Java</h3>
<pre><code class="language-java">package io.github.susimsek.springbootjwedemo.config;

import com.nimbusds.jose.EncryptionMethod;
import com.nimbusds.jose.JWEAlgorithm;
import com.nimbusds.jose.JWSAlgorithm;
import com.nimbusds.jose.jwk.JWKSet;
import com.nimbusds.jose.jwk.RSAKey;
import com.nimbusds.jose.jwk.source.JWKSource;
import com.nimbusds.jose.proc.JWEDecryptionKeySelector;
import com.nimbusds.jose.proc.JWSVerificationKeySelector;
import com.nimbusds.jose.proc.SecurityContext;
import com.nimbusds.jwt.proc.DefaultJWTProcessor;
import io.github.susimsek.springbootjwedemo.security.CookieBearerTokenResolver;
import io.github.susimsek.springbootjwedemo.security.KeyUtils;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.security.oauth2.jwt.JwtDecoder;
import org.springframework.security.oauth2.jwt.JwtEncoder;
import org.springframework.security.oauth2.jwt.NimbusJwtDecoder;
import org.springframework.security.oauth2.jwt.NimbusJwtEncoder;
import org.springframework.security.oauth2.server.resource.authentication.JwtAuthenticationConverter;
import org.springframework.security.oauth2.server.resource.authentication.JwtGrantedAuthoritiesConverter;
import org.springframework.security.oauth2.server.resource.web.BearerTokenResolver;

import java.util.List;

import static io.github.susimsek.springbootjwedemo.security.SecurityUtils.AUTHORITIES_KEY;

@Configuration
public class SecurityJwtConfig {

    private final JwtProperties props;
    public SecurityJwtConfig(JwtProperties props) { this.props = props; }

    @Bean
    public RSAKey signingKey() throws Exception {
        return KeyUtils.buildRsaKey(
            props.getSigning().getPublicKey(),
            props.getSigning().getPrivateKey(),
            props.getSigning().getKeyId(),
            true
        );
    }

    @Bean
    public RSAKey encryptionKey() throws Exception {
        return KeyUtils.buildRsaKey(
            props.getEncryption().getPublicKey(),
            props.getEncryption().getPrivateKey(),
            props.getEncryption().getKeyId(),
            false
        );
    }

    @Bean
    public JWKSource&lt;SecurityContext&gt; jwkSource(RSAKey signingKey, RSAKey encryptionKey) {
        JWKSet jwkSet = new JWKSet(List.of(
            signingKey,
            encryptionKey
        ));
        return (jwkSelector, context) -&gt; jwkSelector.select(jwkSet);
    }

    @Bean
    public JwtDecoder jwtDecoder(JWKSource&lt;SecurityContext&gt; jwkSource) {
        DefaultJWTProcessor&lt;SecurityContext&gt; jwtProcessor = new DefaultJWTProcessor&lt;&gt;();
        JWEDecryptionKeySelector&lt;SecurityContext&gt; jweKeySelector =
            new JWEDecryptionKeySelector&lt;&gt;(
                JWEAlgorithm.RSA_OAEP_256,
                EncryptionMethod.A128GCM,
                jwkSource
            );
        jwtProcessor.setJWEKeySelector(jweKeySelector);

        JWSVerificationKeySelector&lt;SecurityContext&gt; jwsKeySelector =
            new JWSVerificationKeySelector&lt;&gt;(
                JWSAlgorithm.RS256,
                jwkSource
            );
        jwtProcessor.setJWSKeySelector(jwsKeySelector);
        jwtProcessor.setJWTClaimsSetVerifier((claims, context) -&gt; {});

        return new NimbusJwtDecoder(jwtProcessor);
    }

    @Bean
    public JwtEncoder jwtEncoder(JWKSource&lt;SecurityContext&gt; jwkSource) {
        return new NimbusJwtEncoder(jwkSource);
    }

    @Bean
    public JwtAuthenticationConverter jwtAuthenticationConverter() {
        JwtGrantedAuthoritiesConverter converter = new JwtGrantedAuthoritiesConverter();
        converter.setAuthorityPrefix(&quot;&quot;);
        converter.setAuthoritiesClaimName(AUTHORITIES_KEY);

        JwtAuthenticationConverter authConverter = new JwtAuthenticationConverter();
        authConverter.setJwtGrantedAuthoritiesConverter(converter);
        return authConverter;
    }

    @Bean
    public BearerTokenResolver bearerTokenResolver() {
        CookieBearerTokenResolver resolver = new CookieBearerTokenResolver();
        resolver.setAllowUriQueryParameter(false);
        resolver.setAllowFormEncodedBodyParameter(false);
        resolver.setAllowCookie(true);
        return resolver;
    }
}</code></pre>
<h3>Kotlin</h3>
<pre><code class="language-kotlin">package io.github.susimsek.springbootjwedemo.config

import com.nimbusds.jose.EncryptionMethod
import com.nimbusds.jose.JWEAlgorithm
import com.nimbusds.jose.JWSAlgorithm
import com.nimbusds.jose.jwk.JWKSet
import com.nimbusds.jose.jwk.RSAKey
import com.nimbusds.jose.jwk.source.JWKSource
import com.nimbusds.jose.proc.JWEDecryptionKeySelector
import com.nimbusds.jose.proc.JWSVerificationKeySelector
import com.nimbusds.jose.proc.SecurityContext
import com.nimbusds.jwt.proc.DefaultJWTProcessor
import io.github.susimsek.springbootjwedemo.security.CookieBearerTokenResolver
import io.github.susimsek.springbootjwedemo.security.KeyUtils
import org.springframework.context.annotation.Bean
import org.springframework.context.annotation.Configuration
import org.springframework.security.oauth2.jwt.JwtDecoder
import org.springframework.security.oauth2.jwt.JwtEncoder
import org.springframework.security.oauth2.jwt.NimbusJwtDecoder
import org.springframework.security.oauth2.jwt.NimbusJwtEncoder
import org.springframework.security.oauth2.server.resource.authentication.JwtAuthenticationConverter
import org.springframework.security.oauth2.server.resource.authentication.JwtGrantedAuthoritiesConverter
import org.springframework.security.oauth2.server.resource.web.BearerTokenResolver

@Configuration
class SecurityJwtConfig(private val props: JwtProperties) {

    @Bean
    @Throws(Exception::class)
    fun signingKey(): RSAKey =
        KeyUtils.buildRsaKey(
            props.signing.publicKey,
            props.signing.privateKey,
            props.signing.keyId,
            true
        )

    @Bean
    @Throws(Exception::class)
    fun encryptionKey(): RSAKey =
        KeyUtils.buildRsaKey(
            props.encryption.publicKey,
            props.encryption.privateKey,
            props.encryption.keyId,
            false
        )

    @Bean
    fun jwkSource(signingKey: RSAKey, encryptionKey: RSAKey): JWKSource&lt;SecurityContext&gt; {
        val jwkSet = JWKSet(listOf(signingKey, encryptionKey))
        return JWKSource { jwkSelector, context -&gt; jwkSelector.select(jwkSet) }
    }

    @Bean
    fun jwtDecoder(jwkSource: JWKSource&lt;SecurityContext&gt;): JwtDecoder {
        val jwtProcessor = DefaultJWTProcessor&lt;SecurityContext&gt;()
        val jweKeySelector = JWEDecryptionKeySelector(
            JWEAlgorithm.RSA_OAEP_256,
            EncryptionMethod.A128GCM,
            jwkSource
        )
        jwtProcessor.jweKeySelector = jweKeySelector
        val jwsKeySelector = JWSVerificationKeySelector(
            JWSAlgorithm.RS256,
            jwkSource
        )
        jwtProcessor.jwsKeySelector = jwsKeySelector
        jwtProcessor.jwtClaimsSetVerifier = { _, _ -&gt; }
        return NimbusJwtDecoder(jwtProcessor)
    }

    @Bean
    fun jwtEncoder(jwkSource: JWKSource&lt;SecurityContext&gt;): JwtEncoder =
        NimbusJwtEncoder(jwkSource)

    @Bean
    fun jwtAuthenticationConverter(): JwtAuthenticationConverter {
        val converter = JwtGrantedAuthoritiesConverter().apply {
            setAuthorityPrefix(&quot;&quot;)
            setAuthoritiesClaimName(AUTHORITIES_KEY)
        }
        return JwtAuthenticationConverter().apply {
            setJwtGrantedAuthoritiesConverter(converter)
        }
    }

    @Bean
    fun bearerTokenResolver(): BearerTokenResolver =
        CookieBearerTokenResolver().apply {
            setAllowUriQueryParameter(false)
            setAllowFormEncodedBodyParameter(false)
            setAllowCookie(true)
        }
}</code></pre>
<h3>SecurityConfig</h3>
<h3>Java</h3>
<pre><code class="language-java">package io.github.susimsek.springbootjwedemo.config;

import io.github.susimsek.springbootjwedemo.security.AuthoritiesConstants;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.security.authentication.AuthenticationManager;
import org.springframework.security.authentication.ProviderManager;
import org.springframework.security.authentication.dao.DaoAuthenticationProvider;
import org.springframework.security.config.annotation.method.configuration.EnableMethodSecurity;
import org.springframework.security.config.annotation.web.builders.HttpSecurity;
import org.springframework.security.config.annotation.web.configurers.AbstractHttpConfigurer;
import org.springframework.security.config.http.SessionCreationPolicy;
import org.springframework.security.core.userdetails.User;
import org.springframework.security.core.userdetails.UserDetailsService;
import org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder;
import org.springframework.security.crypto.password.PasswordEncoder;
import org.springframework.security.provisioning.InMemoryUserDetailsManager;
import org.springframework.security.web.SecurityFilterChain;
import org.springframework.security.web.servlet.util.matcher.MvcRequestMatcher;
import org.springframework.web.servlet.handler.HandlerMappingIntrospector;

import static org.springframework.security.config.Customizer.withDefaults;

@Configuration
@EnableMethodSecurity(securedEnabled = true)
public class SecurityConfig {

    @Bean
    public InMemoryUserDetailsManager userDetailsService(AdminProperties adminProps,
                                                         UserProperties userProps,
                                                         PasswordEncoder passwordEncoder) {
        var admin = User.withUsername(adminProps.getUsername())
            .password(passwordEncoder.encode(adminProps.getPassword()))
            .authorities(AuthoritiesConstants.ADMIN)
            .build();

        var user = User.withUsername(userProps.getUsername())
            .password(passwordEncoder.encode(userProps.getPassword()))
            .authorities(AuthoritiesConstants.USER)
            .build();

        return new InMemoryUserDetailsManager(admin, user);
    }

    @Bean public PasswordEncoder passwordEncoder() { return new BCryptPasswordEncoder(); }

    @Bean
    public AuthenticationManager authenticationManager(UserDetailsService uds) {
        var provider = new DaoAuthenticationProvider();
        provider.setUserDetailsService(uds);
        provider.setPasswordEncoder(passwordEncoder());
        return new ProviderManager(provider);
    }

    @Bean
    public SecurityFilterChain filterChain(HttpSecurity http,
                                           MvcRequestMatcher.Builder mvc) throws Exception {
        http
            .cors(withDefaults())
            .csrf(AbstractHttpConfigurer::disable)
            .authorizeHttpRequests(authz -&gt;
                authz
                    .requestMatchers(mvc.pattern(&quot;/*.ico&quot;), mvc.pattern(&quot;/*.png&quot;), mvc.pattern(&quot;/*.svg&quot;),
                        mvc.pattern(&quot;/*.webapp&quot;)
                    ).permitAll()
                    .requestMatchers(&quot;/actuator/**&quot;).permitAll()
                    .requestMatchers(
                        &quot;/v3/api-docs/**&quot;,
                        &quot;/swagger-ui.html&quot;,
                        &quot;/swagger-ui/**&quot;
                    ).permitAll()
                    .requestMatchers(mvc.pattern(&quot;/api/auth/login&quot;)).permitAll()
                    .requestMatchers(mvc.pattern(&quot;/api/hello/admin&quot;)).hasAuthority(AuthoritiesConstants.ADMIN)
                .anyRequest().authenticated()
            )
            .sessionManagement(session -&gt;
                session.sessionCreationPolicy(SessionCreationPolicy.STATELESS))
            .oauth2ResourceServer(oauth2 -&gt; oauth2
                .jwt(withDefaults())
            );
        return http.build();
    }

    @Bean
    public MvcRequestMatcher.Builder mvc(HandlerMappingIntrospector introspector) {
        return new MvcRequestMatcher.Builder(introspector);
    }
}</code></pre>
<h3>Kotlin</h3>
<pre><code class="language-kotlin">package io.github.susimsek.springbootjwedemo.config

import io.github.susimsek.springbootjwedemo.security.AuthoritiesConstants
import org.springframework.context.annotation.Bean
import org.springframework.context.annotation.Configuration
import org.springframework.security.authentication.AuthenticationManager
import org.springframework.security.authentication.ProviderManager
import org.springframework.security.authentication.dao.DaoAuthenticationProvider
import org.springframework.security.config.annotation.method.configuration.EnableMethodSecurity
import org.springframework.security.config.annotation.web.builders.HttpSecurity
import org.springframework.security.config.http.SessionCreationPolicy
import org.springframework.security.core.userdetails.User
import org.springframework.security.core.userdetails.UserDetailsService
import org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder
import org.springframework.security.crypto.password.PasswordEncoder
import org.springframework.security.provisioning.InMemoryUserDetailsManager
import org.springframework.security.web.SecurityFilterChain
import org.springframework.security.web.servlet.util.matcher.MvcRequestMatcher
import org.springframework.web.servlet.handler.HandlerMappingIntrospector
import org.springframework.security.config.Customizer.withDefaults

@Configuration
@EnableMethodSecurity(securedEnabled = true)
class SecurityConfig {

    @Bean
    fun userDetailsService(
        adminProps: AdminProperties,
        userProps: UserProperties,
        passwordEncoder: PasswordEncoder
    ): UserDetailsService {
        val admin = User.withUsername(adminProps.username)
            .password(passwordEncoder.encode(adminProps.password))
            .authorities(AuthoritiesConstants.ADMIN)
            .build()
        val user = User.withUsername(userProps.username)
            .password(passwordEncoder.encode(userProps.password))
            .authorities(AuthoritiesConstants.USER)
            .build()
        return InMemoryUserDetailsManager(admin, user)
    }

    @Bean
    fun passwordEncoder(): PasswordEncoder = BCryptPasswordEncoder()

    @Bean
    fun authenticationManager(uds: UserDetailsService): AuthenticationManager {
        val provider = DaoAuthenticationProvider().apply {
            setUserDetailsService(uds)
            setPasswordEncoder(passwordEncoder())
        }
        return ProviderManager(provider)
    }

    @Bean
    fun filterChain(http: HttpSecurity, mvc: MvcRequestMatcher.Builder): SecurityFilterChain =
        http.cors(withDefaults())
            .csrf { it.disable() }
            .authorizeHttpRequests { authz -&gt;
                authz
                    .requestMatchers(mvc.pattern(&quot;/*.ico&quot;), mvc.pattern(&quot;/*.png&quot;), mvc.pattern(&quot;/*.svg&quot;), mvc.pattern(&quot;/*.webapp&quot;)).permitAll()
                    .requestMatchers(&quot;/actuator/**&quot;).permitAll()
                    .requestMatchers(&quot;/v3/api-docs/**&quot;, &quot;/swagger-ui.html&quot;, &quot;/swagger-ui/**&quot;).permitAll()
                    .requestMatchers(mvc.pattern(&quot;/api/auth/login&quot;)).permitAll()
                    .requestMatchers(mvc.pattern(&quot;/api/hello/admin&quot;)).hasAuthority(AuthoritiesConstants.ADMIN)
                    .anyRequest().authenticated()
            }
            .sessionManagement { it.sessionCreationPolicy(SessionCreationPolicy.STATELESS) }
            .oauth2ResourceServer { it.jwt(withDefaults()) }
            .build()

    @Bean
    fun mvc(introspector: HandlerMappingIntrospector): MvcRequestMatcher.Builder =
        MvcRequestMatcher.Builder(introspector)
}</code></pre>
<h3>JwtProperties</h3>
<h3>Java</h3>
<pre><code class="language-java">package io.github.susimsek.springbootjwedemo.config;

import lombok.Data;
import org.springframework.boot.context.properties.ConfigurationProperties;
import org.springframework.context.annotation.Configuration;

import java.time.Duration;

@Configuration
@ConfigurationProperties(prefix = &quot;security.jwt&quot;)
@Data
public class JwtProperties {

    @Data
    public static class Pair {
        private String publicKey;
        private String privateKey;
        private String keyId;
    }

    private Pair signing;
    private Pair encryption;
    private String issuer;
    private Duration expirationDuration;
}</code></pre>
<h3>Kotlin</h3>
<pre><code class="language-kotlin">package io.github.susimsek.springbootjwedemo.config

import org.springframework.boot.context.properties.ConfigurationProperties
import org.springframework.context.annotation.Configuration
import java.time.Duration

@Configuration
@ConfigurationProperties(prefix = &quot;security.jwt&quot;)
class JwtProperties {

  class Pair {
    lateinit var publicKey: String
    lateinit var privateKey: String
    lateinit var keyId: String
  }

  lateinit var signing: Pair
  lateinit var encryption: Pair
  lateinit var issuer: String
  lateinit var expirationDuration: Duration
}</code></pre>
<h3>UserProperties</h3>
<h3>Java</h3>
<pre><code class="language-java">package io.github.susimsek.springbootjwedemo.config;

import lombok.Data;
import org.springframework.boot.context.properties.ConfigurationProperties;
import org.springframework.context.annotation.Configuration;

@Configuration
@ConfigurationProperties(prefix = &quot;security.user&quot;)
@Data
public class UserProperties {
    private String username;
    private String password;
}</code></pre>
<h3>Kotlin</h3>
<pre><code class="language-kotlin">package io.github.susimsek.springbootjwedemo.config

import org.springframework.boot.context.properties.ConfigurationProperties
import org.springframework.context.annotation.Configuration

@Configuration
@ConfigurationProperties(prefix = &quot;security.user&quot;)
class UserProperties {
  lateinit var username: String
  lateinit var password: String
}</code></pre>
<hr />
<h2>üõ†Ô∏è Step 4: Secure JWE Token Utilities</h2>
<p>In this section, we define the core utility classes and constants needed to generate, encrypt, and resolve JSON Web Encryption (JWE) tokens in your Spring Boot application. These components work together to:</p>
<ul>
<li>AuthoritiesConstants: Centralize role names with the `ROLE_` prefix.</li>
<li>CookieBearerTokenResolver: Resolve bearer tokens from Authorization headers or HTTP cookies.</li>
<li>CookieUtils: Create HTTP-only, secure cookies for access tokens.</li>
<li>JweUtil: Sign (JWS) and encrypt (JWE) JWTs using RSA keys and Nimbus.</li>
<li>KeyUtils: Build RSA JWKs from PEM‚Äêencoded key material.</li>
<li>SecurityUtils: Extract the current user‚Äôs login from the security context.</li>
</ul>
<p>These utilities form the foundation for a stateless, JWE‚Äêbased authentication flow in Spring Security.</p>
<h3>AuthoritiesConstants</h3>
<h3>Java</h3>
<pre><code class="language-java">
package io.github.susimsek.springbootjwedemo.security;

import lombok.AccessLevel;
import lombok.NoArgsConstructor;

@NoArgsConstructor(access = AccessLevel.PRIVATE)
public final class AuthoritiesConstants {
    public static final String ADMIN = &quot;ROLE_ADMIN&quot;;
    public static final String USER = &quot;ROLE_USER&quot;;
    public static final String ANONYMOUS = &quot;ROLE_ANONYMOUS&quot;;
}</code></pre>
<h3>Kotlin</h3>
<pre><code class="language-kotlin">
package io.github.susimsek.springbootjwedemo.security

object AuthoritiesConstants {
  const val ADMIN = &quot;ROLE_ADMIN&quot;
  const val USER = &quot;ROLE_USER&quot;
  const val ANONYMOUS = &quot;ROLE_ANONYMOUS&quot;
}</code></pre>
<h3>CookieBearerTokenResolver</h3>
<h3>Java</h3>
<pre><code class="language-java">package io.github.susimsek.springbootjwedemo.security;

import jakarta.servlet.http.Cookie;
import jakarta.servlet.http.HttpServletRequest;
import lombok.Setter;
import org.springframework.http.HttpMethod;
import org.springframework.security.oauth2.core.OAuth2AuthenticationException;
import org.springframework.security.oauth2.server.resource.BearerTokenError;
import org.springframework.security.oauth2.server.resource.BearerTokenErrors;
import org.springframework.security.oauth2.server.resource.web.BearerTokenResolver;
import org.springframework.util.StringUtils;

import java.util.regex.Matcher;
import java.util.regex.Pattern;

@Setter
public class CookieBearerTokenResolver implements BearerTokenResolver {
    private static final String ACCESS_TOKEN_PARAMETER_NAME = &quot;access_token&quot;;
    private static final Pattern AUTHORIZATION_PATTERN =
        Pattern.compile(&quot;^Bearer (?&lt;token&gt;[A-Za-z0-9-._~+/]+=*)$&quot;, Pattern.CASE_INSENSITIVE);

    private boolean allowFormEncodedBodyParameter = false;
    private boolean allowUriQueryParameter       = false;
    private boolean allowCookie                  = true;
    private String  bearerTokenHeaderName       = &quot;Authorization&quot;;
    private String  cookieName                  = &quot;accessToken&quot;;

    @Override
    public String resolve(HttpServletRequest request) {
        String headerToken = resolveFromAuthorizationHeader(request);
        String queryToken  = resolveAccessTokenFromQueryString(request);
        String bodyToken   = resolveAccessTokenFromBody(request);
        String cookieToken = (headerToken == null &amp;&amp; queryToken == null &amp;&amp; bodyToken == null)
            ? resolveFromCookie(request)
            : null;

        return resolveToken(headerToken, queryToken, bodyToken, cookieToken);
    }

    private String resolveFromAuthorizationHeader(HttpServletRequest request) {
        String authorization = request.getHeader(this.bearerTokenHeaderName);
        if (!StringUtils.hasText(authorization) || !authorization.toLowerCase().startsWith(&quot;bearer&quot;)) {
            return null;
        }
        Matcher matcher = AUTHORIZATION_PATTERN.matcher(authorization.trim());
        if (!matcher.matches()) {
            BearerTokenError error = BearerTokenErrors.invalidToken(&quot;Bearer token is malformed&quot;);
            throw new OAuth2AuthenticationException(error);
        }
        return matcher.group(&quot;token&quot;);
    }

    private String resolveAccessTokenFromQueryString(HttpServletRequest request) {
        if (allowUriQueryParameter &amp;&amp; HttpMethod.GET.matches(request.getMethod())) {
            return resolveToken(request.getParameterValues(ACCESS_TOKEN_PARAMETER_NAME));
        }
        return null;
    }

    private String resolveAccessTokenFromBody(HttpServletRequest request) {
        if (allowFormEncodedBodyParameter
            &amp;&amp; HttpMethod.POST.matches(request.getMethod())
            &amp;&amp; &quot;application/x-www-form-urlencoded&quot;.equals(request.getContentType())) {
            return resolveToken(request.getParameterValues(ACCESS_TOKEN_PARAMETER_NAME));
        }
        return null;
    }

    private String resolveFromCookie(HttpServletRequest request) {
        if (!allowCookie || request.getCookies() == null) {
            return null;
        }
        for (Cookie cookie : request.getCookies()) {
            if (cookieName.equals(cookie.getName())) {
                String val = cookie.getValue();
                return StringUtils.hasText(val) ? val : null;
            }
        }
        return null;
    }

    private String resolveToken(String... tokens) {
        String found = null;
        for (String token : tokens) {
            if (token == null) continue;
            if (found != null) {
                BearerTokenError error = BearerTokenErrors.invalidRequest(&quot;Found multiple bearer tokens in the request&quot;);
                throw new OAuth2AuthenticationException(error);
            }
            found = token;
        }
        if (found != null &amp;&amp; found.isBlank()) {
            BearerTokenError error = BearerTokenErrors.invalidRequest(&quot;The requested token parameter is an empty string&quot;);
            throw new OAuth2AuthenticationException(error);
        }
        return found;
    }</code></pre>
<h3>Kotlin</h3>
<pre><code class="language-kotlin">package io.github.susimsek.springbootjwedemo.security

import jakarta.servlet.http.Cookie
import jakarta.servlet.http.HttpServletRequest
import org.springframework.http.HttpMethod
import org.springframework.security.oauth2.core.OAuth2AuthenticationException
import org.springframework.security.oauth2.server.resource.BearerTokenError
import org.springframework.security.oauth2.server.resource.BearerTokenErrors
import org.springframework.security.oauth2.server.resource.web.BearerTokenResolver
import org.springframework.util.StringUtils
import java.util.regex.Pattern

class CookieBearerTokenResolver {
    var allowFormEncodedBodyParameter: Boolean = false
    var allowUriQueryParameter: Boolean = false
    var allowCookie: Boolean = true
    var bearerTokenHeaderName: String = &quot;Authorization&quot;
    var cookieName: String = &quot;accessToken&quot;

    companion object {
        private const val ACCESS_TOKEN_PARAMETER_NAME = &quot;access_token&quot;
        private val AUTHORIZATION_PATTERN =
            Pattern.compile(&quot;^Bearer (?&lt;token&gt;[A-Za-z0-9-._~+/]+=*)$&quot;, Pattern.CASE_INSENSITIVE)
    }

    fun resolve(request: HttpServletRequest): String? {
        val header = resolveFromAuthorizationHeader(request)
        val query  = if (allowUriQueryParameter &amp;&amp; HttpMethod.GET.matches(request.method))
            request.getParameterValues(ACCESS_TOKEN_PARAMETER_NAME)?.let(::resolveToken)
        else null
        val body   = if (allowFormEncodedBodyParameter &amp;&amp; HttpMethod.POST.matches(request.method)
            &amp;&amp; request.contentType == &quot;application/x-www-form-urlencoded&quot;)
            request.getParameterValues(ACCESS_TOKEN_PARAMETER_NAME)?.let(::resolveToken)
        else null
        val cookie = if (header == null &amp;&amp; query == null &amp;&amp; body == null)
            resolveFromCookie(request)
        else null
      return listOf(header, query, body, cookie).filterNotNull().let {
            if (it.size &gt; 1) throw OAuth2AuthenticationException(BearerTokenErrors.invalidRequest(&quot;Found multiple bearer tokens&quot;))
            it.firstOrNull()?: null
        }
    }

    private fun resolveFromAuthorizationHeader(request: HttpServletRequest): String? {
        val auth = request.getHeader(bearerTokenHeaderName) ?: return null
        if (!auth.startsWith(&quot;Bearer &quot;, true)) return null
        val matcher = AUTHORIZATION_PATTERN.matcher(auth.trim())
        return if (matcher.matches()) matcher.group(&quot;token&quot;)
        else throw OAuth2AuthenticationException(BearerTokenErrors.invalidToken(&quot;Malformed token&quot;))
    }

    private fun resolveFromCookie(request: HttpServletRequest): String? {
        if (!allowCookie) return null
        return request.cookies?.firstOrNull { it.name == cookieName }?.value?.takeIf { it.isNotBlank() }
    }

    private fun resolveToken(tokens: Array&lt;String&gt;): String? {
        return tokens.filter { it.isNotBlank() }.let {
            when {
                it.isEmpty() -&gt; null
                it.size &gt; 1   -&gt; throw OAuth2AuthenticationException(BearerTokenErrors.invalidRequest(&quot;Multiple tokens&quot;))
                else          -&gt; it[0]
            }
        }
    }</code></pre>
<h3>CookieUtils</h3>
<h3>Java</h3>
<pre><code class="language-java">package io.github.susimsek.springbootjwedemo.security;

import io.github.susimsek.springbootjwedemo.dto.TokenDTO;
import lombok.experimental.UtilityClass;
import org.springframework.http.ResponseCookie;

@UtilityClass
public class CookieUtils {

    private static final String COOKIE_NAME = &quot;accessToken&quot;;

    public ResponseCookie createAccessTokenCookie(TokenDTO tokenDto) {
        return ResponseCookie.from(COOKIE_NAME, tokenDto.accessToken())
            .httpOnly(true)
            .secure(true)
            .path(&quot;/&quot;)
            .maxAge(tokenDto.accessTokenExpiresIn())
            .sameSite(&quot;Strict&quot;)
            .build();
    }
}</code></pre>
<h3>Kotlin</h3>
<pre><code class="language-kotlin">package io.github.susimsek.springbootjwedemo.security

import io.github.susimsek.springbootjwedemo.dto.TokenDTO
import org.springframework.http.ResponseCookie

object CookieUtils {

  private const val COOKIE_NAME = &quot;accessToken&quot;

  fun createAccessTokenCookie(tokenDto: TokenDTO): ResponseCookie {
    return ResponseCookie.from(COOKIE_NAME, tokenDto.accessToken())
      .httpOnly(true)
      .secure(true)
      .path(&quot;/&quot;)
      .maxAge(tokenDto.accessTokenExpiresIn())
      .sameSite(&quot;Strict&quot;)
      .build()
  }
}</code></pre>
<h3>JweUtil</h3>
<h3>Java</h3>
<pre><code class="language-java">package io.github.susimsek.springbootjwedemo.security;

import com.nimbusds.jose.EncryptionMethod;
import com.nimbusds.jose.JOSEException;
import com.nimbusds.jose.JWEAlgorithm;
import com.nimbusds.jose.JWEHeader;
import com.nimbusds.jose.JWEObject;
import com.nimbusds.jose.Payload;
import com.nimbusds.jose.crypto.RSAEncrypter;
import com.nimbusds.jose.jwk.RSAKey;
import io.github.susimsek.springbootjwedemo.config.JwtProperties;
import io.github.susimsek.springbootjwedemo.dto.TokenDTO;
import lombok.RequiredArgsConstructor;
import org.springframework.security.core.Authentication;
import org.springframework.security.core.GrantedAuthority;
import org.springframework.security.oauth2.jose.jws.SignatureAlgorithm;
import org.springframework.security.oauth2.jwt.*;
import org.springframework.stereotype.Component;

import java.time.Instant;
import java.util.List;

import static io.github.susimsek.springbootjwedemo.security.SecurityUtils.AUTHORITIES_KEY;

@Component
@RequiredArgsConstructor
public class JweUtil {

    private final JwtEncoder jwtEncoder;
    private final RSAKey signingKey;
    private final RSAKey encryptionKey;
    private final JwtProperties props;

    public TokenDTO generateToken(Authentication authentication) throws JOSEException {
        String subject = authentication.getName();
        List&lt;String&gt; roles = authentication.getAuthorities()
            .stream()
            .map(GrantedAuthority::getAuthority)
            .toList();

        Instant now = Instant.now();
        long expiresIn = props.getExpirationDuration().getSeconds();
        Instant exp = now.plusSeconds(expiresIn);

        JwtClaimsSet claims = JwtClaimsSet.builder()
            .issuer(props.getIssuer())
            .issuedAt(now)
            .expiresAt(exp)
            .subject(subject)
            .claim(AUTHORITIES_KEY, roles)
            .build();

        JwsHeader jwsHeader = JwsHeader.with(SignatureAlgorithm.RS256)
            .keyId(signingKey.getKeyID())
            .build();

        String jws = jwtEncoder
            .encode(JwtEncoderParameters.from(jwsHeader, claims))
            .getTokenValue();

        JWEHeader jweHeader = new JWEHeader.Builder(JWEAlgorithm.RSA_OAEP_256, EncryptionMethod.A128GCM)
            .contentType(&quot;JWT&quot;)
            .keyID(encryptionKey.getKeyID())
            .build();

        JWEObject jweObject = new JWEObject(jweHeader, new Payload(jws));
        jweObject.encrypt(new RSAEncrypter(encryptionKey.toRSAPublicKey()));
        String token = jweObject.serialize();

        return new TokenDTO(token, &quot;Bearer&quot;, expiresIn);
    }
}</code></pre>
<h3>Kotlin</h3>
<pre><code class="language-kotlin">package io.github.susimsek.springbootjwedemo.security

import com.nimbusds.jose.EncryptionMethod
import com.nimbusds.jose.JOSEException
import com.nimbusds.jose.JWEAlgorithm
import com.nimbusds.jose.JWEHeader
import com.nimbusds.jose.JWEObject
import com.nimbusds.jose.Payload
import com.nimbusds.jose.crypto.RSAEncrypter
import com.nimbusds.jose.jwk.RSAKey
import io.github.susimsek.springbootjwedemo.config.JwtProperties
import io.github.susimsek.springbootjwedemo.dto.TokenDTO
import lombok.RequiredArgsConstructor
import org.springframework.security.core.Authentication
import org.springframework.security.oauth2.jose.jws.SignatureAlgorithm
import org.springframework.security.oauth2.jwt.JwtClaimsSet
import org.springframework.security.oauth2.jwt.JwtEncoder
import org.springframework.security.oauth2.jwt.JwtEncoderParameters
import org.springframework.stereotype.Component

import java.time.Instant

@Component
@RequiredArgsConstructor
class JweUtil(
    private val jwtEncoder: JwtEncoder,
    private val signingKey: RSAKey,
    private val encryptionKey: RSAKey,
    private val props: JwtProperties
) {
    fun generateToken(authentication: Authentication): TokenDTO {
        val subject = authentication.name
        val roles = authentication.authorities.map { it.authority }

        val now = Instant.now()
        val expiresIn = props.expirationDuration.seconds
        val exp = now.plusSeconds(expiresIn)

        val claims = JwtClaimsSet.builder()
            .issuer(props.issuer)
            .issuedAt(now)
            .expiresAt(exp)
            .subject(subject)
            .claim(AUTHORITIES_KEY, roles)
            .build()

        val jwsHeader = org.springframework.security.oauth2.jwt.JwsHeader.with(SignatureAlgorithm.RS256)
            .keyId(signingKey.keyID)
            .build()

        val jws = jwtEncoder
            .encode(JwtEncoderParameters.from(jwsHeader, claims))
            .tokenValue

        val jweHeader = JWEHeader.Builder(JWEAlgorithm.RSA_OAEP_256, EncryptionMethod.A128GCM)
            .contentType(&quot;JWT&quot;)
            .keyID(encryptionKey.keyID)
            .build()

        val jweObject = JWEObject(jweHeader, Payload(jws))
        jweObject.encrypt(RSAEncrypter(encryptionKey.toRSAPublicKey()))
        val token = jweObject.serialize()

        return TokenDTO(token, &quot;Bearer&quot;, expiresIn)
    }
}</code></pre>
<h3>KeyUtils</h3>
<h3>Java</h3>
<pre><code class="language-java">package io.github.susimsek.springbootjwedemo.security;

import com.nimbusds.jose.JWEAlgorithm;
import com.nimbusds.jose.JWSAlgorithm;
import com.nimbusds.jose.jwk.KeyUse;
import com.nimbusds.jose.jwk.RSAKey;
import lombok.experimental.UtilityClass;

import java.security.KeyFactory;
import java.security.interfaces.RSAPrivateKey;
import java.security.interfaces.RSAPublicKey;
import java.security.spec.PKCS8EncodedKeySpec;
import java.security.spec.X509EncodedKeySpec;
import java.util.Base64;

@UtilityClass
public class KeyUtils {
    public RSAKey buildRsaKey(
            String pubPem,
            String privPem,
            String kid,
            boolean forSign
    ) throws Exception {
        String pubContent = pubPem
            .replace(&quot;-----BEGIN PUBLIC KEY-----&quot;, &quot;&quot;)
            .replace(&quot;-----END PUBLIC KEY-----&quot;, &quot;&quot;)
            .replaceAll(&quot;\\s&quot;, &quot;&quot;);
        String privContent = privPem
            .replace(&quot;-----BEGIN PRIVATE KEY-----&quot;, &quot;&quot;)
            .replace(&quot;-----END PRIVATE KEY-----&quot;, &quot;&quot;)
            .replaceAll(&quot;\\s&quot;, &quot;&quot;);

        byte[] decodedPub = Base64.getDecoder().decode(pubContent);
        byte[] decodedPriv = Base64.getDecoder().decode(privContent);

        KeyFactory kf = KeyFactory.getInstance(&quot;RSA&quot;);
        RSAPublicKey publicKey = (RSAPublicKey) kf.generatePublic(new X509EncodedKeySpec(decodedPub));
        RSAPrivateKey privateKey = (RSAPrivateKey) kf.generatePrivate(new PKCS8EncodedKeySpec(decodedPriv));

        RSAKey.Builder builder = new RSAKey.Builder(publicKey)
            .privateKey(privateKey)
            .keyID(kid);

        if (forSign) {
            builder
                .algorithm(JWSAlgorithm.RS256)
                .keyUse(KeyUse.SIGNATURE);
        } else {
            builder
                .algorithm(JWEAlgorithm.RSA_OAEP_256)
                .keyUse(KeyUse.ENCRYPTION);
        }

        return builder.build();
    }
}</code></pre>
<h3>Kotlin</h3>
<pre><code class="language-kotlin">package io.github.susimsek.springbootjwedemo.security

import com.nimbusds.jose.JWEAlgorithm
import com.nimbusds.jose.JWSAlgorithm
import com.nimbusds.jose.jwk.KeyUse
import com.nimbusds.jose.jwk.RSAKey
import java.security.KeyFactory
import java.security.interfaces.RSAPrivateKey
import java.security.interfaces.RSAPublicKey
import java.security.spec.PKCS8EncodedKeySpec
import java.security.spec.X509EncodedKeySpec
import java.util.Base64

object KeyUtils {
    @JvmStatic
    @Throws(Exception::class)
    fun buildRsaKey(
        pubPem: String,
        privPem: String,
        kid: String,
        forSign: Boolean
    ): RSAKey {
        val pubContent = pubPem
            .replace(&quot;-----BEGIN PUBLIC KEY-----&quot;, &quot;&quot;)
            .replace(&quot;-----END PUBLIC KEY-----&quot;, &quot;&quot;)
            .replace(Regex(&quot;\\s&quot;), &quot;&quot;)
        val privContent = privPem
            .replace(&quot;-----BEGIN PRIVATE KEY-----&quot;, &quot;&quot;)
            .replace(&quot;-----END PRIVATE KEY-----&quot;, &quot;&quot;)
            .replace(Regex(&quot;\\s&quot;), &quot;&quot;)

        val decodedPub = Base64.getDecoder().decode(pubContent)
        val decodedPriv = Base64.getDecoder().decode(privContent)

        val kf = KeyFactory.getInstance(&quot;RSA&quot;)
        val publicKey = kf.generatePublic(X509EncodedKeySpec(decodedPub)) as RSAPublicKey
        val privateKey = kf.generatePrivate(PKCS8EncodedKeySpec(decodedPriv)) as RSAPrivateKey

        val builder = RSAKey.Builder(publicKey)
            .privateKey(privateKey)
            .keyID(kid)

        if (forSign) {
            builder
                .algorithm(JWSAlgorithm.RS256)
                .keyUse(KeyUse.SIGNATURE)
        } else {
            builder
                .algorithm(JWEAlgorithm.RSA_OAEP_256)
                .keyUse(KeyUse.ENCRYPTION)
        }

        return builder.build()
    }
}</code></pre>
<h3>SecurityUtils</h3>
<h3>Java</h3>
<pre><code class="language-java">package io.github.susimsek.springbootjwedemo.security;

import lombok.experimental.UtilityClass;
import org.springframework.security.core.Authentication;
import org.springframework.security.core.context.SecurityContextHolder;
import org.springframework.security.core.userdetails.UserDetails;
import org.springframework.security.oauth2.jwt.Jwt;

import java.util.Optional;

@UtilityClass
public class SecurityUtils {

    public static final String AUTHORITIES_KEY = &quot;auth&quot;;

    public Optional&lt;String&gt; getCurrentUserLogin() {
        var ctx = SecurityContextHolder.getContext();
        return Optional.ofNullable(extractPrincipal(ctx.getAuthentication()));
    }

    private String extractPrincipal(Authentication authentication) {
        if (authentication == null) {
            return null;
        }
        Object principal = authentication.getPrincipal();
        if (principal instanceof Jwt jwt) {
            return jwt.getSubject();
        }
        if (principal instanceof UserDetails ud) {
            return ud.getUsername();
        }
        if (principal instanceof String username) {
            return username;
        }
        return null;
    }
}</code></pre>
<h3>Kotlin</h3>
<pre><code class="language-kotlin">package io.github.susimsek.springbootjwedemo.security

import org.springframework.security.core.Authentication
import org.springframework.security.core.context.SecurityContextHolder
import org.springframework.security.core.userdetails.UserDetails
import org.springframework.security.oauth2.jwt.Jwt
import java.util.Optional

object SecurityUtils {
  const val AUTHORITIES_KEY = &quot;auth&quot;

  fun getCurrentUserLogin(): Optional&lt;String&gt; {
    val authentication: Authentication? = SecurityContextHolder.getContext().authentication
    return Optional.ofNullable(extractPrincipal(authentication))
  }

  private fun extractPrincipal(authentication: Authentication?): String? {
    return when (val principal = authentication?.principal) {
      is Jwt -&gt; principal.subject
      is UserDetails -&gt; principal.username
      is String -&gt; principal
      else -&gt; null
    }
  }
}</code></pre>
<hr />
<h2>üõ†Ô∏è Step 5: Authentication &amp; Protected Endpoints</h2>
<p>In this section, we define the REST controllers and DTOs necessary for:</p>
<ul>
<li>AuthController: Authenticate users, issue JWE tokens, and set secure cookies.</li>
<li>HelloController: Expose protected resource endpoints for authenticated users and admin-specific paths.</li>
<li>LoginRequestDTO: Model the login request payload (username/password).</li>
<li>TokenDTO: Model the authentication response including token and expiration.</li>
</ul>
<p>These components complete the stateless authentication flow by handling login, token issuance, cookie management, and resource protection.</p>
<p>In this section, we expose REST controllers and DTOs to handle user authentication, token issuance, and protected resource access.</p>
<h3>AuthController</h3>
<h3>Java</h3>
<pre><code class="language-java">package io.github.susimsek.springbootjwedemo.controller;

import io.github.susimsek.springbootjwedemo.dto.LoginRequestDTO;
import io.github.susimsek.springbootjwedemo.dto.TokenDTO;
import io.github.susimsek.springbootjwedemo.security.CookieUtils;
import io.github.susimsek.springbootjwedemo.security.JweUtil;
import lombok.RequiredArgsConstructor;
import org.springframework.http.HttpHeaders;
import org.springframework.http.ResponseCookie;
import org.springframework.http.ResponseEntity;
import org.springframework.security.authentication.AuthenticationManager;
import org.springframework.security.authentication.UsernamePasswordAuthenticationToken;
import org.springframework.security.core.Authentication;
import org.springframework.security.core.context.SecurityContextHolder;
import org.springframework.web.bind.annotation.PostMapping;
import org.springframework.web.bind.annotation.RequestBody;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;

@RestController
@RequiredArgsConstructor
@RequestMapping(&quot;/api/auth&quot;)
public class AuthController {

    private final AuthenticationManager authenticationManager;
    private final JweUtil jweUtil;

    @PostMapping(&quot;/login&quot;)
    public ResponseEntity&lt;TokenDTO&gt; login(@RequestBody LoginRequestDTO loginRequest) throws Exception {
        // Authenticate user
        var authToken = new UsernamePasswordAuthenticationToken(
            loginRequest.username(), loginRequest.password()
        );
        Authentication auth = authenticationManager.authenticate(authToken);
        SecurityContextHolder.getContext().setAuthentication(auth);

        // Generate JWE token and cookie
        TokenDTO tokenDto = jweUtil.generateToken(auth);
        ResponseCookie cookie = CookieUtils.createAccessTokenCookie(tokenDto);

        return ResponseEntity.ok()
            .header(HttpHeaders.SET_COOKIE, cookie.toString())
            .body(tokenDto);
    }
}</code></pre>
<h3>Kotlin</h3>
<pre><code class="language-kotlin">package io.github.susimsek.springbootjwedemo.controller

import io.github.susimsek.springbootjwedemo.dto.LoginRequestDTO
import io.github.susimsek.springbootjwedemo.dto.TokenDTO
import io.github.susimsek.springbootjwedemo.security.CookieUtils
import io.github.susimsek.springbootjwedemo.security.JweUtil
import lombok.RequiredArgsConstructor
import org.springframework.http.HttpHeaders
import org.springframework.http.ResponseCookie
import org.springframework.http.ResponseEntity
import org.springframework.security.authentication.AuthenticationManager
import org.springframework.security.authentication.UsernamePasswordAuthenticationToken
import org.springframework.security.core.Authentication
import org.springframework.security.core.context.SecurityContextHolder
import org.springframework.web.bind.annotation.PostMapping
import org.springframework.web.bind.annotation.RequestBody
import org.springframework.web.bind.annotation.RequestMapping
import org.springframework.web.bind.annotation.RestController

@RestController
@RequiredArgsConstructor
@RequestMapping(&quot;/api/auth&quot;)
class AuthController(
    private val authenticationManager: AuthenticationManager,
    private val jweUtil: JweUtil
) {

    @PostMapping(&quot;/login&quot;)
    fun login(@RequestBody loginRequest: LoginRequestDTO): ResponseEntity&lt;TokenDTO&gt; {
        val authToken = UsernamePasswordAuthenticationToken(
            loginRequest.username, loginRequest.password
        )
        val auth: Authentication = authenticationManager.authenticate(authToken)
        SecurityContextHolder.getContext().authentication = auth

        val tokenDto: TokenDTO = jweUtil.generateToken(auth)
        val cookie: ResponseCookie = CookieUtils.createAccessTokenCookie(tokenDto)

        return ResponseEntity.ok()
            .header(HttpHeaders.SET_COOKIE, cookie.toString())
            .body(tokenDto)
    }
}</code></pre>
<h3>HelloController</h3>
<h3>Java</h3>
<pre><code class="language-java">package io.github.susimsek.springbootjwedemo.controller;

import org.springframework.security.core.annotation.AuthenticationPrincipal;
import org.springframework.security.oauth2.jwt.Jwt;
import org.springframework.web.bind.annotation.*;

import static io.github.susimsek.springbootjwedemo.security.SecurityUtils.AUTHORITIES_KEY;

@RestController
@RequestMapping(&quot;/api/hello&quot;)
public class HelloController {

    @GetMapping
    public String helloAll(@AuthenticationPrincipal Jwt jwt) {
        String user = jwt.getSubject();
        var roles = jwt.getClaimAsStringList(AUTHORITIES_KEY);
        return &quot;Hello, &quot; + user + &quot;! Your roles: &quot; + roles;
    }

    @GetMapping(&quot;/admin&quot;)
    public String helloAdmin(@AuthenticationPrincipal Jwt jwt) {
        return &quot;Hello Admin, &quot; + jwt.getSubject() + &quot;!&quot;;
    }
}</code></pre>
<h3>Kotlin</h3>
<pre><code class="language-kotlin">package io.github.susimsek.springbootjwedemo.controller

import org.springframework.security.core.annotation.AuthenticationPrincipal
import org.springframework.security.oauth2.jwt.Jwt
import org.springframework.web.bind.annotation.*

import io.github.susimsek.springbootjwedemo.security.SecurityUtils.AUTHORITIES_KEY

@RestController
@RequestMapping(&quot;/api/hello&quot;)
class HelloController {

    @GetMapping
    fun helloAll(@AuthenticationPrincipal jwt: Jwt): String {
        val user = jwt.subject
        val roles = jwt.getClaimAsStringList(AUTHORITIES_KEY)
        return &quot;Hello, \$user! Your roles: \$roles&quot;
    }

    @GetMapping(&quot;/admin&quot;)
    fun helloAdmin(@AuthenticationPrincipal jwt: Jwt): String {
        return &quot;Hello Admin, \${jwt.subject}!&quot;
    }
}</code></pre>
<h3>LoginRequestDTO</h3>
<h3>Java</h3>
<pre><code class="language-java">package io.github.susimsek.springbootjwedemo.dto;

public record LoginRequestDTO(
    String username,
    String password
) { }</code></pre>
<h3>Kotlin</h3>
<pre><code class="language-kotlin">package io.github.susimsek.springbootjwedemo.dto

data class LoginRequestDTO(
    val username: String,
    val password: String
)</code></pre>
<h3>TokenDTO</h3>
<h3>Java</h3>
<pre><code class="language-java">package io.github.susimsek.springbootjwedemo.dto;

public record TokenDTO(
    String accessToken,
    String tokenType,
    long accessTokenExpiresIn
) {}</code></pre>
<h3>Kotlin</h3>
<pre><code class="language-kotlin">package io.github.susimsek.springbootjwedemo.dto

import kotlin.Long

data class TokenDTO(
    val accessToken: String,
    val tokenType: String,
    val accessTokenExpiresIn: Long
)</code></pre>
<hr />
<h2>‚ñ∂Ô∏è Run the App</h2>
<pre><code class="language-bash">./mvnw spring-boot:run
# or
gradle bootRun</code></pre>
<hr />
<h2>üß™ Test Endpoints</h2>
<h3>Admin Flow</h3>
<p>Login as admin and capture the JWE token from the `Set-Cookie` header:</p>
<pre><code class="language-bash">curl -i -X POST http://localhost:8080/api/auth/login \
  -H &quot;Content-Type: application/json&quot; \
  -d &#39;{&quot;username&quot;:&quot;admin&quot;,&quot;password&quot;:&quot;adminpass&quot;}&#39;</code></pre>
<ul>
<li>Set-Cookie header contains `accessToken=&lt;jwe-token&gt;`</li>
<li>Response body:</li>
</ul>
<pre><code class="language-json">{
  &quot;accessToken&quot;: &quot;&lt;jwe-token&gt;&quot;,
  &quot;tokenType&quot;: &quot;Bearer&quot;,
  &quot;accessTokenExpiresIn&quot;: 3600
}</code></pre>
<p>Use cookie to access hello endpoint:</p>
<pre><code class="language-bash">curl -b &quot;accessToken=&lt;jwe-token&gt;&quot; http://localhost:8080/api/hello</code></pre>
<p>Use Authorization header instead:</p>
<pre><code class="language-bash">curl -H &quot;Authorization: Bearer &lt;jwe-token&gt;&quot; http://localhost:8080/api/hello</code></pre>
<p>Access admin-only endpoint:</p>
<pre><code class="language-bash">curl -H &quot;Authorization: Bearer &lt;jwe-token&gt;&quot; http://localhost:8080/api/hello/admin</code></pre>
<h3>User Flow</h3>
<p>Login as user and capture JWE token from cookie:</p>
<pre><code class="language-bash">curl -i -X POST http://localhost:8080/api/auth/login \
  -H &quot;Content-Type: application/json&quot; \
  -d &#39;{&quot;username&quot;:&quot;user&quot;,&quot;password&quot;:&quot;userpass&quot;}&#39;</code></pre>
<ul>
<li>Set-Cookie header contains `accessToken=&lt;jwe-token&gt;`</li>
</ul>
<p>Use cookie to access hello endpoint:</p>
<pre><code class="language-bash">curl -b &quot;accessToken=&lt;jwe-token&gt;&quot; http://localhost:8080/api/hello</code></pre>
<p>Use Authorization header:</p>
<pre><code class="language-bash">curl -H &quot;Authorization: Bearer &lt;jwe-token&gt;&quot; http://localhost:8080/api/hello</code></pre>
<p>Attempt admin endpoint (should be 403 Forbidden):</p>
<pre><code class="language-bash">curl -H &quot;Authorization: Bearer &lt;jwe-token&gt;&quot; http://localhost:8080/api/hello/admin
# HTTP/1.1 403 Forbidden</code></pre>
<hr />
<h2>üèÅ Conclusion</h2>
<p>This setup delivers a robust, production-ready Spring Boot JWE Authentication solution in Spring Boot, combining best practices, clear structure, and practical examples you can adapt to your own project.</p>]]></content:encoded>
      <category><![CDATA[Java]]></category>
      <category><![CDATA[Kotlin]]></category>
      <category><![CDATA[Spring Boot]]></category>
      <category><![CDATA[Security]]></category>
      <category><![CDATA[JWT]]></category>
      <category><![CDATA[JWE]]></category>
      <category><![CDATA[Programming]]></category>
      <media:thumbnail url="https://suaybsimsek.com/images/spring-boot-jwe-auth-thumbnail.webp" />
    </item>
    <item>
      <title><![CDATA[Spring Boot HTTP Interface Client]]></title>
      <link>https://suaybsimsek.com/en/posts/spring-boot-http-interface-client</link>
      <description><![CDATA[Learn how to use Spring Boot 3.2+ HTTP Interface Client for declarative, type-safe HTTP calls.]]></description>
      <pubDate>Sun, 27 Apr 2025 00:00:00 GMT</pubDate>
      <guid isPermaLink="true">https://suaybsimsek.com/en/posts/spring-boot-http-interface-client</guid>
      <content:encoded><![CDATA[<p>Spring Boot 3.2+ introduces the HTTP Interface Client, enabling you to define declarative, type-safe HTTP clients with simple Java or Kotlin interfaces. In this article, you‚Äôll learn to set it up from scratch using the JSONPlaceholder API.</p>
<hr />
<h2>üåü Why HTTP Interface Client?</h2>
<ul>
<li>Declarative: Define an interface and annotate methods for HTTP calls.</li>
<li>Type-safe: Compiler catches mismatched signatures or misconfigured paths.</li>
<li>Minimal boilerplate: One bean definition, no manual proxy or template code.</li>
<li>Spring-friendly: Leverages Spring Framework 6.2‚Äôs `@HttpExchange`, `@GetExchange`, and `WebClientAdapter`.</li>
</ul>
<hr />
<h2>üìã Prerequisites</h2>
<ul>
<li>‚òï Java Development Kit (JDK) 21 or higher</li>
<li>üì¶ Spring Boot 3.2+</li>
<li>üî§ IDE (IntelliJ IDEA, Eclipse, etc.)</li>
</ul>
<hr />
<h2>üõ†Ô∏è Step 1: Add Dependencies</h2>
<p>Add the Web starter to your build:</p>
<p>Maven:</p>
<pre><code class="language-xml">&lt;dependency&gt;
  &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
  &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;
&lt;/dependency&gt;</code></pre>
<p>Gradle:</p>
<pre><code class="language-groovy">implementation &#39;org.springframework.boot:spring-boot-starter-web&#39;</code></pre>
<hr />
<h2>üõ†Ô∏è Step 2: Configure Base URL</h2>
<p>Add to `application.yml` or `application.properties`:</p>
<pre><code class="language-yaml">jsonplaceholder:
  base-url: https://jsonplaceholder.typicode.com</code></pre>
<pre><code class="language-properties">jsonplaceholder.base-url=https://jsonplaceholder.typicode.com</code></pre>
<hr />
<h2>üõ†Ô∏è Step 3: Define DTO and Client Interface</h2>
<h3>Java</h3>
<pre><code class="language-java">// src/main/java/com/example/client/dto/PostDTO.java
package com.example.client.dto;

public record PostDTO(
    Integer userId,
    Integer id,
    String title,
    String body
) {}

// src/main/java/com/example/client/JsonPlaceholderClient.java
package com.example.client;

import com.example.client.dto.PostDTO;
import org.springframework.web.service.annotation.GetExchange;
import org.springframework.web.service.annotation.HttpExchange;
import org.springframework.web.bind.annotation.PathVariable;
import java.util.List;

@HttpExchange(url = &quot;${jsonplaceholder.base-url}&quot;, accept = &quot;application/json&quot;)
public interface JsonPlaceholderClient {

    @GetExchange(&quot;/posts&quot;)
    List&lt;PostDTO&gt; getPosts();

    @GetExchange(&quot;/posts/{id}&quot;)
    PostDTO getPost(@PathVariable(&quot;id&quot;) Integer id);
}</code></pre>
<h3>Kotlin</h3>
<pre><code class="language-kotlin">// src/main/kotlin/com/example/client/dto/PostDTO.kt
package com.example.client.dto

data class PostDTO(
    val userId: Int,
    val id: Int,
    val title: String,
    val body: String
)

// src/main/kotlin/com/example/client/JsonPlaceholderClient.kt
package com.example.client

import com.example.client.dto.PostDTO
import org.springframework.web.service.annotation.GetExchange
import org.springframework.web.service.annotation.HttpExchange
import org.springframework.web.bind.annotation.PathVariable

@HttpExchange(url = &quot;${jsonplaceholder.base-url}&quot;, accept = &quot;application/json&quot;)
interface JsonPlaceholderClient {

    @GetExchange(&quot;/posts&quot;)
    fun getPosts(): List&lt;PostDTO&gt;

    @GetExchange(&quot;/posts/{id}&quot;)
    fun getPost(@PathVariable(&quot;id&quot;) id: Int): PostDTO
}</code></pre>
<hr />
<h2>üõ†Ô∏è Step 4: Configure the Client Bean</h2>
<h3>Java</h3>
<pre><code class="language-java">// src/main/java/com/example/config/HttpClientConfig.java
package com.example.config;

import com.example.client.JsonPlaceholderClient;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.web.client.support.RestClientAdapter;
import org.springframework.web.service.invoker.HttpServiceProxyFactory;
import org.springframework.web.service.invoker.RestClient;

@Configuration
public class HttpClientConfig {

    @Bean
    public JsonPlaceholderClient jsonPlaceholderClient(RestClient.Builder restClientBuilder) {
        RestClient restClient = restClientBuilder
            .baseUrl(&quot;https://jsonplaceholder.typicode.com&quot;)
            .build();

        var factory = HttpServiceProxyFactory
            .builderFor(RestClientAdapter.create(restClient))
            .build();

        return factory.createClient(JsonPlaceholderClient.class);
    }
}</code></pre>
<h3>Kotlin</h3>
<pre><code class="language-kotlin">// src/main/kotlin/com/example/config/HttpClientConfig.kt
package com.example.config

import com.example.client.JsonPlaceholderClient
import org.springframework.context.annotation.Bean
import org.springframework.context.annotation.Configuration
import org.springframework.web.client.support.RestClientAdapter
import org.springframework.web.service.invoker.HttpServiceProxyFactory
import org.springframework.web.service.invoker.RestClient

@Configuration
class HttpClientConfig {

    @Bean
    fun jsonPlaceholderClient(restClientBuilder: RestClient.Builder): JsonPlaceholderClient {
        val restClient = restClientBuilder
            .baseUrl(&quot;https://jsonplaceholder.typicode.com&quot;)
            .build()

        val factory = HttpServiceProxyFactory
            .builderFor(RestClientAdapter.create(restClient))
            .build()

        return factory.createClient(JsonPlaceholderClient::class.java)
    }
}</code></pre>
<hr />
<h2>üõ†Ô∏è Step 5: Implement Service and Controller</h2>
<h3>Java</h3>
<pre><code class="language-java">// src/main/java/com/example/service/PostService.java
package com.example.service;

import com.example.client.JsonPlaceholderClient;
import com.example.client.dto.PostDTO;
import lombok.RequiredArgsConstructor;
import org.springframework.stereotype.Service;
import java.util.List;

@Service
@RequiredArgsConstructor
public class PostService {
    private final JsonPlaceholderClient client;

    public List&lt;PostDTO&gt; getAllPosts() {
        return client.getPosts();
    }

    public PostDTO getPostById(Integer id) {
        return client.getPost(id);
    }
}

// src/main/java/com/example/controller/PostController.java
package com.example.controller;

import com.example.client.dto.PostDTO;
import com.example.service.PostService;
import lombok.RequiredArgsConstructor;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.*;
import java.util.List;

@RestController
@RequestMapping(&quot;/posts&quot;)
@RequiredArgsConstructor
public class PostController {
    private final PostService postService;

    @GetMapping
    public List&lt;PostDTO&gt; getAllPosts() {
        return postService.getAllPosts();
    }

    @GetMapping(&quot;/{id}&quot;)
    public ResponseEntity&lt;PostDTO&gt; getPostById(@PathVariable Integer id) {
        PostDTO post = postService.getPostById(id);
        return post != null ? ResponseEntity.ok(post) : ResponseEntity.notFound().build();
    }
}</code></pre>
<h3>Kotlin</h3>
<pre><code class="language-kotlin">// src/main/kotlin/com/example/service/PostService.kt
package com.example.service

import com.example.client.JsonPlaceholderClient
import com.example.client.dto.PostDTO
import org.springframework.stereotype.Service

@Service
class PostService(private val client: JsonPlaceholderClient) {
    fun getAllPosts(): List&lt;PostDTO&gt; = client.getPosts()
    fun getPostById(id: Int): PostDTO = client.getPost(id)
}

// src/main/kotlin/com/example/controller/PostController.kt
package com.example.controller

import com.example.client.dto.PostDTO
import com.example.service.PostService
import org.springframework.http.ResponseEntity
import org.springframework.web.bind.annotation.*

@RestController
@RequestMapping(&quot;/posts&quot;)
class PostController(private val postService: PostService) {
    @GetMapping
    fun getAllPosts(): List&lt;PostDTO&gt; = postService.getAllPosts()

    @GetMapping(&quot;/{id}&quot;)
    fun getPostById(@PathVariable id: Int): ResponseEntity&lt;PostDTO&gt; =
        ResponseEntity.ok(postService.getPostById(id))
}</code></pre>
<hr />
<h2>‚ñ∂Ô∏è Run the Application</h2>
<pre><code class="language-bash">./mvnw spring-boot:run
# or
gradle bootRun</code></pre>
<hr />
<h2>üß™ Test Endpoints</h2>
<pre><code class="language-bash">curl http://localhost:8080/posts
curl http://localhost:8080/posts/1</code></pre>
<hr />
<h2>üèÅ Conclusion</h2>
<p>This setup delivers a robust, production-ready Spring Boot HTTP Interface Client solution in Spring Boot, combining best practices, clear structure, and practical examples you can adapt to your own project.</p>]]></content:encoded>
      <category><![CDATA[Java]]></category>
      <category><![CDATA[Kotlin]]></category>
      <category><![CDATA[Spring Boot]]></category>
      <category><![CDATA[REST API]]></category>
      <category><![CDATA[Rest Client]]></category>
      <category><![CDATA[Programming]]></category>
      <media:thumbnail url="https://suaybsimsek.com/images/spring-boot-http-interface-thumbnail.webp" />
    </item>
    <item>
      <title><![CDATA[Spring Boot Async Tasks with Virtual Thread]]></title>
      <link>https://suaybsimsek.com/en/posts/spring-boot-async-tasks-virtual</link>
      <description><![CDATA[Learn how to run asynchronous tasks with `@Async` on JDK 21 virtual threads in Spring Boot.]]></description>
      <pubDate>Sat, 26 Apr 2025 00:00:00 GMT</pubDate>
      <guid isPermaLink="true">https://suaybsimsek.com/en/posts/spring-boot-async-tasks-virtual</guid>
      <content:encoded><![CDATA[<p>Spring Boot 3.2+ lets you combine the simplicity of `@Async` with JDK 21 virtual threads for ultra-lightweight concurrency. Offload work to isolated virtual threads without complex pool configs.</p>
<hr />
<h2>üåü Why Use Virtual Thread in Spring Boot?</h2>
<ul>
<li>Ultra-Lightweight: Virtual threads are thousands of times cheaper than platform threads.</li>
<li>Non-Blocking: `@Async` methods run off the main thread, improving responsiveness.</li>
<li>Scalable: Handle high concurrency with minimal resource overhead.</li>
<li>Simple Config: Enable with a single property, no custom executors needed.</li>
</ul>
<hr />
<h2>üìã Prerequisites</h2>
<ul>
<li>‚òï Java Development Kit (JDK) 21 or higher</li>
<li>üì¶ Spring Boot 3.2+</li>
<li>üî§ IDE (IntelliJ IDEA, Eclipse)</li>
</ul>
<hr />
<h2>üõ†Ô∏è Step 1: Add Dependencies</h2>
<p>To enable async processing, include spring-boot-starter-web in your `pom.xml` or `build.gradle` file.</p>
<p>Maven:</p>
<pre><code class="language-xml">&lt;dependency&gt;
    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
    &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;
&lt;/dependency&gt;</code></pre>
<p>Gradle:</p>
<pre><code class="language-groovy">implementation &#39;org.springframework.boot:spring-boot-starter-web&#39;</code></pre>
<hr />
<h2>üõ†Ô∏è Step 2: Enable Virtual Threads</h2>
<p>Add to `application.yml` or `application.properties`:</p>
<pre><code class="language-yaml">spring:
  threads:
    virtual:
      enabled: true</code></pre>
<pre><code class="language-properties">spring.threads.virtual.enabled=true</code></pre>
<p>This setting auto-configures the following:</p>
<ul>
<li>`applicationTaskExecutor` for `@Async` support</li>
<li>Task scheduler for `@Scheduled` methods</li>
<li>Servlet container thread pools (Tomcat/Jetty) to use virtual threads</li>
</ul>
<hr />
<h2>üõ†Ô∏è Step 3: Enable Async Support</h2>
<p>Annotate your main application class in Java or Kotlin:</p>
<h3>Java</h3>
<pre><code class="language-java">package com.example.async;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;
import org.springframework.scheduling.annotation.EnableAsync;

@SpringBootApplication
@EnableAsync
public class AsyncVirtualApplication {
    public static void main(String[] args) {
        SpringApplication.run(AsyncVirtualApplication.class, args);
    }
}</code></pre>
<h3>Kotlin</h3>
<pre><code class="language-kotlin">package com.example.async

import org.springframework.boot.autoconfigure.SpringBootApplication
import org.springframework.boot.runApplication
import org.springframework.scheduling.annotation.EnableAsync

@SpringBootApplication
@EnableAsync
class AsyncVirtualApplication

fun main(args: Array&lt;String&gt;) {
    runApplication&lt;AsyncVirtualApplication&gt;(*args)
}</code></pre>
<hr />
<h2>üõ†Ô∏è Step 4: Define an Async Service</h2>
<p>Create a service with `@Async`. It will run each call on a new virtual thread.</p>
<h3>Java</h3>
<pre><code class="language-java">package com.example.async;

import lombok.extern.slf4j.Slf4j;
import org.springframework.scheduling.annotation.Async;
import org.springframework.stereotype.Service;

import java.time.LocalTime;
import java.util.concurrent.CompletableFuture;

@Slf4j
@Service
public class AsyncVirtualService {

  @Async
  public void runTask() {
    log.info(&quot;[{}] Async start on {}&quot;, LocalTime.now(), Thread.currentThread());
    try {
      Thread.sleep(1000);
    } catch (InterruptedException ignored) {}
    log.info(&quot;[{}] Async end on {}&quot;, LocalTime.now(), Thread.currentThread());
  }

  @Async
  public CompletableFuture&lt;String&gt; runAndReturn() throws InterruptedException {
    Thread.sleep(500);
    return CompletableFuture.completedFuture(&quot;Completed&quot;);
  }
}</code></pre>
<h3>Kotlin</h3>
<pre><code class="language-kotlin">package com.example.async

import org.slf4j.LoggerFactory
import org.springframework.scheduling.annotation.Async
import org.springframework.stereotype.Service

import java.time.LocalTime
import java.util.concurrent.CompletableFuture

@Service
class AsyncVirtualService {
  private val log = LoggerFactory.getLogger(AsyncVirtualService::class.java)

  @Async
  fun runTask() {
    log.info(&quot;[{}] Async start on {}&quot;, LocalTime.now(), Thread.currentThread())
    try {
      Thread.sleep(1000)
    } catch (_: InterruptedException) {}
    log.info(&quot;[{}] Async end on {}&quot;, LocalTime.now(), Thread.currentThread())
  }

  @Async
  fun runAndReturn(): CompletableFuture&lt;String&gt; {
    Thread.sleep(500)
    return CompletableFuture.completedFuture(&quot;Completed&quot;)
  }
}</code></pre>
<hr />
<h2>üõ†Ô∏è Step 5: Trigger via REST Controller</h2>
<p>Expose endpoints to invoke your async methods:</p>
<h3>Java</h3>
<pre><code class="language-java">package com.example.async;

import lombok.RequiredArgsConstructor;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;

@RestController
@RequestMapping(&quot;/async&quot;)
@RequiredArgsConstructor
public class AsyncVirtualController {

  private final AsyncVirtualService service;

  @GetMapping(&quot;/run&quot;)
  public String triggerRun() {
    service.runTask();
    return &quot;Async virtual thread task triggered&quot;;
  }

  @GetMapping(&quot;/run-return&quot;)
  public String triggerRunAndReturn() throws Exception {
    var future = service.runAndReturn();
    return future.get();
  }
}</code></pre>
<h3>Kotlin</h3>
<pre><code class="language-kotlin">package com.example.async

import org.springframework.web.bind.annotation.GetMapping
import org.springframework.web.bind.annotation.RequestMapping
import org.springframework.web.bind.annotation.RestController

import lombok.RequiredArgsConstructor

@RestController
@RequestMapping(&quot;/async&quot;)
@RequiredArgsConstructor
class AsyncVirtualController(private val service: AsyncVirtualService) {

  @GetMapping(&quot;/run&quot;)
  fun triggerRun(): String {
    service.runTask()
    return &quot;Async virtual thread task triggered&quot;
  }

  @GetMapping(&quot;/run-return&quot;)
  @Throws(Exception::class)
  fun triggerRunAndReturn(): String {
    val future = service.runAndReturn()
    return future.get()
  }
}</code></pre>
<hr />
<h2>‚ñ∂Ô∏è Run the App</h2>
<pre><code class="language-bash">./mvnw spring-boot:run
# or
gradle bootRun</code></pre>
<hr />
<h2>üß™ Test Endpoints</h2>
<p>Trigger void task</p>
<pre><code class="language-bash">curl http://localhost:8080/async/run</code></pre>
<p>Check logs for virtual thread start/end.</p>
<p>Trigger task with return</p>
<pre><code class="language-bash">curl http://localhost:8080/async/run-return
# returns &quot;Completed&quot;</code></pre>
<hr />
<h2>üèÅ Conclusion</h2>
<p>This setup delivers a robust, production-ready Spring Boot Async Tasks with Virtual Thread solution in Spring Boot, combining best practices, clear structure, and practical examples you can adapt to your own project.</p>]]></content:encoded>
      <category><![CDATA[Java]]></category>
      <category><![CDATA[Kotlin]]></category>
      <category><![CDATA[Spring Boot]]></category>
      <category><![CDATA[Async Tasks]]></category>
      <category><![CDATA[Virtual Thread]]></category>
      <category><![CDATA[Programming]]></category>
      <media:thumbnail url="https://suaybsimsek.com/images/spring-boot-async-virtual-thumbnail.webp" />
    </item>
    <item>
      <title><![CDATA[Spring Boot AI Integration]]></title>
      <link>https://suaybsimsek.com/en/posts/spring-boot-ai</link>
      <description><![CDATA[Learn how to integrate AI models into Spring Boot applications using Spring AI for modular, portable, and observable AI workflows.]]></description>
      <pubDate>Wed, 23 Apr 2025 00:00:00 GMT</pubDate>
      <guid isPermaLink="true">https://suaybsimsek.com/en/posts/spring-boot-ai</guid>
      <content:encoded><![CDATA[<p>Spring AI is a framework for AI engineering that applies Spring‚Äôs portability and modular design principles to AI workloads. It lets you build AI-driven applications using familiar Spring idioms and POJOs.</p>
<hr />
<h2>üåü Why Use Spring AI?</h2>
<ul>
<li>Provider-agnostic portability: Write code once and switch between AI providers (OpenAI, Anthropic, Azure, etc.) without changes.</li>
<li>POJO-based design: Model AI inputs and outputs as plain Java/Kotlin objects for type safety and easy integration.</li>
<li>Structured outputs: Automatically map model responses to your domain objects.</li>
<li>Vector store integration: Seamless support for major vector databases (Chroma, Pinecone, Redis, etc.) via a unified API.</li>
<li>Tool/function calling: Enable LLMs to invoke custom functions or services for real-time data.</li>
<li>Observability &amp; evaluation: Built-in metrics and evaluation utilities to monitor AI operations and detect hallucinations.</li>
<li>Chat abstractions: Fluent ChatClient API, similar to Spring‚Äôs WebClient, for building conversational agents.</li>
<li>Retrieval-augmented generation (RAG): Simplify document-based QA and memory-backed chat with advisors and memory APIs.</li>
</ul>
<hr />
<h2>üìã Prerequisites</h2>
<p>Ensure you have the following:</p>
<ul>
<li>‚òï Java Development Kit (JDK) 17+</li>
<li>üì¶ Maven or Gradle installed</li>
<li>üê≥ Spring Boot 3+</li>
<li>üîë OpenAI API Key (set as environment variable `OPENAI_API_KEY`)</li>
</ul>
<hr />
<h2>üõ†Ô∏è Step 1: Add Dependencies</h2>
<p>Include Spring AI starter for OpenAI, Spring Web, and Lombok.</p>
<h3>Maven</h3>
<pre><code class="language-xml">&lt;dependencies&gt;
  &lt;dependency&gt;
    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
    &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;
  &lt;/dependency&gt;
  &lt;dependency&gt;
    &lt;groupId&gt;org.springframework.ai&lt;/groupId&gt;
    &lt;artifactId&gt;spring-ai-starter-model-openai&lt;/artifactId&gt;
  &lt;/dependency&gt;
  &lt;dependency&gt;
    &lt;groupId&gt;org.projectlombok&lt;/groupId&gt;
    &lt;artifactId&gt;lombok&lt;/artifactId&gt;
    &lt;scope&gt;provided&lt;/scope&gt;
  &lt;/dependency&gt;
&lt;/dependencies&gt;</code></pre>
<h3>Gradle</h3>
<pre><code class="language-groovy">plugins {
  id &#39;org.springframework.boot&#39; version &#39;3.2.0&#39;
}

dependencies {
  implementation &#39;org.springframework.boot:spring-boot-starter-web&#39;
  implementation &#39;org.springframework.ai:spring-ai-starter-model-openai&#39;
  compileOnly &#39;org.projectlombok:lombok&#39;
  annotationProcessor &#39;org.projectlombok:lombok&#39;
}</code></pre>
<hr />
<h2>üõ†Ô∏è Step 2: Configuration</h2>
<p>In `application.yml`, configure your OpenAI key and set the ChatClient model:</p>
<pre><code class="language-yaml">spring:
  ai:
    openai:
      api-key: ${OPENAI_API_KEY}
      chat:
        options:
          model: gpt-4.1-mini</code></pre>
<hr />
<h2>üõ†Ô∏è Step 3: Implement the Service Layer</h2>
<p>Create an `AIService` to wrap your ChatClient. Inject `ChatClient.Builder` and build the client.</p>
<h3>Java</h3>
<pre><code class="language-java">package com.example.ai.service;

import org.springframework.ai.chat.client.ChatClient;
import org.springframework.stereotype.Service;
import lombok.RequiredArgsConstructor;

@Service
public class AIService {
    private final ChatClient chatClient;

    public AIService(ChatClient.Builder builder) {
        this.chatClient = builder.build();
    }

    public String getJoke(String topic) {
        return chatClient.prompt()
                .user(u -&gt; u.text(&quot;Tell me a joke about {topic}&quot;).param(&quot;topic&quot;, topic))
                .call()
                .content();
    }
}</code></pre>
<h3>Kotlin</h3>
<pre><code class="language-kotlin">package com.example.ai.service

import org.springframework.ai.chat.client.ChatClient
import org.springframework.stereotype.Service

@Service
class AIService(builder: ChatClient.Builder) {
    private val chatClient: ChatClient = builder.build()

    fun getJoke(topic: String): String {
        return chatClient.prompt()
            .user { it.text(&quot;Tell me a joke about {topic}&quot;).param(&quot;topic&quot;, topic) }
            .call()
            .content()
    }
}</code></pre>
<hr />
<h2>üõ†Ô∏è Step 4: Expose a REST Controller</h2>
<p>Create a `ChatController` to expose your AIService over HTTP.</p>
<h3>Java</h3>
<pre><code class="language-java">package com.example.ai.controller;

import com.example.ai.service.AIService;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RequestParam;
import org.springframework.web.bind.annotation.RestController;
import lombok.RequiredArgsConstructor;

@RestController
@RequiredArgsConstructor
public class ChatController {

    private final AIService aiService;

    @GetMapping(&quot;/joke&quot;)
    public String getJoke(@RequestParam(defaultValue = &quot;dogs&quot;) String topic) {
        return aiService.getJoke(topic);
    }
}</code></pre>
<h3>Kotlin</h3>
<pre><code class="language-kotlin">package com.example.ai.controller

import com.example.ai.service.AIService
import org.springframework.web.bind.annotation.GetMapping
import org.springframework.web.bind.annotation.RequestParam
import org.springframework.web.bind.annotation.RestController

@RestController
class ChatController(private val aiService: AIService) {

    @GetMapping(&quot;/joke&quot;)
    fun getJoke(@RequestParam(defaultValue = &quot;dogs&quot;) topic: String): String {
        return aiService.getJoke(topic)
    }
}</code></pre>
<hr />
<h2>‚ñ∂Ô∏è Running the Application</h2>
<p>Start your Spring Boot app:</p>
<pre><code class="language-bash">./mvnw spring-boot:run
# or
gradle bootRun</code></pre>
<hr />
<h2>üß™ Testing the Integration</h2>
<p>Call your service via HTTP:</p>
<pre><code class="language-bash">curl -X GET &quot;http://localhost:8080/joke?topic=dogs&quot;
# Returns a dog joke generated by the AI model.</code></pre>
<hr />
<h2>üèÅ Conclusion</h2>
<p>This setup delivers a robust, production-ready Spring Boot AI Integration solution in Spring Boot, combining best practices, clear structure, and practical examples you can adapt to your own project.</p>]]></content:encoded>
      <category><![CDATA[Java]]></category>
      <category><![CDATA[Kotlin]]></category>
      <category><![CDATA[Spring Boot]]></category>
      <category><![CDATA[Spring AI]]></category>
      <category><![CDATA[Artificial Intelligence]]></category>
      <category><![CDATA[Programming]]></category>
      <media:thumbnail url="https://suaybsimsek.com/images/spring-boot-ai-thumbnail.webp" />
    </item>
    <item>
      <title><![CDATA[Spring Boot JPA Auditing]]></title>
      <link>https://suaybsimsek.com/en/posts/spring-boot-jpa-auditing</link>
      <description><![CDATA[Learn how to automatically track created and modified fields in your Spring Boot applications using JPA Auditing.]]></description>
      <pubDate>Thu, 10 Apr 2025 00:00:00 GMT</pubDate>
      <guid isPermaLink="true">https://suaybsimsek.com/en/posts/spring-boot-jpa-auditing</guid>
      <content:encoded><![CDATA[<p>JPA Auditing in Spring Boot allows you to automatically track who created or modified an entity and when. This is extremely useful for audit logs, history tracking, and debugging.</p>
<hr />
<h2>üåü Why Use JPA Auditing?</h2>
<ul>
<li>üìÖ Auto track `createdDate`, `lastModifiedDate`</li>
<li>üë§ Record `createdBy`, `modifiedBy`</li>
<li>üßº Cleaner code by avoiding manual field setting</li>
</ul>
<hr />
<h2>üõ†Ô∏è Step 1: Add Dependencies</h2>
<p>Make sure you have the following dependencies in your project:</p>
<p>Maven:</p>
<pre><code class="language-xml">&lt;dependency&gt;
  &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
  &lt;artifactId&gt;spring-boot-starter-data-jpa&lt;/artifactId&gt;
&lt;/dependency&gt;</code></pre>
<p>Gradle:</p>
<pre><code class="language-groovy">dependencies {
  implementation &#39;org.springframework.boot:spring-boot-starter-data-jpa&#39;
}</code></pre>
<hr />
<h2>üõ†Ô∏è Step 2: Enable JPA Auditing</h2>
<p>Add `@EnableJpaAuditing` to your main class or a configuration class.</p>
<h3>Java</h3>
<pre><code class="language-java">import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;
import org.springframework.data.jpa.repository.config.EnableJpaAuditing;

@SpringBootApplication
@EnableJpaAuditing(auditorAwareRef = &quot;auditorProvider&quot;)
public class DemoApplication {
  public static void main(String[] args) {
    SpringApplication.run(DemoApplication.class, args);
  }
}</code></pre>
<h3>Kotlin</h3>
<pre><code class="language-kotlin">import org.springframework.boot.autoconfigure.SpringBootApplication
import org.springframework.boot.runApplication
import org.springframework.data.jpa.repository.config.EnableJpaAuditing

@SpringBootApplication
@EnableJpaAuditing(auditorAwareRef = &quot;auditorProvider&quot;)
class DemoApplication

fun main(args: Array&lt;String&gt;) {
    runApplication&lt;DemoApplication&gt;(*args)
}</code></pre>
<hr />
<h2>üõ†Ô∏è Step 3: Create AuditorAware Bean</h2>
<p>This bean tells Spring Security who the current user is. Here&#39;s a basic static user example:</p>
<h3>Java</h3>
<pre><code class="language-java">@Configuration
public class AuditingConfig {

  @Bean
  public AuditorAware&lt;String&gt; auditorProvider() {
    return () -&gt; Optional.of(&quot;≈ûuayb&quot;);
  }
}</code></pre>
<h3>Kotlin</h3>
<pre><code class="language-kotlin">@Configuration
class AuditingConfig {

  @Bean
  fun auditorProvider(): AuditorAware&lt;String&gt; = AuditorAware { Optional.of(&quot;≈ûuayb&quot;) }
}</code></pre>
<hr />
<h2>üõ†Ô∏è Step 4: Annotate Your Entity</h2>
<p>Use auditing annotations like `@CreatedDate`, `@LastModifiedDate`, etc.</p>
<h3>Java</h3>
<pre><code class="language-java">@Entity
@EntityListeners(AuditingEntityListener.class)
public class Article {

  @Id
  @GeneratedValue(strategy = GenerationType.IDENTITY)
  private Long id;

  private String title;

  @CreatedDate
  private LocalDateTime createdDate;

  @LastModifiedDate
  private LocalDateTime lastModifiedDate;

  @CreatedBy
  private String createdBy;

  @LastModifiedBy
  private String lastModifiedBy;

  // getters &amp; setters
}</code></pre>
<h3>Kotlin</h3>
<pre><code class="language-kotlin">@Entity
@EntityListeners(AuditingEntityListener::class)
data class Article(
  @Id
  @GeneratedValue(strategy = GenerationType.IDENTITY)
  val id: Long? = null,

  var title: String? = null,

  @CreatedDate
  var createdDate: LocalDateTime? = null,

  @LastModifiedDate
  var lastModifiedDate: LocalDateTime? = null,

  @CreatedBy
  var createdBy: String? = null,

  @LastModifiedBy
  var lastModifiedBy: String? = null
)</code></pre>
<hr />
<h2>‚ñ∂Ô∏è Running the Application</h2>
<p>Now when you save an entity using `JpaRepository`, auditing fields will be populated automatically.</p>
<hr />
<h2>üß™ Testing</h2>
<p>You can test JPA Auditing functionality by saving an entity and checking whether the audit fields are populated.</p>
<h3>Java</h3>
<pre><code class="language-java">@SpringBootTest
@AutoConfigureTestDatabase
@Transactional
class ArticleRepositoryTest {

  @Autowired
  private ArticleRepository articleRepository;

  @Test
  void testAuditFieldsAreSet() {
    Article article = new Article();
    article.setTitle(&quot;Test Title&quot;);

    Article saved = articleRepository.save(article);

    assertNotNull(saved.getCreatedDate());
    assertNotNull(saved.getLastModifiedDate());
    assertEquals(&quot;≈ûuayb&quot;, saved.getCreatedBy());
    assertEquals(&quot;≈ûuayb&quot;, saved.getLastModifiedBy());
  }
}</code></pre>
<h3>Kotlin</h3>
<pre><code class="language-kotlin">@SpringBootTest
@AutoConfigureTestDatabase
@Transactional
class ArticleRepositoryTest {

  @Autowired
  lateinit var articleRepository: ArticleRepository

  @Test
  fun `should set audit fields`() {
    val article = Article().apply {
      title = &quot;Test Title&quot;
    }

    val saved = articleRepository.save(article)

    assertNotNull(saved.createdDate)
    assertNotNull(saved.lastModifiedDate)
    assertEquals(&quot;≈ûuayb&quot;, saved.createdBy)
    assertEquals(&quot;≈ûuayb&quot;, saved.lastModifiedBy)
  }
}</code></pre>
<p>Make sure your test includes the correct Spring context and that auditing is enabled during tests. You may also need to mock `SecurityContext` if you&#39;re using a dynamic user in production.</p>
<hr />
<h2>üèÅ Conclusion</h2>
<p>This setup delivers a robust, production-ready Spring Boot JPA Auditing solution in Spring Boot, combining best practices, clear structure, and practical examples you can adapt to your own project.</p>]]></content:encoded>
      <category><![CDATA[Java]]></category>
      <category><![CDATA[Kotlin]]></category>
      <category><![CDATA[Spring Boot]]></category>
      <category><![CDATA[Spring Data]]></category>
      <category><![CDATA[JPA]]></category>
      <category><![CDATA[Auditing]]></category>
      <category><![CDATA[Programming]]></category>
      <media:thumbnail url="https://suaybsimsek.com/images/spring-boot-jpa-auditing-thumbnail.webp" />
    </item>
    <item>
      <title><![CDATA[Spring Boot Test-Driven Development]]></title>
      <link>https://suaybsimsek.com/en/posts/spring-boot-tdd</link>
      <description><![CDATA[Learn how to apply TDD in Spring Boot by writing unit tests first, implementing logic, and ensuring code quality through testing.]]></description>
      <pubDate>Wed, 09 Apr 2025 00:00:00 GMT</pubDate>
      <guid isPermaLink="true">https://suaybsimsek.com/en/posts/spring-boot-tdd</guid>
      <content:encoded><![CDATA[<p>Test-Driven Development (TDD) helps you build robust applications by writing tests before implementing business logic. With Spring Boot, writing unit tests is fast, clean, and efficient.</p>
<hr />
<h2>üåü Why Use TDD in Spring Boot?</h2>
<ul>
<li>Fail Fast: Catch issues early during development.</li>
<li>Clean Design: Forces modular, testable code structure.</li>
<li>Refactor with Confidence: Tests serve as a safety net.</li>
<li>Documentation: Tests describe intended behavior clearly.</li>
</ul>
<hr />
<h2>üìã Prerequisites</h2>
<p>Make sure you have:</p>
<ul>
<li>‚òï JDK 17+ installed</li>
<li>üì¶ Maven or Gradle</li>
<li>üî§ A Java IDE like IntelliJ IDEA or Eclipse</li>
</ul>
<hr />
<h2>üß™ Step 1: Add Test Dependencies</h2>
<p>Add Spring Boot&#39;s test starter to your project.</p>
<p>Maven:</p>
<pre><code class="language-xml">&lt;dependency&gt;
  &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
  &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt;
  &lt;scope&gt;test&lt;/scope&gt;
&lt;/dependency&gt;</code></pre>
<p>Gradle:</p>
<pre><code class="language-groovy">testImplementation &#39;org.springframework.boot:spring-boot-starter-test&#39;</code></pre>
<hr />
<h2>üß™ Step 2: Write Your First Test</h2>
<p>Create a simple unit test before implementing the service.</p>
<h3>Java</h3>
<pre><code class="language-java">package com.example.tdd;

import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

class GreetingServiceTest {

    @Test
    void shouldReturnGreetingMessage() {
        GreetingService service = new GreetingService();
        String result = service.greet(&quot;World&quot;);
        assertEquals(&quot;Hello, World!&quot;, result);
    }
}</code></pre>
<h3>Kotlin</h3>
<pre><code class="language-kotlin">package com.example.tdd

import org.junit.jupiter.api.Assertions.assertEquals
import org.junit.jupiter.api.Test

class GreetingServiceTest {

    @Test
    fun shouldReturnGreetingMessage() {
        val service = GreetingService()
        val result = service.greet(&quot;World&quot;)
        assertEquals(&quot;Hello, World!&quot;, result)
    }
}</code></pre>
<hr />
<h2>üõ†Ô∏è Step 3: Implement the Service</h2>
<p>Now implement the `GreetingService` to pass the test.</p>
<h3>Java</h3>
<pre><code class="language-java">package com.example.tdd;

public class GreetingService {
    public String greet(String name) {
        return &quot;Hello, &quot; + name + &quot;!&quot;;
    }
}</code></pre>
<h3>Kotlin</h3>
<pre><code class="language-kotlin">package com.example.tdd

class GreetingService {
    fun greet(name: String): String {
        return &quot;Hello, $name!&quot;
    }
}</code></pre>
<hr />
<h2>‚ñ∂Ô∏è Running the Tests</h2>
<p>Use your build tool to run the tests:</p>
<pre><code class="language-bash">./mvnw test</code></pre>
<p>Or with Gradle:</p>
<pre><code class="language-bash">gradle test</code></pre>
<p>You should see the test pass ‚úÖ</p>
<hr />
<h3>Refactor and Repeat</h3>
<p>Now that your test passes, you can safely refactor your code. TDD is a loop:</p>
<p>1. Red ‚Äì Write a failing test 2. Green ‚Äì Make it pass 3. Refactor ‚Äì Improve the code</p>
<hr />
<h2>üèÅ Conclusion</h2>
<p>This setup delivers a robust, production-ready Spring Boot Test-Driven Development solution in Spring Boot, combining best practices, clear structure, and practical examples you can adapt to your own project.</p>]]></content:encoded>
      <category><![CDATA[Java]]></category>
      <category><![CDATA[Kotlin]]></category>
      <category><![CDATA[Spring Boot]]></category>
      <category><![CDATA[TDD]]></category>
      <category><![CDATA[Testing]]></category>
      <category><![CDATA[Programming]]></category>
      <media:thumbnail url="https://suaybsimsek.com/images/spring-boot-tdd-thumbnail.webp" />
    </item>
    <item>
      <title><![CDATA[Spring Boot Circuit Breaker]]></title>
      <link>https://suaybsimsek.com/en/posts/spring-boot-circuit-breaker</link>
      <description><![CDATA[Learn how to implement Circuit Breaker in Spring Boot applications for resilient microservices.]]></description>
      <pubDate>Thu, 13 Mar 2025 00:00:00 GMT</pubDate>
      <guid isPermaLink="true">https://suaybsimsek.com/en/posts/spring-boot-circuit-breaker</guid>
      <content:encoded><![CDATA[<p>Spring Boot Circuit Breaker is a fault-tolerance mechanism used to prevent cascading failures in a microservices architecture. It helps applications handle failures gracefully by detecting failures and stopping excessive requests to unhealthy services. This guide will walk you through implementing Circuit Breaker using Resilience4j in Spring Boot.</p>
<hr />
<h2>üåü Why Use Circuit Breaker?</h2>
<ul>
<li>Prevents cascading failures in microservices.</li>
<li>Improves application resilience by stopping excessive failed requests.</li>
<li>Automatically recovers when services become healthy again.</li>
<li>Reduces latency by preventing unnecessary waits for failed services.</li>
<li>Configurable retry strategies to manage failures efficiently.</li>
</ul>
<hr />
<h2>üìã Prerequisites</h2>
<p>Ensure you have the following:</p>
<ul>
<li>‚òï Java Development Kit (JDK) 17+</li>
<li>üì¶ Maven or Gradle installed</li>
<li>üåê Spring Boot &amp; Spring Cloud</li>
<li>üõ† A REST API to demonstrate Circuit Breaker behavior</li>
</ul>
<hr />
<h2>üõ†Ô∏è Step 1: Add Dependencies</h2>
<h3>Maven Configuration:</h3>
<pre><code class="language-xml">&lt;dependency&gt;
  &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;
  &lt;artifactId&gt;spring-cloud-starter-circuitbreaker-resilience4j&lt;/artifactId&gt;
&lt;/dependency&gt;</code></pre>
<h3>Gradle Configuration:</h3>
<pre><code class="language-groovy">implementation &#39;org.springframework.cloud:spring-cloud-starter-circuitbreaker-resilience4j&#39;</code></pre>
<hr />
<h2>üõ†Ô∏è Step 2: Configure Circuit Breaker Properties</h2>
<p>Define Circuit Breaker settings in `application.yml`.</p>
<pre><code class="language-yaml">resilience4j:
  circuitbreaker:
    instances:
      externalService:
        failure-rate-threshold: 50
        slow-call-rate-threshold: 50
        slow-call-duration-threshold: 2000ms
        permitted-number-of-calls-in-half-open-state: 3
        sliding-window-size: 10
        minimum-number-of-calls: 5
        wait-duration-in-open-state: 5s</code></pre>
<hr />
<h2>üõ†Ô∏è Step 3: Implement Circuit Breaker in a REST Service</h2>
<h3>Create a Service to Call an External API</h3>
<h3>Java</h3>
<pre><code class="language-java">package com.example.circuitbreaker.service;

import io.github.resilience4j.circuitbreaker.annotation.CircuitBreaker;
import org.springframework.stereotype.Service;
import org.springframework.web.client.RestTemplate;

@Service
public class ExternalService {

    private final RestTemplate restTemplate = new RestTemplate();

    @CircuitBreaker(name = &quot;externalService&quot;, fallbackMethod = &quot;fallbackResponse&quot;)
    public String callExternalAPI() {
        return restTemplate.getForObject(&quot;http://unreliable-service/api/data&quot;, String.class);
    }

    public String fallbackResponse(Exception e) {
        return &quot;Fallback response: Service is unavailable!&quot;;
    }
}</code></pre>
<h3>Kotlin</h3>
<pre><code class="language-kotlin">package com.example.circuitbreaker.service

import io.github.resilience4j.circuitbreaker.annotation.CircuitBreaker
import org.springframework.stereotype.Service
import org.springframework.web.client.RestTemplate

@Service
class ExternalService {
    private val restTemplate = RestTemplate()

    @CircuitBreaker(name = &quot;externalService&quot;, fallbackMethod = &quot;fallbackResponse&quot;)
    fun callExternalAPI(): String {
        return restTemplate.getForObject(&quot;http://unreliable-service/api/data&quot;, String::class.java) ?: &quot;&quot;
    }

    fun fallbackResponse(e: Exception): String {
        return &quot;Fallback response: Service is unavailable!&quot;
    }
}</code></pre>
<hr />
<h2>üõ†Ô∏è Step 4: Create a REST Controller</h2>
<h3>Java</h3>
<pre><code class="language-java">package com.example.circuitbreaker.controller;

import com.example.circuitbreaker.service.ExternalService;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;

@RestController
@RequestMapping(&quot;/api&quot;)
public class CircuitBreakerController {

    private final ExternalService externalService;

    public CircuitBreakerController(ExternalService externalService) {
        this.externalService = externalService;
    }

    @GetMapping(&quot;/data&quot;)
    public String fetchData() {
        return externalService.callExternalAPI();
    }
}</code></pre>
<h3>Kotlin</h3>
<pre><code class="language-kotlin">package com.example.circuitbreaker.controller

import com.example.circuitbreaker.service.ExternalService
import org.springframework.web.bind.annotation.GetMapping
import org.springframework.web.bind.annotation.RequestMapping
import org.springframework.web.bind.annotation.RestController

@RestController
@RequestMapping(&quot;/api&quot;)
class CircuitBreakerController(private val externalService: ExternalService) {

    @GetMapping(&quot;/data&quot;)
    fun fetchData(): String {
        return externalService.callExternalAPI()
    }
}</code></pre>
<hr />
<h2>‚ñ∂Ô∏è Running the Application</h2>
<p>Start the application:</p>
<pre><code class="language-bash">./mvnw spring-boot:run</code></pre>
<p>or using Gradle:</p>
<pre><code class="language-bash">gradle bootRun</code></pre>
<h2>üß™ Test the Circuit Breaker</h2>
<p>Test the Circuit Breaker:</p>
<pre><code class="language-bash">curl -X GET http://localhost:8080/api/data</code></pre>
<hr />
<h2>üèÅ Conclusion</h2>
<p>This setup delivers a robust, production-ready Spring Boot Circuit Breaker solution in Spring Boot, combining best practices, clear structure, and practical examples you can adapt to your own project.</p>]]></content:encoded>
      <category><![CDATA[Java]]></category>
      <category><![CDATA[Kotlin]]></category>
      <category><![CDATA[Spring Boot]]></category>
      <category><![CDATA[Spring Cloud]]></category>
      <category><![CDATA[Circuit Breaker]]></category>
      <category><![CDATA[Microservice]]></category>
      <category><![CDATA[Programming]]></category>
      <media:thumbnail url="https://suaybsimsek.com/images/spring-boot-circuit-breaker-thumbnail.webp" />
    </item>
    <item>
      <title><![CDATA[Spring Boot Eureka Server]]></title>
      <link>https://suaybsimsek.com/en/posts/spring-boot-eureka-server</link>
      <description><![CDATA[Learn how to set up and configure a Spring Boot Eureka Server for service discovery in microservices architecture.]]></description>
      <pubDate>Sun, 23 Feb 2025 00:00:00 GMT</pubDate>
      <guid isPermaLink="true">https://suaybsimsek.com/en/posts/spring-boot-eureka-server</guid>
      <content:encoded><![CDATA[<p>Spring Boot Eureka Server is a service registry that enables service discovery in a microservices architecture. It allows microservices to register themselves and discover other services dynamically. This guide will walk you through setting up and configuring a Spring Boot Eureka Server.</p>
<hr />
<h2>üåü Why Use Eureka Server?</h2>
<ul>
<li>Service Discovery: Automatically register and discover microservices.</li>
<li>Load Balancing: Enables client-side load balancing with Ribbon.</li>
<li>Failover Support: Services can find alternative instances if one fails.</li>
<li>Scalability: Easily scale microservices without manual configuration.</li>
<li>Spring Cloud Integration: Works seamlessly with Spring Boot applications.</li>
</ul>
<hr />
<h2>üìã Prerequisites</h2>
<p>Ensure you have the following:</p>
<ul>
<li>‚òï Java Development Kit (JDK) 17+</li>
<li>üì¶ Maven or Gradle installed</li>
</ul>
<hr />
<h2>üõ†Ô∏è Step 1: Add Dependencies</h2>
<h3>Maven Configuration:</h3>
<pre><code class="language-xml">&lt;dependency&gt;
    &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;
    &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-server&lt;/artifactId&gt;
&lt;/dependency&gt;</code></pre>
<h3>Gradle Configuration:</h3>
<pre><code class="language-groovy">implementation &#39;org.springframework.cloud:spring-cloud-starter-netflix-eureka-server&#39;</code></pre>
<hr />
<h2>üõ†Ô∏è Step 2: Create the Eureka Server Application</h2>
<h3>Java</h3>
<pre><code class="language-java">package com.example.eurekaserver;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;
import org.springframework.cloud.netflix.eureka.server.EnableEurekaServer;

@SpringBootApplication
@EnableEurekaServer
public class EurekaServerApplication {
    public static void main(String[] args) {
        SpringApplication.run(EurekaServerApplication.class, args);
    }
}</code></pre>
<h3>Kotlin</h3>
<pre><code class="language-kotlin">package com.example.eurekaserver

import org.springframework.boot.autoconfigure.SpringBootApplication
import org.springframework.boot.runApplication
import org.springframework.cloud.netflix.eureka.server.EnableEurekaServer

@SpringBootApplication
@EnableEurekaServer
class EurekaServerApplication

fun main(args: Array&lt;String&gt;) {
    runApplication&lt;EurekaServerApplication&gt;(*args)
}</code></pre>
<hr />
<h2>üõ†Ô∏è Step 3: Configure the Eureka Server</h2>
<p>Create an `application.yml` file for Eureka Server configuration.</p>
<pre><code class="language-yaml">server:
  port: 8761
spring:
  application:
    name: eureka-server
eureka:
  client:
    register-with-eureka: false
    fetch-registry: false
  server:
    wait-time-in-ms-when-sync-empty: 5</code></pre>
<p>&gt; Note: The Eureka Server does not register itself.</p>
<hr />
<h2>‚ñ∂Ô∏è Running the Eureka Server</h2>
<p>Start the Eureka Server application:</p>
<pre><code class="language-bash">./mvnw spring-boot:run</code></pre>
<p>or using Gradle:</p>
<pre><code class="language-bash">gradle bootRun</code></pre>
<p>Access the Eureka Server dashboard:</p>
<pre><code class="language-bash">http://localhost:8761/</code></pre>
<hr />
<h2>üõ†Ô∏è Step 4: Register a Client Application</h2>
<h3>Add Dependencies</h3>
<h3>Maven:</h3>
<pre><code class="language-xml">&lt;dependency&gt;
    &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;
    &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-client&lt;/artifactId&gt;
&lt;/dependency&gt;</code></pre>
<h3>Gradle:</h3>
<pre><code class="language-groovy">implementation &#39;org.springframework.cloud:spring-cloud-starter-netflix-eureka-client&#39;</code></pre>
<h3>Client Application Configuration</h3>
<p>In the client&#39;s `application.yml`, add the following:</p>
<pre><code class="language-yaml">spring:
  application:
    name: eureka-client
eureka:
  client:
    service-url:
      defaultZone: http://localhost:8761/eureka/</code></pre>
<h3>Client Application Code</h3>
<h3>Java</h3>
<pre><code class="language-java">package com.example.eurekaclient;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;

@SpringBootApplication
@RestController
@RequestMapping(&quot;/client&quot;)
public class EurekaClientApplication {

    @GetMapping
    public String getClientMessage() {
        return &quot;Hello from Eureka Client!&quot;;
    }

    public static void main(String[] args) {
        SpringApplication.run(EurekaClientApplication.class, args);
    }
}</code></pre>
<h3>Kotlin</h3>
<pre><code class="language-kotlin">package com.example.eurekaclient

import org.springframework.boot.autoconfigure.SpringBootApplication
import org.springframework.boot.runApplication
import org.springframework.web.bind.annotation.GetMapping
import org.springframework.web.bind.annotation.RequestMapping
import org.springframework.web.bind.annotation.RestController

@SpringBootApplication
@RestController
@RequestMapping(&quot;/client&quot;)
class EurekaClientApplication {

    @GetMapping
    fun getClientMessage(): String {
        return &quot;Hello from Eureka Client!&quot;
    }
}

fun main(args: Array&lt;String&gt;) {
    runApplication&lt;EurekaClientApplication&gt;(*args)
}</code></pre>
<hr />
<h2>‚ñ∂Ô∏è Running the Client Application</h2>
<p>Run the Eureka Client application:</p>
<pre><code class="language-bash">./mvnw spring-boot:run</code></pre>
<p>or using Gradle:</p>
<pre><code class="language-bash">gradle bootRun</code></pre>
<p>Check if the client has registered with Eureka Server by visiting:</p>
<pre><code class="language-bash">http://localhost:8761/</code></pre>
<hr />
<h2>üèÅ Conclusion</h2>
<p>This setup delivers a robust, production-ready Spring Boot Eureka Server solution in Spring Boot, combining best practices, clear structure, and practical examples you can adapt to your own project.</p>]]></content:encoded>
      <category><![CDATA[Java]]></category>
      <category><![CDATA[Kotlin]]></category>
      <category><![CDATA[Spring Boot]]></category>
      <category><![CDATA[Spring Cloud]]></category>
      <category><![CDATA[Eureka Server]]></category>
      <category><![CDATA[Microservice]]></category>
      <category><![CDATA[Programming]]></category>
      <media:thumbnail url="https://suaybsimsek.com/images/spring-boot-eureka-server-thumbnail.webp" />
    </item>
    <item>
      <title><![CDATA[Spring Boot Config Server]]></title>
      <link>https://suaybsimsek.com/en/posts/spring-boot-config-server</link>
      <description><![CDATA[Learn how to use Spring Boot Config Server to centralize and manage application configurations efficiently.]]></description>
      <pubDate>Sat, 22 Feb 2025 00:00:00 GMT</pubDate>
      <guid isPermaLink="true">https://suaybsimsek.com/en/posts/spring-boot-config-server</guid>
      <content:encoded><![CDATA[<p>Spring Boot Config Server enables centralized configuration management for distributed applications, allowing dynamic configuration updates without requiring service restarts. This guide covers how to set up and use Spring Boot Config Server efficiently.</p>
<hr />
<h2>üåü Why Use Config Server?</h2>
<ul>
<li>Centralized Configuration: Manage application settings in a single place.</li>
<li>Dynamic Updates: Update configurations without restarting services.</li>
<li>Environment Profiles: Support different configurations for dev, test, and production environments.</li>
<li>Security &amp; Access Control: Store sensitive configurations securely.</li>
<li>Integration with Git: Keep configuration versions managed and trackable.</li>
</ul>
<hr />
<h2>üìã Prerequisites</h2>
<p>Ensure you have the following:</p>
<ul>
<li>‚òï Java Development Kit (JDK) 17+</li>
<li>üì¶ Maven or Gradle installed</li>
<li>üìÅ Git Repository (for storing configurations)</li>
</ul>
<hr />
<h2>üõ†Ô∏è Step 1: Add Dependencies</h2>
<p>Add the necessary dependencies for Spring Cloud Config Server.</p>
<h3>Maven Configuration:</h3>
<pre><code class="language-xml">&lt;dependency&gt;
    &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;
    &lt;artifactId&gt;spring-cloud-config-server&lt;/artifactId&gt;
&lt;/dependency&gt;</code></pre>
<h3>Gradle Configuration:</h3>
<pre><code class="language-groovy">implementation &#39;org.springframework.cloud:spring-cloud-config-server&#39;</code></pre>
<hr />
<h2>üõ†Ô∏è Step 2: Create the Config Server Application</h2>
<h3>Java</h3>
<pre><code class="language-java">package com.example.configserver;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;
import org.springframework.cloud.config.server.EnableConfigServer;

@SpringBootApplication
@EnableConfigServer
public class ConfigServerApplication {
    public static void main(String[] args) {
        SpringApplication.run(ConfigServerApplication.class, args);
    }
}</code></pre>
<h3>Kotlin</h3>
<pre><code class="language-kotlin">package com.example.configserver

import org.springframework.boot.autoconfigure.SpringBootApplication
import org.springframework.boot.runApplication
import org.springframework.cloud.config.server.EnableConfigServer

@SpringBootApplication
@EnableConfigServer
class ConfigServerApplication

fun main(args: Array&lt;String&gt;) {
    runApplication&lt;ConfigServerApplication&gt;(*args)
}</code></pre>
<hr />
<h2>üõ†Ô∏è Step 3: Configure the Config Server</h2>
<p>Create an `application.yml` file to specify the Git repository for storing configurations.</p>
<pre><code class="language-yaml">server:
  port: 8888
spring:
  cloud:
    config:
      server:
        git:
          uri: https://github.com/example/config-repo
          default-label: main</code></pre>
<p>&gt; Note: Replace `https://github.com/example/config-repo` with your actual Git repository.</p>
<hr />
<h2>üõ†Ô∏è Step 4: Create a Configuration Repository</h2>
<p>In your Git repository (e.g., `config-repo`), create an `application.yml` file with the following content:</p>
<pre><code class="language-yaml">config.key: &#39;Hello from Config Server!&#39;</code></pre>
<p>Commit and push the file to the repository:</p>
<pre><code class="language-bash">git add application.yml
git commit -m &quot;Add config properties&quot;
git push origin main</code></pre>
<hr />
<h2>‚ñ∂Ô∏è Running the Config Server</h2>
<p>Start the Config Server application:</p>
<pre><code class="language-bash">./mvnw spring-boot:run</code></pre>
<p>or using Gradle:</p>
<pre><code class="language-bash">gradle bootRun</code></pre>
<p>Verify it is running by accessing:</p>
<pre><code class="language-bash">curl -X GET http://localhost:8888/application/default</code></pre>
<p>Expected Output:</p>
<pre><code class="language-json">{
  &quot;name&quot;: &quot;application&quot;,
  &quot;profiles&quot;: [&quot;default&quot;],
  &quot;propertySources&quot;: [
    {
      &quot;name&quot;: &quot;https://github.com/example/config-repo/application.yml&quot;,
      &quot;source&quot;: {
        &quot;config.key&quot;: &quot;Hello from Config Server!&quot;
      }
    }
  ]
}</code></pre>
<hr />
<h2>üõ†Ô∏è Step 5: Configure a Client Application</h2>
<h3>Add Dependencies</h3>
<h3>Maven:</h3>
<pre><code class="language-xml">&lt;dependency&gt;
    &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;
    &lt;artifactId&gt;spring-cloud-starter-config&lt;/artifactId&gt;
&lt;/dependency&gt;</code></pre>
<h3>Gradle:</h3>
<pre><code class="language-groovy">implementation &#39;org.springframework.cloud:spring-cloud-starter-config&#39;</code></pre>
<h3>Client Application Configuration</h3>
<p>In the client&#39;s `bootstrap.yml`, add the following:</p>
<pre><code class="language-yaml">spring:
  application:
    name: config-client
  cloud:
    config:
      uri: http://localhost:8888</code></pre>
<h3>Client Application Code</h3>
<h3>Java</h3>
<pre><code class="language-java">package com.example.configclient;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;
import org.springframework.beans.factory.annotation.Value;

@SpringBootApplication
@RestController
@RequestMapping(&quot;/config&quot;)
public class ConfigClientApplication {

  @Value(&quot;${config.key:not found}&quot;)
  private String configValue;

  @GetMapping
  public String getConfigValue() {
    return &quot;Config Value: &quot; + configValue;
  }

  public static void main(String[] args) {
    SpringApplication.run(ConfigClientApplication.class, args);
  }
}</code></pre>
<h3>Kotlin</h3>
<pre><code class="language-kotlin">package com.example.configclient

import org.springframework.boot.autoconfigure.SpringBootApplication
import org.springframework.boot.runApplication
import org.springframework.web.bind.annotation.GetMapping
import org.springframework.web.bind.annotation.RequestMapping
import org.springframework.web.bind.annotation.RestController
import org.springframework.beans.factory.annotation.Value

@SpringBootApplication
@RestController
@RequestMapping(&quot;/config&quot;)
class ConfigClientApplication {

    @Value(&quot;\${config.key:not found}&quot;)
    lateinit var configValue: String

    @GetMapping
    fun getConfigValue(): String {
        return &quot;Config Value: \$configValue&quot;
    }
}

fun main(args: Array&lt;String&gt;) {
    runApplication&lt;ConfigClientApplication&gt;(*args)
}</code></pre>
<hr />
<h2>‚ñ∂Ô∏è Running the Client Application</h2>
<p>Run the Config Client application:</p>
<pre><code class="language-bash">./mvnw spring-boot:run</code></pre>
<p>or using Gradle:</p>
<pre><code class="language-bash">gradle bootRun</code></pre>
<p>Retrieve the configuration from Config Server:</p>
<pre><code class="language-bash">curl -X GET http://localhost:8080/config</code></pre>
<p>Expected Output:</p>
<pre><code class="language-plaintext">Config Value: Hello from Config Server!</code></pre>
<hr />
<h2>üèÅ Conclusion</h2>
<p>This setup delivers a robust, production-ready Spring Boot Config Server solution in Spring Boot, combining best practices, clear structure, and practical examples you can adapt to your own project.</p>]]></content:encoded>
      <category><![CDATA[Java]]></category>
      <category><![CDATA[Kotlin]]></category>
      <category><![CDATA[Spring Boot]]></category>
      <category><![CDATA[Spring Cloud]]></category>
      <category><![CDATA[Config Server]]></category>
      <category><![CDATA[Microservice]]></category>
      <category><![CDATA[Programming]]></category>
      <media:thumbnail url="https://suaybsimsek.com/images/spring-boot-config-server-thumbnail.webp" />
    </item>
    <item>
      <title><![CDATA[Spring Boot Docker Integration]]></title>
      <link>https://suaybsimsek.com/en/posts/spring-boot-docker</link>
      <description><![CDATA[Learn how to build and deploy Spring Boot applications using Docker with Buildpacks and Jib for efficient containerization.]]></description>
      <pubDate>Fri, 21 Feb 2025 00:00:00 GMT</pubDate>
      <guid isPermaLink="true">https://suaybsimsek.com/en/posts/spring-boot-docker</guid>
      <content:encoded><![CDATA[<p>Spring Boot provides multiple ways to containerize applications efficiently using Docker, Buildpacks, and Jib. This guide explores different approaches to building and deploying Spring Boot applications with Docker.</p>
<hr />
<h2>üåü Why Use Docker for Spring Boot?</h2>
<ul>
<li>Portable Deployment: Run applications consistently across environments.</li>
<li>Scalability: Easily scale and manage containerized applications.</li>
<li>Lightweight and Efficient: Optimize resource utilization with minimal overhead.</li>
<li>DevOps Friendly: Seamlessly integrate with CI/CD pipelines.</li>
</ul>
<hr />
<h2>üìã Prerequisites</h2>
<p>Ensure you have the following:</p>
<ul>
<li>‚òï Java Development Kit (JDK) 17+</li>
<li>üì¶ Maven or Gradle installed</li>
<li>üê≥ Docker installed and running</li>
</ul>
<hr />
<h2>üõ†Ô∏è Step 1: Add Dependencies</h2>
<p>To enable Docker support, add the Spring Boot Maven Plugin, Jib Plugin, and Spring Boot Web Starter to your build tool.</p>
<h3>Maven Configuration:</h3>
<pre><code class="language-xml">&lt;dependencies&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
        &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;
    &lt;/dependency&gt;
&lt;/dependencies&gt;

&lt;build&gt;
    &lt;plugins&gt;
        &lt;plugin&gt;
            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
            &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt;
        &lt;/plugin&gt;
        &lt;plugin&gt;
            &lt;groupId&gt;com.google.cloud.tools&lt;/groupId&gt;
            &lt;artifactId&gt;jib-maven-plugin&lt;/artifactId&gt;
            &lt;version&gt;3.3.2&lt;/version&gt;
        &lt;/plugin&gt;
    &lt;/plugins&gt;
&lt;/build&gt;</code></pre>
<h3>Gradle Configuration:</h3>
<pre><code class="language-groovy">plugins {
    id &#39;org.springframework.boot&#39; version &#39;3.2.0&#39;
    id &#39;com.google.cloud.tools.jib&#39; version &#39;3.3.2&#39;
}

dependencies {
    implementation &#39;org.springframework.boot:spring-boot-starter-web&#39;
}</code></pre>
<p>To enable Docker support, add the Spring Boot Maven Plugin and Jib Plugin to your build tool.</p>
<h3>Maven Configuration:</h3>
<pre><code class="language-xml">&lt;build&gt;
    &lt;plugins&gt;
        &lt;plugin&gt;
            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
            &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt;
        &lt;/plugin&gt;
        &lt;plugin&gt;
            &lt;groupId&gt;com.google.cloud.tools&lt;/groupId&gt;
            &lt;artifactId&gt;jib-maven-plugin&lt;/artifactId&gt;
            &lt;version&gt;3.3.2&lt;/version&gt;
        &lt;/plugin&gt;
    &lt;/plugins&gt;
&lt;/build&gt;</code></pre>
<h3>Gradle Configuration:</h3>
<pre><code class="language-groovy">plugins {
    id &#39;org.springframework.boot&#39; version &#39;3.2.0&#39;
    id &#39;com.google.cloud.tools.jib&#39; version &#39;3.3.2&#39;
}</code></pre>
<hr />
<h2>üõ†Ô∏è Step 2: Create a Simple Spring Boot Application</h2>
<p>Define a REST endpoint to deploy inside a Docker container.</p>
<h3>Java</h3>
<pre><code class="language-java">package com.example.docker;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RestController;

@SpringBootApplication
@RestController
public class DockerApplication {

    public static void main(String[] args) {
        SpringApplication.run(DockerApplication.class, args);
    }

    @GetMapping(&quot;/hello&quot;)
    public String hello() {
        return &quot;Hello from Spring Boot running in Docker!&quot;;
    }
}</code></pre>
<h3>Kotlin</h3>
<pre><code class="language-kotlin">package com.example.docker

import org.springframework.boot.autoconfigure.SpringBootApplication
import org.springframework.boot.runApplication
import org.springframework.web.bind.annotation.GetMapping
import org.springframework.web.bind.annotation.RestController

@SpringBootApplication
@RestController
class DockerApplication {

    @GetMapping(&quot;/hello&quot;)
    fun hello(): String = &quot;Hello from Spring Boot running in Docker!&quot;
}

fun main(args: Array&lt;String&gt;) {
    runApplication&lt;DockerApplication&gt;(*args)
}</code></pre>
<hr />
<h2>‚ñ∂Ô∏è Step 3: Build and Run a Docker Image</h2>
<h3>Option 1: Using Buildpacks</h3>
<p>Spring Boot provides built-in support for creating Docker images without a `Dockerfile` using Buildpacks.</p>
<pre><code class="language-bash">mvn spring-boot:build-image</code></pre>
<pre><code class="language-bash">gradle bootBuildImage</code></pre>
<p>Run the container:</p>
<pre><code class="language-bash">docker run --rm -p 8080:8080 myproject:0.0.1-SNAPSHOT</code></pre>
<hr />
<h3>Option 2: Using Jib</h3>
<p>Jib allows building optimized container images without a Docker daemon.</p>
<pre><code class="language-bash">mvn jib:dockerBuild</code></pre>
<pre><code class="language-bash">gradle jibDockerBuild</code></pre>
<p>Run the Jib-built container:</p>
<pre><code class="language-bash">docker run --rm -p 8080:8080 myproject:0.0.1-SNAPSHOT</code></pre>
<hr />
<h2>‚ñ∂Ô∏è Running the Application</h2>
<p>Once the container is running, test the REST API:</p>
<pre><code class="language-bash">curl -X GET http://localhost:8080/hello</code></pre>
<p>Expected Output:</p>
<pre><code class="language-plaintext">Hello from Spring Boot running in Docker!</code></pre>
<hr />
<h2>üèÅ Conclusion</h2>
<p>This setup delivers a robust, production-ready Spring Boot Docker Integration solution in Spring Boot, combining best practices, clear structure, and practical examples you can adapt to your own project.</p>]]></content:encoded>
      <category><![CDATA[Java]]></category>
      <category><![CDATA[Kotlin]]></category>
      <category><![CDATA[Spring Boot]]></category>
      <category><![CDATA[Docker]]></category>
      <category><![CDATA[Containerization]]></category>
      <category><![CDATA[Jib]]></category>
      <category><![CDATA[Programming]]></category>
      <media:thumbnail url="https://suaybsimsek.com/images/spring-boot-docker-thumbnail.webp" />
    </item>
    <item>
      <title><![CDATA[Spring Boot Kubernetes Integration]]></title>
      <link>https://suaybsimsek.com/en/posts/spring-boot-kubernetes</link>
      <description><![CDATA[Learn how to deploy Spring Boot applications on Kubernetes for scalable, containerized microservices.]]></description>
      <pubDate>Fri, 21 Feb 2025 00:00:00 GMT</pubDate>
      <guid isPermaLink="true">https://suaybsimsek.com/en/posts/spring-boot-kubernetes</guid>
      <content:encoded><![CDATA[<p>Spring Boot seamlessly integrates with Kubernetes to provide scalable, containerized applications. This guide explores how to deploy and manage Spring Boot applications in a Kubernetes cluster.</p>
<hr />
<h2>üåü Why Use Kubernetes for Spring Boot?</h2>
<ul>
<li>Scalability: Automatically scale applications based on traffic.</li>
<li>Self-Healing: Kubernetes restarts failed containers automatically.</li>
<li>Declarative Configuration: Manage infrastructure with YAML configurations.</li>
<li>Load Balancing &amp; Service Discovery: Built-in support for routing requests efficiently.</li>
<li>Efficient Resource Utilization: Optimize CPU and memory usage dynamically.</li>
</ul>
<hr />
<h2>üìã Prerequisites</h2>
<p>Ensure you have the following:</p>
<ul>
<li>‚òï Java Development Kit (JDK) 17+</li>
<li>üì¶ Maven or Gradle installed</li>
<li>üõ† Docker installed and running</li>
<li>üåê Kubernetes Cluster (Minikube or a cloud provider like AWS EKS, GKE, or AKS)</li>
<li>üõ† kubectl installed for managing Kubernetes</li>
</ul>
<hr />
<h2>üõ†Ô∏è Step 1: Add Dependencies</h2>
<p>Add the necessary dependencies for Spring Boot Web and Actuator to expose health endpoints.</p>
<h3>Maven Configuration:</h3>
<pre><code class="language-xml">&lt;dependencies&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
        &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;
    &lt;/dependency&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
        &lt;artifactId&gt;spring-boot-starter-actuator&lt;/artifactId&gt;
    &lt;/dependency&gt;
&lt;/dependencies&gt;</code></pre>
<h3>Gradle Configuration:</h3>
<pre><code class="language-groovy">dependencies {
    implementation &#39;org.springframework.boot:spring-boot-starter-web&#39;
    implementation &#39;org.springframework.boot:spring-boot-starter-actuator&#39;
}</code></pre>
<hr />
<h2>üõ†Ô∏è Step 2: Create a Simple Spring Boot Application</h2>
<p>Define a REST endpoint to deploy inside Kubernetes.</p>
<h3>Java</h3>
<pre><code class="language-java">package com.example.kubernetes;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RestController;

@SpringBootApplication
@RestController
public class KubernetesApplication {

    public static void main(String[] args) {
        SpringApplication.run(KubernetesApplication.class, args);
    }

    @GetMapping(&quot;/hello&quot;)
    public String hello() {
        return &quot;Hello from Spring Boot running in Kubernetes!&quot;;
    }
}</code></pre>
<h3>Kotlin</h3>
<pre><code class="language-kotlin">package com.example.kubernetes

import org.springframework.boot.autoconfigure.SpringBootApplication
import org.springframework.boot.runApplication
import org.springframework.web.bind.annotation.GetMapping
import org.springframework.web.bind.annotation.RestController

@SpringBootApplication
@RestController
class KubernetesApplication {

    @GetMapping(&quot;/hello&quot;)
    fun hello(): String = &quot;Hello from Spring Boot running in Kubernetes!&quot;
}

fun main(args: Array&lt;String&gt;) {
    runApplication&lt;KubernetesApplication&gt;(*args)
}</code></pre>
<hr />
<h2>üõ†Ô∏è Step 3: Create Kubernetes Deployment and Service</h2>
<p>Create a deployment.yaml file:</p>
<pre><code class="language-yaml">apiVersion: apps/v1
kind: Deployment
metadata:
  name: spring-boot-app
spec:
  replicas: 2
  selector:
    matchLabels:
      app: spring-boot-app
  template:
    metadata:
      labels:
        app: spring-boot-app
    spec:
      containers:
        - name: spring-boot-app
          image: myproject:0.0.1-SNAPSHOT
          ports:
            - containerPort: 8080</code></pre>
<p>Create a service.yaml file:</p>
<pre><code class="language-yaml">apiVersion: v1
kind: Service
metadata:
  name: spring-boot-service
spec:
  type: LoadBalancer
  selector:
    app: spring-boot-app
  ports:
    - protocol: TCP
      port: 80
      targetPort: 8080</code></pre>
<p>Apply the configurations:</p>
<pre><code class="language-bash">kubectl apply -f deployment.yaml
kubectl apply -f service.yaml</code></pre>
<hr />
<h2>‚ñ∂Ô∏è Running the Application</h2>
<p>Once deployed, retrieve the service URL:</p>
<pre><code class="language-bash">kubectl get services</code></pre>
<p>Test the endpoint:</p>
<pre><code class="language-bash">curl -X GET http://your-service-ip/hello</code></pre>
<p>Expected Output:</p>
<pre><code class="language-plaintext">Hello from Spring Boot running in Kubernetes!</code></pre>
<hr />
<h2>üèÅ Conclusion</h2>
<p>This setup delivers a robust, production-ready Spring Boot Kubernetes Integration solution in Spring Boot, combining best practices, clear structure, and practical examples you can adapt to your own project.</p>]]></content:encoded>
      <category><![CDATA[Java]]></category>
      <category><![CDATA[Kotlin]]></category>
      <category><![CDATA[Spring Boot]]></category>
      <category><![CDATA[Kubernetes]]></category>
      <category><![CDATA[Microservice]]></category>
      <category><![CDATA[Containerization]]></category>
      <category><![CDATA[Programming]]></category>
      <media:thumbnail url="https://suaybsimsek.com/images/spring-boot-kubernetes-thumbnail.webp" />
    </item>
    <item>
      <title><![CDATA[Spring Boot Async Tasks]]></title>
      <link>https://suaybsimsek.com/en/posts/spring-boot-async-tasks</link>
      <description><![CDATA[Learn how to use @Async in Spring Boot to execute tasks asynchronously without blocking the main thread.]]></description>
      <pubDate>Thu, 20 Feb 2025 00:00:00 GMT</pubDate>
      <guid isPermaLink="true">https://suaybsimsek.com/en/posts/spring-boot-async-tasks</guid>
      <content:encoded><![CDATA[<p>Spring Boot provides an easy way to run asynchronous tasks using the `@Async` annotation. This is useful for executing tasks in the background, improving performance, and avoiding blocking the main thread.</p>
<hr />
<h2>üåü Why Use @Async in Spring Boot?</h2>
<ul>
<li>Non-Blocking Execution: Runs tasks asynchronously without blocking the main thread.</li>
<li>Improved Performance: Executes independent tasks in parallel.</li>
<li>Better Scalability: Frees up resources for other processes.</li>
<li>Seamless Integration: Works with Spring Boot‚Äôs dependency injection and lifecycle management.</li>
</ul>
<hr />
<h2>üìã Prerequisites</h2>
<p>Ensure you have the following:</p>
<ul>
<li>‚òï Java Development Kit (JDK) 17+</li>
<li>üì¶ Maven or Gradle installed</li>
<li>üî§ A Java IDE (e.g., IntelliJ IDEA, Eclipse)</li>
</ul>
<hr />
<h2>üõ†Ô∏è Step 1: Add Dependencies</h2>
<p>To enable async processing, include spring-boot-starter-web in your `pom.xml` or `build.gradle` file.</p>
<p>Maven:</p>
<pre><code class="language-xml">&lt;dependency&gt;
    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
    &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;
&lt;/dependency&gt;</code></pre>
<p>Gradle:</p>
<pre><code class="language-groovy">implementation &#39;org.springframework.boot:spring-boot-starter-web&#39;</code></pre>
<hr />
<h2>üõ†Ô∏è Step 2: Enable Async in Your Application</h2>
<p>Annotate your main application class with `@EnableAsync` to enable asynchronous execution.</p>
<h3>Java</h3>
<pre><code class="language-java">package com.example.async;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;
import org.springframework.scheduling.annotation.EnableAsync;

@SpringBootApplication
@EnableAsync
public class AsyncApplication {
    public static void main(String[] args) {
        SpringApplication.run(AsyncApplication.class, args);
    }
}</code></pre>
<h3>Kotlin</h3>
<pre><code class="language-kotlin">package com.example.async

import org.springframework.boot.autoconfigure.SpringBootApplication
import org.springframework.boot.runApplication
import org.springframework.scheduling.annotation.EnableAsync

@SpringBootApplication
@EnableAsync
class AsyncApplication

fun main(args: Array&lt;String&gt;) {
    runApplication&lt;AsyncApplication&gt;(*args)
}</code></pre>
<hr />
<h2>üõ†Ô∏è Step 3: Create an Async Task</h2>
<p>Define an asynchronous method using `@Async`.</p>
<h3>Java</h3>
<pre><code class="language-java">package com.example.async;

import org.springframework.scheduling.annotation.Async;
import org.springframework.stereotype.Service;
import java.time.LocalTime;

@Service
public class AsyncTask {

    @Async
    public void runTask() {
        System.out.println(&quot;Async task executed at: &quot; + LocalTime.now());
    }
}</code></pre>
<h3>Kotlin</h3>
<pre><code class="language-kotlin">package com.example.async

import org.springframework.scheduling.annotation.Async
import org.springframework.stereotype.Service
import java.time.LocalTime

@Service
class AsyncTask {

    @Async
    fun runTask() {
        println(&quot;Async task executed at: ${LocalTime.now()}&quot;)
    }
}</code></pre>
<hr />
<h2>üõ†Ô∏è Step 4: Create a Controller to Trigger Async Tasks</h2>
<p>Create a REST controller to trigger the asynchronous task.</p>
<h3>Java</h3>
<pre><code class="language-java">package com.example.async;

import org.springframework.web.bind.annotation.*;
import lombok.RequiredArgsConstructor;

@RestController
@RequestMapping(&quot;/async&quot;)
@RequiredArgsConstructor
public class AsyncController {

    private final AsyncTask asyncTask;

    @GetMapping(&quot;/run&quot;)
    public String triggerAsyncTask() {
        asyncTask.runTask();
        return &quot;Async task triggered!&quot;;
    }
}</code></pre>
<h3>Kotlin</h3>
<pre><code class="language-kotlin">package com.example.async

import org.springframework.web.bind.annotation.*

@RestController
@RequestMapping(&quot;/async&quot;)
class AsyncController(
    private val asyncTask: AsyncTask
) {

    @GetMapping(&quot;/run&quot;)
    fun triggerAsyncTask(): String {
        asyncTask.runTask()
        return &quot;Async task triggered!&quot;
    }
}</code></pre>
<hr />
<h2>‚ñ∂Ô∏è Running the Application</h2>
<p>Run the Spring Boot application:</p>
<pre><code class="language-bash">./mvnw spring-boot:run</code></pre>
<p>Or using Gradle:</p>
<pre><code class="language-bash">gradle bootRun</code></pre>
<hr />
<h2>üß™ Testing the Async Task</h2>
<h3>Trigger Async Task:</h3>
<pre><code class="language-bash">curl -X GET http://localhost:8080/async/run</code></pre>
<h3>Expected Console Output:</h3>
<pre><code class="language-plaintext">Async task executed at: 12:00:01</code></pre>
<hr />
<h2>üèÅ Conclusion</h2>
<p>This setup delivers a robust, production-ready Spring Boot Async Tasks solution in Spring Boot, combining best practices, clear structure, and practical examples you can adapt to your own project.</p>]]></content:encoded>
      <category><![CDATA[Java]]></category>
      <category><![CDATA[Kotlin]]></category>
      <category><![CDATA[Spring Boot]]></category>
      <category><![CDATA[Async Tasks]]></category>
      <category><![CDATA[Programming]]></category>
      <media:thumbnail url="https://suaybsimsek.com/images/spring-boot-async-thumbnail.webp" />
    </item>
    <item>
      <title><![CDATA[Spring Boot Scheduled Tasks]]></title>
      <link>https://suaybsimsek.com/en/posts/spring-boot-scheduled-tasks</link>
      <description><![CDATA[Learn how to use @Scheduled in Spring Boot to run background tasks at fixed intervals or cron expressions.]]></description>
      <pubDate>Thu, 20 Feb 2025 00:00:00 GMT</pubDate>
      <guid isPermaLink="true">https://suaybsimsek.com/en/posts/spring-boot-scheduled-tasks</guid>
      <content:encoded><![CDATA[<p>Spring Boot allows developers to easily schedule and execute background tasks using the `@Scheduled` annotation. This is useful for running periodic jobs, automation tasks, and batch processing without manual intervention.</p>
<hr />
<h2>üåü Why Use @Scheduled in Spring Boot?</h2>
<ul>
<li>Automate Tasks: Run jobs periodically without human interaction.</li>
<li>Efficient Resource Usage: Schedule tasks without blocking main threads.</li>
<li>Supports Fixed Rate, Fixed Delay, and Cron Expressions.</li>
<li>Seamless Integration: Works with Spring Boot‚Äôs dependency injection and lifecycle management.</li>
</ul>
<hr />
<h2>üìã Prerequisites</h2>
<p>Ensure you have the following:</p>
<ul>
<li>‚òï Java Development Kit (JDK) 17+</li>
<li>üì¶ Maven or Gradle installed</li>
<li>üî§ A Java IDE (e.g., IntelliJ IDEA, Eclipse)</li>
</ul>
<hr />
<h2>üõ†Ô∏è Step 1: Add Dependencies</h2>
<p>To enable scheduling, you need to include spring-boot-starter-web in your `pom.xml` or `build.gradle` file.</p>
<p>Maven:</p>
<pre><code class="language-xml">&lt;dependency&gt;
    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
    &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;
&lt;/dependency&gt;</code></pre>
<p>Gradle:</p>
<pre><code class="language-groovy">implementation &#39;org.springframework.boot:spring-boot-starter-web&#39;</code></pre>
<p>&gt; Why `spring-boot-starter-web`? &gt; Spring Boot applications using `@Scheduled` need a running Spring Context. Including `spring-boot-starter-web` ensures that the application lifecycle is properly managed.</p>
<hr />
<h2>üõ†Ô∏è Step 2: Enable Scheduling in Your Application</h2>
<p>To enable scheduling, annotate your main application class with `@EnableScheduling`.</p>
<h3>Java</h3>
<pre><code class="language-java">package com.example.scheduled;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;
import org.springframework.scheduling.annotation.EnableScheduling;

@SpringBootApplication
@EnableScheduling
public class ScheduledApplication {
    public static void main(String[] args) {
        SpringApplication.run(ScheduledApplication.class, args);
    }
}</code></pre>
<h3>Kotlin</h3>
<pre><code class="language-kotlin">package com.example.scheduled

import org.springframework.boot.autoconfigure.SpringBootApplication
import org.springframework.boot.runApplication
import org.springframework.scheduling.annotation.EnableScheduling

@SpringBootApplication
@EnableScheduling
class ScheduledApplication

fun main(args: Array&lt;String&gt;) {
    runApplication&lt;ScheduledApplication&gt;(*args)
}</code></pre>
<hr />
<h2>üõ†Ô∏è Step 3: Create a Scheduled Task</h2>
<p>Define a scheduled task using `@Scheduled`.</p>
<h3>Java</h3>
<pre><code class="language-java">package com.example.scheduled;

import org.springframework.scheduling.annotation.Scheduled;
import org.springframework.stereotype.Service;
import java.time.LocalTime;

@Service
public class ScheduledTask {

    @Scheduled(fixedRate = 5000)
    public void runTask() {
        System.out.println(&quot;Scheduled task executed at: &quot; + LocalTime.now());
    }
}</code></pre>
<h3>Kotlin</h3>
<pre><code class="language-kotlin">package com.example.scheduled

import org.springframework.scheduling.annotation.Scheduled
import org.springframework.stereotype.Service
import java.time.LocalTime

@Service
class ScheduledTask {

    @Scheduled(fixedRate = 5000)
    fun runTask() {
        println(&quot;Scheduled task executed at: ${LocalTime.now()}&quot;)
    }
}</code></pre>
<hr />
<h2>‚ñ∂Ô∏è Running the Application</h2>
<p>Run the Spring Boot application:</p>
<pre><code class="language-bash">./mvnw spring-boot:run</code></pre>
<p>Or using Gradle:</p>
<pre><code class="language-bash">gradle bootRun</code></pre>
<p>The scheduled task will execute every 5 seconds and print a timestamp.</p>
<hr />
<h2>üß™ Testing the Scheduled Task</h2>
<h3>Expected Console Output:</h3>
<pre><code class="language-plaintext">Scheduled task executed at: 12:00:01
Scheduled task executed at: 12:00:06
Scheduled task executed at: 12:00:11</code></pre>
<hr />
<h2>üèÅ Conclusion</h2>
<p>This setup delivers a robust, production-ready Spring Boot Scheduled Tasks solution in Spring Boot, combining best practices, clear structure, and practical examples you can adapt to your own project.</p>]]></content:encoded>
      <category><![CDATA[Java]]></category>
      <category><![CDATA[Kotlin]]></category>
      <category><![CDATA[Spring Boot]]></category>
      <category><![CDATA[Scheduled Tasks]]></category>
      <category><![CDATA[Programming]]></category>
      <media:thumbnail url="https://suaybsimsek.com/images/spring-boot-scheduled-thumbnail.webp" />
    </item>
    <item>
      <title><![CDATA[Spring Boot Reactive Programming]]></title>
      <link>https://suaybsimsek.com/en/posts/spring-boot-reactive-programming</link>
      <description><![CDATA[Learn how to build reactive applications using Spring Boot with Project Reactor and WebFlux for high-performance asynchronous processing.]]></description>
      <pubDate>Wed, 19 Feb 2025 00:00:00 GMT</pubDate>
      <guid isPermaLink="true">https://suaybsimsek.com/en/posts/spring-boot-reactive-programming</guid>
      <content:encoded><![CDATA[<p>Spring Boot with Reactive Programming enables developers to build non-blocking, event-driven applications that scale efficiently. By leveraging Spring WebFlux and Project Reactor, developers can handle large amounts of concurrent requests with minimal resource consumption, making it ideal for microservices and real-time applications.</p>
<hr />
<h2>üåü Why Use Reactive Programming?</h2>
<ul>
<li>Asynchronous &amp; Non-Blocking: Handle multiple requests efficiently without blocking threads.</li>
<li>Better Scalability: Utilize fewer resources while handling more concurrent users.</li>
<li>Event-Driven Model: Ideal for microservices, real-time applications, and streaming data.</li>
<li>Built-in Backpressure: Prevents overwhelming the system with too many requests.</li>
</ul>
<hr />
<h2>üìã Prerequisites</h2>
<p>Ensure you have the following:</p>
<ul>
<li>‚òï Java Development Kit (JDK) 17+</li>
<li>üì¶ Maven or Gradle installed</li>
<li>üî§ A Java IDE (e.g., IntelliJ IDEA, Eclipse)</li>
</ul>
<hr />
<h2>üõ†Ô∏è Step 1: Add Dependencies</h2>
<p>Add the necessary dependency for Spring WebFlux in your `pom.xml` or `build.gradle` file.</p>
<p>Maven:</p>
<pre><code class="language-xml">&lt;dependency&gt;
    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
    &lt;artifactId&gt;spring-boot-starter-webflux&lt;/artifactId&gt;
&lt;/dependency&gt;</code></pre>
<p>Gradle:</p>
<pre><code class="language-groovy">implementation &#39;org.springframework.boot:spring-boot-starter-webflux&#39;</code></pre>
<hr />
<h2>üõ†Ô∏è Step 2: Create a Reactive REST Controller</h2>
<p>Define a non-blocking REST endpoint using `Mono` and `Flux` to handle asynchronous processing.</p>
<h3>Java</h3>
<pre><code class="language-java">package com.example.reactive;

import org.springframework.web.bind.annotation.*;
import reactor.core.publisher.Flux;
import reactor.core.publisher.Mono;

import java.time.Duration;
import java.util.List;

@RestController
@RequestMapping(&quot;/reactive&quot;)
public class ReactiveController {

    @GetMapping(&quot;/mono&quot;)
    public Mono&lt;String&gt; getMono() {
        return Mono.just(&quot;Hello from Reactive Mono!&quot;);
    }

    @GetMapping(&quot;/flux&quot;)
    public Flux&lt;String&gt; getFlux() {
        return Flux.fromIterable(List.of(&quot;Hello&quot;, &quot;from&quot;, &quot;Reactive&quot;, &quot;Flux&quot;))
                   .delayElements(Duration.ofSeconds(1));
    }
}</code></pre>
<h3>Kotlin</h3>
<pre><code class="language-kotlin">package com.example.reactive

import org.springframework.web.bind.annotation.*
import reactor.core.publisher.Flux
import reactor.core.publisher.Mono
import java.time.Duration

@RestController
@RequestMapping(&quot;/reactive&quot;)
class ReactiveController {

    @GetMapping(&quot;/mono&quot;)
    fun getMono(): Mono&lt;String&gt; {
        return Mono.just(&quot;Hello from Reactive Mono!&quot;)
    }

    @GetMapping(&quot;/flux&quot;)
    fun getFlux(): Flux&lt;String&gt; {
        return Flux.just(&quot;Hello&quot;, &quot;from&quot;, &quot;Reactive&quot;, &quot;Flux&quot;)
            .delayElements(Duration.ofSeconds(1))
    }
}</code></pre>
<hr />
<h2>‚ñ∂Ô∏è Running the Application</h2>
<p>Run the Spring Boot application:</p>
<pre><code class="language-bash">./mvnw spring-boot:run</code></pre>
<p>Or using Gradle:</p>
<pre><code class="language-bash">gradle bootRun</code></pre>
<hr />
<h2>üß™ Testing the API</h2>
<h3>Test Mono Endpoint:</h3>
<pre><code class="language-bash">curl -X GET http://localhost:8080/reactive/mono</code></pre>
<p>Expected output:</p>
<pre><code class="language-plaintext">Hello from Reactive Mono!</code></pre>
<h3>Test Flux Endpoint:</h3>
<pre><code class="language-bash">curl -X GET http://localhost:8080/reactive/flux</code></pre>
<p>Expected output (delayed by 1 second per word):</p>
<pre><code class="language-plaintext">Hello
from
Reactive
Flux</code></pre>
<hr />
<h2>üèÅ Conclusion</h2>
<p>This setup delivers a robust, production-ready Spring Boot Reactive Programming solution in Spring Boot, combining best practices, clear structure, and practical examples you can adapt to your own project.</p>]]></content:encoded>
      <category><![CDATA[Java]]></category>
      <category><![CDATA[Kotlin]]></category>
      <category><![CDATA[Spring Boot]]></category>
      <category><![CDATA[Reactive Programming]]></category>
      <category><![CDATA[Spring WebFlux]]></category>
      <category><![CDATA[Programming]]></category>
      <media:thumbnail url="https://suaybsimsek.com/images/spring-boot-reactive-thumbnail.webp" />
    </item>
    <item>
      <title><![CDATA[Spring Boot GraalVM Native Application]]></title>
      <link>https://suaybsimsek.com/en/posts/spring-boot-graalvm</link>
      <description><![CDATA[Learn how to build and deploy a Spring Boot application as a GraalVM native image for improved startup time and reduced resource usage.]]></description>
      <pubDate>Sat, 28 Dec 2024 00:00:00 GMT</pubDate>
      <guid isPermaLink="true">https://suaybsimsek.com/en/posts/spring-boot-graalvm</guid>
      <content:encoded><![CDATA[<p>Spring Boot with GraalVM Native enables developers to create applications that offer lightning-fast startup times, reduced memory consumption, and enhanced security. With native image support, your Spring Boot applications can efficiently run in resource-constrained environments, making them ideal for modern cloud-native architectures.</p>
<hr />
<h2>üåü Why Build a Native Application with GraalVM?</h2>
<ul>
<li>Faster Startup Times: Native images start much faster compared to JVM-based applications.</li>
<li>Reduced Resource Usage: Native images consume less memory, making them ideal for cloud and containerized environments.</li>
<li>Enhanced Security: Smaller runtime and reduced attack surface.</li>
</ul>
<hr />
<h2>üìã Prerequisites</h2>
<p>Ensure you have the following:</p>
<ul>
<li>‚òï Java Development Kit (JDK) 17+</li>
<li>üõ† GraalVM installed with native-image support</li>
<li>üïù Maven or Gradle</li>
<li>üê≥ Docker for building container images (optional)</li>
</ul>
<hr />
<h2>üõ†Ô∏è Step 1: Add Dependencies</h2>
<p>Add the GraalVM Native Build Tools plugin to your `pom.xml` or `build.gradle` file.</p>
<p>Maven:</p>
<pre><code class="language-xml">&lt;plugin&gt;
    &lt;groupId&gt;org.graalvm.buildtools&lt;/groupId&gt;
    &lt;artifactId&gt;native-maven-plugin&lt;/artifactId&gt;
    &lt;version&gt;0.9.20&lt;/version&gt;
&lt;/plugin&gt;</code></pre>
<p>Gradle:</p>
<pre><code class="language-groovy">plugins {
    id &#39;org.graalvm.buildtools.native&#39; version &#39;0.9.20&#39;
}</code></pre>
<hr />
<h2>üõ†Ô∏è Step 2: Write a REST Controller</h2>
<p>Create a simple REST endpoint to test the native image functionality.</p>
<h3>Java</h3>
<pre><code class="language-java">package com.example.graalvmnative;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RestController;

@SpringBootApplication
@RestController
public class MyApplication {

    public static void main(String[] args) {
        SpringApplication.run(MyApplication.class, args);
    }

    @GetMapping(&quot;/greeting&quot;)
    public String greeting() {
        return &quot;Hello from GraalVM Native!&quot;;
    }
}</code></pre>
<h3>Kotlin</h3>
<pre><code class="language-kotlin">package com.example.graalvmnative

import org.springframework.boot.autoconfigure.SpringBootApplication
import org.springframework.boot.runApplication
import org.springframework.web.bind.annotation.GetMapping
import org.springframework.web.bind.annotation.RestController

@SpringBootApplication
@RestController
class MyApplication {

    @GetMapping(&quot;/greeting&quot;)
    fun greeting(): String = &quot;Hello from GraalVM Native!&quot;
}

fun main(args: Array&lt;String&gt;) {
    runApplication&lt;MyApplication&gt;(*args)
}</code></pre>
<hr />
<h2>üõ†Ô∏è Step 3: Build a Native Image</h2>
<h3>Using Maven</h3>
<p>Run the following command to create a native image:</p>
<pre><code class="language-bash">mvn -Pnative package</code></pre>
<h3>Using Gradle</h3>
<p>Run the following command:</p>
<pre><code class="language-bash">gradle nativeCompile</code></pre>
<hr />
<h2>üõ†Ô∏è Step 4: Build a Docker Image</h2>
<p>Spring Boot provides built-in support for creating Docker images with native executables.</p>
<h3>Maven Command:</h3>
<pre><code class="language-bash">mvn -Pnative spring-boot:build-image</code></pre>
<h3>Gradle Command:</h3>
<pre><code class="language-bash">gradle bootBuildImage</code></pre>
<p>The Docker image will be available locally and can be run using:</p>
<pre><code class="language-bash">docker run --rm -p 8080:8080 myproject:0.0.1-SNAPSHOT</code></pre>
<hr />
<h2>‚ñ∂Ô∏è Running the Application</h2>
<h3>Running Locally</h3>
<p>You can run the native image directly:</p>
<pre><code class="language-bash">./target/myproject</code></pre>
<h3>Running in Docker</h3>
<p>If you built the Docker image, run it using:</p>
<pre><code class="language-bash">docker run --rm -p 8080:8080 myproject:0.0.1-SNAPSHOT</code></pre>
<hr />
<h2>üß™ Testing the API</h2>
<p>Test the REST endpoint using cURL or Postman:</p>
<pre><code class="language-bash">curl -X GET http://localhost:8080/greeting</code></pre>
<p>Expected output:</p>
<pre><code class="language-plaintext">Hello from GraalVM Native!</code></pre>
<hr />
<h2>üèÅ Conclusion</h2>
<p>This setup delivers a robust, production-ready Spring Boot GraalVM Native Application solution in Spring Boot, combining best practices, clear structure, and practical examples you can adapt to your own project.</p>]]></content:encoded>
      <category><![CDATA[Java]]></category>
      <category><![CDATA[Kotlin]]></category>
      <category><![CDATA[Spring Boot]]></category>
      <category><![CDATA[GraalVM]]></category>
      <category><![CDATA[Native Image]]></category>
      <category><![CDATA[Programming]]></category>
      <media:thumbnail url="https://suaybsimsek.com/images/spring-boot-graalvm-thumbnail.webp" />
    </item>
    <item>
      <title><![CDATA[Spring Boot Kafka Integration]]></title>
      <link>https://suaybsimsek.com/en/posts/spring-boot-kafka</link>
      <description><![CDATA[Learn how to integrate Apache Kafka with Spring Boot to send and consume JSON messages through Kafka topics.]]></description>
      <pubDate>Wed, 25 Dec 2024 00:00:00 GMT</pubDate>
      <guid isPermaLink="true">https://suaybsimsek.com/en/posts/spring-boot-kafka</guid>
      <content:encoded><![CDATA[<p>Apache Kafka is a distributed event streaming platform that facilitates real-time data processing. This guide demonstrates how to send and consume JSON messages in a Spring Boot application using Kafka.</p>
<hr />
<h2>üåü Why Use Kafka?</h2>
<ul>
<li>Scalable Messaging: Handle large volumes of data seamlessly.</li>
<li>Fault Tolerance: Ensure data durability and high availability.</li>
<li>Real-Time Processing: Process and analyze data in real time.</li>
<li>Integration: Easily integrate Kafka with Spring Boot for efficient development.</li>
</ul>
<hr />
<h2>üìã Prerequisites</h2>
<p>üïä Ensure you have the following:</p>
<ul>
<li>‚òï Java Development Kit (JDK) 17+</li>
<li>üì¶ Maven or Gradle installed</li>
<li>üî† A Java IDE (e.g., IntelliJ IDEA, Eclipse)</li>
<li>üî† Apache Kafka installed and running</li>
</ul>
<hr />
<h2>üõ†Ô∏è Step 1: Add Dependencies</h2>
<p>To integrate Kafka into your Spring Boot project, add the following dependencies:</p>
<ul>
<li>Maven:</li>
</ul>
<pre><code class="language-xml">&lt;dependency&gt;
  &lt;groupId&gt;org.springframework.kafka&lt;/groupId&gt;
  &lt;artifactId&gt;spring-kafka&lt;/artifactId&gt;
&lt;/dependency&gt;</code></pre>
<ul>
<li>Gradle:</li>
</ul>
<pre><code class="language-groovy">implementation &#39;org.springframework.kafka:spring-kafka&#39;</code></pre>
<hr />
<h2>üõ†Ô∏è Step 2: Configure Kafka</h2>
<p>Set up Kafka connection in your `application.properties` or `application.yml` file:</p>
<pre><code class="language-properties">spring.kafka.bootstrap-servers=localhost:9092
spring.kafka.consumer.group-id=my-group
spring.kafka.consumer.auto-offset-reset=earliest
spring.kafka.producer.key-serializer=org.apache.kafka.common.serialization.StringSerializer
spring.kafka.producer.value-serializer=org.springframework.kafka.support.serializer.JsonSerializer
spring.kafka.consumer.value-deserializer=org.springframework.kafka.support.serializer.JsonDeserializer
spring.kafka.consumer.properties.spring.json.trusted.packages=*</code></pre>
<hr />
<h2>üõ†Ô∏è Step 3: Create a Model for JSON Messages</h2>
<h3>Model Class</h3>
<h3>Java</h3>
<pre><code class="language-java">package com.example.kafka.model;

import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;

@Data
@NoArgsConstructor
@AllArgsConstructor
public class Message {
    private String id;
    private String content;
}</code></pre>
<h3>Kotlin</h3>
<pre><code class="language-kotlin">package com.example.kafka.model

data class Message(
    val id: String,
    val content: String
)</code></pre>
<hr />
<h2>üõ†Ô∏è Step 4: Implement Kafka Producer and Consumer</h2>
<h3>Producer Example</h3>
<h3>Java</h3>
<pre><code class="language-java">package com.example.kafka.producer;

import com.example.kafka.model.Message;
import lombok.RequiredArgsConstructor;
import org.springframework.kafka.core.KafkaTemplate;
import org.springframework.stereotype.Service;

@Service
@RequiredArgsConstructor
public class KafkaProducer {

    private final KafkaTemplate&lt;String, Message&gt; kafkaTemplate;

    public void sendMessage(String topic, Message message) {
        kafkaTemplate.send(topic, message);
    }
}</code></pre>
<h3>Kotlin</h3>
<pre><code class="language-kotlin">package com.example.kafka.producer

import com.example.kafka.model.Message
import org.springframework.kafka.core.KafkaTemplate
import org.springframework.stereotype.Service

@Service
class KafkaProducer(private val kafkaTemplate: KafkaTemplate&lt;String, Message&gt;) {

    fun sendMessage(topic: String, message: Message) {
        kafkaTemplate.send(topic, message)
    }
}</code></pre>
<h3>Consumer Example</h3>
<h3>Java</h3>
<pre><code class="language-java">package com.example.kafka.consumer;

import com.example.kafka.model.Message;
import org.springframework.kafka.annotation.KafkaListener;
import org.springframework.stereotype.Service;

@Service
public class KafkaConsumer {

    @KafkaListener(topics = &quot;my-topic&quot;, groupId = &quot;my-group&quot;)
    public void consumeMessage(Message message) {
        System.out.println(&quot;Received message: &quot; + message);
    }
}</code></pre>
<h3>Kotlin</h3>
<pre><code class="language-kotlin">package com.example.kafka.consumer

import com.example.kafka.model.Message
import org.springframework.kafka.annotation.KafkaListener
import org.springframework.stereotype.Service

@Service
class KafkaConsumer {

    @KafkaListener(topics = [&quot;my-topic&quot;], groupId = &quot;my-group&quot;)
    fun consumeMessage(message: Message) {
        println(&quot;Received message: $message&quot;)
    }
}</code></pre>
<hr />
<h3>Controller Example</h3>
<h3>Java</h3>
<pre><code class="language-java">package com.example.kafka.controller;

import com.example.kafka.model.Message;
import com.example.kafka.producer.KafkaProducer;
import lombok.RequiredArgsConstructor;
import org.springframework.web.bind.annotation.*;

@RestController
@RequestMapping(&quot;/kafka&quot;)
@RequiredArgsConstructor
public class KafkaController {

    private final KafkaProducer kafkaProducer;

    @PostMapping(&quot;/publish&quot;)
    public String publishMessage(@RequestParam String topic, @RequestBody Message message) {
        kafkaProducer.sendMessage(topic, message);
        return &quot;Message sent to topic: &quot; + topic;
    }
}</code></pre>
<h3>Kotlin</h3>
<pre><code class="language-kotlin">package com.example.kafka.controller

import com.example.kafka.model.Message
import com.example.kafka.producer.KafkaProducer
import org.springframework.web.bind.annotation.*

@RestController
@RequestMapping(&quot;/kafka&quot;)
class KafkaController(private val kafkaProducer: KafkaProducer) {

    @PostMapping(&quot;/publish&quot;)
    fun publishMessage(@RequestParam topic: String, @RequestBody message: Message): String {
        kafkaProducer.sendMessage(topic, message)
        return &quot;Message sent to topic: $topic&quot;
    }
}</code></pre>
<hr />
<h2>‚ñ∂Ô∏è Running the Application</h2>
<p>Run the application using the following command:</p>
<pre><code class="language-bash">./mvnw spring-boot:run</code></pre>
<hr />
<h2>üß™ Testing the API</h2>
<p>You can test the Kafka Producer endpoint using cURL or Postman:</p>
<pre><code class="language-bash">curl -X POST &quot;http://localhost:8080/kafka/publish&quot; \
-H &quot;Content-Type: application/json&quot; \
-d &#39;{&quot;id&quot;: &quot;123&quot;, &quot;content&quot;: &quot;Hello Kafka!&quot;}&#39;</code></pre>
<p>Check the Kafka Consumer logs to verify that the message was received and processed.</p>
<hr />
<h2>üèÅ Conclusion</h2>
<p>This setup delivers a robust, production-ready Spring Boot Kafka Integration solution in Spring Boot, combining best practices, clear structure, and practical examples you can adapt to your own project.</p>]]></content:encoded>
      <category><![CDATA[Java]]></category>
      <category><![CDATA[Kotlin]]></category>
      <category><![CDATA[Spring Boot]]></category>
      <category><![CDATA[Kafka]]></category>
      <category><![CDATA[Messaging]]></category>
      <category><![CDATA[Programming]]></category>
      <media:thumbnail url="https://suaybsimsek.com/images/spring-boot-kafka-thumbnail.webp" />
    </item>
    <item>
      <title><![CDATA[Spring Boot Redis Caching]]></title>
      <link>https://suaybsimsek.com/en/posts/spring-boot-redis-caching</link>
      <description><![CDATA[Learn how to implement Redis caching in your Spring Boot application to improve performance and efficiency.]]></description>
      <pubDate>Sun, 22 Dec 2024 00:00:00 GMT</pubDate>
      <guid isPermaLink="true">https://suaybsimsek.com/en/posts/spring-boot-redis-caching</guid>
      <content:encoded><![CDATA[<p>Redis is a powerful in-memory data store often used for caching, messaging, and real-time data management. This guide explains how to integrate Redis into a Spring Boot application using both Java and Kotlin.</p>
<hr />
<h2>üåü Why Use Redis?</h2>
<ul>
<li>High Performance: Redis provides extremely low latency for read and write operations.</li>
<li>Versatile Data Structures: Supports strings, hashes, lists, sets, and more.</li>
<li>Scalability: Ideal for distributed caching and real-time analytics.</li>
<li>Integration: Easily integrates with Spring Boot for seamless development.</li>
</ul>
<hr />
<h2>üìã Prerequisites</h2>
<p>üóà Ensure you have the following:</p>
<ul>
<li>‚òï Java Development Kit (JDK) 17+</li>
<li>üì¶ Maven or Gradle installed</li>
<li>üî§ A Java IDE (e.g., IntelliJ IDEA, Eclipse)</li>
<li>üí† Redis Server installed and running locally or accessible via a network</li>
</ul>
<hr />
<h2>üõ†Ô∏è Step 1: Add Dependencies</h2>
<p>To integrate Redis into your Spring Boot project, add the following dependencies:</p>
<ul>
<li>Maven:</li>
</ul>
<pre><code class="language-xml">&lt;dependency&gt;
  &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
  &lt;artifactId&gt;spring-boot-starter-data-redis&lt;/artifactId&gt;
&lt;/dependency&gt;</code></pre>
<ul>
<li>Gradle:</li>
</ul>
<pre><code class="language-groovy">implementation &#39;org.springframework.boot:spring-boot-starter-data-redis&#39;</code></pre>
<hr />
<h2>üõ†Ô∏è Step 2: Configure Redis</h2>
<p>Set up the Redis connection in your `application.properties` or `application.yml` file.</p>
<h3>Example Configuration:</h3>
<pre><code class="language-properties">spring.redis.host=localhost
spring.redis.port=6379</code></pre>
<p>For advanced setups, such as password authentication or SSL, add these properties:</p>
<pre><code class="language-properties">spring.redis.password=yourpassword
spring.redis.ssl=true</code></pre>
<hr />
<h2>üõ†Ô∏è Step 3: Enable Caching</h2>
<p>Add the `@EnableCaching` annotation to your main application class to enable Spring&#39;s caching abstraction.</p>
<h3>Java</h3>
<pre><code class="language-java">package com.example.redis;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;
import org.springframework.cache.annotation.EnableCaching;

@SpringBootApplication
@EnableCaching
public class RedisApplication {
  public static void main(String[] args) {
    SpringApplication.run(RedisApplication.class, args);
  }
}</code></pre>
<h3>Kotlin</h3>
<pre><code class="language-kotlin">package com.example.redis

import org.springframework.boot.autoconfigure.SpringBootApplication
import org.springframework.boot.runApplication
import org.springframework.cache.annotation.EnableCaching

@SpringBootApplication
@EnableCaching
class RedisApplication

fun main(args: Array&lt;String&gt;) {
  runApplication&lt;RedisApplication&gt;(*args)
}</code></pre>
<hr />
<h2>üõ†Ô∏è Step 4: Service Layer Example with Caching</h2>
<h3>Java</h3>
<pre><code class="language-java">package com.example.redis.service;

import org.springframework.cache.annotation.Cacheable;
import org.springframework.stereotype.Service;

@Service
public class UserService {

  @Cacheable(&quot;users&quot;)
  public String getUserById(String id) {
    simulateSlowService();
    return &quot;User with ID: &quot; + id;
  }

  private void simulateSlowService() {
    try {
      Thread.sleep(3000L);
    } catch (InterruptedException e) {
      throw new IllegalStateException(e);
    }
  }
}</code></pre>
<h3>Kotlin</h3>
<pre><code class="language-kotlin">package com.example.redis.service

import org.springframework.cache.annotation.Cacheable
import org.springframework.stereotype.Service

@Service
class UserService {

  @Cacheable(&quot;users&quot;)
  fun getUserById(id: String): String {
    simulateSlowService()
    return &quot;User with ID: $id&quot;
  }

  private fun simulateSlowService() {
    Thread.sleep(3000L)
  }
}</code></pre>
<hr />
<h3>Configuring TTL (Time-To-Live)</h3>
<p>Set the cache expiration time in your `application.properties` file:</p>
<pre><code class="language-properties">spring.cache.redis.time-to-live=600000</code></pre>
<p>This sets the TTL to 10 minutes (600,000 milliseconds).</p>
<hr />
<h3>Controller Example</h3>
<p>Create a REST controller to expose the caching functionality.</p>
<h3>Java</h3>
<pre><code class="language-java">package com.example.redis.controller;

import com.example.redis.service.UserService;
import lombok.RequiredArgsConstructor;
import org.springframework.web.bind.annotation.*;

@RestController
@RequestMapping(&quot;/users&quot;)
@RequiredArgsConstructor
public class UserController {

  private final UserService userService;

  @GetMapping(&quot;/{id}&quot;)
  public String getUser(@PathVariable String id) {
    return userService.getUserById(id);
  }
}</code></pre>
<h3>Kotlin</h3>
<pre><code class="language-kotlin">package com.example.redis.controller

import com.example.redis.service.UserService
import org.springframework.web.bind.annotation.*

@RestController
@RequestMapping(&quot;/users&quot;)
class UserController(
  private val userService: UserService
) {
  @GetMapping(&quot;/{id}&quot;)
  fun getUser(@PathVariable id: String): String = userService.getUserById(id)
}</code></pre>
<hr />
<h2>‚ñ∂Ô∏è Running the Application</h2>
<p>Run the application using the following command:</p>
<pre><code class="language-bash">./mvnw spring-boot:run</code></pre>
<hr />
<h2>üß™ Testing the API</h2>
<p>You can test the API using cURL or Postman:</p>
<ul>
<li>Fetch a User (cached):</li>
</ul>
<pre><code class="language-bash">curl -X GET http://localhost:8080/users/1</code></pre>
<p>Make subsequent requests to observe faster responses due to caching.</p>
<hr />
<h2>üèÅ Conclusion</h2>
<p>This setup delivers a robust, production-ready Spring Boot Redis Caching solution in Spring Boot, combining best practices, clear structure, and practical examples you can adapt to your own project.</p>]]></content:encoded>
      <category><![CDATA[Java]]></category>
      <category><![CDATA[Kotlin]]></category>
      <category><![CDATA[Spring Boot]]></category>
      <category><![CDATA[Redis]]></category>
      <category><![CDATA[Caching]]></category>
      <category><![CDATA[Programming]]></category>
      <media:thumbnail url="https://suaybsimsek.com/images/spring-boot-redis-thumbnail.webp" />
    </item>
    <item>
      <title><![CDATA[Spring Boot with OpenAPI]]></title>
      <link>https://suaybsimsek.com/en/posts/spring-boot-openapi</link>
      <description><![CDATA[Learn how to integrate OpenAPI into your Spring Boot application for API documentation and testing using SpringDoc.]]></description>
      <pubDate>Fri, 20 Dec 2024 00:00:00 GMT</pubDate>
      <guid isPermaLink="true">https://suaybsimsek.com/en/posts/spring-boot-openapi</guid>
      <content:encoded><![CDATA[<p>OpenAPI simplifies API documentation and testing by providing an interactive interface and machine-readable documentation. This guide will show you how to integrate OpenAPI into your Spring Boot application using SpringDoc.</p>
<hr />
<h2>üåü Why Use OpenAPI?</h2>
<ul>
<li>Interactive Documentation: Offers a user-friendly interface for exploring APIs.</li>
<li>Standardized Format: Generates machine-readable API definitions.</li>
<li>Ease of Testing: Provides built-in tools for testing endpoints.</li>
<li>Client Code Generation: Allows automatic generation of client code for various programming languages.</li>
</ul>
<hr />
<h2>üìã Prerequisites</h2>
<p>üìã Ensure you have the following:</p>
<ul>
<li>‚òï Java Development Kit (JDK) 17+</li>
<li>üì¶ Maven or Gradle installed</li>
<li>üî§ A Java IDE (e.g., IntelliJ IDEA, Eclipse)</li>
</ul>
<hr />
<h2>üõ†Ô∏è Step 1: Add Dependencies</h2>
<p>To integrate OpenAPI using SpringDoc, add the following dependency to your Spring Boot project:</p>
<ul>
<li>Maven:</li>
</ul>
<pre><code class="language-xml">&lt;dependency&gt;
  &lt;groupId&gt;org.springdoc&lt;/groupId&gt;
  &lt;artifactId&gt;springdoc-openapi-starter-webmvc-ui&lt;/artifactId&gt;
  &lt;version&gt;2.1.0&lt;/version&gt;
&lt;/dependency&gt;</code></pre>
<ul>
<li>Gradle:</li>
</ul>
<pre><code class="language-groovy">implementation &#39;org.springdoc:springdoc-openapi-starter-webmvc-ui:2.1.0&#39;</code></pre>
<hr />
<h2>üõ†Ô∏è Step 2: Configure OpenAPI</h2>
<p>SpringDoc requires minimal configuration. You can customize your OpenAPI documentation using the `application.properties` or `application.yml` file.</p>
<h3>Example Configuration:</h3>
<pre><code class="language-properties">springdoc.api-docs.path=/api-docs
springdoc.swagger-ui.path=/swagger-ui.html</code></pre>
<hr />
<h2>üõ†Ô∏è Step 3: Annotate Your REST Controllers</h2>
<p>Add annotations to your REST controllers and models to generate OpenAPI documentation automatically.</p>
<h3>Java</h3>
<h3>Controller Example</h3>
<pre><code class="language-java">package com.example.openapi.controller;

import com.example.openapi.model.User;
import io.swagger.v3.oas.annotations.Operation;
import io.swagger.v3.oas.annotations.media.Content;
import io.swagger.v3.oas.annotations.responses.ApiResponse;
import org.springframework.web.bind.annotation.*;

import java.util.List;

@RestController
@RequestMapping(&quot;/users&quot;)
public class UserController {

  @Operation(summary = &quot;Get all users&quot;, description = &quot;Retrieve a list of users&quot;)
  @ApiResponse(responseCode = &quot;200&quot;, description = &quot;Successful operation&quot;,
    content = @Content(mediaType = &quot;application/json&quot;))
  @GetMapping
  public List&lt;User&gt; getAllUsers() {
    return List.of(new User(1L, &quot;John Doe&quot;, &quot;john@example.com&quot;));
  }

  @Operation(summary = &quot;Create a new user&quot;, description = &quot;Add a new user to the system&quot;)
  @ApiResponse(responseCode = &quot;201&quot;, description = &quot;User created successfully&quot;,
    content = @Content(mediaType = &quot;application/json&quot;))
  @PostMapping
  public User createUser(@RequestBody User user) {
    return user;
  }
}</code></pre>
<h3>User Model</h3>
<pre><code class="language-java">package com.example.openapi.model;

import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;

@Data
@NoArgsConstructor
@AllArgsConstructor
public class User {

    private Long id;
    private String name;
    private String email;
}</code></pre>
<h3>Kotlin</h3>
<h3>Controller Example</h3>
<pre><code class="language-kotlin">package com.example.openapi.controller

import com.example.openapi.model.User
import io.swagger.v3.oas.annotations.*
import io.swagger.v3.oas.annotations.responses.*
import io.swagger.v3.oas.annotations.media.*
import org.springframework.web.bind.annotation.*

@RestController
@RequestMapping(&quot;/users&quot;)
class UserController {

    @Operation(summary = &quot;Get all users&quot;, description = &quot;Retrieve a list of users&quot;)
    @ApiResponse(responseCode = &quot;200&quot;, description = &quot;Successful operation&quot;,
                 content = [Content(mediaType = &quot;application/json&quot;)])
    @GetMapping
    fun getAllUsers(): List&lt;User&gt; = listOf(User(1L, &quot;John Doe&quot;, &quot;john@example.com&quot;))

    @Operation(summary = &quot;Create a new user&quot;, description = &quot;Add a new user to the system&quot;)
    @ApiResponse(responseCode = &quot;201&quot;, description = &quot;User created successfully&quot;,
                 content = [Content(mediaType = &quot;application/json&quot;)])
    @PostMapping
    fun createUser(@RequestBody user: User): User = user
}</code></pre>
<h3>User Model</h3>
<pre><code class="language-kotlin">package com.example.openapi.model

data class User(
  val id: Long,
  val name: String,
  val email: String
)</code></pre>
<hr />
<h2>‚ñ∂Ô∏è Running the Application</h2>
<p>Run the application using the following command:</p>
<pre><code class="language-bash">./mvnw spring-boot:run</code></pre>
<p>Access the OpenAPI documentation at:</p>
<ul>
<li>API Docs: `http://localhost:8080/api-docs`</li>
<li>Swagger UI: `http://localhost:8080/swagger-ui.html`</li>
</ul>
<hr />
<h2>üß™ Testing the API</h2>
<p>You can test the generated API documentation by exploring the Swagger UI interface:</p>
<p>1. Navigate to `http://localhost:8080/swagger-ui.html` in your browser. 2. Test endpoints interactively by providing inputs and observing responses.</p>
<hr />
<h2>üèÅ Conclusion</h2>
<p>This setup delivers a robust, production-ready Spring Boot with OpenAPI solution in Spring Boot, combining best practices, clear structure, and practical examples you can adapt to your own project.</p>]]></content:encoded>
      <category><![CDATA[Java]]></category>
      <category><![CDATA[Kotlin]]></category>
      <category><![CDATA[Spring Boot]]></category>
      <category><![CDATA[OpenAPI]]></category>
      <category><![CDATA[Documentation]]></category>
      <category><![CDATA[Programming]]></category>
      <media:thumbnail url="https://suaybsimsek.com/images/spring-boot-openapi-thumbnail.webp" />
    </item>
    <item>
      <title><![CDATA[Clean Coding Practices in Spring Boot]]></title>
      <link>https://suaybsimsek.com/en/posts/spring-boot-clean-coding</link>
      <description><![CDATA[Learn how to apply clean coding principles in Spring Boot projects. Includes best practices, examples, and benefits of using Lombok in Java and Kotlin clean code techniques.]]></description>
      <pubDate>Thu, 19 Dec 2024 00:00:00 GMT</pubDate>
      <guid isPermaLink="true">https://suaybsimsek.com/en/posts/spring-boot-clean-coding</guid>
      <content:encoded><![CDATA[<p>Clean coding practices ensure that your Spring Boot applications are maintainable, readable, and scalable. This guide provides essential tips and code examples to help you write cleaner and more efficient code in both Java and Kotlin.</p>
<hr />
<h2>üåü Why Focus on Clean Coding?</h2>
<p>Adopting clean coding principles helps to:</p>
<ul>
<li>Improve code readability and maintainability.</li>
<li>Reduce technical debt.</li>
<li>Make onboarding new developers easier.</li>
<li>Enhance scalability and debugging processes.</li>
</ul>
<hr />
<h2>üìã Prerequisites</h2>
<p>üìã Ensure you have the following:</p>
<ul>
<li>‚òï Java Development Kit (JDK) 17+</li>
<li>üì¶ Maven or Gradle installed</li>
<li>üî§ A Java IDE (e.g., IntelliJ IDEA, Eclipse)</li>
<li>üõ†Ô∏è Familiarity with Spring Boot basics</li>
</ul>
<hr />
<h2>üõ†Ô∏è Step 1: Structure Your Project</h2>
<p>Organize your Spring Boot project for better clarity:</p>
<ul>
<li>Controller Layer: Handles incoming HTTP requests.</li>
<li>Service Layer: Contains business logic.</li>
<li>Repository Layer: Interacts with the database.</li>
</ul>
<h3>Example Folder Structure:</h3>
<pre><code>src/main/java/com/example/cleanproject
‚îú‚îÄ‚îÄ controller
‚îú‚îÄ‚îÄ service
‚îú‚îÄ‚îÄ repository
‚îú‚îÄ‚îÄ entity
‚îî‚îÄ‚îÄ dto</code></pre>
<hr />
<h2>üõ†Ô∏è Step 2: Use Lombok for Cleaner Java Code</h2>
<p>Lombok reduces boilerplate code in Java, making your classes more concise and readable. Here&#39;s how to use Lombok effectively:</p>
<h3>Add Lombok Dependency</h3>
<ul>
<li>Maven:</li>
</ul>
<pre><code class="language-xml">&lt;dependency&gt;
  &lt;groupId&gt;org.projectlombok&lt;/groupId&gt;
  &lt;artifactId&gt;lombok&lt;/artifactId&gt;
  &lt;scope&gt;provided&lt;/scope&gt;
&lt;/dependency&gt;</code></pre>
<ul>
<li>Gradle:</li>
</ul>
<pre><code class="language-groovy">provided &#39;org.projectlombok:lombok&#39;
annotationProcessor &#39;org.projectlombok:lombok&#39;</code></pre>
<h3>Example: Entity with Lombok</h3>
<pre><code class="language-java">package com.example.cleanproject.entity;

import jakarta.persistence.*;
import lombok.Data;
import lombok.NoArgsConstructor;
import lombok.AllArgsConstructor;

@Data
@NoArgsConstructor
@AllArgsConstructor
@Entity
public class User {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    private String name;

    private String email;
}</code></pre>
<p>Benefits:</p>
<ul>
<li>`@Data` generates getters, setters, equals, hashCode, and toString methods.</li>
<li>`@NoArgsConstructor` and `@AllArgsConstructor` create constructors.</li>
</ul>
<hr />
<h2>üõ†Ô∏è Step 3: Write Concise and Readable Code in Kotlin</h2>
<p>Kotlin offers modern features that naturally lead to cleaner code:</p>
<h3>Example: Entity in Kotlin</h3>
<pre><code class="language-kotlin">package com.example.cleanproject.entity

import jakarta.persistence.*

@Entity
data class User(
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    val id: Long = 0,
    var name: String,
    var email: String
)</code></pre>
<p>Advantages of Kotlin:</p>
<ul>
<li>`data class` automatically generates `toString`, `equals`, and `hashCode` methods.</li>
<li>Immutable properties (`val`) ensure better stability.</li>
</ul>
<hr />
<h2>üõ†Ô∏è Step 4: Follow Dependency Injection Principles</h2>
<p>Use dependency injection to decouple components and improve testability.</p>
<h3>Example: Service Layer with DI</h3>
<h3>Java</h3>
<pre><code class="language-java">package com.example.cleanproject.service;

import com.example.cleanproject.entity.User;
import com.example.cleanproject.repository.UserRepository;
import lombok.RequiredArgsConstructor;
import org.springframework.stereotype.Service;

import java.util.List;

@Service
@RequiredArgsConstructor
public class UserService {

    private final UserRepository userRepository;

    public List&lt;User&gt; getAllUsers() {
        return userRepository.findAll();
    }
}</code></pre>
<h3>Kotlin</h3>
<pre><code class="language-kotlin">package com.example.cleanproject.service

import com.example.cleanproject.entity.User
import com.example.cleanproject.repository.UserRepository
import org.springframework.stereotype.Service

@Service
class UserService(
    private val userRepository: UserRepository
) {
    fun getAllUsers(): List&lt;User&gt; = userRepository.findAll()
}</code></pre>
<hr />
<h2>üõ†Ô∏è Step 5: Use DTOs for Data Transfer</h2>
<p>Data Transfer Objects (DTOs) separate your domain and API layers, promoting better encapsulation.</p>
<h3>Example: DTO for User</h3>
<h3>Java</h3>
<pre><code class="language-java">package com.example.cleanproject.dto;

import lombok.Data;

@Data
public class UserDTO {
    private String name;
    private String email;
}</code></pre>
<h3>Kotlin</h3>
<pre><code class="language-kotlin">package com.example.cleanproject.dto

data class UserDTO(
    val name: String,
    val email: String
)</code></pre>
<hr />
<h3>Controller Layer</h3>
<p>Implement a controller to handle HTTP requests and interact with the service layer.</p>
<h3>Java</h3>
<pre><code class="language-java">package com.example.cleanproject.controller;

import com.example.cleanproject.dto.UserDTO;
import com.example.cleanproject.service.UserService;
import lombok.RequiredArgsConstructor;
import org.springframework.web.bind.annotation.*;

import java.util.List;

@RestController
@RequestMapping(&quot;/api/users&quot;)
@RequiredArgsConstructor
public class UserController {

    private final UserService userService;

    @GetMapping
    public List&lt;UserDTO&gt; getAllUsers() {
        return userService.getAllUsers();
    }
}</code></pre>
<h3>Kotlin</h3>
<pre><code class="language-kotlin">package com.example.cleanproject.controller

import com.example.cleanproject.dto.UserDTO
import com.example.cleanproject.service.UserService
import org.springframework.web.bind.annotation.*

@RestController
@RequestMapping(&quot;/api/users&quot;)
class UserController(
    private val userService: UserService
) {

    @GetMapping
    fun getAllUsers(): List&lt;UserDTO&gt; = userService.getAllUsers()
}</code></pre>
<hr />
<h2>‚ñ∂Ô∏è Running the Application</h2>
<p>Run the application using the following command:</p>
<pre><code class="language-bash">./mvnw spring-boot:run</code></pre>
<p>Test endpoints using a tool like Postman or cURL.</p>
<hr />
<h2>üß™ Testing the API</h2>
<p>You can test the API using the following cURL command:</p>
<ul>
<li>Fetch all users:</li>
</ul>
<pre><code class="language-bash">curl -X GET http://localhost:8080/api/users</code></pre>
<hr />
<h2>üèÅ Conclusion</h2>
<p>This setup delivers a robust, production-ready Clean Coding Practices in Spring Boot solution in Spring Boot, combining best practices, clear structure, and practical examples you can adapt to your own project.</p>]]></content:encoded>
      <category><![CDATA[Java]]></category>
      <category><![CDATA[Kotlin]]></category>
      <category><![CDATA[Spring Boot]]></category>
      <category><![CDATA[Clean Coding]]></category>
      <category><![CDATA[Programming]]></category>
      <media:thumbnail url="https://suaybsimsek.com/images/spring-boot-clean-coding-thumbnail.webp" />
    </item>
    <item>
      <title><![CDATA[Spring Boot DevTools]]></title>
      <link>https://suaybsimsek.com/en/posts/spring-boot-devtools</link>
      <description><![CDATA[Learn how to utilize Spring Boot DevTools for rapid development. Includes live reload, caching, and debugging tips.]]></description>
      <pubDate>Thu, 19 Dec 2024 00:00:00 GMT</pubDate>
      <guid isPermaLink="true">https://suaybsimsek.com/en/posts/spring-boot-devtools</guid>
      <content:encoded><![CDATA[<p>Spring Boot DevTools is a must-have tool for developers looking to speed up their development process. This guide will walk you through the features and setup of DevTools, including live reload, caching, and debugging enhancements.</p>
<hr />
<h2>üåü Why Use Spring Boot DevTools?</h2>
<p>Spring Boot DevTools provides features such as:</p>
<ul>
<li>Live Reload: Automatically reloads the application on code changes.</li>
<li>Enhanced Caching: Disables template caching for faster iteration.</li>
<li>Debugging Tools: Improves development-time debugging experience.</li>
</ul>
<hr />
<h2>üìã Prerequisites</h2>
<p>üìã Ensure you have the following:</p>
<ul>
<li>‚òï Java Development Kit (JDK) 17+</li>
<li>üì¶ Maven or Gradle installed</li>
<li>üî§ A Java IDE (e.g., IntelliJ IDEA, Eclipse)</li>
</ul>
<hr />
<h2>üõ†Ô∏è Step 1: Add Dependencies</h2>
<p>To enable DevTools, add the following dependency to your Spring Boot project:</p>
<ul>
<li>Maven:</li>
</ul>
<pre><code class="language-xml">&lt;dependency&gt;
  &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
  &lt;artifactId&gt;spring-boot-devtools&lt;/artifactId&gt;
  &lt;scope&gt;runtime&lt;/scope&gt;
&lt;/dependency&gt;</code></pre>
<ul>
<li>Gradle:</li>
</ul>
<pre><code class="language-groovy">runtimeOnly &#39;org.springframework.boot:spring-boot-devtools&#39;</code></pre>
<hr />
<h2>üõ†Ô∏è Step 2: Configure DevTools</h2>
<p>Spring Boot DevTools requires minimal configuration but offers some customization options. Here are some common configurations:</p>
<h3>Enable Live Reload</h3>
<p>Live reload is enabled by default when using DevTools with supported IDEs like IntelliJ IDEA or Eclipse.</p>
<h3>Disable Caching</h3>
<p>Disable caching for templates to see changes instantly:</p>
<pre><code class="language-properties">spring.thymeleaf.cache=false
spring.freemarker.cache=false</code></pre>
<h3>Restart Exclusions</h3>
<p>Exclude specific files or directories from triggering a restart:</p>
<pre><code class="language-properties">spring.devtools.restart.exclude=static/**,public/**</code></pre>
<hr />
<h2>üõ†Ô∏è Step 3: Debugging Enhancements</h2>
<p>Spring Boot DevTools improves debugging by:</p>
<ul>
<li>Automatic Restart: Restarts the application context when code changes are detected.</li>
<li>Remote Debugging: Provides the ability to debug applications running on remote servers.</li>
</ul>
<p>To enable remote debugging:</p>
<pre><code class="language-properties">spring.devtools.remote.secret=mysecretkey</code></pre>
<p>Use the following command to connect:</p>
<pre><code class="language-bash">java -jar myapp.jar -Dspring.devtools.remote.secret=mysecretkey</code></pre>
<hr />
<h2>‚ñ∂Ô∏è Running the Application</h2>
<p>Run the application using the following command:</p>
<pre><code class="language-bash">./mvnw spring-boot:run</code></pre>
<p>Make changes to your code, and observe live reload and application context restarts.</p>
<hr />
<h2>üß™ Test DevTools</h2>
<p>You can test Spring Boot DevTools features as follows:</p>
<ul>
<li>Live Reload: Make a change in your controller or template and save the file. The application should reload automatically.</li>
<li>Template Updates: Update a `.html` file and verify the changes without restarting the server.</li>
<li>Debugging: Add breakpoints in your IDE and test remote debugging with `DevTools` enabled.</li>
</ul>
<hr />
<h2>üèÅ Conclusion</h2>
<p>This setup delivers a robust, production-ready Spring Boot DevTools solution in Spring Boot, combining best practices, clear structure, and practical examples you can adapt to your own project.</p>]]></content:encoded>
      <category><![CDATA[Java]]></category>
      <category><![CDATA[Kotlin]]></category>
      <category><![CDATA[Spring Boot]]></category>
      <category><![CDATA[Dev Tools]]></category>
      <category><![CDATA[Programming]]></category>
      <media:thumbnail url="https://suaybsimsek.com/images/spring-boot-devtools-thumbnail.webp" />
    </item>
    <item>
      <title><![CDATA[Spring Boot Actuator]]></title>
      <link>https://suaybsimsek.com/en/posts/spring-boot-actuator</link>
      <description><![CDATA[Learn how to use Spring Boot Actuator to monitor and manage your applications with ease. Includes endpoints, customization, and security examples.]]></description>
      <pubDate>Wed, 18 Dec 2024 00:00:00 GMT</pubDate>
      <guid isPermaLink="true">https://suaybsimsek.com/en/posts/spring-boot-actuator</guid>
      <content:encoded><![CDATA[<p>Spring Boot Actuator provides production-ready features to monitor and manage your applications. This guide explores Actuator&#39;s capabilities, how to enable it, and secure its endpoints.</p>
<hr />
<h2>üåü Why Use Spring Boot Actuator?</h2>
<p>Spring Boot Actuator allows developers to:</p>
<ul>
<li>Monitor application health</li>
<li>Gather metrics and information</li>
<li>Expose management endpoints for operational tasks</li>
</ul>
<hr />
<h2>üìã Prerequisites</h2>
<p>üìã Ensure you have the following:</p>
<ul>
<li>‚òï Java Development Kit (JDK) 17+</li>
<li>üíº Maven or Gradle installed</li>
<li>üÑÑ A Java IDE (e.g., IntelliJ IDEA, Eclipse)</li>
</ul>
<hr />
<h2>üõ†Ô∏è Step 1: Add Dependencies</h2>
<p>To enable Actuator, add the following dependency to your Spring Boot project:</p>
<ul>
<li>Maven:</li>
</ul>
<pre><code class="language-xml">&lt;dependency&gt;
  &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
  &lt;artifactId&gt;spring-boot-starter-actuator&lt;/artifactId&gt;
&lt;/dependency&gt;</code></pre>
<ul>
<li>Gradle:</li>
</ul>
<pre><code class="language-groovy">implementation &#39;org.springframework.boot:spring-boot-starter-actuator&#39;</code></pre>
<hr />
<h2>üõ†Ô∏è Step 2: Enable Actuator Endpoints</h2>
<p>By default, Actuator exposes several endpoints to provide application insights. You can enable these endpoints in your `application.properties` or `application.yml` file.</p>
<h3>Configuration Example:</h3>
<pre><code class="language-properties">management.endpoints.web.exposure.include=health,info,metrics
management.endpoint.health.show-details=always</code></pre>
<hr />
<h2>üõ†Ô∏è Step 3: Using Actuator Endpoints</h2>
<p>Here are some commonly used Actuator endpoints:</p>
<ul>
<li>`/actuator/health`: Provides application health status.</li>
<li>`/actuator/info`: Displays application metadata.</li>
<li>`/actuator/metrics`: Offers application performance metrics.</li>
</ul>
<p>You can access these endpoints via a browser or API tools like cURL.</p>
<p>Example:</p>
<pre><code class="language-bash">curl -X GET http://localhost:8080/actuator/health</code></pre>
<hr />
<h2>üõ†Ô∏è Step 4: Customize Actuator Endpoints</h2>
<p>You can customize Actuator endpoints to suit your needs. For example, you can define additional metadata in the `application.properties` file for the `/actuator/info` endpoint:</p>
<pre><code class="language-properties">info.app.name=My Application
info.app.version=1.0.0
info.app.description=Spring Boot Actuator Example</code></pre>
<hr />
<h2>üõ†Ô∏è Step 5: Secure Actuator Endpoints</h2>
<p>For production environments, it&#39;s essential to secure Actuator endpoints. Use Spring Security to restrict access.</p>
<h3>Java</h3>
<h3>Example Security Configuration</h3>
<pre><code class="language-java">package com.example.demo.config;

import org.springframework.context.annotation.Configuration;
import org.springframework.security.config.annotation.web.builders.HttpSecurity;
import org.springframework.security.web.SecurityFilterChain;

@Configuration
public class SecurityConfig {

    public SecurityFilterChain securityFilterChain(HttpSecurity http) throws Exception {
        http
            .authorizeHttpRequests()
                .requestMatchers(&quot;/actuator/**&quot;).hasRole(&quot;ADMIN&quot;)
                .anyRequest().authenticated()
            .and()
            .httpBasic();
        return http.build();
    }
}</code></pre>
<h3>Kotlin</h3>
<h3>Example Security Configuration</h3>
<pre><code class="language-kotlin">package com.example.demo.config

import org.springframework.context.annotation.Bean
import org.springframework.context.annotation.Configuration
import org.springframework.security.config.annotation.web.builders.HttpSecurity
import org.springframework.security.web.SecurityFilterChain

@Configuration
class SecurityConfig {

    @Bean
    fun securityFilterChain(http: HttpSecurity): SecurityFilterChain {
        http
            .authorizeHttpRequests()
                .requestMatchers(&quot;/actuator/**&quot;).hasRole(&quot;ADMIN&quot;)
                .anyRequest().authenticated()
            .and()
            .httpBasic()
        return http.build()
    }
}</code></pre>
<hr />
<h2>‚ñ∂Ô∏è Running the Application</h2>
<p>Run the application using the following command:</p>
<pre><code class="language-bash">./mvnw spring-boot:run</code></pre>
<p>Access the Actuator endpoints at:</p>
<pre><code>http://localhost:8080/actuator/health</code></pre>
<hr />
<h2>üß™ Test the API</h2>
<p>You can test the Actuator endpoints using cURL or browser:</p>
<ul>
<li>Health Endpoint:</li>
</ul>
<pre><code class="language-bash">curl -X GET http://localhost:8080/actuator/health</code></pre>
<ul>
<li>Info Endpoint:</li>
</ul>
<pre><code class="language-bash">curl -X GET http://localhost:8080/actuator/info</code></pre>
<hr />
<h2>üèÅ Conclusion</h2>
<p>This setup delivers a robust, production-ready Spring Boot Actuator solution in Spring Boot, combining best practices, clear structure, and practical examples you can adapt to your own project.</p>]]></content:encoded>
      <category><![CDATA[Java]]></category>
      <category><![CDATA[Kotlin]]></category>
      <category><![CDATA[Spring Boot]]></category>
      <category><![CDATA[Actuator]]></category>
      <category><![CDATA[Monitoring]]></category>
      <category><![CDATA[Programming]]></category>
      <media:thumbnail url="https://suaybsimsek.com/images/spring-boot-actuator-thumbnail.webp" />
    </item>
    <item>
      <title><![CDATA[Aspect-Oriented Programming in Spring Boot]]></title>
      <link>https://suaybsimsek.com/en/posts/spring-boot-aop</link>
      <description><![CDATA[Learn how to implement Aspect-Oriented Programming (AOP) in Spring Boot using Java and Kotlin. Covers core concepts, use cases, and practical examples.]]></description>
      <pubDate>Wed, 18 Dec 2024 00:00:00 GMT</pubDate>
      <guid isPermaLink="true">https://suaybsimsek.com/en/posts/spring-boot-aop</guid>
      <content:encoded><![CDATA[<p>Aspect-Oriented Programming (AOP) provides a way to modularize cross-cutting concerns, such as logging, transaction management, and security. This guide demonstrates how to implement AOP in Spring Boot with examples in Java and Kotlin.</p>
<hr />
<h2>üåü Why Use AOP?</h2>
<p>AOP enables developers to separate concerns that affect multiple parts of an application, like logging or security, into reusable aspects. This approach promotes cleaner code, improved maintainability, and reduced redundancy.</p>
<hr />
<h2>üìã Prerequisites</h2>
<p>üìã Ensure you have the following:</p>
<ul>
<li>‚òï Java Development Kit (JDK) 17+</li>
<li>üì¶ Maven or Gradle installed</li>
<li>üî§ A Java IDE (e.g., IntelliJ IDEA, Eclipse)</li>
</ul>
<hr />
<h2>üõ†Ô∏è Step 1: Add Dependencies</h2>
<p>Include the following dependencies in your project:</p>
<ul>
<li>Maven:</li>
</ul>
<pre><code class="language-xml">&lt;dependency&gt;
  &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
  &lt;artifactId&gt;spring-boot-starter-aop&lt;/artifactId&gt;
&lt;/dependency&gt;</code></pre>
<ul>
<li>Gradle:</li>
</ul>
<pre><code class="language-groovy">implementation &#39;org.springframework.boot:spring-boot-starter-aop&#39;</code></pre>
<hr />
<h2>üõ†Ô∏è Step 2: Define a Service</h2>
<p>Create a simple service to demonstrate AOP.</p>
<h3>Java</h3>
<h3>Service</h3>
<pre><code class="language-java">package com.example.demo.service;

import org.springframework.stereotype.Service;

@Service
public class UserService {

    public String getUserById(String id) {
        return &quot;User with ID: &quot; + id;
    }

    public String getAllUsers() {
        return &quot;Fetching all users.&quot;;
    }
}</code></pre>
<h3>Kotlin</h3>
<h3>Service</h3>
<pre><code class="language-kotlin">package com.example.demo.service

import org.springframework.stereotype.Service

@Service
class UserService {

    fun getUserById(id: String): String {
        return &quot;User with ID: $id&quot;
    }

    fun getAllUsers(): String {
        return &quot;Fetching all users.&quot;
    }
}</code></pre>
<hr />
<h2>üõ†Ô∏è Step 3: Create an Aspect</h2>
<p>Define an aspect to log method execution details.</p>
<h3>Java</h3>
<h3>Aspect</h3>
<pre><code class="language-java">package com.example.demo.aspect;

import org.aspectj.lang.annotation.Aspect;
import org.aspectj.lang.annotation.Before;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.stereotype.Component;

@Aspect
@Component
public class LoggingAspect {

    private static final Logger logger = LoggerFactory.getLogger(LoggingAspect.class);

    @Before(&quot;execution(* com.example.demo.service.UserService.*(..))&quot;)
    public void logBefore() {
        logger.info(&quot;Method execution started.&quot;);
    }
}</code></pre>
<h3>Kotlin</h3>
<h3>Aspect</h3>
<pre><code class="language-kotlin">package com.example.demo.aspect

import org.aspectj.lang.annotation.Aspect
import org.aspectj.lang.annotation.Before
import org.slf4j.LoggerFactory
import org.springframework.stereotype.Component

@Aspect
@Component
class LoggingAspect {

    private val logger = LoggerFactory.getLogger(LoggingAspect::class.java)

    @Before(&quot;execution(* com.example.demo.service.UserService.*(..))&quot;)
    fun logBefore() {
        logger.info(&quot;Method execution started.&quot;)
    }
}</code></pre>
<hr />
<h2>üõ†Ô∏è Step 4: Create a Controller</h2>
<p>Expose the service methods through a REST controller.</p>
<h3>Java</h3>
<h3>Controller</h3>
<pre><code class="language-java">package com.example.demo.controller;

import com.example.demo.service.UserService;
import lombok.RequiredArgsConstructor;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.PathVariable;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;

@RestController
@RequestMapping(&quot;/api/users&quot;)
@RequiredArgsConstructor
public class UserController {

    private final UserService userService;

    @GetMapping(&quot;/{id}&quot;)
    public String getUserById(@PathVariable String id) {
        return userService.getUserById(id);
    }

    @GetMapping
    public String getAllUsers() {
        return userService.getAllUsers();
    }
}</code></pre>
<h3>Kotlin</h3>
<h3>Controller</h3>
<pre><code class="language-kotlin">package com.example.demo.controller

import com.example.demo.service.UserService
import org.springframework.web.bind.annotation.GetMapping
import org.springframework.web.bind.annotation.PathVariable
import org.springframework.web.bind.annotation.RequestMapping
import org.springframework.web.bind.annotation.RestController

@RestController
@RequestMapping(&quot;/api/users&quot;)
class UserController(
    private val userService: UserService
) {

    @GetMapping(&quot;/{id}&quot;)
    fun getUserById(@PathVariable id: String): String = userService.getUserById(id)

    @GetMapping
    fun getAllUsers(): String = userService.getAllUsers()
}</code></pre>
<hr />
<h2>‚ñ∂Ô∏è Running the Application</h2>
<p>Run the application using the following commands:</p>
<ul>
<li>Spring Boot (Java/Kotlin):</li>
</ul>
<p>```bash ./mvnw spring-boot:run ```</p>
<p>Access the API at `http://localhost:8080/api/users`.</p>
<hr />
<h2>üß™ Testing the API</h2>
<p>You can test the API using the following cURL commands:</p>
<ul>
<li>Fetch all users:</li>
</ul>
<pre><code class="language-bash">curl -X GET http://localhost:8080/api/users</code></pre>
<ul>
<li>Fetch a user by ID:</li>
</ul>
<pre><code class="language-bash">curl -X GET http://localhost:8080/api/users/1</code></pre>
<hr />
<h2>üèÅ Conclusion</h2>
<p>This setup delivers a robust, production-ready Aspect-Oriented Programming in Spring Boot solution in Spring Boot, combining best practices, clear structure, and practical examples you can adapt to your own project.</p>]]></content:encoded>
      <category><![CDATA[Java]]></category>
      <category><![CDATA[Kotlin]]></category>
      <category><![CDATA[Spring Boot]]></category>
      <category><![CDATA[AOP]]></category>
      <category><![CDATA[Programming]]></category>
      <media:thumbnail url="https://suaybsimsek.com/images/spring-boot-aop-thumbnail.webp" />
    </item>
    <item>
      <title><![CDATA[Dependency Injection in Spring Boot]]></title>
      <link>https://suaybsimsek.com/en/posts/spring-boot-di</link>
      <description><![CDATA[Learn how Dependency Injection (DI) works in Spring Boot, including examples in Java and Kotlin. Covers key concepts, annotations, and practical use cases.]]></description>
      <pubDate>Wed, 18 Dec 2024 00:00:00 GMT</pubDate>
      <guid isPermaLink="true">https://suaybsimsek.com/en/posts/spring-boot-di</guid>
      <content:encoded><![CDATA[<p>Dependency Injection (DI) is a fundamental concept in Spring Boot that helps achieve loose coupling and increased testability. This guide demonstrates how to use DI in Spring Boot with practical examples in Java and Kotlin.</p>
<hr />
<h2>üåü Why Use Dependency Injection?</h2>
<p>Dependency Injection allows developers to manage and inject dependencies into classes without manually instantiating them. This leads to:</p>
<ul>
<li>Better code modularity</li>
<li>Simplified testing</li>
<li>Easier maintenance</li>
</ul>
<hr />
<h2>üìã Prerequisites</h2>
<p>üìã Ensure you have the following:</p>
<ul>
<li>‚òï Java Development Kit (JDK) 17+</li>
<li>üì¶ Maven or Gradle installed</li>
<li>üî§ A Java IDE (e.g., IntelliJ IDEA, Eclipse)</li>
</ul>
<hr />
<h2>üõ†Ô∏è Step 1: Add Dependencies</h2>
<p>Include the necessary Spring Boot dependencies:</p>
<ul>
<li>Maven:</li>
</ul>
<pre><code class="language-xml">&lt;dependency&gt;
  &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
  &lt;artifactId&gt;spring-boot-starter&lt;/artifactId&gt;
&lt;/dependency&gt;</code></pre>
<ul>
<li>Gradle:</li>
</ul>
<pre><code class="language-groovy">implementation &#39;org.springframework.boot:spring-boot-starter&#39;</code></pre>
<hr />
<h2>üõ†Ô∏è Step 2: Create a Service</h2>
<p>Define a simple service to demonstrate DI.</p>
<h3>Java</h3>
<h3>Service</h3>
<pre><code class="language-java">package com.example.demo.service;

import org.springframework.stereotype.Service;

@Service
public class UserService {

    public String getUserById(String id) {
        return &quot;User with ID: &quot; + id;
    }

    public String getAllUsers() {
        return &quot;Fetching all users.&quot;;
    }
}</code></pre>
<h3>Kotlin</h3>
<h3>Service</h3>
<pre><code class="language-kotlin">package com.example.demo.service

import org.springframework.stereotype.Service

@Service
class UserService {

    fun getUserById(id: String): String {
        return &quot;User with ID: $id&quot;
    }

    fun getAllUsers(): String {
        return &quot;Fetching all users.&quot;
    }
}</code></pre>
<hr />
<h2>üõ†Ô∏è Step 3: Inject Dependencies</h2>
<p>Use annotations to inject the service into other components.</p>
<h3>Java</h3>
<h3>Controller</h3>
<pre><code class="language-java">package com.example.demo.controller;

import com.example.demo.service.UserService;
import lombok.RequiredArgsConstructor;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.PathVariable;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;

@RestController
@RequestMapping(&quot;/api/users&quot;)
@RequiredArgsConstructor
public class UserController {

    private final UserService userService;

    @GetMapping(&quot;/{id}&quot;)
    public String getUserById(@PathVariable String id) {
        return userService.getUserById(id);
    }

    @GetMapping
    public String getAllUsers() {
        return userService.getAllUsers();
    }
}</code></pre>
<h3>Kotlin</h3>
<h3>Controller</h3>
<pre><code class="language-kotlin">package com.example.demo.controller

import com.example.demo.service.UserService
import org.springframework.web.bind.annotation.GetMapping
import org.springframework.web.bind.annotation.PathVariable
import org.springframework.web.bind.annotation.RequestMapping
import org.springframework.web.bind.annotation.RestController

@RestController
@RequestMapping(&quot;/api/users&quot;)
class UserController(
    private val userService: UserService
) {

    @GetMapping(&quot;/{id}&quot;)
    fun getUserById(@PathVariable id: String): String = userService.getUserById(id)

    @GetMapping
    fun getAllUsers(): String = userService.getAllUsers()
}</code></pre>
<hr />
<h2>‚ñ∂Ô∏è Running the Application</h2>
<p>Run the application using the following commands:</p>
<ul>
<li>Spring Boot (Java/Kotlin):</li>
</ul>
<p>```bash ./mvnw spring-boot:run ```</p>
<p>Access the API at `http://localhost:8080/api/users`.</p>
<hr />
<h2>üß™ Test the API</h2>
<p>You can test the API using the following cURL commands:</p>
<ul>
<li>Fetch all users:</li>
</ul>
<pre><code class="language-bash">curl -X GET http://localhost:8080/api/users</code></pre>
<ul>
<li>Fetch a user by ID:</li>
</ul>
<pre><code class="language-bash">curl -X GET http://localhost:8080/api/users/1</code></pre>
<hr />
<h2>üèÅ Conclusion</h2>
<p>This setup delivers a robust, production-ready Dependency Injection in Spring Boot solution in Spring Boot, combining best practices, clear structure, and practical examples you can adapt to your own project.</p>]]></content:encoded>
      <category><![CDATA[Java]]></category>
      <category><![CDATA[Kotlin]]></category>
      <category><![CDATA[Spring Boot]]></category>
      <category><![CDATA[Dependency Injection]]></category>
      <category><![CDATA[Programming]]></category>
      <media:thumbnail url="https://suaybsimsek.com/images/spring-boot-di-thumbnail.webp" />
    </item>
    <item>
      <title><![CDATA[Object-Relational Mapping]]></title>
      <link>https://suaybsimsek.com/en/posts/object-relational-mapping</link>
      <description><![CDATA[Learn how to set up an ORM-based application with Spring Boot using Java, Kotlin, and Go (Gin). Includes PostgreSQL integration and basic CRUD operations.]]></description>
      <pubDate>Mon, 16 Dec 2024 00:00:00 GMT</pubDate>
      <guid isPermaLink="true">https://suaybsimsek.com/en/posts/object-relational-mapping</guid>
      <content:encoded><![CDATA[<p>Object-Relational Mapping (ORM) simplifies database operations in modern applications. This guide will show you how to set up ORM with PostgreSQL using Spring Boot and the Gin framework.</p>
<hr />
<h2>üåü Why Use ORM?</h2>
<p>ORM bridges the gap between object-oriented programming and relational databases by mapping objects directly to database tables. This eliminates the need for manual SQL queries, reducing errors and increasing productivity for developers.</p>
<hr />
<h2>üìã Prerequisites</h2>
<p>üìã Ensure you have the following:</p>
<ul>
<li>‚òï Java Development Kit (JDK) 17+</li>
<li>üì¶ Maven or Gradle installed</li>
<li>üñ•Ô∏è A Java IDE</li>
<li>üêò PostgreSQL installed and running</li>
</ul>
<p>For Go:</p>
<ul>
<li>üîß Golang 1.17+ installed</li>
<li>üîÑ go.mod initialized in your project</li>
</ul>
<hr />
<h2>üõ†Ô∏è Step 1: Add Dependencies</h2>
<p>To set up a Spring Boot project and integrate ORM, follow these steps:</p>
<h3>Add Dependencies</h3>
<p>For Spring Boot projects, include the following dependencies in your project:</p>
<ul>
<li>Maven:</li>
</ul>
<pre><code class="language-xml">&lt;dependency&gt;
  &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
  &lt;artifactId&gt;spring-boot-starter-data-jpa&lt;/artifactId&gt;
&lt;/dependency&gt;
&lt;dependency&gt;
  &lt;groupId&gt;org.postgresql&lt;/groupId&gt;
  &lt;artifactId&gt;postgresql&lt;/artifactId&gt;
&lt;/dependency&gt;</code></pre>
<ul>
<li>Gradle:</li>
</ul>
<pre><code class="language-groovy">implementation &#39;org.springframework.boot:spring-boot-starter-data-jpa&#39;
implementation &#39;org.postgresql:postgresql&#39;</code></pre>
<h3>Configure the Database</h3>
<p>Set up your PostgreSQL connection in the `application.properties` or `application.yml` file:</p>
<pre><code class="language-properties">spring.datasource.url=jdbc:postgresql://localhost:5432/demo
spring.datasource.username=your_username
spring.datasource.password=your_password
spring.jpa.hibernate.ddl-auto=update</code></pre>
<h3>Initialize the Project</h3>
<p>If you haven&#39;t already, create your Spring Boot project using [Spring Initializr](https://start.spring.io/):</p>
<p>1. Choose Spring Web, Spring Data JPA, and PostgreSQL Driver as dependencies. 2. Download the project and import it into your preferred IDE.</p>
<p>For Go projects:</p>
<ul>
<li>Install Gin Framework and GORM:</li>
</ul>
<pre><code class="language-bash"># Install the Gin framework
go get -u github.com/gin-gonic/gin

# Install the GORM PostgreSQL driver
go get -u gorm.io/driver/postgres

# Install the GORM ORM library
go get -u gorm.io/gorm</code></pre>
<hr />
<h2>üõ†Ô∏è Step 2: Define the Model and Implement the REST Controller</h2>
<p>This step combines creating the entity/model, repository, and REST controllers.</p>
<h3>Java</h3>
<h3>Entity</h3>
<pre><code class="language-java">package com.example.demo.entity;

import jakarta.persistence.*;
import lombok.Data;

@Data
@Entity
public class User {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    private String name;

    private String email;
}</code></pre>
<h3>Repository</h3>
<pre><code class="language-java">package com.example.demo.repository;

import com.example.demo.entity.User;
import org.springframework.data.jpa.repository.JpaRepository;

public interface UserRepository extends JpaRepository&lt;User, Long&gt; {
}</code></pre>
<h3>REST Controller</h3>
<pre><code class="language-java">package com.example.demo.controller;

import com.example.demo.entity.User;
import com.example.demo.repository.UserRepository;
import org.springframework.web.bind.annotation.*;

import java.util.List;

@RestController
@RequestMapping(&quot;/api/users&quot;)
import lombok.RequiredArgsConstructor;

@RequiredArgsConstructor
public class UserController {

  private final UserRepository userRepository;

  @GetMapping
  public List&lt;User&gt; getAllUsers() {
    return userRepository.findAll();
  }

  @PostMapping
  public User createUser(@RequestBody User user) {
    return userRepository.save(user);
  }
}</code></pre>
<h3>Kotlin</h3>
<h3>Entity</h3>
<pre><code class="language-kotlin">package com.example.demo.entity

import jakarta.persistence.*

@Entity
class User(
  @Id
  @GeneratedValue(strategy = GenerationType.IDENTITY)
  val id: Long = 0,

  var name: String,

  var email: String
)</code></pre>
<h3>Repository</h3>
<pre><code class="language-kotlin">package com.example.demo.repository

import com.example.demo.entity.User
import org.springframework.data.jpa.repository.JpaRepository

interface UserRepository : JpaRepository&lt;User, Long&gt;</code></pre>
<h3>REST Controller</h3>
<pre><code class="language-kotlin">package com.example.demo.controller

import com.example.demo.entity.User
import com.example.demo.repository.UserRepository
import org.springframework.web.bind.annotation.*

@RestController
@RequestMapping(&quot;/api/users&quot;)
class UserController(
  private val userRepository: UserRepository
) {

  @GetMapping
  fun getAllUsers(): List&lt;User&gt; = userRepository.findAll()

  @PostMapping
  fun createUser(@RequestBody user: User): User = userRepository.save(user)
}</code></pre>
<h3>Go</h3>
<h3>Model and Database Connection</h3>
<pre><code class="language-go">package main

import (
	&quot;gorm.io/driver/postgres&quot;
	&quot;gorm.io/gorm&quot;
)

var DB *gorm.DB

func connectDatabase() {
	dsn := &quot;host=localhost user=your_username password=your_password dbname=demo port=5432 sslmode=disable&quot;
	db, err := gorm.Open(postgres.Open(dsn), &amp;gorm.Config{})
	if err != nil {
		panic(&quot;Failed to connect to database!&quot;)
	}

	DB = db
	DB.AutoMigrate(&amp;User{})
}

type User struct {
	ID    uint   `json:&quot;id&quot; gorm:&quot;primaryKey&quot;`
	Name  string `json:&quot;name&quot;`
	Email string `json:&quot;email&quot;`
}</code></pre>
<h3>Handlers</h3>
<pre><code class="language-go">package main

import (
	&quot;github.com/gin-gonic/gin&quot;
)

func getUsers(c *gin.Context) {
	var users []User
	DB.Find(&amp;users)
	c.JSON(200, users)
}

func createUser(c *gin.Context) {
	var user User
	if err := c.ShouldBindJSON(&amp;user); err != nil {
		c.JSON(400, gin.H{&quot;error&quot;: err.Error()})
		return
	}
	DB.Create(&amp;user)
	c.JSON(201, user)
}

func main() {
	r := gin.Default()
	connectDatabase()

	r.GET(&quot;/api/users&quot;, getUsers)
	r.POST(&quot;/api/users&quot;, createUser)

	r.Run() // Listen and serve on 0.0.0.0:8080
}</code></pre>
<hr />
<h2>‚ñ∂Ô∏è Running the Applications</h2>
<ul>
<li>Spring Boot:</li>
</ul>
<p>```bash ./mvnw spring-boot:run ```</p>
<ul>
<li>Gin:</li>
</ul>
<p>```bash go run main.go ```</p>
<hr />
<h2>üß™ Testing with cURL</h2>
<p>You can test the API using the following cURL commands:</p>
<p>Fetch All Users:</p>
<pre><code class="language-bash">curl -X GET http://localhost:8080/api/users</code></pre>
<p>Create a New User:</p>
<pre><code class="language-bash">curl -X POST http://localhost:8080/api/users \
-H &quot;Content-Type: application/json&quot; \
-d &#39;{&quot;name&quot;: &quot;John Doe&quot;, &quot;email&quot;: &quot;johndoe@example.com&quot;}&#39;</code></pre>
<hr />
<h2>üèÅ Conclusion</h2>
<p>This setup delivers a robust, production-ready Object-Relational Mapping solution in Spring Boot, combining best practices, clear structure, and practical examples you can adapt to your own project.</p>]]></content:encoded>
      <category><![CDATA[Java]]></category>
      <category><![CDATA[Kotlin]]></category>
      <category><![CDATA[Go]]></category>
      <category><![CDATA[Spring Boot]]></category>
      <category><![CDATA[Gin]]></category>
      <category><![CDATA[ORM]]></category>
      <category><![CDATA[Programming]]></category>
      <media:thumbnail url="https://suaybsimsek.com/images/orm-thumbnail.webp" />
    </item>
    <item>
      <title><![CDATA[Input Validation in REST APIs]]></title>
      <link>https://suaybsimsek.com/en/posts/rest-api-input-validation</link>
      <description><![CDATA[Learn how to implement input validation in REST APIs using Java, Kotlin, and Go with frameworks like Spring Boot and Gin. Covers annotations, custom validators, and error handling.]]></description>
      <pubDate>Sun, 15 Dec 2024 00:00:00 GMT</pubDate>
      <guid isPermaLink="true">https://suaybsimsek.com/en/posts/rest-api-input-validation</guid>
      <content:encoded><![CDATA[<p>Input validation is crucial for building secure and robust REST APIs. In this article, we will explore how to implement input validation in Spring Boot using Java, Kotlin, and Go (with Gin).</p>
<hr />
<h2>üåü Why Validate Input?</h2>
<p>Validation ensures the data sent to your API adheres to expected formats and prevents potential vulnerabilities like SQL Injection, XSS, and bad data entries.</p>
<hr />
<h2>üß™ Step 1: Add Validation Dependencies</h2>
<p>For Spring Boot projects, include the following dependencies:</p>
<ul>
<li>Maven:</li>
</ul>
<pre><code class="language-xml">&lt;dependency&gt;
  &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
  &lt;artifactId&gt;spring-boot-starter-validation&lt;/artifactId&gt;
&lt;/dependency&gt;</code></pre>
<ul>
<li>Gradle:</li>
</ul>
<pre><code class="language-groovy">implementation &#39;org.springframework.boot:spring-boot-starter-validation&#39;</code></pre>
<p>For Go projects with Gin, use the following:</p>
<pre><code class="language-bash"># Install the Gin framework
go get -u github.com/gin-gonic/gin

# Install the validator package
go get -u github.com/go-playground/validator/v10</code></pre>
<hr />
<h2>üß™ Step 2: Define a DTO with Validation Rules</h2>
<p>Use annotations to define validation constraints on fields. Examples include `@NotNull`, `@Size`, and `@Pattern`.</p>
<h3>Java</h3>
<pre><code class="language-java">package com.example.demo.dto;

import jakarta.validation.constraints.NotNull;
import jakarta.validation.constraints.Size;
import lombok.Data;

@Data
public class TodoRequest {

    @NotNull(message = &quot;Title is required&quot;)
    @Size(min = 3, max = 50, message = &quot;Title must be between 3 and 50 characters&quot;)
    private String title;

    private boolean completed;
}</code></pre>
<h3>Kotlin</h3>
<pre><code class="language-kotlin">package com.example.demo.dto

import jakarta.validation.constraints.NotNull
import jakarta.validation.constraints.Size

data class TodoRequest(
    @field:NotNull(message = &quot;Title is required&quot;)
    @field:Size(min = 3, max = 50, message = &quot;Title must be between 3 and 50 characters&quot;)
    val title: String?,

    val completed: Boolean = false
)</code></pre>
<h3>Go</h3>
<pre><code class="language-go">package dto

import (
    &quot;github.com/go-playground/validator/v10&quot;
)

type TodoRequest struct {
    Title     string `validate:&quot;required,min=3,max=50&quot;`
    Completed bool   `validate:&quot;&quot;`
}

var validate = validator.New()

func ValidateTodoRequest(todo TodoRequest) error {
    return validate.Struct(todo)
}</code></pre>
<hr />
<h2>üß™ Step 3: Create a Controller with Validation</h2>
<p>Integrate validation into your REST endpoints.</p>
<h3>Java</h3>
<pre><code class="language-java">package com.example.demo.controller;

import com.example.demo.dto.TodoRequest;
import org.springframework.validation.annotation.Validated;
import org.springframework.web.bind.annotation.*;

@RestController
@RequestMapping(&quot;/api/todos&quot;)
public class TodoController {

    @PostMapping
    public String createTodo(@Validated @RequestBody TodoRequest request) {
        return &quot;Todo created: &quot; + request.getTitle();
    }
}</code></pre>
<h3>Kotlin</h3>
<pre><code class="language-kotlin">package com.example.demo.controller

import com.example.demo.dto.TodoRequest
import org.springframework.validation.annotation.Validated
import org.springframework.web.bind.annotation.*

@RestController
@RequestMapping(&quot;/api/todos&quot;)
class TodoController {

    @PostMapping
    fun createTodo(@Validated @RequestBody request: TodoRequest): String {
        return &quot;Todo created: ${request.title}&quot;
    }
}</code></pre>
<h3>Go</h3>
<pre><code class="language-go">package controller

import (
    &quot;dto&quot;
    &quot;github.com/gin-gonic/gin&quot;
    &quot;net/http&quot;
)

func CreateTodoHandler(c *gin.Context) {
    var todo dto.TodoRequest

    if err := c.ShouldBindJSON(&amp;todo); err != nil {
        c.JSON(http.StatusBadRequest, gin.H{&quot;error&quot;: err.Error()})
        return
    }

    if err := dto.ValidateTodoRequest(todo); err != nil {
        c.JSON(http.StatusBadRequest, gin.H{&quot;error&quot;: err.Error()})
        return
    }

    c.JSON(http.StatusOK, gin.H{&quot;message&quot;: &quot;Todo created&quot;, &quot;title&quot;: todo.Title})
}</code></pre>
<hr />
<h2>üß™ Step 4: Handle Validation Errors</h2>
<p>Customize error handling to return user-friendly responses.</p>
<h3>Java</h3>
<pre><code class="language-java">package com.example.demo.exception;

import org.springframework.http.HttpStatus;
import org.springframework.web.bind.annotation.ExceptionHandler;
import org.springframework.web.bind.annotation.RestControllerAdvice;
import org.springframework.web.bind.MethodArgumentNotValidException;

import java.util.HashMap;
import java.util.Map;

@RestControllerAdvice
public class GlobalExceptionHandler {

    @ExceptionHandler(MethodArgumentNotValidException.class)
    public Map&lt;String, String&gt; handleValidationExceptions(MethodArgumentNotValidException ex) {
        Map&lt;String, String&gt; errors = new HashMap&lt;&gt;();
        ex.getBindingResult().getFieldErrors().forEach(error -&gt; errors.put(error.getField(), error.getDefaultMessage()));
        return errors;
    }
}</code></pre>
<h3>Kotlin</h3>
<pre><code class="language-kotlin">package com.example.demo.exception

import org.springframework.http.HttpStatus
import org.springframework.web.bind.annotation.ExceptionHandler
import org.springframework.web.bind.annotation.RestControllerAdvice
import org.springframework.web.bind.MethodArgumentNotValidException

@RestControllerAdvice
class GlobalExceptionHandler {

    @ExceptionHandler(MethodArgumentNotValidException::class)
    fun handleValidationExceptions(ex: MethodArgumentNotValidException): Map&lt;String, String&gt; {
        return ex.bindingResult.fieldErrors.associate { it.field to it.defaultMessage.orEmpty() }
    }
}</code></pre>
<h3>Go</h3>
<pre><code class="language-go">package middleware

import (
    &quot;github.com/gin-gonic/gin&quot;
    &quot;net/http&quot;
)

func ErrorHandler() gin.HandlerFunc {
    return func(c *gin.Context) {
        c.Next()

        if len(c.Errors) &gt; 0 {
            c.JSON(http.StatusBadRequest, gin.H{&quot;errors&quot;: c.Errors.JSON()})
        }
    }
}</code></pre>
<hr />
<h3>main.go Example</h3>
<p>Here is an example of the `main.go` file for setting up a Gin application:</p>
<pre><code class="language-go">package main

import (
	&quot;controller&quot;
	&quot;github.com/gin-gonic/gin&quot;
)

func main() {
	r := gin.Default()

	r.POST(&quot;/api/todos&quot;, controller.CreateTodoHandler)

	r.Run() // Start the server on http://localhost:8080
}</code></pre>
<hr />
<h2>‚ñ∂Ô∏è Step 5: Run the Application</h2>
<p>To run the application:</p>
<h3>Spring Boot (Java/Kotlin)</h3>
<p>Run the Spring Boot application from your IDE or terminal:</p>
<pre><code class="language-bash">./mvnw spring-boot:run # For Maven projects
./gradlew bootRun       # For Gradle projects</code></pre>
<p>Access the API at `http://localhost:8080/api/todos`.</p>
<h3>Gin (Go)</h3>
<p>Run the Go application:</p>
<pre><code class="language-bash">go run main.go</code></pre>
<p>Access the API at `http://localhost:8080/api/todos`.</p>
<h2>üß™ Testing with cURL</h2>
<p>Here are some example cURL commands to test the API:</p>
<ul>
<li>POST a new Todo:</li>
</ul>
<pre><code class="language-bash">curl -X POST http://localhost:8080/api/todos \
-H &quot;Content-Type: application/json&quot; \
-d &#39;{&quot;title&quot;: &quot;New Task&quot;, &quot;completed&quot;: false}&#39;</code></pre>
<ul>
<li>GET all Todos:</li>
</ul>
<pre><code class="language-bash">curl -X GET http://localhost:8080/api/todos</code></pre>
<ul>
<li>Handle Validation Errors:</li>
</ul>
<p>Send an invalid request:</p>
<pre><code class="language-bash">curl -X POST http://localhost:8080/api/todos \
-H &quot;Content-Type: application/json&quot; \
-d &#39;{&quot;title&quot;: &quot;&quot;}&#39;</code></pre>
<hr />
<h2>üèÅ Conclusion</h2>
<p>This setup delivers a robust, production-ready Input Validation in REST APIs solution in Spring Boot, combining best practices, clear structure, and practical examples you can adapt to your own project.</p>]]></content:encoded>
      <category><![CDATA[Java]]></category>
      <category><![CDATA[Kotlin]]></category>
      <category><![CDATA[Go]]></category>
      <category><![CDATA[Spring Boot]]></category>
      <category><![CDATA[Gin]]></category>
      <category><![CDATA[Validation]]></category>
      <category><![CDATA[Programming]]></category>
      <media:thumbnail url="https://suaybsimsek.com/images/input-validation-thumbnail.webp" />
    </item>
    <item>
      <title><![CDATA[Building APIs with Spring for GraphQL]]></title>
      <link>https://suaybsimsek.com/en/posts/spring-boot-graphql</link>
      <description><![CDATA[Learn how to build GraphQL APIs using Spring for GraphQL with Java and Kotlin. Includes schema creation, query handling, and integration.]]></description>
      <pubDate>Sun, 15 Dec 2024 00:00:00 GMT</pubDate>
      <guid isPermaLink="true">https://suaybsimsek.com/en/posts/spring-boot-graphql</guid>
      <content:encoded><![CDATA[<p>Spring for GraphQL simplifies the development of GraphQL APIs by integrating with Spring Boot. This guide demonstrates how to create a GraphQL API using Java and Kotlin, with examples for schema definition, query handling, and dependency injection.</p>
<hr />
<h2>üåü Why Use GraphQL?</h2>
<p>GraphQL allows clients to request specific data, reducing over-fetching and under-fetching compared to REST. It also supports strong typing and facilitates efficient data fetching, making it a popular choice for modern APIs.</p>
<hr />
<h2>üìã Prerequisites</h2>
<p>üìã Ensure you have the following:</p>
<ul>
<li>‚òï Java Development Kit (JDK) 17+</li>
<li>üì¶ Maven or Gradle installed</li>
<li>üî§ A Java IDE (e.g., IntelliJ IDEA, Eclipse)</li>
</ul>
<hr />
<h2>üõ†Ô∏è Step 1: Add Dependencies</h2>
<p>Include the following dependencies in your project to enable Spring for GraphQL.</p>
<ul>
<li>Maven:</li>
</ul>
<pre><code class="language-xml">&lt;dependency&gt;
  &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
  &lt;artifactId&gt;spring-boot-starter-graphql&lt;/artifactId&gt;
&lt;/dependency&gt;</code></pre>
<ul>
<li>Gradle:</li>
</ul>
<pre><code class="language-groovy">implementation &#39;org.springframework.boot:spring-boot-starter-graphql&#39;</code></pre>
<hr />
<h2>üõ†Ô∏è Step 2: Define the GraphQL Schema</h2>
<p>Create a schema file named `schema.graphqls` under the `src/main/resources/graphql` directory.</p>
<pre><code class="language-graphql">type Query {
  getUser(id: ID!): User
  getUsers: [User]
}

type User {
  id: ID!
  name: String!
  email: String!
}</code></pre>
<hr />
<h2>üõ†Ô∏è Step 3: Implement the Data Model and Services</h2>
<p>Define the data model and service layer for handling queries.</p>
<h3>Java</h3>
<h3>Entity</h3>
<pre><code class="language-java">package com.example.demo.model;

import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;

@Data
@NoArgsConstructor
@AllArgsConstructor
public class User {
    private String id;
    private String name;
    private String email;
}</code></pre>
<h3>Service</h3>
<pre><code class="language-java">package com.example.demo.service;

import com.example.demo.model.User;
import org.springframework.stereotype.Service;

import java.util.List;
import java.util.Map;
import java.util.stream.Collectors;
import java.util.stream.Stream;

@Service
public class UserService {

    private final Map&lt;String, User&gt; userData = Stream.of(
        new User(&quot;1&quot;, &quot;Alice&quot;, &quot;alice@example.com&quot;),
        new User(&quot;2&quot;, &quot;Bob&quot;, &quot;bob@example.com&quot;)
    ).collect(Collectors.toMap(User::getId, user -&gt; user));

    public User getUser(String id) {
        return userData.get(id);
    }

    public List&lt;User&gt; getUsers() {
        return List.copyOf(userData.values());
    }
}</code></pre>
<hr />
<h3>Kotlin</h3>
<h3>Entity</h3>
<pre><code class="language-kotlin">package com.example.demo.model

data class User(
    val id: String,
    val name: String,
    val email: String
)</code></pre>
<h3>Service</h3>
<pre><code class="language-kotlin">package com.example.demo.service

import com.example.demo.model.User
import org.springframework.stereotype.Service

@Service
class UserService {

    private val userData = mapOf(
        &quot;1&quot; to User(&quot;1&quot;, &quot;Alice&quot;, &quot;alice@example.com&quot;),
        &quot;2&quot; to User(&quot;2&quot;, &quot;Bob&quot;, &quot;bob@example.com&quot;)
    )

    fun getUser(id: String): User? = userData[id]

    fun getUsers(): List&lt;User&gt; = userData.values.toList()
}</code></pre>
<hr />
<h2>üõ†Ô∏è Step 4: Implement GraphQL Controllers</h2>
<p>Controllers handle GraphQL queries and mutations. Use the `@Controller` annotation in Spring for GraphQL.</p>
<h3>Java</h3>
<pre><code class="language-java">package com.example.demo.controller;

import com.example.demo.model.User;
import com.example.demo.service.UserService;
import lombok.RequiredArgsConstructor;
import org.springframework.graphql.data.method.annotation.QueryMapping;
import org.springframework.stereotype.Controller;

import java.util.List;

@Controller
@RequiredArgsConstructor
public class UserController {

    private final UserService userService;

    @QueryMapping
    public User getUser(String id) {
        return userService.getUser(id);
    }

    @QueryMapping
    public List&lt;User&gt; getUsers() {
        return userService.getUsers();
    }
}</code></pre>
<hr />
<h3>Kotlin</h3>
<pre><code class="language-kotlin">package com.example.demo.controller

import com.example.demo.model.User
import com.example.demo.service.UserService
import org.springframework.graphql.data.method.annotation.QueryMapping
import org.springframework.stereotype.Controller

@Controller
class UserController(
    private val userService: UserService
) {

    @QueryMapping
    fun getUser(id: String): User? = userService.getUser(id)

    @QueryMapping
    fun getUsers(): List&lt;User&gt; = userService.getUsers()
}</code></pre>
<hr />
<h2>‚ñ∂Ô∏è Running the Application</h2>
<p>Run the application using the following commands:</p>
<ul>
<li>Spring Boot (Java/Kotlin):</li>
</ul>
<p>```bash ./mvnw spring-boot:run ```</p>
<p>Access the GraphQL Playground at `http://localhost:8080/graphiql` to test your API.</p>
<hr />
<h2>üß™ Testing the GraphQL API</h2>
<p>Here are some example queries to test your API:</p>
<ul>
<li>Fetch a user by ID:</li>
</ul>
<pre><code class="language-graphql">query {
  getUser(id: &quot;1&quot;) {
    id
    name
    email
  }
}</code></pre>
<ul>
<li>Fetch all users:</li>
</ul>
<pre><code class="language-graphql">query {
  getUsers {
    id
    name
    email
  }
}</code></pre>
<hr />
<h2>üèÅ Conclusion</h2>
<p>This setup delivers a robust, production-ready Building APIs with Spring for GraphQL solution in Spring Boot, combining best practices, clear structure, and practical examples you can adapt to your own project.</p>]]></content:encoded>
      <category><![CDATA[Java]]></category>
      <category><![CDATA[Kotlin]]></category>
      <category><![CDATA[GraphQL]]></category>
      <category><![CDATA[Spring Boot]]></category>
      <category><![CDATA[Programming]]></category>
      <media:thumbnail url="https://suaybsimsek.com/images/spring-boot-graphql-thumbnail.webp" />
    </item>
    <item>
      <title><![CDATA[Gin - First Application]]></title>
      <link>https://suaybsimsek.com/en/posts/golang-gin-first-application</link>
      <description><![CDATA[A beginner-friendly guide to creating your first Golang Gin application from scratch. Learn the basics and start your journey with Gin.]]></description>
      <pubDate>Sat, 14 Dec 2024 00:00:00 GMT</pubDate>
      <guid isPermaLink="true">https://suaybsimsek.com/en/posts/golang-gin-first-application</guid>
      <content:encoded><![CDATA[<p>Gin simplifies the process of building high-performance web applications with Golang. In this guide, we‚Äôll walk through creating your first Gin application step by step.</p>
<hr />
<h2>üìã Prerequisites</h2>
<p>üìã Before starting, ensure you have the following:</p>
<ul>
<li>üîß Golang 1.17+ installed</li>
<li>üóç A text editor or IDE (e.g., Visual Studio Code, GoLand, or Vim)</li>
</ul>
<hr />
<h2>üõ†Ô∏è Step 1: Set Up Your Gin Project</h2>
<p>You can set up your first Gin project by following these steps:</p>
<p>1. Initialize a Go Module</p>
<pre><code class="language-bash">mkdir gin-first-app
cd gin-first-app
go mod init gin-first-app</code></pre>
<p>2. Install Gin</p>
<pre><code class="language-bash">go get -u github.com/gin-gonic/gin</code></pre>
<hr />
<h2>üõ†Ô∏è Step 2: Writing Your First Endpoint</h2>
<p>Let‚Äôs write a simple endpoint to say hello:</p>
<p>Create a file named `main.go` with the following content:</p>
<pre><code class="language-go">package main

import (
	&quot;github.com/gin-gonic/gin&quot;
)

func main() {
	r := gin.Default()

	r.GET(&quot;/hello&quot;, func(c *gin.Context) {
		c.JSON(200, gin.H{
			&quot;message&quot;: &quot;Hello, Gin!&quot;,
		})
	})

	r.Run() // Listen and serve on 0.0.0.0:8080
}</code></pre>
<hr />
<h2>‚ñ∂Ô∏è Step 3: Run the Application</h2>
<p>1. Open a terminal in the project folder. 2. Execute the following command to run your application:</p>
<pre><code class="language-bash">go run main.go</code></pre>
<p>3. Access the endpoint at: ``` http://localhost:8080/hello ```</p>
<p>Response:</p>
<pre><code class="language-json">{
  &quot;message&quot;: &quot;Hello, Gin!&quot;
}</code></pre>
<hr />
<h2>üèÅ Conclusion</h2>
<p>This setup delivers a robust, production-ready guide to Gin - First Application, combining best practices, clear structure, and practical examples you can adapt to your own project.</p>]]></content:encoded>
      <category><![CDATA[Go]]></category>
      <category><![CDATA[Gin]]></category>
      <category><![CDATA[Beginner Guide]]></category>
      <category><![CDATA[Programming]]></category>
      <media:thumbnail url="https://suaybsimsek.com/images/golang-gin-first-app-thumbnail.webp" />
    </item>
    <item>
      <title><![CDATA[Building a REST API with Spring Boot]]></title>
      <link>https://suaybsimsek.com/en/posts/building-a-rest-api-with-spring-boot</link>
      <description><![CDATA[Learn how to create a REST API using Spring Boot. Includes HTTP methods, JSON handling, Lombok integration, and curl for testing.]]></description>
      <pubDate>Wed, 11 Dec 2024 00:00:00 GMT</pubDate>
      <guid isPermaLink="true">https://suaybsimsek.com/en/posts/building-a-rest-api-with-spring-boot</guid>
      <content:encoded><![CDATA[<p>Spring Boot is an excellent tool for quickly developing RESTful web services. In this article, we‚Äôll walk through creating a REST API step by step using Spring Boot.</p>
<hr />
<h2>üåü What is a REST API?</h2>
<p>REST (Representational State Transfer) is an architectural style for designing web services. It uses standard HTTP methods for communication between clients and servers.</p>
<h3>HTTP Methods</h3>
<p>| Method | Description                    | Example Endpoint | | ------ | ------------------------------ | ---------------- | | GET    | Retrieves a resource.          | `/api/todos`     | | POST   | Creates a new resource.        | `/api/todos`     | | PUT    | Updates or creates a resource. | `/api/todos/1`   | | DELETE | Deletes a resource.            | `/api/todos/1`   |</p>
<hr />
<h2>üõ†Ô∏è Step 1: Create a Project</h2>
<p>You can create a Spring Boot project using [Spring Initializr](https://start.spring.io/). Select the following settings:</p>
<ul>
<li>Project: Maven</li>
<li>Language: Java or Kotlin</li>
<li>Spring Boot Version: 3.0.0+</li>
<li>Dependencies: Spring Web, Spring Boot DevTools, Lombok</li>
</ul>
<p>Download the project, open it in your IDE, and get ready to run it.</p>
<hr />
<h2>üõ†Ô∏è Step 2: Create a Model Class</h2>
<p>Create a model class for a `Todo` object:</p>
<h3>Java</h3>
<pre><code class="language-java">package com.example.demo.model;

import lombok.Data;

@Data
public class Todo {
    private Long id;
    private String title;
    private boolean completed;
}</code></pre>
<h3>Kotlin</h3>
<pre><code class="language-kotlin">package com.example.demo.model

data class Todo(
    var id: Long,
    var title: String,
    var completed: Boolean
)</code></pre>
<hr />
<h2>üõ†Ô∏è Step 3: Create a Controller Class</h2>
<p>Add a `TodoController` class to define CRUD operations as REST endpoints:</p>
<h3>Java</h3>
<pre><code class="language-java">package com.example.demo.controller;

import com.example.demo.model.Todo;
import org.springframework.web.bind.annotation.*;

import java.util.ArrayList;
import java.util.List;

@RestController
@RequestMapping(&quot;/api/todos&quot;)
public class TodoController {

    private List&lt;Todo&gt; todos = new ArrayList&lt;&gt;();

    @GetMapping
    public List&lt;Todo&gt; getAllTodos() {
        return todos;
    }

    @PostMapping
    public Todo createTodo(@RequestBody Todo todo) {
        todo.setId((long) (todos.size() + 1));
        todos.add(todo);
        return todo;
    }

    @PutMapping(&quot;/{id}&quot;)
    public Todo updateTodo(@PathVariable Long id, @RequestBody Todo updatedTodo) {
        Todo todo = todos.stream().filter(t -&gt; t.getId().equals(id)).findFirst().orElse(null);
        if (todo != null) {
            todo.setTitle(updatedTodo.getTitle());
            todo.setCompleted(updatedTodo.isCompleted());
        }
        return todo;
    }

    @DeleteMapping(&quot;/{id}&quot;)
    public void deleteTodo(@PathVariable Long id) {
        todos.removeIf(todo -&gt; todo.getId().equals(id));
    }
}</code></pre>
<h3>Kotlin</h3>
<pre><code class="language-kotlin">package com.example.demo.controller

import com.example.demo.model.Todo
import org.springframework.web.bind.annotation.*

@RestController
@RequestMapping(&quot;/api/todos&quot;)
class TodoController {

    private val todos = mutableListOf&lt;Todo&gt;()

    @GetMapping
    fun getAllTodos(): List&lt;Todo&gt; = todos

    @PostMapping
    fun createTodo(@RequestBody todo: Todo): Todo {
        todo.id = (todos.size + 1).toLong()
        todos.add(todo)
        return todo
    }

    @PutMapping(&quot;/{id}&quot;)
    fun updateTodo(@PathVariable id: Long, @RequestBody updatedTodo: Todo): Todo? {
        val todo = todos.find { it.id == id }
        todo?.apply {
            title = updatedTodo.title
            completed = updatedTodo.completed
        }
        return todo
    }

    @DeleteMapping(&quot;/{id}&quot;)
    fun deleteTodo(@PathVariable id: Long) {
        todos.removeIf { it.id == id }
    }
}</code></pre>
<hr />
<h2>üß™ Step 4: Test the API</h2>
<p>Test your API using `curl` commands:</p>
<ul>
<li>GET All Todos:</li>
</ul>
<pre><code class="language-bash">curl -X GET http://localhost:8080/api/todos</code></pre>
<ul>
<li>POST New Todo:</li>
</ul>
<pre><code class="language-bash">curl -X POST http://localhost:8080/api/todos -H &quot;Content-Type: application/json&quot; -d &#39;{&quot;title&quot;: &quot;New Todo&quot;, &quot;completed&quot;: false}&#39;</code></pre>
<ul>
<li>PUT Update Todo:</li>
</ul>
<pre><code class="language-bash">curl -X PUT http://localhost:8080/api/todos/1 -H &quot;Content-Type: application/json&quot; -d &#39;{&quot;title&quot;: &quot;Updated Todo&quot;, &quot;completed&quot;: true}&#39;</code></pre>
<ul>
<li>DELETE Delete Todo:</li>
</ul>
<pre><code class="language-bash">curl -X DELETE http://localhost:8080/api/todos/1</code></pre>
<hr />
<h2>üèÅ Conclusion</h2>
<p>This setup delivers a robust, production-ready Building a REST API with Spring Boot solution in Spring Boot, combining best practices, clear structure, and practical examples you can adapt to your own project.</p>]]></content:encoded>
      <category><![CDATA[Java]]></category>
      <category><![CDATA[Kotlin]]></category>
      <category><![CDATA[Spring Boot]]></category>
      <category><![CDATA[REST API]]></category>
      <category><![CDATA[Programming]]></category>
      <media:thumbnail url="https://suaybsimsek.com/images/spring-boot-rest-api-thumbnail.webp" />
    </item>
    <item>
      <title><![CDATA[Spring Boot - First Application]]></title>
      <link>https://suaybsimsek.com/en/posts/spring-boot-first-application</link>
      <description><![CDATA[A beginner-friendly guide to creating your first Spring Boot application from scratch. Learn the basics and start your journey with Spring Boot.]]></description>
      <pubDate>Tue, 10 Dec 2024 00:00:00 GMT</pubDate>
      <guid isPermaLink="true">https://suaybsimsek.com/en/posts/spring-boot-first-application</guid>
      <content:encoded><![CDATA[<p>Spring Boot simplifies the process of building production-ready applications with the Spring Framework. In this guide, we‚Äôll walk through creating your first Spring Boot application step by step.</p>
<hr />
<h2>üìã Prerequisites</h2>
<p>üìã Before starting, ensure you have the following:</p>
<ul>
<li>‚òï Java Development Kit (JDK) 17+ installed</li>
<li>üì¶ Maven or Gradle installed</li>
<li>üñ•Ô∏è A Java IDE (e.g., IntelliJ IDEA, Eclipse, or Visual Studio Code)</li>
</ul>
<hr />
<h2>üõ†Ô∏è Step 1: Create a Spring Boot Project</h2>
<p>You can create your first Spring Boot project in two ways:</p>
<p>1. Using Spring Initializr üñ±Ô∏è</p>
<ul>
<li>Visit [Spring Initializr](https://start.spring.io/).</li>
<li>Configure the following:</li>
<li>üìÇ Project: `Maven`</li>
<li>üë®‚Äçüíª Language: `Java` or `Kotlin`</li>
<li>üîÑ Spring Boot Version: `3.0.0` (or the latest version).</li>
<li>üìú Add dependencies: `Spring Web`</li>
<li>Click Generate to download the project files.</li>
</ul>
<p>2. Using IntelliJ IDEA üíª</p>
<ul>
<li>Open IntelliJ IDEA.</li>
<li>Go to `New Project &gt; Spring Initializr`.</li>
<li>Configure similar parameters as mentioned above.</li>
</ul>
<hr />
<h2>üõ†Ô∏è Step 2: Writing Your First Endpoint</h2>
<p>Let‚Äôs write a simple endpoint to say hello:</p>
<h3>Java</h3>
<pre><code class="language-java">package com.example.demo;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RestController;

@SpringBootApplication
@RestController
public class DemoApplication {
    public static void main(String[] args) {
        SpringApplication.run(DemoApplication.class, args);
    }

    @GetMapping(&quot;/hello&quot;)
    public String sayHello() {
        return &quot;Hello, Spring Boot!&quot;;
    }
}</code></pre>
<h3>Kotlin</h3>
<pre><code class="language-kotlin">package com.example.demo

import org.springframework.boot.autoconfigure.SpringBootApplication
import org.springframework.boot.runApplication
import org.springframework.web.bind.annotation.GetMapping
import org.springframework.web.bind.annotation.RestController

@SpringBootApplication
@RestController
class DemoApplication

fun main(args: Array&lt;String&gt;) {
    runApplication&lt;DemoApplication&gt;(*args)
}

@GetMapping(&quot;/hello&quot;)
fun sayHello(): String {
    return &quot;Hello, Spring Boot!&quot;
}</code></pre>
<hr />
<h2>‚ñ∂Ô∏è Step 3: Run the Application</h2>
<p>1. Open a terminal in the project folder. 2. Execute the command to run your application:</p>
<pre><code class="language-bash">./mvnw spring-boot:run</code></pre>
<p>3. Access the endpoint at: ``` http://localhost:8080/hello ```</p>
<p>Response:</p>
<pre><code>Hello, Spring Boot!</code></pre>
<hr />
<h2>üèÅ Conclusion</h2>
<p>This setup delivers a robust, production-ready Spring Boot - First Application solution in Spring Boot, combining best practices, clear structure, and practical examples you can adapt to your own project.</p>]]></content:encoded>
      <category><![CDATA[Java]]></category>
      <category><![CDATA[Kotlin]]></category>
      <category><![CDATA[Spring Boot]]></category>
      <category><![CDATA[Beginner Guide]]></category>
      <category><![CDATA[Programming]]></category>
      <media:thumbnail url="https://suaybsimsek.com/images/spring-boot-first-app-thumbnail.webp" />
    </item>
  </channel>
</rss>
