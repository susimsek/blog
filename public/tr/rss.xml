<?xml version="1.0" encoding="UTF-8"?>
<?xml-stylesheet type="text/xsl" href="/rss.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:media="http://search.yahoo.com/mrss/" xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title><![CDATA[Åuayb'in Blogu]]></title>
    <link>https://suaybsimsek.com/tr</link>
    <description><![CDATA[En son makaleleri, eÄŸitimleri ve analizleri keÅŸfedin.]]></description>
    <docs>https://www.rssboard.org/rss-specification</docs>
    <generator><![CDATA[Åuayb's Blog RSS Generator]]></generator>
    <ttl>60</ttl>
    <pubDate>Fri, 27 Feb 2026 00:00:00 GMT</pubDate>
    <lastBuildDate>Sat, 28 Feb 2026 00:00:00 GMT</lastBuildDate>
    <atom:updated>2026-02-28T00:00:00.000Z</atom:updated>
    <language>tr-TR</language>
    <copyright><![CDATA[Â© 2026 Åuayb ÅimÅŸek. TÃ¼m haklarÄ± saklÄ±dÄ±r.]]></copyright>
    <image>
      <url>https://suaybsimsek.com/images/logo.webp</url>
      <title><![CDATA[Åuayb'in Blogu]]></title>
      <link>https://suaybsimsek.com/tr</link>
    </image>
    <atom:link rel="self" type="application/rss+xml" href="https://suaybsimsek.com/tr/rss.xml" />
    <atom:link rel="alternate" hreflang="en" type="application/rss+xml" href="https://suaybsimsek.com/en/rss.xml" />
    <item>
      <title><![CDATA[Captain Tsubasa 2: World Fighters]]></title>
      <link>https://suaybsimsek.com/tr/posts/captain-tsubasa-2-world-fighters</link>
      <description><![CDATA[Captain Tsubasa 2: World Fighters iÃ§in Bandai Namco resmi sayfasÄ± ve topluluk takibine dayalÄ± detaylÄ± bir inceleme: platformlar, oynanÄ±ÅŸ Ã¶lÃ§eÄŸi, bilinen bilgiler ve Ã§Ä±kÄ±ÅŸ Ã¶ncesi aÃ§Ä±k noktalar.]]></description>
      <pubDate>Fri, 27 Feb 2026 00:00:00 GMT</pubDate>
      <atom:updated>2026-02-28T00:00:00.000Z</atom:updated>
      <guid isPermaLink="true">https://suaybsimsek.com/tr/posts/captain-tsubasa-2-world-fighters</guid>
      <content:encoded><![CDATA[<p>Captain Tsubasa serisine yeni ve bÃ¼yÃ¼k Ã¶lÃ§ekli bir oyun geliyor; ilk resmi tanÄ±tÄ±m da beklentinin Ã¼zerinde bir kapsam hedeflendiÄŸini gÃ¶steriyor. <code>Captain Tsubasa 2: World Fighters</code>, gÃ¼Ã§lÃ¼ anime kimliÄŸi ve geniÅŸ oynanabilir kadrosuyla yÃ¼ksek tempolu bir arcade futbol deneyimi olarak sunuluyor.</p>
<p>Bu yazÄ±da, Bandai Namcoâ€™nun resmi sayfasÄ±ndaki doÄŸrulanmÄ±ÅŸ bilgileri erken dÃ¶nem varsayÄ±mlardan ayÄ±rÄ±yor; topluluk takibini ise ikincil bir referans olarak kullanarak Ã§Ä±kÄ±ÅŸ Ã¶ncesi netleÅŸmesi gereken noktalarÄ± Ã¶zetliyorum.</p>
<hr>
<h2>ğŸŒŸ Bu Duyuru Neden Ã–nemli?</h2>
<p>Bu duyuruyu Ã¶nemli kÄ±lan ÅŸey yalnÄ±zca bir devam oyunu olmasÄ± deÄŸil; resmi tanÄ±tÄ±mÄ±n daha geniÅŸ platform daÄŸÄ±lÄ±mÄ±, daha bÃ¼yÃ¼k karakter havuzu ve daha sinematik bir maÃ§ sunumu hedeflediÄŸini gÃ¶stermesi.</p>
<ul>
<li>Resmi sayfada <code>2026</code> Ã§Ä±kÄ±ÅŸ penceresi yer alÄ±yor</li>
<li>Konsol + PC (<code>Steam</code>) platform daÄŸÄ±lÄ±mÄ± var</li>
<li>TanÄ±tÄ±m dili Ã¶lÃ§eÄŸi vurguluyor: takÄ±m sayÄ±sÄ±, karakter sayÄ±sÄ±, sinematik sahneler</li>
<li>OynanÄ±ÅŸ aÃ§Ä±klamalarÄ± sadece kadro gÃ¼ncellemesi deÄŸil, sistemsel geliÅŸtirme de iÅŸaret ediyor</li>
</ul>
<hr>
<h2>ğŸ“‹ Gereksinimler</h2>
<p>Bu inceleme, <code>Captain Tsubasa</code> evrenine aÅŸina olup ÅŸu an hangi bilgilerin gerÃ§ekten doÄŸrulandÄ±ÄŸÄ±nÄ± hÄ±zlÄ± ve net biÃ§imde gÃ¶rmek isteyen okurlar iÃ§in hazÄ±rlandÄ±.</p>
<ul>
<li>Anime futbol / arcade spor oyunu yapÄ±sÄ±na temel aÅŸinalÄ±k</li>
<li>Ã‡Ä±kÄ±ÅŸ platformu planlamasÄ± ilgisi (<code>PS5</code>, <code>Xbox Series X|S</code>, <code>Switch</code>, <code>PC</code>)</li>
<li>Erken duyuru sayfalarÄ±nÄ±n zaman iÃ§inde gÃ¼ncellenebileceÄŸi beklentisi</li>
</ul>
<hr>
<h2>ğŸ› ï¸ Resmi Bilgiler</h2>
<p>Temel bilgiler iÃ§in baÅŸlangÄ±Ã§ noktasÄ± Bandai Namcoâ€™nun resmi oyun sayfasÄ± olmalÄ±. Ã‡Ä±kÄ±ÅŸ penceresi, platformlar ve yayÄ±mlayÄ±cÄ± tarafÄ±ndaki metadata iÃ§in bu aÅŸamada en gÃ¼venilir kaynak burasÄ±.</p>
<p>Kaynaklar:</p>
<ul>
<li><a href="https://www.bandainamcoent.com/games/captain-tsubasa-2-world-fighters">Bandai Namco - CAPTAIN TSUBASA 2: WORLD FIGHTERS</a></li>
<li><a href="https://captaintsubasa.fandom.com/wiki/Captain_Tsubasa_2:_World_Fighters">Captain Tsubasa Fandom Wiki sayfasÄ±</a></li>
<li><a href="https://youtu.be/oXf50MRXfM8">Duyuru FragmanÄ± (YouTube)</a></li>
</ul>
<p>Resmi sayfada gÃ¶rÃ¼nen doÄŸrulanmÄ±ÅŸ bilgiler:</p>
<ul>
<li>Oyun adÄ±: <code>CAPTAIN TSUBASA 2: WORLD FIGHTERS</code></li>
<li>Ã‡Ä±kÄ±ÅŸ penceresi: <code>2026</code></li>
<li>GeliÅŸtirici: <code>Tamsoft Corporation</code></li>
<li>TÃ¼r etiketi: <code>Sport (Arcade)</code></li>
<li>Ã–zellik etiketi: <code>Single-player</code></li>
<li>Platformlar: <code>PlayStation 5</code>, <code>Xbox Series X|S</code>, <code>Steam</code>, <code>Nintendo Switch</code></li>
</ul>
<p>AynÄ± sayfa ayrÄ±ca wishlist/maÄŸaza yÃ¶nlendirmeleri, medya iÃ§erikleri ve <code>5 Åubat 2026</code> tarihli duyuru haber kartÄ±nÄ± da iÃ§eriyor.</p>
<hr>
<h2>ğŸ› ï¸ OynanÄ±ÅŸ Vaatleri</h2>
<p>DetaylÄ± oynanÄ±ÅŸ analizi henÃ¼z yayÄ±nlanmamÄ±ÅŸ olsa da resmi sayfadaki metinler oyunun nasÄ±l bir deneyim hedeflediÄŸini anlamak iÃ§in yeterli ipucu veriyor.</p>
<p>Resmi genel bakÄ±ÅŸ bÃ¶lÃ¼mÃ¼nde Ã¶ne Ã§Ä±kanlar:</p>
<ul>
<li><code>22 milli takÄ±m</code></li>
<li><code>110+ oynanabilir karakter</code></li>
<li>SÃ¼per insan hareketlerle akÄ±ÅŸÄ± sÃ¼rekli deÄŸiÅŸen â€œsuper action soccerâ€ yapÄ±sÄ±</li>
</ul>
<p>Ã–zellik bÃ¶lÃ¼mÃ¼nde ek olarak:</p>
<ul>
<li>Saha iÃ§i hareketleri Ã¶ne Ã§Ä±karan <code>150+</code> kesit/sahne</li>
<li>Pas, dripling, mÃ¼dahale ve blok aksiyonlarÄ±nda yeni sÃ¼per hareketler</li>
<li>SÃ¼per ÅŸutlar ve bloklar iÃ§in kaleci-vuruÅŸÃ§u karÅŸÄ±laÅŸmasÄ±nÄ± Ã¶ne Ã§Ä±karan yeni sistem</li>
</ul>
<p>Bu tablo, oyunun anime gÃ¶steriÅŸini korurken Ã¶zellikle ÅŸut-kurtarÄ±ÅŸ anlarÄ±nÄ± daha yapÄ±landÄ±rÄ±lmÄ±ÅŸ ve taktik hissi veren bir dÃ¼zene taÅŸÄ±mayÄ± hedeflediÄŸini dÃ¼ÅŸÃ¼ndÃ¼rÃ¼yor.</p>
<hr>
<h2>ğŸ› ï¸ Topluluk KaynaklarÄ±</h2>
<p>Fandom sayfasÄ± hÄ±zlÄ± gÃ¼ncellenen iyi bir takip noktasÄ±, ancak resmi aÃ§Ä±klamalar gelmeden satÄ±n alma veya Ã§Ä±kÄ±ÅŸ planÄ± iÃ§in tek baÅŸÄ±na yeterli kaynak olarak gÃ¶rÃ¼lmemeli.</p>
<p><code>26 Åubat 2026</code> itibarÄ±yla Fandom sayfasÄ± gÃ¼ncellemeleri takip etmek iÃ§in faydalÄ± olsa da bazÄ± alanlar hÃ¢lÃ¢ geliÅŸim aÅŸamasÄ±nda gÃ¶rÃ¼nÃ¼yor:</p>
<ul>
<li>HikÃ¢ye bÃ¶lÃ¼mlerinin bazÄ± kÄ±sÄ±mlarÄ± hÃ¢lÃ¢ tamamlanma aÅŸamasÄ±nda</li>
<li>TakÄ±m listeleri mevcut olsa da kapsam zamanla geniÅŸleyebilir</li>
<li>Galeri/medya ve metadata alanlarÄ± yeni fragmanlarla hÄ±zlÄ± gÃ¼ncellenebilir</li>
</ul>
<p>Yeni duyurulan oyunlar iÃ§in bu durum normaldir. DoÄŸru yaklaÅŸÄ±m, topluluk sayfasÄ±nÄ± deÄŸiÅŸimleri takip etmek iÃ§in kullanÄ±rken kritik bilgileri resmi kaynaklarla yeniden doÄŸrulamaktÄ±r.</p>
<hr>
<h2>ğŸ§ª Kritik Belirsizlikler</h2>
<p>Duyuru sayfalarÄ± Ã¶nce pazarlama Ã§erÃ§evesini netleÅŸtirir; satÄ±n alma kararÄ±nÄ± etkileyen detaylar ise Ã§oÄŸu zaman daha sonra gelir. Bu nedenle aÅŸaÄŸÄ±daki baÅŸlÄ±klarÄ± takip etmek Ã¶nemli:</p>
<ul>
<li>Net Ã§Ä±kÄ±ÅŸ tarihi (resmi sayfada ÅŸu an sadece <code>2026</code> var)</li>
<li>Tam mod listesi (<code>single-player</code> etiketi var, Ã§evrimiÃ§i/yerel modlar aÃ§Ä±kÃ§a doÄŸrulanmalÄ±)</li>
<li>Platform bazlÄ± fiyat ve sÃ¼rÃ¼m detaylarÄ±</li>
<li><code>Switch</code> ile <code>PS5/Xbox Series X|S/PC</code> arasÄ±nda performans hedefleri</li>
<li>Mikro Ã¶deme/maÄŸaza yapÄ±sÄ± (resmi sayfada ESRB tarafÄ±nda <code>In-Game Purchases</code> ibaresi gÃ¶rÃ¼nÃ¼yor)</li>
<li>BÃ¶lgesel Ã§Ä±kÄ±ÅŸ ve dil desteÄŸi detaylarÄ±</li>
</ul>
<p>Resmi sayfa ayrÄ±ca ABD derecelendirme baÄŸlamÄ± iÃ§in <code>Mild Violence</code> ve <code>Mild Language</code> gibi ESRB tanÄ±mlarÄ±nÄ± da gÃ¶steriyor.</p>
<hr>
<h2>â–¶ï¸ GÃ¼ncellemeleri Takip Et</h2>
<p>Her gÃ¼ncellemenin peÅŸinden koÅŸmadan saÄŸlÄ±klÄ± takip yapmak iÃ§in ÅŸu sÄ±ra en verimli akÄ±ÅŸÄ± saÄŸlar:</p>
<ol>
<li>Resmi Bandai Namco oyun sayfasÄ± (Ã§Ä±kÄ±ÅŸ tarihi/platform metadata deÄŸiÅŸimleri)</li>
<li>Resmi fragmanlar ve medya galerisi</li>
<li>Fandom/topluluk sayfasÄ± (kadro, takÄ±m, hikÃ¢ye derleme takibi)</li>
<li>MaÄŸaza sayfalarÄ± (<code>Steam</code> ve konsol maÄŸazalarÄ±) fiyat/sÃ¼rÃ¼m/sistem bilgileri</li>
</ol>
<p>Ã‡Ä±kÄ±ÅŸta satÄ±n almayÄ± dÃ¼ÅŸÃ¼nÃ¼yorsan oyunu tercih ettiÄŸin platformda wishlistâ€™e ekle ve her yeni fragman/duyuru sonrasÄ±nda resmi sayfayÄ± yeniden kontrol et.</p>
<hr>
<h2>ğŸ¬ Medya</h2>
<p>Bu medya bÃ¶lÃ¼mÃ¼nÃ¼ iki parÃ§aya ayÄ±rdÄ±m: Ã¶nce resmi fragmanÄ± hÄ±zlÄ±ca izleyebilir, ardÄ±ndan galeri gÃ¶rselleriyle oyunun gÃ¶rsel tonuna bakabilirsiniz.</p>
<h3>Fragman</h3>

  <a href="https://youtu.be/oXf50MRXfM8" target="_blank" rel="noopener noreferrer">
    <img src="/images/posts/captain-tsubasa-2-world-fighters/announcement-trailer.webp" alt="Captain Tsubasa 2 World Fighters duyuru fragmanÄ± gÃ¶rseli" width="1200" height="675">
  </a>
  
    Duyuru FragmanÄ±
    <br>
    <a class="" href="https://youtu.be/oXf50MRXfM8" target="_blank" rel="noopener noreferrer">YouTube'da izle</a>
  

<h3>Galeri</h3>
<p>Bu galeride oyunun gÃ¶rsel tarzÄ±nÄ±, karakter sunumunu ve maÃ§ iÃ§i efektlerini Ã§Ä±kÄ±ÅŸ Ã¶ncesinde hÄ±zlÄ±ca inceleyebilir; tanÄ±tÄ±mÄ±n genel tonunu daha net hissedebilirsiniz.</p>
<p>Kaynak galeri: <a href="https://captaintsubasa.fandom.com/wiki/Captain_Tsubasa_2:_World_Fighters">Captain Tsubasa Fandom Wiki sayfasÄ±</a></p>
<div class="post-media-grid">
  
    <img src="/images/posts/captain-tsubasa-2-world-fighters/gallery-cover.webp" alt="Captain Tsubasa 2 World Fighters kapak gÃ¶rseli" width="1200" height="630">
    Kapak gÃ¶rseli
  
  
    <img src="/images/posts/captain-tsubasa-2-world-fighters/gallery-flying-drive-shot.webp" alt="Tsubasa Flying Drive Shot ekran gÃ¶rÃ¼ntÃ¼sÃ¼" width="1200" height="630">
    Flying Drive Shot sahnesi
  
  
    <img src="/images/posts/captain-tsubasa-2-world-fighters/gallery-wakabayashi.webp" alt="Wakabayashi Genzo karakter gÃ¶rseli" width="1200" height="630">
    Wakabayashi Genzo karakter gÃ¶rseli
  
  
    <img src="/images/posts/captain-tsubasa-2-world-fighters/gallery-jito-hiroshi.webp" alt="Jito Hiroshi karakter gÃ¶rseli" width="1200" height="630">
    Jito Hiroshi karakter gÃ¶rseli
  
  
    <img src="/images/posts/captain-tsubasa-2-world-fighters/gallery-hayabusa-volley.webp" alt="Hayabusa Volley ekran gÃ¶rÃ¼ntÃ¼sÃ¼" width="1200" height="630">
    Hayabusa Volley sahnesi
  
  
    <img src="/images/posts/captain-tsubasa-2-world-fighters/gallery-neo-tiger-shot.webp" alt="Neo Tiger Shot ekran gÃ¶rÃ¼ntÃ¼sÃ¼" width="1200" height="630">
    Neo Tiger Shot sahnesi
  
  
    <img src="/images/posts/captain-tsubasa-2-world-fighters/gallery-tsubasa-ozora.webp" alt="Tsubasa Ozora karakter gÃ¶rseli" width="1200" height="630">
    Tsubasa Ozora karakter gÃ¶rseli
  
  
    <img src="/images/posts/captain-tsubasa-2-world-fighters/gallery-misugi-jun.webp" alt="Misugi Jun karakter gÃ¶rseli" width="1200" height="630">
    Misugi Jun karakter gÃ¶rseli
  
  
    <img src="/images/posts/captain-tsubasa-2-world-fighters/gallery-heel-lift-vs-santana.webp" alt="Heel Lift ve Santana sahnesi ekran gÃ¶rÃ¼ntÃ¼sÃ¼" width="1200" height="630">
    Heel Lift karÅŸÄ±laÅŸma sahnesi
  
  
    <img src="/images/posts/captain-tsubasa-2-world-fighters/gallery-drive-shot.webp" alt="Drive Shot ekran gÃ¶rÃ¼ntÃ¼sÃ¼" width="1200" height="630">
    Drive Shot sahnesi
  
</div>
<hr>
<h2>ğŸ SonuÃ§</h2>
<p>Mevcut tanÄ±tÄ±m materyallerine gÃ¶re <code>Captain Tsubasa 2: World Fighters</code>, geniÅŸ platform desteÄŸi, bÃ¼yÃ¼k karakter havuzu ve daha sinematik arcade futbol odaÄŸÄ±yla serinin Ã¶lÃ§eÄŸini belirgin biÃ§imde bÃ¼yÃ¼tmeyi hedefliyor. En doÄŸru sonraki adÄ±m, resmi Bandai Namco sayfasÄ±nÄ± takip ederek net Ã§Ä±kÄ±ÅŸ tarihi ve tam mod listesini doÄŸrulayÄ±p platform kararÄ±nÄ± buna gÃ¶re vermek olacaktÄ±r.</p>]]></content:encoded>
      <category><![CDATA[Captain Tsubasa]]></category>
      <category><![CDATA[Anime Oyunu]]></category>
      <category><![CDATA[Spor Oyunu]]></category>
      <media:thumbnail url="https://suaybsimsek.com/images/captain-tsubasa-2-world-fighters-thumbnail.webp" />
    </item>
    <item>
      <title><![CDATA[Captain Tsubasa: Rise of New Champions]]></title>
      <link>https://suaybsimsek.com/tr/posts/captain-tsubasa-rise-of-new-champions</link>
      <description><![CDATA[World Fighters gelmeden Ã¶nce Rise of New Champions, Captain Tsubasaâ€™nÄ±n modern konsol kimliÄŸini en net gÃ¶steren oyun olarak Ã¶ne Ã§Ä±kÄ±yor: hÄ±zlÄ±, gÃ¶steriÅŸli ve bÃ¼tÃ¼nÃ¼yle anime futbolu ruhuna yaslanan bir yapÄ±m.]]></description>
      <pubDate>Thu, 26 Feb 2026 00:00:00 GMT</pubDate>
      <atom:updated>2026-02-27T00:00:00.000Z</atom:updated>
      <guid isPermaLink="true">https://suaybsimsek.com/tr/posts/captain-tsubasa-rise-of-new-champions</guid>
      <content:encoded><![CDATA[<p><code>Captain Tsubasa 2: World Fighters</code> Ã§Ä±kmadan Ã¶nce, <code>Captain Tsubasa: Rise of New Champions</code> hÃ¢lÃ¢ modern Captain Tsubasa konsol oyununun temel referans noktasÄ± olarak duruyor. Bandai Namco ve Tamsoftâ€™un seriyi hÄ±zlÄ±, gÃ¶steriÅŸli ve anime aÄŸÄ±rlÄ±klÄ± bir arcade futbol yapÄ±sÄ±na nasÄ±l taÅŸÄ±dÄ±ÄŸÄ±nÄ± en net gÃ¶steren yapÄ±m bu oyun oldu.</p>
<p>Bu yazÄ±da oyuna bugÃ¼nden bakÄ±yorum: Ã§Ä±kÄ±ÅŸ dÃ¶neminde resmi olarak neler doÄŸrulandÄ±, sÃ¼rÃ¼m ve DLC yapÄ±sÄ± ne anlatÄ±yor, bugÃ¼n seriye geri dÃ¶nen biri iÃ§in oyun neden hÃ¢lÃ¢ Ã¶nemli.</p>
<hr>
<h2>ğŸŒŸ Bu Oyun HÃ¢lÃ¢ Neden Ã–nemli?</h2>
<p><code>Rise of New Champions</code>, yaklaÅŸÄ±k on yÄ±llÄ±k aranÄ±n ardÄ±ndan gelen yeni Captain Tsubasa konsol oyunu olarak konumlandÄ±rÄ±ldÄ± ve bu baÄŸlam bugÃ¼n de Ã¶nemini koruyor. Ã‡Ã¼nkÃ¼ serinin daha sonra nereye gideceÄŸine dair temel ÅŸablonu bu oyun kurdu: animeye sadÄ±k sunum, abartÄ±lÄ± sÃ¼per hareketler ve simÃ¼lasyondan Ã§ok arcade tempoya yaslanan maÃ§ akÄ±ÅŸÄ±.</p>
<ul>
<li>Bandai Namco Europe sayfasÄ±nda resmi Ã§Ä±kÄ±ÅŸ tarihi <code>28 AÄŸustos 2020</code> olarak yer alÄ±yor</li>
<li>Resmi sayfa geliÅŸtiriciyi <code>TAMSOFT</code>, tÃ¼rÃ¼ ise <code>Arcade</code> olarak listeliyor</li>
<li>Platform listesi <code>PlayStation 4</code>, <code>Nintendo Switch</code> ve <code>Steam</code></li>
<li>GÃ¼ncel resmi sayfa hÃ¢lÃ¢ geniÅŸ sÃ¼rÃ¼m ve DLC yapÄ±sÄ±nÄ± gÃ¶sterdiÄŸi iÃ§in, sonraki Captain Tsubasa oyunlarÄ±yla kÄ±yas yaparken gÃ¼Ã§lÃ¼ bir referans olmaya devam ediyor</li>
</ul>
<hr>
<h2>ğŸ“‹ Gereksinimler</h2>
<p>Bu inceleme, oyunu sadece nostaljiyle deÄŸil; bugÃ¼n gerÃ§ekten nasÄ±l deÄŸerlendirmek gerektiÄŸi aÃ§Ä±sÄ±ndan gÃ¶rmek isteyen okurlar iÃ§in hazÄ±rlandÄ±.</p>
<ul>
<li><code>Captain Tsubasa</code> anime/manga evrenine temel aÅŸinalÄ±k</li>
<li>GerÃ§ekÃ§i futbol simÃ¼lasyonu yerine anime tarzÄ± arcade futbol beklentisi</li>
<li>SÃ¼rÃ¼m/maÄŸaza detaylarÄ±nÄ± dikkatle kontrol etme isteÄŸi; Ã§Ã¼nkÃ¼ oyunun iÃ§erik yapÄ±sÄ± temel oyun paketinin Ã¶tesine uzanÄ±yor</li>
</ul>
<hr>
<h2>ğŸ› ï¸ Resmi Bilgiler</h2>
<p>Ã‡Ä±kÄ±ÅŸ tarihi, platform desteÄŸi ve Ã¼rÃ¼n Ã§erÃ§evesi iÃ§in ilk durak Bandai Namco Europe sayfasÄ± olmalÄ±. Temel metadata aÃ§Ä±sÄ±ndan en gÃ¼venilir birincil kaynak hÃ¢lÃ¢ burasÄ±.</p>
<p>Kaynaklar:</p>
<ul>
<li><a href="https://en.bandainamcoent.eu/captain-tsubasa/captain-tsubasa-rise-of-new-champions">Bandai Namco Europe - CAPTAIN TSUBASA: RISE OF NEW CHAMPIONS</a></li>
<li><a href="https://captaintsubasa.fandom.com/wiki/Captain_Tsubasa:_Rise_of_New_Champions">Captain Tsubasa Fandom Wiki sayfasÄ±</a></li>
<li><a href="https://captaintsubasa.fandom.com/wiki/Captain_Tsubasa:_Rise_of_New_Champions/Gallery#Art">Fandom Art galerisi</a></li>
<li><a href="https://captaintsubasa.fandom.com/wiki/Captain_Tsubasa:_Rise_of_New_Champions/Gallery#Japan">Fandom Japan galeri referansÄ±</a></li>
<li><a href="https://youtu.be/WHBQO6tH4Dk">Bandai sayfasÄ±ndaki resmi fragman (YouTube)</a></li>
</ul>
<p>Resmi sayfada doÄŸrulanan bilgiler:</p>
<ul>
<li>Oyun adÄ±: <code>CAPTAIN TSUBASA: RISE OF NEW CHAMPIONS</code></li>
<li>Ã‡Ä±kÄ±ÅŸ tarihi: <code>28/08/2020</code></li>
<li>GeliÅŸtirici: <code>TAMSOFT</code></li>
<li>TÃ¼r: <code>Arcade</code></li>
<li>Platformlar: <code>PlayStation 4</code>, <code>Nintendo Switch</code>, <code>Steam</code></li>
</ul>
<p>Resmi aÃ§Ä±klama ayrÄ±ca oyunu yaklaÅŸÄ±k on yÄ±llÄ±k aradan sonra gelen yeni Captain Tsubasa konsol yapÄ±mÄ± olarak konumlandÄ±rÄ±yor ve anime gÃ¶steriÅŸini gÃ¼ncel gÃ¶rsel sunumla birleÅŸtirmeyi vurguluyor.</p>
<hr>
<h2>ğŸ› ï¸ OynanÄ±ÅŸ YaklaÅŸÄ±mÄ±</h2>
<p>Resmi Ã¶zellik bÃ¶lÃ¼mÃ¼ oyunun yÃ¶nÃ¼nÃ¼ Ã§ok aÃ§Ä±k biÃ§imde tarif ediyor: bu bir futbol simÃ¼lasyonu deÄŸil, anime temposuna yaslanan bir aksiyon futbol oyunu.</p>
<p>Resmi sayfada Ã¶ne Ã§Ä±kan baÅŸlÄ±klar:</p>
<ul>
<li>Toon shading ile daha gerÃ§ekÃ§i efektleri birleÅŸtiren gÃ¶rsel stil</li>
<li>Karakterlere Ã¶zgÃ¼ stilleri Ã¶ne Ã§Ä±karan detaylÄ± sunum</li>
<li>YÃ¼ksek tempolu <code>arcade football action</code></li>
<li>Ã–zel hareketleri ve Ã¶ne Ã§Ä±kan anlarÄ± eriÅŸilebilir kÄ±lan basit kontrol yapÄ±sÄ±</li>
</ul>
<p>Bu Ã§erÃ§eve, oyunun gÃ¼cÃ¼nÃ¼ ve sÄ±nÄ±rÄ±nÄ± aynÄ± anda anlatÄ±yor. Daha taktik ve simÃ¼lasyon aÄŸÄ±rlÄ±klÄ± bir futbol deneyimi arÄ±yorsan bu doÄŸru baÅŸlangÄ±Ã§ noktasÄ± deÄŸil. Ama animeye yakÄ±n, hÄ±zlÄ±, sert ve gÃ¶steriÅŸli maÃ§ akÄ±ÅŸÄ± istiyorsan oyun tam olarak bunu hedefliyor.</p>
<hr>
<h2>ğŸ› ï¸ SÃ¼rÃ¼m ve DLC YapÄ±sÄ±</h2>
<p>Resmi sayfanÄ±n bugÃ¼n hÃ¢lÃ¢ en faydalÄ± taraflarÄ±ndan biri, oyunun Ã§Ä±kÄ±ÅŸ sonrasÄ± iÃ§erik yapÄ±sÄ±nÄ± gÃ¶rÃ¼nÃ¼r biÃ§imde korumasÄ±.</p>
<p>Sayfada gÃ¶rÃ¼nen sÃ¼rÃ¼m ve iÃ§erik baÅŸlÄ±klarÄ± arasÄ±nda ÅŸunlar var:</p>
<ul>
<li><code>Champions Edition</code></li>
<li><code>Collector's Edition</code></li>
<li><code>Deluxe Edition</code></li>
<li><code>Legends Edition</code></li>
<li><code>New Hero Edition</code></li>
<li><code>Character Pass: 9 DLC players</code></li>
<li><code>Season Pass Bonus: New Champions Uniform Set</code></li>
<li><code>Deluxe Edition Bonus: V Jump Collaboration Uniform Set</code></li>
</ul>
<p>Oyuncu aÃ§Ä±sÄ±ndan bu detaylar pazarlama sÃ¼sÃ¼ deÄŸil; bugÃ¼n oyunu satÄ±n alÄ±rken veya yeniden deÄŸerlendirirken hangi paketin ne sunduÄŸunu doÄŸrudan etkiliyor.</p>
<p>Resmi sayfa ayrÄ±ca <code>EPISODE: RISING STARS</code> gibi daha sonraki DLC/haber baÅŸlÄ±klarÄ±nÄ± da gÃ¶stermeye devam ediyor. Bu da oyunun destek sÃ¼recinin yalnÄ±zca ilk Ã§Ä±kÄ±ÅŸ dÃ¶nemiyle sÄ±nÄ±rlÄ± kalmadÄ±ÄŸÄ±nÄ± gÃ¶steriyor.</p>
<hr>
<h2>ğŸ› ï¸ Topluluk KaynaklarÄ±</h2>
<p>Fandom sayfasÄ± Ã¶zellikle kadro referanslarÄ±, hikÃ¢ye yapÄ±sÄ± Ã¶zetleri ve arÅŸivlenmiÅŸ tanÄ±tÄ±m gÃ¶rselleri iÃ§in hÃ¢lÃ¢ deÄŸerli. <code>Art</code> ve <code>Japan</code> galeri bÃ¶lÃ¼mleri de resmi medya bloklarÄ± zaman iÃ§inde deÄŸiÅŸse bile gÃ¶rsel referans toplamaya yardÄ±mcÄ± oluyor.</p>
<p>Åu amaÃ§larla kullanÄ±ÅŸlÄ±:</p>
<ul>
<li>Kadro ve takÄ±m referanslarÄ±nÄ± toplu gÃ¶rmek</li>
<li>HikÃ¢ye/karakter yapÄ±sÄ±nÄ± hÄ±zlÄ± taramak</li>
<li>ArÅŸivlenmiÅŸ galeri gÃ¶rselleri ve bÃ¶lgesel kapak referanslarÄ±na bakmak</li>
</ul>
<p>Åu konularda Ã¶nce resmi kaynaklara dÃ¶nmek gerekir:</p>
<ul>
<li>Ã‡Ä±kÄ±ÅŸ tarihi ve platform doÄŸrulamasÄ±</li>
<li>SÃ¼rÃ¼m/maÄŸaza metadataâ€™sÄ±</li>
<li>GÃ¼ncel DLC ve maÄŸaza yÃ¶nlendirmeleri</li>
</ul>
<p>DoÄŸru yaklaÅŸÄ±m basit: satÄ±n alma ve resmi Ã¼rÃ¼n bilgisi iÃ§in Bandai Namco; baÄŸlam ve arÅŸiv takibi iÃ§in topluluk kaynaklarÄ±.</p>
<hr>
<h2>â–¶ï¸ BugÃ¼n Neyi Kontrol Etmeli?</h2>
<p>Bu oyun 2020 Ã§Ä±kÄ±ÅŸlÄ± ve katmanlÄ± bir sÃ¼rÃ¼m yapÄ±sÄ±na sahip olduÄŸu iÃ§in, bugÃ¼n sorulmasÄ± gereken sorular Ã§Ä±kÄ±ÅŸ gÃ¼nÃ¼ndekilerden farklÄ±.</p>
<p>Ã–nce ÅŸu baÅŸlÄ±klarÄ± netleÅŸtir:</p>
<ol>
<li>BugÃ¼n senin platformunda gerÃ§ekten hangi sÃ¼rÃ¼m mevcut</li>
<li><code>Character Pass</code> ve sonraki DLC iÃ§erikleri pakete dahil mi, ayrÄ± mÄ±</li>
<li>Oyunu asÄ±l olarak arcade maÃ§ deneyimi, seri atmosferi ya da koleksiyon deÄŸeri iÃ§in mi istediÄŸin</li>
<li>Uzun vadede oynamak istediÄŸin platformun gerÃ§ekten <code>PS4</code>, <code>Switch</code> ya da <code>Steam</code> tarafÄ±nda hangisi olduÄŸu</li>
</ol>
<p>AmacÄ±n <code>World Fighters</code> Ã¶ncesi modern Captain Tsubasa oyun formÃ¼lÃ¼nÃ¼ anlamaksa bu oyun hÃ¢lÃ¢ gÃ¼Ã§lÃ¼ bir referans. Ama en dolu paketi almak istiyorsan maÄŸaza listelerini birbirinin aynÄ±sÄ± varsaymak doÄŸru yaklaÅŸÄ±m olmaz.</p>
<hr>
<h2>ğŸ¬ Medya</h2>
<p>Bu medya bÃ¶lÃ¼mÃ¼nde Ã¶nce resmi fragman var, ardÄ±ndan da statik export iÃ§inde stabil Ã§alÄ±ÅŸan resmi gÃ¶rsellerden oluÅŸturulmuÅŸ kÄ±sa bir galeri geliyor. Ek arÅŸiv gÃ¶rselleri ve Japan cover referansÄ± iÃ§in yukarÄ±daki Fandom galeri baÄŸlantÄ±larÄ± iyi yardÄ±mcÄ± kaynaklar olmaya devam ediyor.</p>
<h3>Fragman</h3>

  <a href="https://youtu.be/WHBQO6tH4Dk" target="_blank" rel="noopener noreferrer">
    <img src="/images/posts/captain-tsubasa-rise-of-new-champions/announcement-trailer.webp" alt="Captain Tsubasa Rise of New Champions fragman gÃ¶rseli" width="1200" height="675">
  </a>
  
    Resmi Fragman
    <br>
    <a class="" href="https://youtu.be/WHBQO6tH4Dk" target="_blank" rel="noopener noreferrer">YouTube'da izle</a>
  

<h3>Galeri</h3>
<p>Bu galeri oyunun gÃ¶rsel kimliÄŸini hÄ±zlÄ±ca okumaya yardÄ±mcÄ± oluyor: animeye sadÄ±k tanÄ±tÄ±m gÃ¶rselleri, maÃ§ sunumunu gÃ¶steren kareler ve Ã§Ä±kÄ±ÅŸ dÃ¶neminin sÃ¼rÃ¼m paketleri.</p>
<p>Ek referans baÄŸlantÄ±larÄ±:</p>
<ul>
<li><a href="https://captaintsubasa.fandom.com/wiki/Captain_Tsubasa:_Rise_of_New_Champions/Gallery#Art">Fandom Art galerisi</a></li>
<li><a href="https://captaintsubasa.fandom.com/wiki/Captain_Tsubasa:_Rise_of_New_Champions/Gallery#Japan">Fandom Japan cover referansÄ±</a></li>
</ul>
<div class="post-media-grid">
  
    <img src="/images/posts/captain-tsubasa-rise-of-new-champions/gallery-drive-shot.webp" alt="Captain Tsubasa Rise of New Champions Tsubasa&#x27;nÄ±n Drive Shot gÃ¶rseli" width="1200" height="630">
    Tsubasa'nÄ±n Drive Shot'Ä±
  
  
    <img src="/images/posts/captain-tsubasa-rise-of-new-champions/gallery-key-art.webp" alt="Captain Tsubasa Rise of New Champions Tsubasa&#x27;nÄ±n Neo Drive Shot gÃ¶rseli" width="1200" height="630">
    Tsubasa'nÄ±n Neo Drive Shot'Ä±
  
  
    <img src="/images/posts/captain-tsubasa-rise-of-new-champions/gallery-breakthrough.webp" alt="Captain Tsubasa Rise of New Champions Hyuga&#x27;nÄ±n Straight Line Dribble gÃ¶rseli" width="1200" height="630">
    Hyuga'nÄ±n Straight Line Dribble'Ä±
  
  
    <img src="/images/posts/captain-tsubasa-rise-of-new-champions/gallery-key-feature-1.webp" alt="Captain Tsubasa Rise of New Champions Hyuga&#x27;nÄ±n Neo Tiger Shot gÃ¶rseli" width="1200" height="630">
    Hyuga'nÄ±n Neo Tiger Shot'Ä±
  
  
    <img src="/images/posts/captain-tsubasa-rise-of-new-champions/gallery-key-feature-2.webp" alt="Captain Tsubasa Rise of New Champions Hyuga ve Tsubasa&#x27;nÄ±n Neo Drive Tiger Twin Shot gÃ¶rseli" width="1200" height="630">
    Hyuga ve Tsubasa'nÄ±n Neo Drive Tiger Twin Shot'Ä±
  
  
    <img src="/images/posts/captain-tsubasa-rise-of-new-champions/gallery-champions-edition.webp" alt="Captain Tsubasa Rise of New Champions Schneider&#x27;in Fire Shot gÃ¶rseli" width="1200" height="630">
    Schneider'in Fire Shot'Ä±
  
  
    <img src="/images/posts/captain-tsubasa-rise-of-new-champions/gallery-new-hero-edition.webp" alt="Captain Tsubasa Rise of New Champions Wakabayashi&#x27;nin kurtarÄ±ÅŸ gÃ¶rseli" width="1200" height="630">
    Wakabayashi'nin kurtarÄ±ÅŸÄ±
  
  
    <img src="/images/posts/captain-tsubasa-rise-of-new-champions/gallery-packshot.webp" alt="Captain Tsubasa Rise of New Champions Misugi&#x27;nin Slice Shot gÃ¶rseli" width="1200" height="630">
    Misugi'nin Slice Shot'Ä±
  
  
    <img src="/images/posts/captain-tsubasa-rise-of-new-champions/gallery-sky-rocket-volley.webp" alt="Captain Tsubasa Rise of New Champions Misugi&#x27;nin Crystal Overhead gÃ¶rseli" width="1200" height="630">
    Misugi'nin Crystal Overhead'i
  
  
    <img src="/images/posts/captain-tsubasa-rise-of-new-champions/gallery-carlos-turn.webp" alt="Captain Tsubasa Rise of New Champions Carlos Turn gÃ¶rseli" width="1200" height="630">
    Carlos Turn
  
</div>
<hr>
<h2>ğŸ SonuÃ§</h2>
<p><code>Captain Tsubasa: Rise of New Champions</code>, <code>World Fighters</code> Ã¶ncesi serinin modern konsol yÃ¶nÃ¼nÃ¼ anlamak iÃ§in hÃ¢lÃ¢ en net referans: hÄ±zlÄ± arcade tempo, animeye sadÄ±k gÃ¶steriÅŸ ve sÃ¼rÃ¼m/DLC aÄŸÄ±rlÄ±klÄ± bir Ã¼rÃ¼n yapÄ±sÄ±. BugÃ¼n seriye geri dÃ¶nÃ¼yorsan en akÄ±llÄ± yaklaÅŸÄ±m Ã¶nce sÃ¼rÃ¼m iÃ§eriklerini doÄŸrulamak, sonra bu oyunu oynanacak giriÅŸ noktasÄ± mÄ±, koleksiyon Ã¼rÃ¼nÃ¼ mÃ¼, yoksa bir karÅŸÄ±laÅŸtÄ±rma zemini mi olarak istediÄŸine karar vermek.</p>]]></content:encoded>
      <category><![CDATA[Captain Tsubasa]]></category>
      <category><![CDATA[Anime Oyunu]]></category>
      <category><![CDATA[Spor Oyunu]]></category>
      <media:thumbnail url="https://suaybsimsek.com/images/captain-tsubasa-rise-of-new-champions-thumbnail.webp" />
    </item>
    <item>
      <title><![CDATA[Spring Boot Configuration Properties]]></title>
      <link>https://suaybsimsek.com/tr/posts/spring-boot-configuration-properties</link>
      <description><![CDATA[@ConfigurationProperties ile tip-gÃ¼venli yapÄ±landÄ±rma tanÄ±mlamayÄ±, @Validated ile ayarlarÄ± doÄŸrulamayÄ± ve profile-specific application-{profile}.yml dosyalarÄ±yla ortama gÃ¶re deÄŸer yÃ¶netimini Ã¶ÄŸrenin.]]></description>
      <pubDate>Wed, 04 Feb 2026 00:00:00 GMT</pubDate>
      <atom:updated>2026-02-17T00:00:00.000Z</atom:updated>
      <guid isPermaLink="true">https://suaybsimsek.com/tr/posts/spring-boot-configuration-properties</guid>
      <content:encoded><![CDATA[<p>Ã‡ok sayÄ±da <code>@Value</code> ve daÄŸÄ±nÄ±k ayarlarla uÄŸraÅŸÄ±yorsan, <code>@ConfigurationProperties</code> Spring Bootâ€™ta yapÄ±landÄ±rmayÄ± tip-gÃ¼venli, dÃ¼zenli ve doÄŸrulanabilir hale getirmenin en iyi yoludur.</p>
<p>Bu yazÄ±da ÅŸunlarÄ± Ã¶ÄŸreneceksin:</p>
<ul>
<li>YapÄ±landÄ±rmayÄ± sÄ±nÄ±f olarak modelleme (Java/Kotlin)</li>
<li>Uygulama aÃ§Ä±lÄ±ÅŸÄ±nda ayar doÄŸrulama (fail fast)</li>
<li><code>application-{profile}.yml</code> ile ortama gÃ¶re override mantÄ±ÄŸÄ±</li>
</ul>
<hr>
<h2>ğŸŒŸ Neden <code>@ConfigurationProperties</code>?</h2>
<p>Bu bÃ¶lÃ¼mde Neden <code>@ConfigurationProperties</code>? konusunu netleÅŸtirip uygulamada kullanacaÄŸÄ±nÄ±z temel noktalarÄ± Ã¶zetliyoruz.</p>
<ul>
<li>âœ… Tip-gÃ¼venli config eriÅŸimi (IDE autocomplete, refactor dostu)</li>
<li>âœ… Ä°lgili ayarlarÄ± tek bir prefix altÄ±nda toplama</li>
<li>âœ… HatalÄ± configâ€™i erken yakalama (uygulama aÃ§Ä±lÄ±ÅŸÄ±nda)</li>
</ul>
<hr>
<h2>ğŸ“‹ Gereksinimler</h2>
<p>Bu bÃ¶lÃ¼mde Gereksinimler konusunu netleÅŸtirip uygulamada kullanacaÄŸÄ±nÄ±z temel noktalarÄ± Ã¶zetliyoruz.</p>
<ul>
<li>Java 17+</li>
<li>Spring Boot 3.x</li>
<li>Maven veya Gradle</li>
</ul>
<hr>
<h2>ğŸ› ï¸ AdÄ±m 1: <code>application.yml</code> iÃ§inde config tanÄ±mla</h2>
<p>Uygulamaya Ã¶zel bir prefix belirle (Ã¶r. <code>app</code>):</p>
<pre><code class="language-yaml">app:
  security:
    enabled: true
    token-expiry-seconds: 3600
  allowed-origins:
    - 'https://example.com'
    - 'http://localhost:3000'
</code></pre>
<hr>
<h2>ğŸ› ï¸ AdÄ±m 2: <code>@ConfigurationProperties</code> sÄ±nÄ±fÄ±nÄ± oluÅŸtur</h2>
<h3>Java</h3>
<pre><code class="language-java">import java.util.List;

import org.springframework.boot.context.properties.ConfigurationProperties;

@ConfigurationProperties(prefix = "app")
public class AppProperties {

  private Security security = new Security();
  private List&#x3C;String> allowedOrigins = List.of();

  public Security getSecurity() {
    return security;
  }

  public void setSecurity(Security security) {
    this.security = security;
  }

  public List&#x3C;String> getAllowedOrigins() {
    return allowedOrigins;
  }

  public void setAllowedOrigins(List&#x3C;String> allowedOrigins) {
    this.allowedOrigins = allowedOrigins;
  }

  public static class Security {
    private boolean enabled = true;
    private int tokenExpirySeconds = 3600;

    public boolean isEnabled() {
      return enabled;
    }

    public void setEnabled(boolean enabled) {
      this.enabled = enabled;
    }

    public int getTokenExpirySeconds() {
      return tokenExpirySeconds;
    }

    public void setTokenExpirySeconds(int tokenExpirySeconds) {
      this.tokenExpirySeconds = tokenExpirySeconds;
    }
  }
}
</code></pre>
<h3>Kotlin</h3>
<pre><code class="language-kotlin">import org.springframework.boot.context.properties.ConfigurationProperties

@ConfigurationProperties(prefix = "app")
data class AppProperties(
  val security: Security = Security(),
  val allowedOrigins: List&#x3C;String> = emptyList(),
) {
  data class Security(
    val enabled: Boolean = true,
    val tokenExpirySeconds: Int = 3600,
  )
}
</code></pre>
<hr>
<h2>ğŸ› ï¸ AdÄ±m 3: Properties sÄ±nÄ±flarÄ±nÄ± etkinleÅŸtir</h2>
<p>Ä°ki yaygÄ±n yÃ¶ntem var:</p>
<ol>
<li><code>@ConfigurationProperties</code> sÄ±nÄ±flarÄ±nÄ± tara:</li>
</ol>
<pre><code class="language-java">import org.springframework.boot.autoconfigure.SpringBootApplication;
import org.springframework.boot.context.properties.ConfigurationPropertiesScan;

@SpringBootApplication
@ConfigurationPropertiesScan
public class DemoApplication {}
</code></pre>
<ol start="2">
<li>Sadece belirli sÄ±nÄ±flarÄ± enable et:</li>
</ol>
<pre><code class="language-java">import org.springframework.boot.autoconfigure.SpringBootApplication;
import org.springframework.boot.context.properties.EnableConfigurationProperties;

@SpringBootApplication
@EnableConfigurationProperties(AppProperties.class)
public class DemoApplication {}
</code></pre>
<hr>
<h2>ğŸ§ª AdÄ±m 4: AÃ§Ä±lÄ±ÅŸta doÄŸrula (fail fast)</h2>
<p>Constraint ekleyip sÄ±nÄ±fÄ± <code>@Validated</code> ile iÅŸaretle.</p>
<h3>Java</h3>
<pre><code class="language-java">import java.util.List;

import jakarta.validation.Valid;
import jakarta.validation.constraints.Min;
import jakarta.validation.constraints.NotEmpty;

import org.springframework.boot.context.properties.ConfigurationProperties;
import org.springframework.validation.annotation.Validated;

@ConfigurationProperties(prefix = "app")
@Validated
public class AppProperties {

  @Valid
  private Security security = new Security();

  @NotEmpty
  private List&#x3C;String> allowedOrigins = List.of();

  public Security getSecurity() { return security; }
  public void setSecurity(Security security) { this.security = security; }

  public List&#x3C;String> getAllowedOrigins() { return allowedOrigins; }
  public void setAllowedOrigins(List&#x3C;String> allowedOrigins) { this.allowedOrigins = allowedOrigins; }

  public static class Security {
    private boolean enabled = true;

    @Min(60)
    private int tokenExpirySeconds = 3600;

    public boolean isEnabled() { return enabled; }
    public void setEnabled(boolean enabled) { this.enabled = enabled; }

    public int getTokenExpirySeconds() { return tokenExpirySeconds; }
    public void setTokenExpirySeconds(int tokenExpirySeconds) { this.tokenExpirySeconds = tokenExpirySeconds; }
  }
}
</code></pre>
<h3>Kotlin</h3>
<pre><code class="language-kotlin">import jakarta.validation.Valid
import jakarta.validation.constraints.Min
import jakarta.validation.constraints.NotEmpty
import org.springframework.boot.context.properties.ConfigurationProperties
import org.springframework.validation.annotation.Validated

@ConfigurationProperties(prefix = "app")
@Validated
data class AppProperties(
  @field:Valid
  val security: Security = Security(),

  @field:NotEmpty
  val allowedOrigins: List&#x3C;String> = emptyList(),
) {
  data class Security(
    val enabled: Boolean = true,

    @field:Min(60)
    val tokenExpirySeconds: Int = 3600,
  )
}
</code></pre>
<p>Not: Bu doÄŸrulamanÄ±n Ã§alÄ±ÅŸmasÄ± iÃ§in classpathâ€™te bir Bean Validation implementasyonu olmalÄ± (Ã¶rn. <code>spring-boot-starter-validation</code>).</p>
<hr>
<h2>ğŸ› ï¸ AdÄ±m 5: Profile-specific dosyalarÄ± kullan (<code>application-{profile}.yml</code>)</h2>
<p>Spring Boot Ã¶nce <code>application.yml</code>â€™Ä± okur, sonra aktif profileâ€™a gÃ¶re override dosyalarÄ±nÄ± uygular.</p>
<p>Ã–rnek:</p>
<ul>
<li><code>application.yml</code> (varsayÄ±lanlar)</li>
<li><code>application-prod.yml</code> (prod override)</li>
</ul>
<pre><code class="language-yaml"># application-prod.yml
app:
  security:
    enabled: true
  allowed-origins:
    - 'https://mycompany.com'
</code></pre>
<p>Birden fazla profile aktifse â€œson yazan kazanÄ±râ€ mantÄ±ÄŸÄ± geÃ§erlidir (son aktif profile, Ã¶nceki profillerin deÄŸerlerini override edebilir).</p>
<hr>
<h2>ğŸŒŸ Ä°puÃ§larÄ±</h2>
<p>Bu bÃ¶lÃ¼mde Ä°puÃ§larÄ± konusunu netleÅŸtirip uygulamada kullanacaÄŸÄ±nÄ±z temel noktalarÄ± Ã¶zetliyoruz.</p>
<ul>
<li>Non-trivial ayarlarda <code>@Value</code> yerine <code>@ConfigurationProperties</code> kullan.</li>
<li><code>security</code>, <code>mail</code>, <code>storage</code> gibi alanlara gÃ¶re ayrÄ± rootâ€™lar tanÄ±mla.</li>
<li>BoÅŸ olmamasÄ± gereken veya aralÄ±k kÄ±sÄ±tÄ± olan deÄŸerlerde doÄŸrulama constraintâ€™leri ekle.</li>
</ul>
<hr>
<h2>ğŸ SonuÃ§</h2>
<p>ArtÄ±k tip-gÃ¼venli, aÃ§Ä±lÄ±ÅŸta doÄŸrulanan ve profile gÃ¶re override edilebilen bir Spring Boot yapÄ±landÄ±rma katmanÄ±n var. Sonraki adÄ±mda ortam bazlÄ± gizli deÄŸerleri dÄ±ÅŸsallaÅŸtÄ±rÄ±p regresyonlarÄ± erken yakalamak iÃ§in yapÄ±landÄ±rma testleri ekleyin.</p>]]></content:encoded>
      <category><![CDATA[Java]]></category>
      <category><![CDATA[Kotlin]]></category>
      <category><![CDATA[Spring Boot]]></category>
      <category><![CDATA[YapÄ±landÄ±rma]]></category>
      <media:thumbnail url="https://suaybsimsek.com/images/spring-boot-configuration-properties-thumbnail.webp" />
    </item>
    <item>
      <title><![CDATA[Spring Boot GraphQL JWE Kimlik DoÄŸrulama]]></title>
      <link>https://suaybsimsek.com/tr/posts/spring-boot-graphql-jwe-authentication</link>
      <description><![CDATA[Stateless ÅŸifreli JWTâ€™ler (JWE) ile Spring Boot GraphQL APIâ€™lerinizi gÃ¼venli hale getirmeyi; kullanÄ±cÄ± kimliÄŸi ve rolleri JPA ile bir veritabanÄ±nda saklamayÄ± Ã¶ÄŸrenin.]]></description>
      <pubDate>Sat, 17 May 2025 00:00:00 GMT</pubDate>
      <atom:updated>2025-05-18T00:00:00.000Z</atom:updated>
      <guid isPermaLink="true">https://suaybsimsek.com/tr/posts/spring-boot-graphql-jwe-authentication</guid>
      <content:encoded><![CDATA[<p>Spring Boot GraphQL JWE Kimlik DoÄŸrulamasÄ±, GraphQLâ€™in esnekliÄŸini, stateless ÅŸifreli JWTâ€™leri (JWE) ve JPA'yÄ± birleÅŸtirerek gÃ¼venli ve Ã¶lÃ§eklendirilebilir bir API sunar.</p>
<hr>
<h2>ğŸŒŸ GraphQL + JWE Kimlik DoÄŸrulamasÄ± Neden KullanÄ±lmalÄ±?</h2>
<p>Bu bÃ¶lÃ¼mde GraphQL + JWE Kimlik DoÄŸrulamasÄ± Neden KullanÄ±lmalÄ±? konusunu netleÅŸtirip uygulamada kullanacaÄŸÄ±nÄ±z temel noktalarÄ± Ã¶zetliyoruz.</p>
<ul>
<li>Stateless GÃ¼venlik: Tokenlar kendi iÃ§inde tÃ¼m bilgiyi barÄ±ndÄ±rÄ±r ve sunucu tarafÄ±nda saklama gerektirmez.</li>
<li>GraphQL EsnekliÄŸi: Her query veya mutationu tutarlÄ± bir ÅŸekilde koruyun.</li>
<li>Veri Hassasiyeti: Ä°stemcilerin tam olarak istediÄŸi veriyi Ã§eker.</li>
<li>BÃ¼tÃ¼nlÃ¼k: Ä°mzalÄ± tokenlar, iÃ§eriÄŸin deÄŸiÅŸtirilmediÄŸini garanti eder.</li>
<li>Gizlilik: ÅifrelenmiÅŸ JWTâ€™ler hassas bilgileri dÄ±ÅŸarÄ±dan okunamaz halde tutar.</li>
<li>Standartlara DayalÄ±: JOSE, Spring Security ve GraphQLâ€™den yararlanÄ±n.</li>
<li>Ã–lÃ§eklenebilirlik: Session replikasyonu veya sticky session gerektirmeden yatay Ã¶lÃ§eklenebilir.</li>
</ul>
<hr>
<h2>ğŸ“‹ Gereksinimler</h2>
<p>Bu bÃ¶lÃ¼mde Gereksinimler konusunu netleÅŸtirip uygulamada kullanacaÄŸÄ±nÄ±z temel noktalarÄ± Ã¶zetliyoruz.</p>
<ul>
<li>â˜• JDK 17 veya Ã¼zeri</li>
<li>ğŸ“¦ Spring Boot 3.2+</li>
<li>ğŸ”¤ IDE (IntelliJ IDEA, Eclipse)</li>
<li>ğŸ›¢ï¸ PostgreSQL (veya geliÅŸtirme iÃ§in H2)</li>
</ul>
<hr>
<h2>ğŸ› ï¸ AdÄ±m 1: BaÄŸÄ±mlÄ±lÄ±klarÄ± Ekle</h2>
<p><code>pom.xml</code> veya <code>build.gradle</code> dosyanÄ±za ÅŸunlarÄ± ekleyin.</p>
<p>Maven:</p>
<pre><code class="language-xml">&#x3C;dependencies>
  &#x3C;dependency>
    &#x3C;groupId>org.springframework.boot&#x3C;/groupId>
    &#x3C;artifactId>spring-boot-starter-web&#x3C;/artifactId>
  &#x3C;/dependency>
  &#x3C;dependency>
    &#x3C;groupId>org.springframework.boot&#x3C;/groupId>
    &#x3C;artifactId>spring-boot-starter-websocket&#x3C;/artifactId>
  &#x3C;/dependency>
  &#x3C;dependency>
    &#x3C;groupId>org.springframework.security&#x3C;/groupId>
    &#x3C;artifactId>spring-security-oauth2-resource-server&#x3C;/artifactId>
  &#x3C;/dependency>
  &#x3C;dependency>
    &#x3C;groupId>org.springframework.boot&#x3C;/groupId>
    &#x3C;artifactId>spring-boot-starter-data-jpa&#x3C;/artifactId>
  &#x3C;/dependency>
  &#x3C;dependency>
    &#x3C;groupId>org.springframework.boot&#x3C;/groupId>
    &#x3C;artifactId>spring-boot-starter-graphql&#x3C;/artifactId>
  &#x3C;/dependency>
  &#x3C;dependency>
    &#x3C;groupId>com.graphql-java&#x3C;/groupId>
    &#x3C;artifactId>graphql-java-extended-scalars&#x3C;/artifactId>
    &#x3C;version>22.0&#x3C;/version>
  &#x3C;/dependency>
  &#x3C;dependency>
    &#x3C;groupId>org.liquibase&#x3C;/groupId>
    &#x3C;artifactId>liquibase-core&#x3C;/artifactId>
  &#x3C;/dependency>
  &#x3C;dependency>
    &#x3C;groupId>org.projectlombok&#x3C;/groupId>
    &#x3C;artifactId>lombok&#x3C;/artifactId>
    &#x3C;optional>true&#x3C;/optional>
  &#x3C;/dependency>
  &#x3C;dependency>
    &#x3C;groupId>com.h2database&#x3C;/groupId>
    &#x3C;artifactId>h2&#x3C;/artifactId>
    &#x3C;scope>runtime&#x3C;/scope>
  &#x3C;/dependency>
&#x3C;/dependencies>

&#x3C;build>
&#x3C;plugins>
  &#x3C;plugin>
    &#x3C;groupId>org.hibernate.orm.tooling&#x3C;/groupId>
    &#x3C;artifactId>hibernate-enhance-maven-plugin&#x3C;/artifactId>
    &#x3C;version>${hibernate.version}&#x3C;/version>
    &#x3C;executions>
      &#x3C;execution>
        &#x3C;id>enhance&#x3C;/id>
        &#x3C;goals>
          &#x3C;goal>enhance&#x3C;/goal>
        &#x3C;/goals>
        &#x3C;configuration>
          &#x3C;enableLazyInitialization>true&#x3C;/enableLazyInitialization>
          &#x3C;enableDirtyTracking>true&#x3C;/enableDirtyTracking>
          &#x3C;enableAssociationManagement>true&#x3C;/enableAssociationManagement>
        &#x3C;/configuration>
      &#x3C;/execution>
    &#x3C;/executions>
  &#x3C;/plugin>
  &#x3C;plugin>
    &#x3C;groupId>org.graalvm.buildtools&#x3C;/groupId>
    &#x3C;artifactId>native-maven-plugin&#x3C;/artifactId>
  &#x3C;/plugin>
&#x3C;/plugins>
&#x3C;/build>
</code></pre>
<p>Gradle:</p>
<pre><code class="language-groovy">dependencies {
  implementation 'org.springframework.boot:spring-boot-starter-web'
  implementation 'org.springframework.boot:spring-boot-starter-websocket'
  implementation 'org.springframework.security:spring-security-oauth2-resource-server'
  implementation 'org.springframework.boot:spring-boot-starter-data-jpa'
  implementation 'org.springframework.boot:spring-boot-starter-graphql'
  implementation 'com.graphql-java:graphql-java-extended-scalars:22.0'
  implementation 'org.liquibase:liquibase-core'
  compileOnly 'org.projectlombok:lombok'
  runtimeOnly 'com.h2database:h2'
}

plugins {
  id 'org.hibernate.orm' version '6.6.13.Final'
  id 'org.graalvm.buildtools.native' version '0.10.6'
}

hibernate {
  enhancement {
    enableAssociationManagement = true
  }
}
</code></pre>
<hr>
<h2>ğŸ› ï¸ AdÄ±m 2: YapÄ±landÄ±rma DosyalarÄ±</h2>
<p>Bu bÃ¶lÃ¼mde, Spring Boot uygulamamÄ±zÄ± H2/PostgreSQL, JPA, Liquibase changelogâ€™larÄ±, veri yÃ¼klemeleri, JWE anahtar Ã¶zellikleri, GraphQL ÅŸema tanÄ±mlarÄ± ve GraalVM native-image reflection tanÄ±mlarÄ± ile yapÄ±landÄ±rmak iÃ§in gereken tÃ¼m uygulama ve veritabanÄ± dÃ¼zeyindeki yapÄ±landÄ±rma dosyalarÄ±nÄ± tanÄ±mlÄ±yoruz.</p>
<ul>
<li>
<p><code>application.yml</code>
Spring datasource, H2 konsolu, JPA/Hibernate, Liquibase changelog pathâ€™i, GraphQL subscriptions pathi ve tÃ¼m JWT/JWE anahtarlarÄ±, issuer ve geÃ§erlilik sÃ¼resi (expiration) ayarlarÄ±nÄ± iÃ§erir.</p>
</li>
<li>
<p><code>liquibase/master.xml</code>
Liquibase master changelog dosyasÄ±; H2 ve PostgreSQL iÃ§in DBMS Ã¶zel Ã¶zellikler ve alt changelog tanÄ±mlarÄ±nÄ± barÄ±ndÄ±rÄ±r.</p>
</li>
<li>
<p><code>liquibase/changelog/changelog-user.xml</code>
<code>user_identity</code>, <code>authority</code> ve <code>user_authority_mapping</code> tablolarÄ±, indeksler, yabancÄ± anahtarlar (FK) ve ilk <code>&#x3C;loadData></code> adÄ±mlarÄ±nÄ± tanÄ±mlayan temel ÅŸema deÄŸiÅŸiklik changelogu.</p>
</li>
<li>
<p><code>liquibase/data/user.csv</code>
KullanÄ±cÄ± kayÄ±tlarÄ± (UUID, kullanÄ±cÄ± adÄ±, bcrypt ile ÅŸifrelenmiÅŸ parola, e-posta, enabled flagi, zaman damgalarÄ± ve oluÅŸturan kullanÄ±cÄ± bilgisi).</p>
</li>
<li>
<p><code>liquibase/data/authority.csv</code>
Yetki kayÄ±tlarÄ± (UUID, ad, aÃ§Ä±klama, zaman damgalarÄ± ve oluÅŸturan kullanÄ±cÄ± bilgisi).</p>
</li>
<li>
<p><code>liquibase/data/user_authority_mapping.csv</code>
KullanÄ±cÄ±lar ile yetkiler arasÄ±ndaki mappingler (composite birincil anahtar, zaman damgalarÄ± ve oluÅŸturan kullanÄ±cÄ± bilgisi).</p>
</li>
<li>
<p><code>graphql/schema.graphqls</code>
API iÃ§in Ã¶zel scalar tipler, query, subscription ve mutation tanÄ±mlarÄ± ile DTO ÅŸema tanÄ±mlamalarÄ±nÄ± iÃ§eren GraphQL ÅŸema dosyasÄ±.</p>
</li>
<li>
<p><code>META-INF/native-image/liquibase/reflect-config.json</code>
GraalVM native-image oluÅŸtururken Liquibase sÄ±nÄ±flarÄ± iÃ§in gerekli reflection kurallarÄ±nÄ± tanÄ±mlar.</p>
</li>
</ul>
<p>application.yml</p>
<pre><code class="language-yaml">spring:
  datasource:
    url: jdbc:h2:mem:testdb;MODE=PostgreSQL;DB_CLOSE_DELAY=-1;DB_CLOSE_ON_EXIT=FALSE
    driver-class-name: org.h2.Driver
    username: sa
    password: password
  h2:
    console:
      enabled: true
  jpa:
    open-in-view: false
    hibernate:
      ddl-auto: none
    show-sql: true
    properties:
      hibernate.format_sql: true
  liquibase:
    change-log: classpath:liquibase/master.xml
  graphql:
    websocket:
      path: /subscriptions
    graphiql:
      enabled: true
security:
  admin:
    username: admin
    password: adminpass
  user:
    username: user
    password: userpass
  jwt:
    issuer: demo-issuer
    expiration-duration: 3600s
    signing:
      key-id: signing-key
      public-key: |-
        -----BEGIN PUBLIC KEY-----
        MIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEAjZEcz5itWkDGOSqZdB5P
        JE0ccOCckskp0hN3kQbT1qnv+9/k66jlWgVi4HSTppwdNF/Ylu5u541Qj+Okyg+u
        8o2PvKo5CfgvTDsFLTrZHUXU6hCSGatLAQoeN6lT8wzov2r4DFecXrIqcO6SvMB5
        ecPqsfiTi4trsNKgJ4cWS6gILH62ISd1ipUadfpnUzDMO1OulV0CJNV6bcBk7Es9
        RW6AHfg9j8osSanpwvRM4MJkB0SRxYUnrN9faGpkBZISZJ8TShhaTHEGfSNgKe5y
        8iu+AMGGZu8DYczVmqS3Ske1fq6y5HEGCma7Mo019GmwKeHBo1obuET6cZRygj4y
        twIDAQAB
        -----END PUBLIC KEY-----
      private-key: |-
        -----BEGIN PRIVATE KEY-----
        MIIEvAIBADANBgkqhkiG9w0BAQEFAASCBKYwggSiAgEAAoIBAQCNkRzPmK1aQMY5
        Kpl0Hk8kTRxw4JySySnSE3eRBtPWqe/73+TrqOVaBWLgdJOmnB00X9iW7m7njVCP
        46TKD67yjY+8qjkJ+C9MOwUtOtkdRdTqEJIZq0sBCh43qVPzDOi/avgMV5xesipw
        7pK8wHl5w+qx+JOLi2uw0qAnhxZLqAgsfrYhJ3WKlRp1+mdTMMw7U66VXQIk1Xpt
        wGTsSz1FboAd+D2PyixJqenC9EzgwmQHRJHFhSes319oamQFkhJknxNKGFpMcQZ9
        I2Ap7nLyK74AwYZm7wNhzNWapLdKR7V+rrLkcQYKZrsyjTX0abAp4cGjWhu4RPpx
        lHKCPjK3AgMBAAECggEABMo/sNCIMREXA/EqjxDFecN4LmOTOK5A0YBiH9Cc01sd
        qSaavtSQqhqbjV+0bUNEA7UohXbc3s3bx3qa5VFhiIh8sBQMaQdyRkCK/MxMc16d
        BSx5XQ/8MjVO73A1zHgH2g47BWPjgRrDL94KrgNPOO0FoG76QxL9GlcOHzhFa1rf
        xbb2auLBtflKy+5TZNnB/sbFC9ISpWywzfblD2Fsvxupl0vNWtA0Y2rPbKMZRnY+
        V6NC38yxW3HHAdWQRYLGOitM59I0HBgnjQKzTBNIsjPnJA2BSZvMBtQ1e3RQV0qE
        8VVoktZ8A0KDUxqdKWYlGYAY5hIw1y3UUsPRUbS3fQKBgQDAZehu+Kb5Sw+h00Qu
        vViNHDvi0PwmhQrHVpgjrppCnWsTk6FJFm+EBLY+87usXuRCnfZ1semb6P+yjLh2
        bJ9IXIrFAztcyE+7eZfn0H7mHA7E2ICKTjNdKbjy8kHViHpgdXREnAOrFTTk/BqW
        dq+weG2OuxYczWsY4XliWaVyiwKBgQC8XYExpSmoyI37o+jr9405k30tbGUw4X+/
        xYOvSUuafI8IOSLfKTpsvkMN3hxpJO6apIRAjOALbotKUA5FrHQPenuBWOr3mBJT
        euLiaWphqU8YN5dbNd+JhC/Jh5DLhY5FpB2Fv2MKSoF7+onpjDy9pEU5aReeBB0v
        ekUw4nWiBQKBgHxyrnjxP1frFG5xMB4nfZqw04+v7BmiXsl3mqsh6kgCeNtN17pl
        17YGMjfgAdnJ+02XzW5tqRSfDp3YZgy7z//HVD+BCqnGK8SxLu/ULfD73xW2kNZl
        JNYzAZ2r06eiQr4X2x/x5nGIIxGmfDAtDxFPpFX5b6ErwgVy+sgCAoFnAoGAWSpu
        EMEdQk+FnnwNsz2g9YNSuyDXmdb08SOfXWd1yXBzCLJ7RmYuyPEbrsHYcxFPfZap
        ICFPoTm35/qTdvnWiskxE56yw3eSHUBLjF/YQtixn0YZeMy8v0z6jgyFR0I2gdLZ
        QsnBKUrxlm2XwR1oV2Eef7m2u085PZNEk4pvor0CgYA6n060r48/CgRVslAeGder
        fZ3n+2ru8q2UVB38evepjLifn5+tKdFzZ7/NckXMC0NOVzm74qG46VFLMw5TtyT4
        /hRvGSYxA6dMjXy+tcrAns9Isrz2PnYFntlbhU6hw0um809tFunbvITfyeOjAsDW
        stC4thnhzXXT1Y3RfFtYEg==
        -----END PRIVATE KEY-----
    encryption:
      key-id: encryption-key
      public-key: |-
        -----BEGIN PUBLIC KEY-----
        MIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEAtU7Vu4tML8qg9BISaUH0
        BTU0+qkHJS3TUl3R0hEPttZJGf8EgT7bpWqRjdhMC2SYt2ifNF82EgMo/eva1rLn
        wYtCsxjJ7oB4U2m16/JKHtphmMUGhSLgbp+Y8pGAQ+P6u4HLlI0qbL92Syb6QCTr
        nYIlzZ2uUAvUQg/SbuAvdS4kdauZtpMNbhryusMVvILVBC5yUhfLJAkjbU3qWo/n
        2NKPr4kjwwFh6FaAf0HLsXCFmJbPPok6WMZeDqPORPZCt5gU2t04fS7s/2SSbhQ/
        i+7yyT4pl44cUlNLLN3Qo73sai5H90q7Dvmk3M5/YMJB0Ueyb705LHyOO5xA618s
        qQIDAQAB
        -----END PUBLIC KEY-----
      private-key: |-
        -----BEGIN PRIVATE KEY-----
        MIIEvgIBADANBgkqhkiG9w0BAQEFAASCBKgwggSkAgEAAoIBAQC1TtW7i0wvyqD0
        EhJpQfQFNTT6qQclLdNSXdHSEQ+21kkZ/wSBPtulapGN2EwLZJi3aJ80XzYSAyj9
        69rWsufBi0KzGMnugHhTabXr8koe2mGYxQaFIuBun5jykYBD4/q7gcuUjSpsv3ZL
        JvpAJOudgiXNna5QC9RCD9Ju4C91LiR1q5m2kw1uGvK6wxW8gtUELnJSF8skCSNt
        Tepaj+fY0o+viSPDAWHoVoB/QcuxcIWYls8+iTpYxl4Oo85E9kK3mBTa3Th9Luz/
        ZJJuFD+L7vLJPimXjhxSU0ss3dCjvexqLkf3SrsO+aTczn9gwkHRR7JvvTksfI47
        nEDrXyypAgMBAAECggEAREnJHrY8n9OGA+e6n4KD0mJT7gUz98Dm0yMbIC/k50yW
        hAAVRkjSmd8lq3NIURI2ov342NTznJ0sF1d6OVtxBujY2nP/uqEQsPoj1xaO7Ef8
        cnnjFsooFgJurQ44bVm02mLstqrky8jhWTT5FKfTRqP6cRNu0B9kdu1WqQQvW8a/
        C8xD8XUFzzJFQsEstJ076NjlZNH3EeqFiLxyVdV7tPEJRnOe2V2BAAgda3ByA6Jc
        Nd4xYHTVr5rZ+KES9gaAgb86+S7hNigsxz5Gp58NimLEyz1Qd+d9QCgPRgKOV5Uq
        0ci6c28ZrxW9wa/2CGCpoow1V7hRy1fZ24g2Tz91cQKBgQDbSdP/FQYuem0pUf8u
        mA/niEC8Jz30FW3ix5aqbQ8YRudK48Xy8F7AWnlS0wT2k/Xaeppn9YSPK4HlsNk2
        1gnpNfzdqXpJQtuxcPPeFNzUdXzBrsLXYqtlhOX/afrzqMhp73gkqoxXtqwD7BqN
        VfMcVXsWrEZQrRPBn/RUnnLdJwKBgQDTqUGupm93UlhoPgLXHGF/seQwPPHcU6lS
        SS9l512Ie21B+vZecgO4r77BXJwbY4rZVA5/m+wrsNmsT2f8yfdbs84cBDDWiKy5
        t2Um8zrus+BCIffxc9Fck9/htK33jLLcYwdSAm3a9pJxR9f/kAdredSTGBNJ3W/2
        rfh3cdNprwKBgDi7WfBFRSsjGzi0cPth9cNlubGzyVBrdtlT34PJ4Tzboxz53o1i
        aHEFNxwZYdBVKSbTzzyUBS5xCBMfdKK+LyQ5hmjmXq+zb1jxqvXKmfMRTixhhSDp
        8wO5pTM1/Omqwea+QGvj/5j1tnzxSVFFajbrWoPcH/jhPho6wqBducPDAoGBALOJ
        MEOavZXy7TaO0w3v7uvH0wzvxR/kfw1jMqc3l2j7ePOskmoOQAXaXO3bRjcdOlua
        Jyoq8islOZ4lRMlx7zWD0OKG035GNGzbmRtu2aA8R48RDSVr3jyu2gqznZULbXPv
        M/hmQxSmbhVUoW0PmJubnaqfk0zmXeBaNRXsIS3VAoGBALdsAtqR23PVeL6sYj2l
        dRNTDXpfvjFqJ5NThRO/4mT0CrPHQVj+Mz2bTc/Dxiwi8s8m3L+g23i3hodh/QMb
        Iz+UbcJZBGAKsFbPKGOtj6Bi07y/L11mcuNJzOWe61/JbVmJss0s+N/v3XucK/Ge
        CUaGOccsMO221v6JoBh9J3Hz
        -----END PRIVATE KEY-----
</code></pre>
<p>master.xml</p>
<pre><code class="language-xml">&#x3C;?xml version="1.0" encoding="UTF-8"?>
&#x3C;databaseChangeLog
  xmlns="http://www.liquibase.org/xml/ns/dbchangelog"
  xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
  xsi:schemaLocation="
      http://www.liquibase.org/xml/ns/dbchangelog
      http://www.liquibase.org/xml/ns/dbchangelog/dbchangelog-4.9.xsd">

  &#x3C;!-- H2 defaults -->
  &#x3C;property name="now" value="now()" dbms="h2"/>
  &#x3C;property name="floatType" value="float4" dbms="h2"/>
  &#x3C;property name="uuidType" value="uuid" dbms="h2"/>
  &#x3C;property name="datetimeType" value="datetime(6)" dbms="h2"/>
  &#x3C;property name="binaryType" value="LONGVARBINARY" dbms="h2"/>
  &#x3C;property name="clobType" value="longvarchar" dbms="h2"/>
  &#x3C;property name="blobType" value="blob" dbms="h2"/>

  &#x3C;!-- PostgreSQL overrides -->
  &#x3C;property name="now" value="current_timestamp" dbms="postgresql"/>
  &#x3C;property name="floatType" value="float4" dbms="postgresql"/>
  &#x3C;property name="uuidType" value="uuid" dbms="postgresql"/>
  &#x3C;property name="datetimeType" value="datetime" dbms="postgresql"/>
  &#x3C;property name="binaryType" value="BYTEA" dbms="postgresql"/>
  &#x3C;property name="clobType" value="clob" dbms="postgresql"/>
  &#x3C;property name="blobType" value="blob" dbms="postgresql"/>

  &#x3C;!-- include the core auth changelog -->
  &#x3C;include file="classpath:db/changelog/changelog-user.xml"/>

&#x3C;/databaseChangeLog>
</code></pre>
<p>changelog-user.xml</p>
<pre><code class="language-xml">&#x3C;?xml version="1.0" encoding="UTF-8"?>
&#x3C;databaseChangeLog
  xmlns="http://www.liquibase.org/xml/ns/dbchangelog"
  xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
  xsi:schemaLocation="
      http://www.liquibase.org/xml/ns/dbchangelog
      http://www.liquibase.org/xml/ns/dbchangelog/dbchangelog-4.9.xsd">

  &#x3C;changeSet id="20250510-1" author="susimsek">
    &#x3C;createTable tableName="user_identity">
      &#x3C;column name="id" type="varchar(36)">
        &#x3C;constraints primaryKey="true" primaryKeyName="pk_user_identity" nullable="false"/>
      &#x3C;/column>
      &#x3C;column name="username" type="varchar(50)">
        &#x3C;constraints nullable="false" unique="true"/>
      &#x3C;/column>
      &#x3C;column name="password" type="varchar(100)">
        &#x3C;constraints nullable="false"/>
      &#x3C;/column>
      &#x3C;column name="email" type="varchar(100)">
        &#x3C;constraints nullable="false" unique="true"/>
      &#x3C;/column>
      &#x3C;column name="first_name" type="varchar(50)"/>
      &#x3C;column name="last_name" type="varchar(50)"/>
      &#x3C;column name="enabled" type="boolean">
        &#x3C;constraints nullable="false"/>
      &#x3C;/column>
      &#x3C;column name="created_at" type="datetime">
        &#x3C;constraints nullable="false"/>
      &#x3C;/column>
      &#x3C;column name="created_by" type="varchar(50)">
        &#x3C;constraints nullable="false"/>
      &#x3C;/column>
      &#x3C;column name="updated_at" type="datetime"/>
      &#x3C;column name="updated_by" type="varchar(50)"/>
    &#x3C;/createTable>

    &#x3C;createIndex indexName="idx_user_identity_username" tableName="user_identity">
      &#x3C;column name="username"/>
    &#x3C;/createIndex>
    &#x3C;createIndex indexName="idx_user_identity_email" tableName="user_identity">
      &#x3C;column name="email"/>
    &#x3C;/createIndex>
  &#x3C;/changeSet>

  &#x3C;changeSet id="20250510-2" author="susimsek">
    &#x3C;createTable tableName="authority">
      &#x3C;column name="id" type="varchar(36)">
        &#x3C;constraints primaryKey="true" primaryKeyName="pk_authority" nullable="false"/>
      &#x3C;/column>
      &#x3C;column name="name" type="varchar(50)">
        &#x3C;constraints nullable="false" unique="true"/>
      &#x3C;/column>
      &#x3C;column name="description" type="varchar(255)"/>
      &#x3C;column name="created_at" type="datetime">
        &#x3C;constraints nullable="false"/>
      &#x3C;/column>
      &#x3C;column name="created_by" type="varchar(50)">
        &#x3C;constraints nullable="false"/>
      &#x3C;/column>
      &#x3C;column name="updated_at" type="datetime"/>
      &#x3C;column name="updated_by" type="varchar(50)"/>
    &#x3C;/createTable>

    &#x3C;createIndex indexName="idx_authority_name" tableName="authority">
      &#x3C;column name="name"/>
    &#x3C;/createIndex>
  &#x3C;/changeSet>

  &#x3C;changeSet id="20250510-3" author="susimsek">
    &#x3C;createTable tableName="user_authority_mapping">
      &#x3C;column name="user_id" type="varchar(36)">
        &#x3C;constraints nullable="false"/>
      &#x3C;/column>
      &#x3C;column name="authority_id" type="varchar(36)">
        &#x3C;constraints nullable="false"/>
      &#x3C;/column>
      &#x3C;column name="created_at" type="datetime">
        &#x3C;constraints nullable="false"/>
      &#x3C;/column>
      &#x3C;column name="created_by" type="varchar(50)">
        &#x3C;constraints nullable="false"/>
      &#x3C;/column>
      &#x3C;column name="updated_at" type="datetime"/>
      &#x3C;column name="updated_by" type="varchar(50)"/>
    &#x3C;/createTable>

    &#x3C;addPrimaryKey
      tableName="user_authority_mapping"
      columnNames="user_id, authority_id"
      constraintName="pk_user_authority_mapping"/>
  &#x3C;/changeSet>

  &#x3C;changeSet id="20250510-4" author="susimsek">
    &#x3C;addForeignKeyConstraint
      baseTableName="user_authority_mapping"
      baseColumnNames="user_id"
      constraintName="fk_user_authority_user"
      referencedTableName="user_identity"
      referencedColumnNames="id"/>
  &#x3C;/changeSet>

  &#x3C;changeSet id="20250510-5" author="susimsek">
    &#x3C;addForeignKeyConstraint
      baseTableName="user_authority_mapping"
      baseColumnNames="authority_id"
      constraintName="fk_user_authority_authority"
      referencedTableName="authority"
      referencedColumnNames="id"/>
  &#x3C;/changeSet>

  &#x3C;changeSet id="20250510-1-data" author="susimsek">
    &#x3C;loadData
      file="db/data/user.csv"
      separator=";"
      tableName="user_identity">
      &#x3C;column name="id" type="string"/>
      &#x3C;column name="username" type="string"/>
      &#x3C;column name="password" type="string"/>
      &#x3C;column name="email" type="string"/>
      &#x3C;column name="first_name" type="string"/>
      &#x3C;column name="last_name" type="string"/>
      &#x3C;column name="enabled" type="boolean"/>
      &#x3C;column name="created_at" type="datetime"/>
      &#x3C;column name="created_by" type="string"/>
      &#x3C;column name="updated_at" type="datetime"/>
      &#x3C;column name="updated_by" type="string"/>
    &#x3C;/loadData>
  &#x3C;/changeSet>

  &#x3C;changeSet id="20250510-2-data" author="susimsek">
    &#x3C;loadData
      file="db/data/authority.csv"
      separator=";"
      tableName="authority">
      &#x3C;column name="id" type="string"/>
      &#x3C;column name="name" type="string"/>
      &#x3C;column name="description" type="string"/>
      &#x3C;column name="created_at" type="datetime"/>
      &#x3C;column name="created_by" type="string"/>
      &#x3C;column name="updated_at" type="datetime"/>
      &#x3C;column name="updated_by" type="string"/>
    &#x3C;/loadData>
  &#x3C;/changeSet>

  &#x3C;changeSet id="20250510-3-data" author="susimsek">
    &#x3C;loadData
      file="db/data/user_authority_mapping.csv"
      separator=";"
      tableName="user_authority_mapping">
      &#x3C;column name="user_id" type="string"/>
      &#x3C;column name="authority_id" type="string"/>
      &#x3C;column name="created_at" type="datetime"/>
      &#x3C;column name="created_by" type="string"/>
      &#x3C;column name="updated_at" type="datetime"/>
      &#x3C;column name="updated_by" type="string"/>
    &#x3C;/loadData>
  &#x3C;/changeSet>

&#x3C;/databaseChangeLog>
</code></pre>
<p>user.csv</p>
<pre><code class="language-csv">id;username;password;email;first_name;last_name;enabled;created_at;created_by;updated_at;updated_by
a1b2c3d4-e5f6-7890-abcd-ef1234567890;admin;$2a$10$sva6wl8pmGKJE6NIWrxwcuJK1Jaa2I/LOI43iHVpbR4YB8KjGViiK;admin@example.com;Admin;User;true;2025-05-10 12:00:00;system;2025-05-10 12:00:00;system
09876543-21fe-dcba-0987-654321fedcba;user;$2a$10$5Py4PyteLuXEqnGpSigzfu0V55C7Hi7zX18lmh.J8Bpmft.h23voG;user@example.com;Normal;User;true;2025-05-10 12:00:00;system;2025-05-10 12:00:00;system
</code></pre>
<p>authority.csv</p>
<pre><code class="language-csv">id;name;description;created_at;created_by;updated_at;updated_by
f47ac10b-58cc-4372-a567-0e02b2c3d479;ROLE_ADMIN;Administrator role;2025-05-10 12:00:00;system;2025-05-10 12:00:00;system
9c858901-8a57-4791-81fe-4c455b099bc9;ROLE_USER;User role;2025-05-10 12:00:00;system;2025-05-10 12:00:00;system
</code></pre>
<p>user_authority_mapping.csv</p>
<pre><code class="language-csv">user_id;authority_id;created_at;created_by;updated_at;updated_by
a1b2c3d4-e5f6-7890-abcd-ef1234567890;9c858901-8a57-4791-81fe-4c455b099bc9;2025-05-10 12:00:00;system;2025-05-10 12:00:00;system
a1b2c3d4-e5f6-7890-abcd-ef1234567890;f47ac10b-58cc-4372-a567-0e02b2c3d479;2025-05-10 12:00:00;system;2025-05-10 12:00:00;system
09876543-21fe-dcba-0987-654321fedcba;9c858901-8a57-4791-81fe-4c455b099bc9;2025-05-10 12:00:00;system;2025-05-10 12:00:00;system
</code></pre>
<p>schema.graphqls</p>
<pre><code class="language-graphql">scalar Long
scalar Date
scalar Instant

type Query {
  helloAll: String!
  helloAdmin: String!
}

type Mutation {
  login(input: LoginInput!): TokenDTO!
  logout: Boolean!
  greet(input: GreetInput!): GreetDTO!
}

type Subscription {
  greetStream(input: GreetInput!): GreetDTO!
  greetStreamAdmin(input: GreetInput!): GreetDTO!
}

input LoginInput {
  username: String!
  password: String!
}

input GreetInput {
  message: String!
}

type TokenDTO {
  accessToken: String!
  tokenType: String!
  accessTokenExpiresIn: Long!
}

type GreetDTO {
  greeting: String!
  timestamp: Instant!
}
</code></pre>
<p>reflect-config.json</p>
<pre><code class="language-json">[
  {
    "name": "liquibase.logging.mdc.MdcManagerFactory",
    "methods": [{ "name": "&#x3C;init>", "parameterTypes": [] }]
  },
  {
    "name": "liquibase.change.core.LoadDataColumnConfig",
    "queryAllPublicMethods": true,
    "allDeclaredMethods": true,
    "methods": [{ "name": "&#x3C;init>", "parameterTypes": [] }]
  },
  {
    "name": "liquibase.command.CommandFactory",
    "methods": [{ "name": "&#x3C;init>", "parameterTypes": [] }]
  },
  {
    "name": "liquibase.changelog.ChangeLogHistoryServiceFactory",
    "methods": [{ "name": "&#x3C;init>", "parameterTypes": [] }]
  },
  {
    "name": "liquibase.datatype.core.BigIntType",
    "allPublicMethods": true,
    "methods": [{ "name": "&#x3C;init>", "parameterTypes": [] }]
  },
  {
    "name": "liquibase.datatype.core.BlobType",
    "allPublicMethods": true,
    "methods": [{ "name": "&#x3C;init>", "parameterTypes": [] }]
  },
  {
    "name": "liquibase.datatype.core.BooleanType",
    "allPublicMethods": true,
    "methods": [{ "name": "&#x3C;init>", "parameterTypes": [] }]
  },
  {
    "name": "liquibase.datatype.core.CharType",
    "allPublicMethods": true,
    "methods": [{ "name": "&#x3C;init>", "parameterTypes": [] }]
  },
  {
    "name": "liquibase.datatype.core.ClobType",
    "allPublicMethods": true,
    "methods": [{ "name": "&#x3C;init>", "parameterTypes": [] }]
  },
  {
    "name": "liquibase.datatype.core.CurrencyType",
    "allPublicMethods": true,
    "methods": [{ "name": "&#x3C;init>", "parameterTypes": [] }]
  },
  {
    "name": "liquibase.datatype.core.DatabaseFunctionType",
    "allPublicMethods": true,
    "methods": [{ "name": "&#x3C;init>", "parameterTypes": [] }]
  },
  {
    "name": "liquibase.datatype.core.DateTimeType",
    "allPublicMethods": true,
    "methods": [{ "name": "&#x3C;init>", "parameterTypes": [] }]
  },
  {
    "name": "liquibase.datatype.core.DateType",
    "allPublicMethods": true,
    "methods": [{ "name": "&#x3C;init>", "parameterTypes": [] }]
  },
  {
    "name": "liquibase.datatype.core.DecimalType",
    "allPublicMethods": true,
    "methods": [{ "name": "&#x3C;init>", "parameterTypes": [] }]
  },
  {
    "name": "liquibase.datatype.core.DoubleType",
    "allPublicMethods": true,
    "methods": [{ "name": "&#x3C;init>", "parameterTypes": [] }]
  },
  {
    "name": "liquibase.datatype.core.FloatType",
    "allPublicMethods": true,
    "methods": [{ "name": "&#x3C;init>", "parameterTypes": [] }]
  },
  {
    "name": "liquibase.datatype.core.IntType",
    "allPublicMethods": true,
    "methods": [{ "name": "&#x3C;init>", "parameterTypes": [] }]
  },
  {
    "name": "liquibase.datatype.core.MediumIntType",
    "allPublicMethods": true,
    "methods": [{ "name": "&#x3C;init>", "parameterTypes": [] }]
  },
  {
    "name": "liquibase.datatype.core.NCharType",
    "allPublicMethods": true,
    "methods": [{ "name": "&#x3C;init>", "parameterTypes": [] }]
  },
  {
    "name": "liquibase.datatype.core.NumberType",
    "allPublicMethods": true,
    "methods": [{ "name": "&#x3C;init>", "parameterTypes": [] }]
  },
  {
    "name": "liquibase.datatype.core.NVarcharType",
    "allPublicMethods": true,
    "methods": [{ "name": "&#x3C;init>", "parameterTypes": [] }]
  },
  {
    "name": "liquibase.datatype.core.SmallIntType",
    "allPublicMethods": true,
    "methods": [{ "name": "&#x3C;init>", "parameterTypes": [] }]
  },
  {
    "name": "liquibase.datatype.core.TimestampType",
    "allPublicMethods": true,
    "methods": [{ "name": "&#x3C;init>", "parameterTypes": [] }]
  },
  {
    "name": "liquibase.datatype.core.TimeType",
    "allPublicMethods": true,
    "methods": [{ "name": "&#x3C;init>", "parameterTypes": [] }]
  },
  {
    "name": "liquibase.datatype.core.TinyIntType",
    "allPublicMethods": true,
    "methods": [{ "name": "&#x3C;init>", "parameterTypes": [] }]
  },
  {
    "name": "liquibase.datatype.core.UnknownType",
    "allPublicMethods": true,
    "methods": [{ "name": "&#x3C;init>", "parameterTypes": [] }]
  },
  {
    "name": "liquibase.datatype.core.UUIDType",
    "allPublicMethods": true,
    "methods": [{ "name": "&#x3C;init>", "parameterTypes": [] }]
  },
  {
    "name": "liquibase.datatype.core.VarcharType",
    "allPublicMethods": true,
    "methods": [{ "name": "&#x3C;init>", "parameterTypes": [] }]
  },
  {
    "name": "liquibase.datatype.core.XMLType",
    "allPublicMethods": true,
    "methods": [{ "name": "&#x3C;init>", "parameterTypes": [] }]
  }
]
</code></pre>
<hr>
<h2>ğŸ› ï¸ AdÄ±m 3: GraphQL &#x26; GÃ¼venlik &#x26; VeritabanÄ± YapÄ±landÄ±rmasÄ±</h2>
<p>Bu bÃ¶lÃ¼mde JWE tabanlÄ± kimlik doÄŸrulama, GraphQL entegrasyonu, GraalVM native-image Ã§alÄ±ÅŸma zamanÄ± ipuÃ§larÄ± ve Ã¶zel scalars iÃ§in gerekli bean'leri ve ayarlarÄ± tanÄ±mlÄ±yoruz:</p>
<ul>
<li>JwtProperties: JWT dÃ¼zenleyicisi (issuer), geÃ§erlilik sÃ¼resi ve imzalama/ÅŸifreleme anahtar Ã§iftlerini yapÄ±landÄ±rÄ±r.</li>
<li>SecurityJwtConfig: RSA JWK nesnelerini oluÅŸturur, JWT encoder/decoderâ€™Ä±, authentication converter ve token resolver ve WebSocket interceptor beanâ€™lerini yapÄ±landÄ±rÄ±r.</li>
<li>SecurityConfig: <code>DomainUserDetailsService</code> ile entegre olur, kimlik doÄŸrulama yÃ¶neticisi (authentication manager), password encoder ve JWE desteÄŸi ile stateless gÃ¼venlik filtre zincirini yapÄ±landÄ±rÄ±r.</li>
<li>DatabaseConfig: JPA repository'lerini, auditing ve transaction yÃ¶netimini etkinleÅŸtirir.</li>
<li>GraphQLConfig: GraphQL iÃ§in Ã¶zel scalarlarÄ± (<code>Long</code>, <code>Date</code>, <code>Instant</code>) tanÄ±mlar.</li>
<li>InstantScalar: GraphQL ÅŸemasÄ±nda ISO-8601 uyumlu <code>Instant</code> tipini tanÄ±mlayan custom scalar.</li>
<li>NativeConfig: GraalVM native-image derlemesi iÃ§in Ã§alÄ±ÅŸma zamanÄ± ipuÃ§larÄ±nÄ± (reflection ve kaynak desenleri) kaydeder.</li>
</ul>
<p>SecurityJwtConfig</p>
<h3>Java</h3>
<pre><code class="language-java">package io.github.susimsek.springbootgraphqljwedemo.config;

import com.nimbusds.jose.EncryptionMethod;
import com.nimbusds.jose.JWEAlgorithm;
import com.nimbusds.jose.JWSAlgorithm;
import com.nimbusds.jose.jwk.JWKSet;
import com.nimbusds.jose.jwk.RSAKey;
import com.nimbusds.jose.jwk.source.JWKSource;
import com.nimbusds.jose.proc.JWEDecryptionKeySelector;
import com.nimbusds.jose.proc.JWSVerificationKeySelector;
import com.nimbusds.jose.proc.SecurityContext;
import com.nimbusds.jwt.proc.DefaultJWTProcessor;
import io.github.susimsek.springbootgraphqljwedemo.security.CookieAuthenticationWebSocketInterceptor;
import io.github.susimsek.springbootgraphqljwedemo.security.CookieBearerTokenResolver;
import io.github.susimsek.springbootgraphqljwedemo.security.KeyUtils;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.graphql.server.WebSocketGraphQlInterceptor;
import org.springframework.graphql.server.support.BearerTokenAuthenticationExtractor;
import org.springframework.security.authentication.ProviderManager;
import org.springframework.security.oauth2.jwt.JwtDecoder;
import org.springframework.security.oauth2.jwt.JwtEncoder;
import org.springframework.security.oauth2.jwt.NimbusJwtDecoder;
import org.springframework.security.oauth2.jwt.NimbusJwtEncoder;
import org.springframework.security.oauth2.server.resource.authentication.JwtAuthenticationConverter;
import org.springframework.security.oauth2.server.resource.authentication.JwtGrantedAuthoritiesConverter;
import org.springframework.security.oauth2.server.resource.authentication.JwtAuthenticationProvider;
import org.springframework.security.oauth2.server.resource.web.BearerTokenResolver;

import java.util.List;

import static io.github.susimsek.springbootgraphqljwedemo.security.SecurityUtils.AUTHORITIES_KEY;

@Configuration
public class SecurityJwtConfig {

  private final JwtProperties props;

  public SecurityJwtConfig(JwtProperties props) {
    this.props = props;
  }

  @Bean
  public RSAKey signingKey() throws Exception {
    return KeyUtils.buildRsaKey(
      props.getSigning().getPublicKey(),
      props.getSigning().getPrivateKey(),
      props.getSigning().getKeyId(),
      true
    );
  }

  @Bean
  public RSAKey encryptionKey() throws Exception {
    return KeyUtils.buildRsaKey(
      props.getEncryption().getPublicKey(),
      props.getEncryption().getPrivateKey(),
      props.getEncryption().getKeyId(),
      false
    );
  }

  @Bean
  public JWKSource&#x3C;SecurityContext> jwkSource(RSAKey signingKey, RSAKey encryptionKey) {
    JWKSet jwkSet = new JWKSet(List.of(signingKey, encryptionKey));
    return (jwkSelector, context) -> jwkSelector.select(jwkSet);
  }

  @Bean
  public JwtDecoder jwtDecoder(JWKSource&#x3C;SecurityContext> jwkSource) {
    DefaultJWTProcessor&#x3C;SecurityContext> jwtProcessor = new DefaultJWTProcessor&#x3C;>();

    jwtProcessor.setJWEKeySelector(new JWEDecryptionKeySelector&#x3C;>(
      JWEAlgorithm.RSA_OAEP_256,
      EncryptionMethod.A128GCM,
      jwkSource
    ));
    jwtProcessor.setJWSKeySelector(new JWSVerificationKeySelector&#x3C;>(
      JWSAlgorithm.RS256,
      jwkSource
    ));
    jwtProcessor.setJWTClaimsSetVerifier((claims, ctx) -> {});

    return new NimbusJwtDecoder(jwtProcessor);
  }

  @Bean
  public JwtEncoder jwtEncoder(JWKSource&#x3C;SecurityContext> jwkSource) {
    return new NimbusJwtEncoder(jwkSource);
  }

  @Bean
  public JwtAuthenticationConverter jwtAuthenticationConverter() {
    JwtGrantedAuthoritiesConverter converter = new JwtGrantedAuthoritiesConverter();
    converter.setAuthorityPrefix("");
    converter.setAuthoritiesClaimName(AUTHORITIES_KEY);

    JwtAuthenticationConverter authConverter = new JwtAuthenticationConverter();
    authConverter.setJwtGrantedAuthoritiesConverter(converter);
    return authConverter;
  }

  @Bean
  public BearerTokenResolver bearerTokenResolver() {
    CookieBearerTokenResolver resolver = new CookieBearerTokenResolver();
    resolver.setAllowUriQueryParameter(false);
    resolver.setAllowFormEncodedBodyParameter(false);
    resolver.setAllowCookie(true);
    return resolver;
  }

  @Bean
  public WebSocketGraphQlInterceptor authenticationInterceptor(JwtDecoder jwtDecoder) {
    return new CookieAuthenticationWebSocketInterceptor(
      new BearerTokenAuthenticationExtractor(),
      new ProviderManager(new JwtAuthenticationProvider(jwtDecoder))
    );
  }
}
</code></pre>
<h3>Kotlin</h3>
<pre><code class="language-kotlin">package io.github.susimsek.springbootgraphqljwedemo.config

import com.nimbusds.jose.EncryptionMethod
import com.nimbusds.jose.JWEAlgorithm
import com.nimbusds.jose.JWSAlgorithm
import com.nimbusds.jose.jwk.JWKSet
import com.nimbusds.jose.jwk.RSAKey
import com.nimbusds.jose.jwk.source.JWKSource
import com.nimbusds.jose.proc.JWEDecryptionKeySelector
import com.nimbusds.jose.proc.JWSVerificationKeySelector
import com.nimbusds.jose.proc.SecurityContext
import com.nimbusds.jwt.proc.DefaultJWTProcessor
import io.github.susimsek.springbootgraphqljwedemo.security.CookieAuthenticationWebSocketInterceptor
import io.github.susimsek.springbootgraphqljwedemo.security.CookieBearerTokenResolver
import io.github.susimsek.springbootgraphqljwedemo.security.KeyUtils
import org.springframework.context.annotation.Bean
import org.springframework.context.annotation.Configuration
import org.springframework.graphql.server.WebSocketGraphQlInterceptor
import org.springframework.graphql.server.support.BearerTokenAuthenticationExtractor
import org.springframework.security.authentication.ProviderManager
import org.springframework.security.oauth2.jwt.JwtDecoder
import org.springframework.security.oauth2.jwt.JwtEncoder
import org.springframework.security.oauth2.jwt.NimbusJwtDecoder
import org.springframework.security.oauth2.jwt.NimbusJwtEncoder
import org.springframework.security.oauth2.server.resource.authentication.JwtAuthenticationConverter
import org.springframework.security.oauth2.server.resource.authentication.JwtGrantedAuthoritiesConverter
import org.springframework.security.oauth2.server.resource.authentication.JwtAuthenticationProvider
import org.springframework.security.oauth2.server.resource.web.BearerTokenResolver

@Configuration
class SecurityJwtConfig(
  private val props: JwtProperties
) {

  @Bean
  @Throws(Exception::class)
  fun signingKey(): RSAKey = KeyUtils.buildRsaKey(
    props.signing.publicKey,
    props.signing.privateKey,
    props.signing.keyId,
    true
  )

  @Bean
  @Throws(Exception::class)
  fun encryptionKey(): RSAKey = KeyUtils.buildRsaKey(
    props.encryption.publicKey,
    props.encryption.privateKey,
    props.encryption.keyId,
    false
  )

  @Bean
  fun jwkSource(
    signingKey: RSAKey,
    encryptionKey: RSAKey
  ): JWKSource&#x3C;SecurityContext> {
    val jwkSet = JWKSet(listOf(signingKey, encryptionKey))
    return JWKSource { jwkSelector, _ -> jwkSelector.select(jwkSet) }
  }

  @Bean
  fun jwtDecoder(jwkSource: JWKSource&#x3C;SecurityContext>): JwtDecoder {
    val processor = DefaultJWTProcessor&#x3C;SecurityContext>().apply {
      setJWEKeySelector(JWEDecryptionKeySelector(
        JWEAlgorithm.RSA_OAEP_256,
        EncryptionMethod.A128GCM,
        jwkSource
      ))
      setJWSKeySelector(JWSVerificationKeySelector(
        JWSAlgorithm.RS256,
        jwkSource
      ))
      setJWTClaimsSetVerifier { _, _ -> }
    }
    return NimbusJwtDecoder(processor)
  }

  @Bean
  fun jwtEncoder(jwkSource: JWKSource&#x3C;SecurityContext>): JwtEncoder =
    NimbusJwtEncoder(jwkSource)

  @Bean
  fun jwtAuthenticationConverter(): JwtAuthenticationConverter {
    val granted = JwtGrantedAuthoritiesConverter().apply {
      authorityPrefix = ""
      authoritiesClaimName = SecurityUtils.AUTHORITIES_KEY
    }
    return JwtAuthenticationConverter().apply {
      setJwtGrantedAuthoritiesConverter(granted)
    }
  }

  @Bean
  fun bearerTokenResolver(): BearerTokenResolver =
    CookieBearerTokenResolver().apply {
      setAllowUriQueryParameter(false)
      setAllowFormEncodedBodyParameter(false)
      setAllowCookie(true)
    }

  @Bean
  fun authenticationInterceptor(jwtDecoder: JwtDecoder): WebSocketGraphQlInterceptor =
    CookieAuthenticationWebSocketInterceptor(
      BearerTokenAuthenticationExtractor(),
      ProviderManager(JwtAuthenticationProvider(jwtDecoder))
    )
}
</code></pre>
<p>SecurityConfig</p>
<h3>Java</h3>
<pre><code class="language-java">package io.github.susimsek.springbootgraphqljwedemo.config;

import io.github.susimsek.springbootgraphqljwedemo.repository.UserRepository;
import io.github.susimsek.springbootgraphqljwedemo.security.DomainUserDetailsService;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.security.authentication.AuthenticationManager;
import org.springframework.security.authentication.ProviderManager;
import org.springframework.security.authentication.dao.DaoAuthenticationProvider;
import org.springframework.security.config.annotation.method.configuration.EnableMethodSecurity;
import org.springframework.security.config.annotation.web.builders.HttpSecurity;
import org.springframework.security.config.annotation.web.configurers.AbstractHttpConfigurer;
import org.springframework.security.config.http.SessionCreationPolicy;
import org.springframework.security.core.userdetails.UserDetailsService;
import org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder;
import org.springframework.security.crypto.password.PasswordEncoder;
import org.springframework.security.web.SecurityFilterChain;
import org.springframework.security.web.servlet.util.matcher.MvcRequestMatcher;
import org.springframework.web.servlet.handler.HandlerMappingIntrospector;

import static org.springframework.security.config.Customizer.withDefaults;

@Configuration
@EnableMethodSecurity(securedEnabled = true)
public class SecurityConfig {

  @Bean
  public SecurityFilterChain securityFilterChain(HttpSecurity http,
                                                 MvcRequestMatcher.Builder mvc) throws Exception {
    http
      .cors(withDefaults())
      .csrf(AbstractHttpConfigurer::disable)
      .authorizeHttpRequests(authz ->
        authz
          .requestMatchers(
            mvc.pattern("/webjars/**"),
            mvc.pattern("/css/**"),
            mvc.pattern("/js/**")
          ).permitAll()
          .requestMatchers(
            mvc.pattern("/*.ico"),
            mvc.pattern("/*.png"),
            mvc.pattern("/*.svg"),
            mvc.pattern("/*.webapp")
          ).permitAll()
          .requestMatchers("/actuator/**").permitAll()
          .requestMatchers(
            "/v3/api-docs/**",
            "/swagger-ui.html",
            "/swagger-ui/**"
          ).permitAll()
          .requestMatchers(
            mvc.pattern("/graphql"),
            mvc.pattern("/graphiql"),
            mvc.pattern("/subscriptions")
          ).permitAll()
          .anyRequest().authenticated()
      )
      .sessionManagement(session ->
        session.sessionCreationPolicy(SessionCreationPolicy.STATELESS))
      .oauth2ResourceServer(oauth2 -> oauth2
        .jwt(withDefaults())
      );

    return http.build();
  }

  @Bean
  public UserDetailsService userDetailsService(UserRepository userRepository) {
    return new DomainUserDetailsService(userRepository);
  }

  @Bean
  public PasswordEncoder passwordEncoder() {
    return new BCryptPasswordEncoder();
  }

  @Bean
  public AuthenticationManager authenticationManager(
    UserDetailsService userDetailsService,
    PasswordEncoder passwordEncoder) {
    DaoAuthenticationProvider provider = new DaoAuthenticationProvider();
    provider.setUserDetailsService(userDetailsService);
    provider.setPasswordEncoder(passwordEncoder);
    return new ProviderManager(provider);
  }

  @Bean
  public MvcRequestMatcher.Builder mvc(HandlerMappingIntrospector introspector) {
    return new MvcRequestMatcher.Builder(introspector);
  }
}
</code></pre>
<h3>Kotlin</h3>
<pre><code class="language-kotlin">package io.github.susimsek.springbootgraphqljwedemo.config

import io.github.susimsek.springbootgraphqljwedemo.repository.UserRepository
import io.github.susimsek.springbootgraphqljwedemo.security.DomainUserDetailsService
import org.springframework.context.annotation.Bean
import org.springframework.context.annotation.Configuration
import org.springframework.security.authentication.AuthenticationManager
import org.springframework.security.authentication.ProviderManager
import org.springframework.security.authentication.dao.DaoAuthenticationProvider
import org.springframework.security.config.annotation.method.configuration.EnableMethodSecurity
import org.springframework.security.config.annotation.web.builders.HttpSecurity
import org.springframework.security.config.annotation.web.configurers.AbstractHttpConfigurer
import org.springframework.security.config.http.SessionCreationPolicy
import org.springframework.security.core.userdetails.UserDetailsService
import org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder
import org.springframework.security.crypto.password.PasswordEncoder
import org.springframework.security.web.SecurityFilterChain
import org.springframework.security.web.servlet.util.matcher.MvcRequestMatcher
import org.springframework.web.servlet.handler.HandlerMappingIntrospector
import org.springframework.security.config.Customizer.withDefaults

@Configuration
@EnableMethodSecurity(securedEnabled = true)
class SecurityConfig {

  @Bean
  @Throws(Exception::class)
  fun securityFilterChain(
    http: HttpSecurity,
    mvc: MvcRequestMatcher.Builder
  ): SecurityFilterChain {
    http
      .cors(withDefaults())
      .csrf { it.disable() }
      .authorizeHttpRequests { authz ->
        authz
          .requestMatchers(
            mvc.pattern("/webjars/**"),
            mvc.pattern("/css/**"),
            mvc.pattern("/js/**")
          ).permitAll()
          .requestMatchers(
            mvc.pattern("/*.ico"),
            mvc.pattern("/*.png"),
            mvc.pattern("/*.svg"),
            mvc.pattern("/*.webapp")
          ).permitAll()
          .requestMatchers("/actuator/**").permitAll()
          .requestMatchers(
            "/v3/api-docs/**",
            "/swagger-ui.html",
            "/swagger-ui/**"
          ).permitAll()
          .requestMatchers(
            mvc.pattern("/graphql"),
            mvc.pattern("/graphiql"),
            mvc.pattern("/subscriptions")
          ).permitAll()
          .anyRequest().authenticated()
      }
      .sessionManagement {
        it.sessionCreationPolicy(SessionCreationPolicy.STATELESS)
      }
      .oauth2ResourceServer {
        it.jwt(withDefaults())
      }

    return http.build()
  }

  @Bean
  fun userDetailsService(userRepository: UserRepository): UserDetailsService =
    DomainUserDetailsService(userRepository)

  @Bean
  fun passwordEncoder(): PasswordEncoder = BCryptPasswordEncoder()

  @Bean
  fun authenticationManager(
    userDetailsService: UserDetailsService,
    passwordEncoder: PasswordEncoder
  ): AuthenticationManager {
    val provider = DaoAuthenticationProvider().apply {
      setUserDetailsService(userDetailsService)
      setPasswordEncoder(passwordEncoder)
    }
    return ProviderManager(provider)
  }

  @Bean
  fun mvc(introspector: HandlerMappingIntrospector): MvcRequestMatcher.Builder =
    MvcRequestMatcher.Builder(introspector)
}
</code></pre>
<p>JwtProperties</p>
<h3>Java</h3>
<pre><code class="language-java">package io.github.susimsek.springbootgraphqljwedemo.config;

import lombok.Data;
import org.springframework.boot.context.properties.ConfigurationProperties;
import org.springframework.context.annotation.Configuration;

import java.time.Duration;

@Configuration
@ConfigurationProperties(prefix = "security.jwt")
@Data
public class JwtProperties {

    @Data
    public static class Pair {
        private String publicKey;
        private String privateKey;
        private String keyId;
    }

    private Pair signing;
    private Pair encryption;
    private String issuer;
    private Duration expirationDuration;
}
</code></pre>
<h3>Kotlin</h3>
<pre><code class="language-kotlin">package io.github.susimsek.springbootgraphqljwedemo.config

import org.springframework.boot.context.properties.ConfigurationProperties
import org.springframework.context.annotation.Configuration
import java.time.Duration

@Configuration
@ConfigurationProperties(prefix = "security.jwt")
class JwtProperties {

  class Pair {
    lateinit var publicKey: String
    lateinit var privateKey: String
    lateinit var keyId: String
  }

  lateinit var signing: Pair
  lateinit var encryption: Pair
  lateinit var issuer: String
  lateinit var expirationDuration: Duration
}
</code></pre>
<p>DatabaseConfig</p>
<h3>Java</h3>
<pre><code class="language-java">package io.github.susimsek.springbootgraphqljwedemo.config;

import org.springframework.context.annotation.Configuration;
import org.springframework.data.jpa.repository.config.EnableJpaAuditing;
import org.springframework.data.jpa.repository.config.EnableJpaRepositories;
import org.springframework.transaction.annotation.EnableTransactionManagement;

@Configuration
@EnableJpaRepositories("io.github.susimsek.springbootgraphqljwedemo.repository")
@EnableJpaAuditing(auditorAwareRef = "springSecurityAuditorAware")
@EnableTransactionManagement
public class DatabaseConfig {

}
</code></pre>
<h3>Kotlin</h3>
<pre><code class="language-kotlin">package io.github.susimsek.springbootgraphqljwedemo.config

import org.springframework.context.annotation.Configuration
import org.springframework.data.jpa.repository.config.EnableJpaAuditing
import org.springframework.data.jpa.repository.config.EnableJpaRepositories
import org.springframework.transaction.annotation.EnableTransactionManagement

@Configuration
@EnableJpaRepositories("io.github.susimsek.springbootgraphqljwedemo.repository")
@EnableJpaAuditing(auditorAwareRef = "springSecurityAuditorAware")
@EnableTransactionManagement
class DatabaseConfig
</code></pre>
<p>GraphQLConfig</p>
<h3>Java</h3>
<pre><code class="language-java">package io.github.susimsek.springbootgraphqljwedemo.config;

import graphql.scalars.ExtendedScalars;
import io.github.susimsek.springbootgraphqljwedemo.scalar.InstantScalar;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.graphql.execution.RuntimeWiringConfigurer;

@Configuration
public class GraphQLConfig {

  @Bean
  public RuntimeWiringConfigurer runtimeWiringConfigurer() {
    return wiring -> wiring
      .scalar(ExtendedScalars.GraphQLLong)
      .scalar(ExtendedScalars.Date)
      .scalar(InstantScalar.INSTANCE);
  }
}
</code></pre>
<h3>Kotlin</h3>
<pre><code class="language-kotlin">package io.github.susimsek.springbootgraphqljwedemo.config

import graphql.scalars.ExtendedScalars
import io.github.susimsek.springbootgraphqljwedemo.scalar.InstantScalar
import org.springframework.context.annotation.Bean
import org.springframework.context.annotation.Configuration
import org.springframework.graphql.execution.RuntimeWiringConfigurer

@Configuration
class GraphQLConfig {

  @Bean
  fun runtimeWiringConfigurer(): RuntimeWiringConfigurer {
    return RuntimeWiringConfigurer { wiring ->
      wiring
        .scalar(ExtendedScalars.GraphQLLong)
        .scalar(ExtendedScalars.Date)
        .scalar(InstantScalar.INSTANCE)
    }
  }
}
</code></pre>
<p>InstantScalar</p>
<h3>Java</h3>
<pre><code class="language-java">package io.github.susimsek.springbootgraphqljwedemo.scalar;

import graphql.GraphQLContext;
import graphql.execution.CoercedVariables;
import graphql.language.StringValue;
import graphql.language.Value;
import graphql.scalars.util.Kit;
import graphql.schema.Coercing;
import graphql.schema.CoercingParseLiteralException;
import graphql.schema.CoercingParseValueException;
import graphql.schema.CoercingSerializeException;
import graphql.schema.GraphQLScalarType;
import lombok.AccessLevel;
import lombok.NoArgsConstructor;
import org.springframework.lang.NonNull;

import java.time.Instant;
import java.time.format.DateTimeParseException;
import java.util.Locale;

@NoArgsConstructor(access = AccessLevel.PRIVATE)
public final class InstantScalar {

  public static final GraphQLScalarType INSTANCE;

  static {
    Coercing&#x3C;Instant, String> coercing = new Coercing&#x3C;>() {
      @Override
      public String serialize(
        @NonNull Object input,
        @NonNull GraphQLContext context,
        @NonNull Locale locale
      ) throws CoercingSerializeException {
        if (input instanceof Instant instant) {
          return instant.toString();
        }
        throw new CoercingSerializeException(
          "Expected java.time.Instant but was: " + Kit.typeName(input) + "'."
        );
      }

      @Override
      public Instant parseValue(
        @NonNull Object input,
        @NonNull GraphQLContext context,
        @NonNull Locale locale
      ) throws CoercingParseValueException {
        if (input instanceof String s) {
          try {
            return Instant.parse(s);
          } catch (DateTimeParseException e) {
            throw new CoercingParseValueException("Invalid Instant value: " + e.getMessage() + "'.");
          }
        }
        throw new CoercingParseValueException(
          "Expected a String for Instant but was: " + Kit.typeName(input) + "'."
        );
      }

      @Override
      public Instant parseLiteral(
        @NonNull Value&#x3C;?> input,
        @NonNull CoercedVariables variables,
        @NonNull GraphQLContext context,
        @NonNull Locale locale
      ) throws CoercingParseLiteralException {
        if (input instanceof StringValue sv) {
          String s = sv.getValue();
          try {
            return Instant.parse(s);
          } catch (DateTimeParseException e) {
            throw new CoercingParseLiteralException("Invalid Instant literal: " + e.getMessage() + "'");
          }
        }
        throw new CoercingParseLiteralException(
          "Expected AST type 'StringValue' but was: " + Kit.typeName(input) + "'."
        );
      }

      @Override
      @NonNull
      public Value&#x3C;?> valueToLiteral(
        @NonNull Object input,
        @NonNull GraphQLContext context,
        @NonNull Locale locale
      ) {
        String serialized = serialize(input, context, locale);
        return StringValue.newStringValue(serialized).build();
      }
    };

    INSTANCE = GraphQLScalarType.newScalar()
      .name("Instant")
      .description("An ISO-8601 compliant java.time.Instant scalar")
      .specifiedByUrl("https://www.rfc-editor.org/rfc/rfc3339.html#section-5.6")
      .coercing(coercing)
      .build();
  }
}
</code></pre>
<h3>Kotlin</h3>
<pre><code class="language-kotlin">package io.github.susimsek.springbootgraphqljwedemo.scalar

import graphql.GraphQLContext
import graphql.execution.CoercedVariables
import graphql.language.StringValue
import graphql.language.Value
import graphql.scalars.util.Kit
import graphql.schema.Coercing
import graphql.schema.CoercingParseLiteralException
import graphql.schema.CoercingParseValueException
import graphql.schema.CoercingSerializeException
import graphql.schema.GraphQLScalarType
import java.time.Instant
import java.time.format.DateTimeParseException
import java.util.Locale

object InstantScalar {

  @JvmField
  val INSTANCE: GraphQLScalarType = GraphQLScalarType.newScalar()
    .name("Instant")
    .description("An ISO-8601 compliant java.time.Instant scalar")
    .specifiedByUrl("https://www.rfc-editor.org/rfc/rfc3339.html#section-5.6")
    .coercing(object : Coercing&#x3C;Instant, String> {
      override fun serialize(
        input: Any,
        context: GraphQLContext,
        locale: Locale
      ): String {
        return if (input is Instant) {
          input.toString()
        } else {
          throw CoercingSerializeException("Expected java.time.Instant but was: ${Kit.typeName(input)}'.")
        }
      }

      override fun parseValue(
        input: Any,
        context: GraphQLContext,
        locale: Locale
      ): Instant {
        if (input is String) {
          return try {
            Instant.parse(input)
          } catch (e: DateTimeParseException) {
            throw CoercingParseValueException("Invalid Instant value: ${e.message}'.")
          }
        }
        throw CoercingParseValueException("Expected a String for Instant but was: ${Kit.typeName(input)}'.")
      }

      override fun parseLiteral(
        input: Value&#x3C;*>,
        variables: CoercedVariables,
        context: GraphQLContext,
        locale: Locale
      ): Instant {
        if (input is StringValue) {
          return try {
            Instant.parse(input.value)
          } catch (e: DateTimeParseException) {
            throw CoercingParseLiteralException("Invalid Instant literal: ${e.message}'")
          }
        }
        throw CoercingParseLiteralException("Expected AST type 'StringValue' but was: ${Kit.typeName(input)}'.")
      }

      override fun valueToLiteral(
        input: Any,
        context: GraphQLContext,
        locale: Locale
      ): Value&#x3C;*> {
        val serialized = serialize(input, context, locale)
        return StringValue.newStringValue(serialized).build()
      }
    })
    .build()
}
</code></pre>
<p>NativeConfig</p>
<h3>Java</h3>
<pre><code class="language-java">package io.github.susimsek.springbootgraphqljwedemo.config;

import org.springframework.aot.hint.MemberCategory;
import org.springframework.aot.hint.RuntimeHints;
import org.springframework.aot.hint.RuntimeHintsRegistrar;

public class NativeConfig {

  public static class AppNativeRuntimeHints implements RuntimeHintsRegistrar {

    @Override
    public void registerHints(RuntimeHints hints, ClassLoader classLoader) {
      hints.reflection()
        .registerType(sun.misc.Unsafe.class,
          hint -> hint.withMembers(MemberCategory.INVOKE_PUBLIC_METHODS));
      hints.reflection()
        .registerType(java.util.Locale.class,
          hint -> hint.withMembers(MemberCategory.INVOKE_PUBLIC_METHODS));
      hints.reflection()
        .registerType(org.hibernate.binder.internal.BatchSizeBinder.class,
          hint -> hint.withMembers(MemberCategory.INVOKE_PUBLIC_CONSTRUCTORS));
      hints.resources().registerPattern("liquibase/*");
      hints.reflection()
        .registerType(liquibase.ui.LoggerUIService.class,
          hint -> hint.withMembers(MemberCategory.INVOKE_PUBLIC_CONSTRUCTORS));
      hints.reflection()
        .registerType(liquibase.database.LiquibaseTableNamesFactory.class,
          hint -> hint.withMembers(MemberCategory.INVOKE_DECLARED_CONSTRUCTORS));
      hints.reflection()
        .registerType(liquibase.report.ShowSummaryGeneratorFactory.class,
          hint -> hint.withMembers(MemberCategory.INVOKE_DECLARED_CONSTRUCTORS));
      hints.reflection()
        .registerType(liquibase.changelog.FastCheckService.class,
          hint -> hint.withMembers(MemberCategory.INVOKE_DECLARED_CONSTRUCTORS));
      hints.reflection()
        .registerType(liquibase.changelog.visitor.ValidatingVisitorGeneratorFactory.class,
          hint -> hint.withMembers(MemberCategory.INVOKE_DECLARED_CONSTRUCTORS));
    }
  }
}
</code></pre>
<h3>Kotlin</h3>
<pre><code class="language-kotlin">package io.github.susimsek.springbootgraphqljwedemo.config

import org.springframework.aot.hint.MemberCategory
import org.springframework.aot.hint.RuntimeHints
import org.springframework.aot.hint.RuntimeHintsRegistrar

class NativeConfig {

  class AppNativeRuntimeHints : RuntimeHintsRegistrar {
    override fun registerHints(hints: RuntimeHints, classLoader: ClassLoader) {
      hints.reflection().registerType(
        sun.misc.Unsafe::class.java,
        hint = hint@{ it.withMembers(MemberCategory.INVOKE_PUBLIC_METHODS) }
      )
      hints.reflection().registerType(
        java.util.Locale::class.java,
        hint = hint@{ it.withMembers(MemberCategory.INVOKE_PUBLIC_METHODS) }
      )
      hints.reflection().registerType(
        org.hibernate.binder.internal.BatchSizeBinder::class.java,
        hint = hint@{ it.withMembers(MemberCategory.INVOKE_PUBLIC_CONSTRUCTORS) }
      )
      hints.resources().registerPattern("liquibase/*")
      hints.reflection().registerType(
        liquibase.ui.LoggerUIService::class.java,
        hint = hint@{ it.withMembers(MemberCategory.INVOKE_PUBLIC_CONSTRUCTORS) }
      )
      hints.reflection().registerType(
        liquibase.database.LiquibaseTableNamesFactory::class.java,
        hint = hint@{ it.withMembers(MemberCategory.INVOKE_DECLARED_CONSTRUCTORS) }
      )
      hints.reflection().registerType(
        liquibase.report.ShowSummaryGeneratorFactory::class.java,
        hint = hint@{ it.withMembers(MemberCategory.INVOKE_DECLARED_CONSTRUCTORS) }
      )
      hints.reflection().registerType(
        liquibase.changelog.FastCheckService::class.java,
        hint = hint@{ it.withMembers(MemberCategory.INVOKE_DECLARED_CONSTRUCTORS) }
      )
      hints.reflection().registerType(
        liquibase.changelog.visitor.ValidatingVisitorGeneratorFactory::class.java,
        hint = hint@{ it.withMembers(MemberCategory.INVOKE_DECLARED_CONSTRUCTORS) }
      )
    }
  }
}
</code></pre>
<p>Main</p>
<h3>Java</h3>
<pre><code class="language-java">package io.github.susimsek.springbootgraphqljwedemo;

import io.github.susimsek.springbootgraphqljwedemo.config.NativeConfig;
import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;
import org.springframework.context.annotation.ImportRuntimeHints;

@SpringBootApplication
@ImportRuntimeHints({ NativeConfig.AppNativeRuntimeHints.class })
public class SpringBootJweAuthJpaDemoApplication {

  public static void main(String[] args) {
    SpringApplication.run(SpringBootJweAuthJpaDemoApplication.class, args);
  }

}
</code></pre>
<h3>Kotlin</h3>
<pre><code class="language-kotlin">package io.github.susimsek.springbootgraphqljwedemo

import io.github.susimsek.springbootgraphqljwedemo.config.NativeConfig
import org.springframework.boot.autoconfigure.SpringBootApplication
import org.springframework.boot.runApplication
import org.springframework.context.annotation.ImportRuntimeHints

@SpringBootApplication
@ImportRuntimeHints(NativeConfig.AppNativeRuntimeHints::class)
class SpringBootJweAuthJpaDemoApplication

fun main(args: Array&#x3C;String>) {
  runApplication&#x3C;SpringBootJweAuthJpaDemoApplication>(*args)
}
</code></pre>
<hr>
<h2>ğŸ› ï¸ AdÄ±m 4: JPA Entegrasyonu</h2>
<p>Bu bÃ¶lÃ¼mde, kullanÄ±cÄ±larÄ±, rollerleri ve bunlarÄ±n eÅŸlemelerini temsil eden JPA entityâ€™lerini ve kullanÄ±cÄ±larÄ± yetkileriyle birlikte yÃ¼klemek iÃ§in Spring Data JPA deposunu tanÄ±mlÄ±yoruz.</p>
<ul>
<li>BaseEntity: Audit alanlarÄ± (<code>createdAt</code>, <code>createdBy</code>, <code>updatedAt</code>, <code>updatedBy</code>) saÄŸlayan soyut Ã¼st sÄ±nÄ±f.</li>
<li>Authority: Rol verilerini saklayan <code>authority</code> tablosu entityâ€™si.</li>
<li>User: KullanÄ±cÄ± kimlik bilgileri ve profili saklayan <code>user_identity</code> tablosu entityâ€™si.</li>
<li>UserAuthorityMapping: KullanÄ±cÄ±larÄ± ve rolleri birbirine baÄŸlayan <code>user_authority_mapping</code> iliÅŸki tablosunun entityâ€™si.</li>
<li>UserAuthorityMappingId: <code>UserAuthorityMapping</code> iÃ§in composite anahtar sÄ±nÄ±fÄ±.</li>
<li>UserRepository: Entity graph kullanarak kullanÄ±cÄ± ve yetkilerini getiren Spring Data JPA repository.</li>
</ul>
<p>BaseEntity</p>
<h3>Java</h3>
<pre><code class="language-java">package io.github.susimsek.springbootgraphqljwedemo.entity;

import jakarta.persistence.Column;
import jakarta.persistence.EntityListeners;
import jakarta.persistence.MappedSuperclass;
import lombok.Getter;
import lombok.Setter;
import org.springframework.data.annotation.CreatedBy;
import org.springframework.data.annotation.CreatedDate;
import org.springframework.data.annotation.LastModifiedBy;
import org.springframework.data.annotation.LastModifiedDate;
import org.springframework.data.jpa.domain.support.AuditingEntityListener;

import java.time.Instant;

@MappedSuperclass
@EntityListeners(AuditingEntityListener.class)
@Getter
@Setter
public abstract class BaseEntity {

  @CreatedDate
  @Column(name = "created_at", nullable = false, updatable = false)
  private Instant createdAt;

  @CreatedBy
  @Column(name = "created_by", nullable = false, updatable = false, length = 50)
  private String createdBy;

  @LastModifiedDate
  @Column(name = "updated_at")
  private Instant updatedAt;

  @LastModifiedBy
  @Column(name = "updated_by", length = 50)
  private String updatedBy;
}
</code></pre>
<h3>Kotlin</h3>
<pre><code class="language-kotlin">package io.github.susimsek.springbootgraphqljwedemo.entity

import jakarta.persistence.Column
import jakarta.persistence.EntityListeners
import jakarta.persistence.MappedSuperclass
import org.springframework.data.annotation.CreatedBy
import org.springframework.data.annotation.CreatedDate
import org.springframework.data.annotation.LastModifiedBy
import org.springframework.data.annotation.LastModifiedDate
import org.springframework.data.jpa.domain.support.AuditingEntityListener
import java.time.Instant

@MappedSuperclass
@EntityListeners(AuditingEntityListener::class)
abstract class BaseEntity {

  @CreatedDate
  @Column(name = "created_at", nullable = false, updatable = false)
  lateinit var createdAt: Instant

  @CreatedBy
  @Column(name = "created_by", nullable = false, updatable = false, length = 50)
  lateinit var createdBy: String

  @LastModifiedDate
  @Column(name = "updated_at")
  var updatedAt: Instant? = null

  @LastModifiedBy
  @Column(name = "updated_by", length = 50)
  var updatedBy: String? = null
}
</code></pre>
<p>Authority</p>
<h3>Java</h3>
<pre><code class="language-java">package io.github.susimsek.springbootgraphqljwedemo.entity;

import jakarta.persistence.Column;
import jakarta.persistence.Entity;
import jakarta.persistence.Id;
import jakarta.persistence.Table;
import lombok.AllArgsConstructor;
import lombok.Getter;
import lombok.NoArgsConstructor;
import lombok.Setter;
import org.hibernate.proxy.HibernateProxy;

import java.util.Objects;

@Entity
@Table(name = "authority")
@Getter
@Setter
@NoArgsConstructor
@AllArgsConstructor
public class Authority extends BaseEntity {

  @Id
  @Column(length = 36, nullable = false)
  private String id;

  @Column(length = 50, nullable = false, unique = true)
  private String name;

  @Column(length = 255)
  private String description;

  @Override
  public final boolean equals(Object obj) {
    if (this == obj) {
      return true;
    }
    if (!(obj instanceof Authority other)) {
      return false;
    }
    Class&#x3C;?> objClass = obj instanceof HibernateProxy proxy
      ? proxy.getHibernateLazyInitializer().getPersistentClass()
      : obj.getClass();
    Class&#x3C;?> thisClass = this instanceof HibernateProxy proxy
      ? proxy.getHibernateLazyInitializer().getPersistentClass()
      : this.getClass();
    if (!thisClass.equals(objClass)) {
      return false;
    }
    return id != null &#x26;&#x26; Objects.equals(id, other.id);
  }

  @Override
  public final int hashCode() {
    return this instanceof HibernateProxy proxy
      ? proxy.getHibernateLazyInitializer().getPersistentClass().hashCode()
      : getClass().hashCode();
  }
}
</code></pre>
<h3>Kotlin</h3>
<pre><code class="language-kotlin">package io.github.susimsek.springbootgraphqljwedemo.entity

import jakarta.persistence.Column
import jakarta.persistence.Entity
import jakarta.persistence.Id
import jakarta.persistence.Table
import org.hibernate.proxy.HibernateProxy
import java.util.Objects

@Entity
@Table(name = "authority")
class Authority(
  @Id
  @Column(length = 36, nullable = false)
  var id: String,

  @Column(length = 50, nullable = false, unique = true)
  var name: String,

  @Column(length = 255)
  var description: String?
) : BaseEntity() {

  override fun equals(other: Any?): Boolean {
    if (this === other) return true
    if (other !is Authority) return false
    val objClass = (other as? HibernateProxy)?.hibernateLazyInitializer?.persistentClass ?: other::class.java
    val thisClass = (this as? HibernateProxy)?.hibernateLazyInitializer?.persistentClass ?: this::class.java
    if (thisClass != objClass) return false
    return id == other.id
  }

  override fun hashCode(): Int {
    return (this as? HibernateProxy)?.hibernateLazyInitializer?.persistentClass?.hashCode()
      ?: javaClass.hashCode()
  }
}
</code></pre>
<p>User</p>
<h3>Java</h3>
<pre><code class="language-java">package io.github.susimsek.springbootgraphqljwedemo.entity;

import jakarta.persistence.CascadeType;
import jakarta.persistence.Column;
import jakarta.persistence.Entity;
import jakarta.persistence.FetchType;
import jakarta.persistence.Id;
import jakarta.persistence.NamedAttributeNode;
import jakarta.persistence.NamedEntityGraph;
import jakarta.persistence.NamedSubgraph;
import jakarta.persistence.OneToMany;
import jakarta.persistence.Table;
import lombok.AllArgsConstructor;
import lombok.Getter;
import lombok.NoArgsConstructor;
import lombok.Setter;
import org.hibernate.proxy.HibernateProxy;

import java.util.HashSet;
import java.util.Objects;
import java.util.Set;

@Entity
@Table(name = "user_identity")
@Getter
@Setter
@NoArgsConstructor
@AllArgsConstructor
@NamedEntityGraph(
  name = "User.withAuthorities",
  attributeNodes = @NamedAttributeNode(value = "authorities", subgraph = "auth-subgraph"),
  subgraphs = @NamedSubgraph(
    name = "auth-subgraph",
    attributeNodes = @NamedAttributeNode("authority")
  )
)
public class User extends BaseEntity {

  @Id
  @Column(name = "id", length = 36, nullable = false, updatable = false)
  private String id;

  @Column(name = "username", length = 50, nullable = false, unique = true)
  private String username;

  @Column(name = "password", length = 100, nullable = false)
  private String password;

  @Column(name = "email", length = 100, nullable = false, unique = true)
  private String email;

  @Column(name = "first_name", length = 50)
  private String firstName;

  @Column(name = "last_name", length = 50)
  private String lastName;

  @Column(name = "enabled", nullable = false)
  private boolean enabled;

  @OneToMany(mappedBy = "user", fetch = FetchType.LAZY,
    cascade = CascadeType.ALL, orphanRemoval = true)
  private Set&#x3C;UserAuthorityMapping> authorities = new HashSet&#x3C;>();

  @Override
  public final boolean equals(Object obj) {
    if (this == obj) return true;
    if (!(obj instanceof User other)) return false;
    Class&#x3C;?> objClass = (obj instanceof HibernateProxy hp
      ? hp.getHibernateLazyInitializer().getPersistentClass()
      : obj.getClass());
    Class&#x3C;?> thisClass = (this instanceof HibernateProxy hp
      ? hp.getHibernateLazyInitializer().getPersistentClass()
      : this.getClass());
    if (!thisClass.equals(objClass)) return false;
    return id != null &#x26;&#x26; id.equals(other.id);
  }

  @Override
  public final int hashCode() {
    return (this instanceof HibernateProxy hp
      ? hp.getHibernateLazyInitializer().getPersistentClass().hashCode()
      : getClass().hashCode());
  }
}
</code></pre>
<h3>Kotlin</h3>
<pre><code class="language-kotlin">package io.github.susimsek.springbootgraphqljwedemo.entity

import jakarta.persistence.CascadeType
import jakarta.persistence.Column
import jakarta.persistence.Entity
import jakarta.persistence.FetchType
import jakarta.persistence.Id
import jakarta.persistence.NamedAttributeNode
import jakarta.persistence.NamedEntityGraph
import jakarta.persistence.NamedSubgraph
import jakarta.persistence.OneToMany
import jakarta.persistence.Table
import org.hibernate.proxy.HibernateProxy
import java.util.*

@Entity
@Table(name = "user_identity")
@NamedEntityGraph(
  name = "User.withAuthorities",
  attributeNodes = [NamedAttributeNode(value = "authorities", subgraph = "auth-subgraph")],
  subgraphs = [
    NamedSubgraph(
      name = "auth-subgraph",
      attributeNodes = [NamedAttributeNode("authority")]
    )
  ]
)
class User(

  @Id
  @Column(name = "id", length = 36, nullable = false, updatable = false)
  var id: String,

  @Column(name = "username", length = 50, nullable = false, unique = true)
  var username: String,

  @Column(name = "password", length = 100, nullable = false)
  var password: String,

  @Column(name = "email", length = 100, nullable = false, unique = true)
  var email: String,

  @Column(name = "first_name", length = 50)
  var firstName: String? = null,

  @Column(name = "last_name", length = 50)
  var lastName: String? = null,

  @Column(name = "enabled", nullable = false)
  var enabled: Boolean = true

) : BaseEntity() {

  @OneToMany(
    mappedBy = "user",
    fetch = FetchType.LAZY,
    cascade = [CascadeType.ALL],
    orphanRemoval = true
  )
  var authorities: MutableSet&#x3C;UserAuthorityMapping> = HashSet()

  override fun equals(other: Any?): Boolean {
    if (this === other) return true
    if (other !is User) return false
    val objClass = (other as? HibernateProxy)?.hibernateLazyInitializer?.persistentClass
      ?: other::class.java
    val thisClass = (this as? HibernateProxy)?.hibernateLazyInitializer?.persistentClass
      ?: this::class.java
    if (thisClass != objClass) return false
    return id == other.id
  }

  override fun hashCode(): Int =
    ((this as? HibernateProxy)?.hibernateLazyInitializer?.persistentClass?.hashCode()
      ?: javaClass.hashCode())
}
</code></pre>
<p>UserAuthorityMapping</p>
<h3>Java</h3>
<pre><code class="language-java">package io.github.susimsek.springbootgraphqljwedemo.entity;

import jakarta.persistence.Column;
import jakarta.persistence.Entity;
import jakarta.persistence.FetchType;
import jakarta.persistence.Id;
import jakarta.persistence.IdClass;
import jakarta.persistence.JoinColumn;
import jakarta.persistence.ManyToOne;
import jakarta.persistence.Table;
import lombok.AllArgsConstructor;
import lombok.Getter;
import lombok.NoArgsConstructor;
import lombok.Setter;
import org.hibernate.proxy.HibernateProxy;

import java.util.Objects;

@Entity
@Table(name = "user_authority_mapping")
@IdClass(UserAuthorityMappingId.class)
@Getter
@Setter
@NoArgsConstructor
@AllArgsConstructor
public class UserAuthorityMapping extends BaseEntity {

  @Id
  @Column(name = "user_id", length = 36, nullable = false)
  private String userId;

  @Id
  @Column(name = "authority_id", length = 36, nullable = false)
  private String authorityId;

  @ManyToOne(fetch = FetchType.LAZY)
  @JoinColumn(name = "user_id", insertable = false, updatable = false)
  private User user;

  @ManyToOne(fetch = FetchType.LAZY)
  @JoinColumn(name = "authority_id", insertable = false, updatable = false)
  private Authority authority;

  @Override
  public final boolean equals(Object obj) {
    if (this == obj) return true;
    if (!(obj instanceof UserAuthorityMapping other)) return false;
    Class&#x3C;?> objCls = (obj instanceof HibernateProxy hp
      ? hp.getHibernateLazyInitializer().getPersistentClass()
      : obj.getClass());
    Class&#x3C;?> thisCls = (this instanceof HibernateProxy hp
      ? hp.getHibernateLazyInitializer().getPersistentClass()
      : this.getClass());
    if (!thisCls.equals(objCls)) return false;
    return userId != null &#x26;&#x26; userId.equals(other.userId)
      &#x26;&#x26; authorityId != null &#x26;&#x26; authorityId.equals(other.authorityId);
  }

  @Override
  public final int hashCode() {
    return (this instanceof HibernateProxy hp
      ? hp.getHibernateLazyInitializer().getPersistentClass().hashCode()
      : Objects.hash(userId, authorityId));
  }
}
</code></pre>
<h3>Kotlin</h3>
<pre><code class="language-kotlin">package io.github.susimsek.springbootgraphqljwedemo.entity

import jakarta.persistence.*
import org.hibernate.proxy.HibernateProxy
import java.util.*

@Entity
@Table(name = "user_authority_mapping")
@IdClass(UserAuthorityMappingId::class)
data class UserAuthorityMapping(

  @Id
  @Column(name = "user_id", length = 36, nullable = false)
  var userId: String = "",

  @Id
  @Column(name = "authority_id", length = 36, nullable = false)
  var authorityId: String = "",

  @ManyToOne(fetch = FetchType.LAZY)
  @JoinColumn(name = "user_id", insertable = false, updatable = false)
  var user: User? = null,

  @ManyToOne(fetch = FetchType.LAZY)
  @JoinColumn(name = "authority_id", insertable = false, updatable = false)
  var authority: Authority? = null

) : BaseEntity() {

  override fun equals(other: Any?): Boolean {
    if (this === other) return true
    if (other !is UserAuthorityMapping) return false

    val objCls = (other as? HibernateProxy)?.hibernateLazyInitializer?.persistentClass
      ?: other::class.java
    val thisCls = (this as? HibernateProxy)?.hibernateLazyInitializer?.persistentClass
      ?: this::class.java

    if (thisCls != objCls) return false
    return userId == other.userId &#x26;&#x26; authorityId == other.authorityId
  }

  override fun hashCode(): Int {
    return (this as? HibernateProxy)?.hibernateLazyInitializer?.persistentClass?.hashCode()
      ?: Objects.hash(userId, authorityId)
  }
}
</code></pre>
<p>UserAuthorityMappingId</p>
<h3>Java</h3>
<pre><code class="language-java">package io.github.susimsek.springbootgraphqljwedemo.entity;

import java.io.Serializable;
import java.util.Objects;
import lombok.AllArgsConstructor;
import lombok.Getter;
import lombok.NoArgsConstructor;
import lombok.Setter;

@Getter
@Setter
@NoArgsConstructor
@AllArgsConstructor
public class UserAuthorityMappingId implements Serializable {

  private String userId;
  private String authorityId;

  @Override
  public boolean equals(Object o) {
    if (this == o) return true;
    if (o == null || getClass() != o.getClass()) return false;
    UserAuthorityMappingId that = (UserAuthorityMappingId) o;
    return Objects.equals(userId, that.userId) &#x26;&#x26;
      Objects.equals(authorityId, that.authorityId);
  }

  @Override
  public int hashCode() {
    return Objects.hash(userId, authorityId);
  }
}
</code></pre>
<h3>Kotlin</h3>
<pre><code class="language-kotlin">package io.github.susimsek.springbootgraphqljwedemo.entity

import java.io.Serializable
import java.util.Objects

data class UserAuthorityMappingId(
  var userId: String = "",
  var authorityId: String = ""
) : Serializable {

  override fun equals(other: Any?): Boolean {
    if (this === other) return true
    if (other == null || this::class != other::class) return false
    other as UserAuthorityMappingId
    return userId == other.userId &#x26;&#x26; authorityId == other.authorityId
  }

  override fun hashCode(): Int {
    return Objects.hash(userId, authorityId)
  }
}
</code></pre>
<p>UserRepository</p>
<h3>Java</h3>
<pre><code class="language-java">package io.github.susimsek.springbootgraphqljwedemo.repository;

import io.github.susimsek.springbootgraphqljwedemo.entity.User;
import org.springframework.data.jpa.repository.EntityGraph;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.stereotype.Repository;

import java.util.Optional;

@Repository
public interface UserRepository extends JpaRepository&#x3C;User, String> {

  @EntityGraph("User.withAuthorities")
  Optional&#x3C;User> findOneWithAuthoritiesByUsername(String username);
}
</code></pre>
<h3>Kotlin</h3>
<pre><code class="language-kotlin">package io.github.susimsek.springbootgraphqljwedemo.repository

import io.github.susimsek.springbootgraphqljwedemo.entity.User
import org.springframework.data.jpa.repository.EntityGraph
import org.springframework.data.jpa.repository.JpaRepository
import org.springframework.stereotype.Repository
import java.util.Optional

@Repository
interface UserRepository : JpaRepository&#x3C;User, String> {

  @EntityGraph("User.withAuthorities")
  fun findOneWithAuthoritiesByUsername(username: String): Optional&#x3C;User>
}
</code></pre>
<hr>
<h2>ğŸ› ï¸ AdÄ±m 5: GÃ¼venli JWE Token YardÄ±mcÄ± SÄ±nÄ±flarÄ± OluÅŸturun</h2>
<p>Bu bÃ¶lÃ¼mde, Spring Boot uygulamanÄ±zda JSON Web Encryption (JWE) tokenlarÄ± oluÅŸturmak, ÅŸifrelemek ve Ã§Ã¶zmek iÃ§in gerekli temel yardÄ±mcÄ± sÄ±nÄ±flarÄ± ve sabitleri tanÄ±mlÄ±yoruz. AyrÄ±ca auditing entegrasyonu ve JPA tabanlÄ± UserDetailsService de ekliyoruz:</p>
<ul>
<li>AuthoritiesConstants: <code>ROLE_</code> Ã¶n ekiyle rol isimlerini merkezileÅŸtirir.</li>
<li>CookieBearerTokenResolver: Bearer tokenâ€™larÄ± yetkilendirme baÅŸlÄ±klarÄ±ndan veya HTTP Ã§erezlerinden Ã§Ã¶zer.</li>
<li>CookieUtils: Yeni veya sÃ¼resi dolmuÅŸ tokenâ€™ler iÃ§in HTTP-only, secure <code>ResponseCookie</code> oluÅŸturur ve <code>HttpHeaders</code> iÃ§inden <code>accessToken</code> deÄŸerini Ã§Ä±kartÄ±r.</li>
<li>JweUtil: Nimbus kÃ¼tÃ¼phanesi ile RSA anahtarlarÄ± kullanarak JWTâ€™leri imzalar (JWS) ve ÅŸifreler (JWE).</li>
<li>KeyUtils: PEM formatÄ±ndaki anahtar Ã§iftinden RSA JWKâ€™leri oluÅŸturur.</li>
<li>SecurityUtils: SecurityContext oturum aÃ§an kullanÄ±cÄ±nÄ±n bilgisini sunar.</li>
<li>SpringSecurityAuditorAware: Auditing iÃ§in oturum aÃ§an kullanÄ±cÄ±yÄ± saÄŸlayan <code>AuditorAware</code> implementasyonu.</li>
<li>DomainUserDetailsService: JPA tabanlÄ± <code>UserDetailsService</code>, kullanÄ±cÄ± kimlik bilgilerini ve yetkilerini getirir.</li>
<li>GraphQlTokenCookieInterceptor: GraphQL yanÄ±tlarÄ±nÄ± yakalar ve <code>GraphQLContext</code> iÃ§indeki <code>accessToken</code> veya <code>clearAccessToken</code> flaglerine gÃ¶re eriÅŸim Ã§erezini oluÅŸturur veya siler.</li>
<li>CookieAuthenticationWebSocketInterceptor: Headerdan veya Ã§erezlerden alÄ±nan JWE tokenâ€™larla WebSocket baÄŸlantÄ±larÄ±nÄ± doÄŸrular.</li>
</ul>
<p>Bu yardÄ±mcÄ±lar, Spring Security ile durumsuz (stateless) JWE tabanlÄ± bir kimlik doÄŸrulama akÄ±ÅŸÄ±nÄ±n temelini oluÅŸturur.</p>
<p>AuthoritiesConstants</p>
<h3>Java</h3>
<pre><code class="language-java">
package io.github.susimsek.springbootgraphqljwedemo.security;

import lombok.AccessLevel;
import lombok.NoArgsConstructor;

@NoArgsConstructor(access = AccessLevel.PRIVATE)
public final class AuthoritiesConstants {
    public static final String ADMIN = "ROLE_ADMIN";
    public static final String USER = "ROLE_USER";
    public static final String ANONYMOUS = "ROLE_ANONYMOUS";
}
</code></pre>
<h3>Kotlin</h3>
<pre><code class="language-kotlin">
package io.github.susimsek.springbootgraphqljwedemo.security

object AuthoritiesConstants {
  const val ADMIN = "ROLE_ADMIN"
  const val USER = "ROLE_USER"
  const val ANONYMOUS = "ROLE_ANONYMOUS"
}
</code></pre>
<p>CookieBearerTokenResolver</p>
<h3>Java</h3>
<pre><code class="language-java">package io.github.susimsek.springbootgraphqljwedemo.security;

import jakarta.servlet.http.Cookie;
import jakarta.servlet.http.HttpServletRequest;
import lombok.Setter;
import org.springframework.http.HttpMethod;
import org.springframework.security.oauth2.core.OAuth2AuthenticationException;
import org.springframework.security.oauth2.server.resource.BearerTokenError;
import org.springframework.security.oauth2.server.resource.BearerTokenErrors;
import org.springframework.security.oauth2.server.resource.web.BearerTokenResolver;
import org.springframework.util.StringUtils;

import java.util.regex.Matcher;
import java.util.regex.Pattern;

@Setter
public class CookieBearerTokenResolver implements BearerTokenResolver {
    private static final String ACCESS_TOKEN_PARAMETER_NAME = "access_token";
    private static final Pattern AUTHORIZATION_PATTERN =
        Pattern.compile("^Bearer (?&#x3C;token>[A-Za-z0-9-._~+/]+=*)$", Pattern.CASE_INSENSITIVE);

    private boolean allowFormEncodedBodyParameter = false;
    private boolean allowUriQueryParameter       = false;
    private boolean allowCookie                  = true;
    private String  bearerTokenHeaderName       = "Authorization";
    private String  cookieName                  = "accessToken";

    @Override
    public String resolve(HttpServletRequest request) {
        String headerToken = resolveFromAuthorizationHeader(request);
        String queryToken  = resolveAccessTokenFromQueryString(request);
        String bodyToken   = resolveAccessTokenFromBody(request);
        String cookieToken = (headerToken == null &#x26;&#x26; queryToken == null &#x26;&#x26; bodyToken == null)
            ? resolveFromCookie(request)
            : null;

        return resolveToken(headerToken, queryToken, bodyToken, cookieToken);
    }

    private String resolveFromAuthorizationHeader(HttpServletRequest request) {
        String authorization = request.getHeader(this.bearerTokenHeaderName);
        if (!StringUtils.hasText(authorization) || !authorization.toLowerCase().startsWith("bearer")) {
            return null;
        }
        Matcher matcher = AUTHORIZATION_PATTERN.matcher(authorization.trim());
        if (!matcher.matches()) {
            BearerTokenError error = BearerTokenErrors.invalidToken("Bearer token is malformed");
            throw new OAuth2AuthenticationException(error);
        }
        return matcher.group("token");
    }

    private String resolveAccessTokenFromQueryString(HttpServletRequest request) {
        if (allowUriQueryParameter &#x26;&#x26; HttpMethod.GET.matches(request.getMethod())) {
            return resolveToken(request.getParameterValues(ACCESS_TOKEN_PARAMETER_NAME));
        }
        return null;
    }

    private String resolveAccessTokenFromBody(HttpServletRequest request) {
        if (allowFormEncodedBodyParameter
            &#x26;&#x26; HttpMethod.POST.matches(request.getMethod())
            &#x26;&#x26; "application/x-www-form-urlencoded".equals(request.getContentType())) {
            return resolveToken(request.getParameterValues(ACCESS_TOKEN_PARAMETER_NAME));
        }
        return null;
    }

    private String resolveFromCookie(HttpServletRequest request) {
        if (!allowCookie || request.getCookies() == null) {
            return null;
        }
        for (Cookie cookie : request.getCookies()) {
            if (cookieName.equals(cookie.getName())) {
                String val = cookie.getValue();
                return StringUtils.hasText(val) ? val : null;
            }
        }
        return null;
    }

    private String resolveToken(String... tokens) {
        String found = null;
        for (String token : tokens) {
            if (token == null) continue;
            if (found != null) {
                BearerTokenError error = BearerTokenErrors.invalidRequest("Found multiple bearer tokens in the request");
                throw new OAuth2AuthenticationException(error);
            }
            found = token;
        }
        if (found != null &#x26;&#x26; found.isBlank()) {
            BearerTokenError error = BearerTokenErrors.invalidRequest("The requested token parameter is an empty string");
            throw new OAuth2AuthenticationException(error);
        }
        return found;
    }
</code></pre>
<h3>Kotlin</h3>
<pre><code class="language-kotlin">package io.github.susimsek.springbootgraphqljwedemo.security

import jakarta.servlet.http.Cookie
import jakarta.servlet.http.HttpServletRequest
import org.springframework.http.HttpMethod
import org.springframework.security.oauth2.core.OAuth2AuthenticationException
import org.springframework.security.oauth2.server.resource.BearerTokenError
import org.springframework.security.oauth2.server.resource.BearerTokenErrors
import org.springframework.security.oauth2.server.resource.web.BearerTokenResolver
import org.springframework.util.StringUtils
import java.util.regex.Pattern

class CookieBearerTokenResolver {
    var allowFormEncodedBodyParameter: Boolean = false
    var allowUriQueryParameter: Boolean = false
    var allowCookie: Boolean = true
    var bearerTokenHeaderName: String = "Authorization"
    var cookieName: String = "accessToken"

    companion object {
        private const val ACCESS_TOKEN_PARAMETER_NAME = "access_token"
        private val AUTHORIZATION_PATTERN =
            Pattern.compile("^Bearer (?&#x3C;token>[A-Za-z0-9-._~+/]+=*)$", Pattern.CASE_INSENSITIVE)
    }

    fun resolve(request: HttpServletRequest): String? {
        val header = resolveFromAuthorizationHeader(request)
        val query  = if (allowUriQueryParameter &#x26;&#x26; HttpMethod.GET.matches(request.method))
            request.getParameterValues(ACCESS_TOKEN_PARAMETER_NAME)?.let(::resolveToken)
        else null
        val body   = if (allowFormEncodedBodyParameter &#x26;&#x26; HttpMethod.POST.matches(request.method)
            &#x26;&#x26; request.contentType == "application/x-www-form-urlencoded")
            request.getParameterValues(ACCESS_TOKEN_PARAMETER_NAME)?.let(::resolveToken)
        else null
        val cookie = if (header == null &#x26;&#x26; query == null &#x26;&#x26; body == null)
            resolveFromCookie(request)
        else null
      return listOf(header, query, body, cookie).filterNotNull().let {
            if (it.size > 1) throw OAuth2AuthenticationException(BearerTokenErrors.invalidRequest("Found multiple bearer tokens"))
            it.firstOrNull()?: null
        }
    }

    private fun resolveFromAuthorizationHeader(request: HttpServletRequest): String? {
        val auth = request.getHeader(bearerTokenHeaderName) ?: return null
        if (!auth.startsWith("Bearer ", true)) return null
        val matcher = AUTHORIZATION_PATTERN.matcher(auth.trim())
        return if (matcher.matches()) matcher.group("token")
        else throw OAuth2AuthenticationException(BearerTokenErrors.invalidToken("Malformed token"))
    }

    private fun resolveFromCookie(request: HttpServletRequest): String? {
        if (!allowCookie) return null
        return request.cookies?.firstOrNull { it.name == cookieName }?.value?.takeIf { it.isNotBlank() }
    }

    private fun resolveToken(tokens: Array&#x3C;String>): String? {
        return tokens.filter { it.isNotBlank() }.let {
            when {
                it.isEmpty() -> null
                it.size > 1   -> throw OAuth2AuthenticationException(BearerTokenErrors.invalidRequest("Multiple tokens"))
                else          -> it[0]
            }
        }
    }
</code></pre>
<p>CookieUtils</p>
<h3>Java</h3>
<pre><code class="language-java">package io.github.susimsek.springbootjweauthjpademo.security;

import io.github.susimsek.springbootjweauthjpademo.dto.TokenDTO;
import lombok.experimental.UtilityClass;
import org.springframework.http.HttpHeaders;
import org.springframework.http.ResponseCookie;

import java.net.HttpCookie;
import java.util.Arrays;
import java.util.Optional;

@UtilityClass
public class CookieUtils {

  public static final String COOKIE_NAME = "accessToken";

  public ResponseCookie createAccessTokenCookie(TokenDTO tokenDto) {
    return ResponseCookie.from(COOKIE_NAME, tokenDto.accessToken())
      .httpOnly(true)
      .secure(true)
      .path("/")
      .maxAge(tokenDto.accessTokenExpiresIn())
      .sameSite("Strict")
      .build();
  }

  public static ResponseCookie removeAccessTokenCookie() {
    return ResponseCookie.from(COOKIE_NAME, "")
      .httpOnly(true)
      .secure(true)
      .path("/")
      .maxAge(0)
      .sameSite("Strict")
      .build();
  }

  public String resolveToken(HttpHeaders headers) {
    return Optional.ofNullable(headers.getFirst(HttpHeaders.COOKIE))
      .map(h -> h.split(";"))
      .stream()
      .flatMap(Arrays::stream)
      .flatMap(part -> HttpCookie.parse(part).stream())
      .filter(c -> COOKIE_NAME.equals(c.getName()))
      .map(HttpCookie::getValue)
      .findFirst()
      .orElse(null);
  }
}
</code></pre>
<h3>Kotlin</h3>
<pre><code class="language-kotlin">package io.github.susimsek.springbootjweauthjpademo.security

import io.github.susimsek.springbootjweauthjpademo.dto.TokenDTO
import org.springframework.http.HttpHeaders
import org.springframework.http.ResponseCookie
import java.net.HttpCookie

object CookieUtils {

  const val COOKIE_NAME = "accessToken"

  fun createAccessTokenCookie(tokenDto: TokenDTO): ResponseCookie =
    ResponseCookie.from(COOKIE_NAME, tokenDto.accessToken())
      .httpOnly(true)
      .secure(true)
      .path("/")
      .maxAge(tokenDto.accessTokenExpiresIn())
      .sameSite("Strict")
      .build()

  fun removeAccessTokenCookie(): ResponseCookie =
    ResponseCookie.from(COOKIE_NAME, "")
      .httpOnly(true)
      .secure(true)
      .path("/")
      .maxAge(0)
      .sameSite("Strict")
      .build()

  fun resolveToken(headers: HttpHeaders): String? =
    headers.getFirst(HttpHeaders.COOKIE)
      ?.split(";")
      .orEmpty()
      .asSequence()
      .flatMap { HttpCookie.parse(it).asSequence() }
      .firstOrNull { it.name == COOKIE_NAME }
      ?.value
}
</code></pre>
<p>JweUtil</p>
<h3>Java</h3>
<pre><code class="language-java">package io.github.susimsek.springbootgraphqljwedemo.security;

import com.nimbusds.jose.EncryptionMethod;
import com.nimbusds.jose.JOSEException;
import com.nimbusds.jose.JWEAlgorithm;
import com.nimbusds.jose.JWEHeader;
import com.nimbusds.jose.JWEObject;
import com.nimbusds.jose.Payload;
import com.nimbusds.jose.crypto.RSAEncrypter;
import com.nimbusds.jose.jwk.RSAKey;
import io.github.susimsek.springbootgraphqljwedemo.config.JwtProperties;
import io.github.susimsek.springbootgraphqljwedemo.dto.TokenDTO;
import lombok.RequiredArgsConstructor;
import org.springframework.security.core.Authentication;
import org.springframework.security.core.GrantedAuthority;
import org.springframework.security.oauth2.jose.jws.SignatureAlgorithm;
import org.springframework.security.oauth2.jwt.*;
import org.springframework.stereotype.Component;

import java.time.Instant;
import java.util.List;

import static io.github.susimsek.springbootgraphqljwedemo.security.SecurityUtils.AUTHORITIES_KEY;

@Component
@RequiredArgsConstructor
public class JweUtil {

    private final JwtEncoder jwtEncoder;
    private final RSAKey signingKey;
    private final RSAKey encryptionKey;
    private final JwtProperties props;

    public TokenDTO generateToken(Authentication authentication) throws JOSEException {
        String subject = authentication.getName();
        List&#x3C;String> roles = authentication.getAuthorities()
            .stream()
            .map(GrantedAuthority::getAuthority)
            .toList();

        Instant now = Instant.now();
        long expiresIn = props.getExpirationDuration().getSeconds();
        Instant exp = now.plusSeconds(expiresIn);

        JwtClaimsSet claims = JwtClaimsSet.builder()
            .issuer(props.getIssuer())
            .issuedAt(now)
            .expiresAt(exp)
            .subject(subject)
            .claim(AUTHORITIES_KEY, roles)
            .build();

        JwsHeader jwsHeader = JwsHeader.with(SignatureAlgorithm.RS256)
            .keyId(signingKey.getKeyID())
            .build();

        String jws = jwtEncoder
            .encode(JwtEncoderParameters.from(jwsHeader, claims))
            .getTokenValue();

        JWEHeader jweHeader = new JWEHeader.Builder(JWEAlgorithm.RSA_OAEP_256, EncryptionMethod.A128GCM)
            .contentType("JWT")
            .keyID(encryptionKey.getKeyID())
            .build();

        JWEObject jweObject = new JWEObject(jweHeader, new Payload(jws));
        jweObject.encrypt(new RSAEncrypter(encryptionKey.toRSAPublicKey()));
        String token = jweObject.serialize();

        return new TokenDTO(token, "Bearer", expiresIn);
    }
}
</code></pre>
<h3>Kotlin</h3>
<pre><code class="language-kotlin">package io.github.susimsek.springbootgraphqljwedemo.security

import com.nimbusds.jose.EncryptionMethod
import com.nimbusds.jose.JOSEException
import com.nimbusds.jose.JWEAlgorithm
import com.nimbusds.jose.JWEHeader
import com.nimbusds.jose.JWEObject
import com.nimbusds.jose.Payload
import com.nimbusds.jose.crypto.RSAEncrypter
import com.nimbusds.jose.jwk.RSAKey
import io.github.susimsek.springbootgraphqljwedemo.config.JwtProperties
import io.github.susimsek.springbootgraphqljwedemo.dto.TokenDTO
import lombok.RequiredArgsConstructor
import org.springframework.security.core.Authentication
import org.springframework.security.oauth2.jose.jws.SignatureAlgorithm
import org.springframework.security.oauth2.jwt.JwtClaimsSet
import org.springframework.security.oauth2.jwt.JwtEncoder
import org.springframework.security.oauth2.jwt.JwtEncoderParameters
import org.springframework.stereotype.Component

import java.time.Instant

@Component
@RequiredArgsConstructor
class JweUtil(
    private val jwtEncoder: JwtEncoder,
    private val signingKey: RSAKey,
    private val encryptionKey: RSAKey,
    private val props: JwtProperties
) {
    fun generateToken(authentication: Authentication): TokenDTO {
        val subject = authentication.name
        val roles = authentication.authorities.map { it.authority }

        val now = Instant.now()
        val expiresIn = props.expirationDuration.seconds
        val exp = now.plusSeconds(expiresIn)

        val claims = JwtClaimsSet.builder()
            .issuer(props.issuer)
            .issuedAt(now)
            .expiresAt(exp)
            .subject(subject)
            .claim(AUTHORITIES_KEY, roles)
            .build()

        val jwsHeader = org.springframework.security.oauth2.jwt.JwsHeader.with(SignatureAlgorithm.RS256)
            .keyId(signingKey.keyID)
            .build()

        val jws = jwtEncoder
            .encode(JwtEncoderParameters.from(jwsHeader, claims))
            .tokenValue

        val jweHeader = JWEHeader.Builder(JWEAlgorithm.RSA_OAEP_256, EncryptionMethod.A128GCM)
            .contentType("JWT")
            .keyID(encryptionKey.keyID)
            .build()

        val jweObject = JWEObject(jweHeader, Payload(jws))
        jweObject.encrypt(RSAEncrypter(encryptionKey.toRSAPublicKey()))
        val token = jweObject.serialize()

        return TokenDTO(token, "Bearer", expiresIn)
    }
}
</code></pre>
<p>KeyUtils</p>
<h3>Java</h3>
<pre><code class="language-java">package io.github.susimsek.springbootgraphqljwedemo.security;

import com.nimbusds.jose.JWEAlgorithm;
import com.nimbusds.jose.JWSAlgorithm;
import com.nimbusds.jose.jwk.KeyUse;
import com.nimbusds.jose.jwk.RSAKey;
import lombok.experimental.UtilityClass;

import java.security.KeyFactory;
import java.security.interfaces.RSAPrivateKey;
import java.security.interfaces.RSAPublicKey;
import java.security.spec.PKCS8EncodedKeySpec;
import java.security.spec.X509EncodedKeySpec;
import java.util.Base64;

@UtilityClass
public class KeyUtils {
    public RSAKey buildRsaKey(
            String pubPem,
            String privPem,
            String kid,
            boolean forSign
    ) throws Exception {
        String pubContent = pubPem
            .replace("-----BEGIN PUBLIC KEY-----", "")
            .replace("-----END PUBLIC KEY-----", "")
            .replaceAll("\\s", "");
        String privContent = privPem
            .replace("-----BEGIN PRIVATE KEY-----", "")
            .replace("-----END PRIVATE KEY-----", "")
            .replaceAll("\\s", "");

        byte[] decodedPub = Base64.getDecoder().decode(pubContent);
        byte[] decodedPriv = Base64.getDecoder().decode(privContent);

        KeyFactory kf = KeyFactory.getInstance("RSA");
        RSAPublicKey publicKey = (RSAPublicKey) kf.generatePublic(new X509EncodedKeySpec(decodedPub));
        RSAPrivateKey privateKey = (RSAPrivateKey) kf.generatePrivate(new PKCS8EncodedKeySpec(decodedPriv));

        RSAKey.Builder builder = new RSAKey.Builder(publicKey)
            .privateKey(privateKey)
            .keyID(kid);

        if (forSign) {
            builder
                .algorithm(JWSAlgorithm.RS256)
                .keyUse(KeyUse.SIGNATURE);
        } else {
            builder
                .algorithm(JWEAlgorithm.RSA_OAEP_256)
                .keyUse(KeyUse.ENCRYPTION);
        }

        return builder.build();
    }
}
</code></pre>
<h3>Kotlin</h3>
<pre><code class="language-kotlin">package io.github.susimsek.springbootgraphqljwedemo.security

import com.nimbusds.jose.JWEAlgorithm
import com.nimbusds.jose.JWSAlgorithm
import com.nimbusds.jose.jwk.KeyUse
import com.nimbusds.jose.jwk.RSAKey
import java.security.KeyFactory
import java.security.interfaces.RSAPrivateKey
import java.security.interfaces.RSAPublicKey
import java.security.spec.PKCS8EncodedKeySpec
import java.security.spec.X509EncodedKeySpec
import java.util.Base64

object KeyUtils {
    @JvmStatic
    @Throws(Exception::class)
    fun buildRsaKey(
        pubPem: String,
        privPem: String,
        kid: String,
        forSign: Boolean
    ): RSAKey {
        val pubContent = pubPem
            .replace("-----BEGIN PUBLIC KEY-----", "")
            .replace("-----END PUBLIC KEY-----", "")
            .replace(Regex("\\s"), "")
        val privContent = privPem
            .replace("-----BEGIN PRIVATE KEY-----", "")
            .replace("-----END PRIVATE KEY-----", "")
            .replace(Regex("\\s"), "")

        val decodedPub = Base64.getDecoder().decode(pubContent)
        val decodedPriv = Base64.getDecoder().decode(privContent)

        val kf = KeyFactory.getInstance("RSA")
        val publicKey = kf.generatePublic(X509EncodedKeySpec(decodedPub)) as RSAPublicKey
        val privateKey = kf.generatePrivate(PKCS8EncodedKeySpec(decodedPriv)) as RSAPrivateKey

        val builder = RSAKey.Builder(publicKey)
            .privateKey(privateKey)
            .keyID(kid)

        if (forSign) {
            builder
                .algorithm(JWSAlgorithm.RS256)
                .keyUse(KeyUse.SIGNATURE)
        } else {
            builder
                .algorithm(JWEAlgorithm.RSA_OAEP_256)
                .keyUse(KeyUse.ENCRYPTION)
        }

        return builder.build()
    }
}
</code></pre>
<p>SecurityUtils</p>
<h3>Java</h3>
<pre><code class="language-java">package io.github.susimsek.springbootgraphqljwedemo.security;

import lombok.experimental.UtilityClass;
import org.springframework.security.core.Authentication;
import org.springframework.security.core.context.SecurityContextHolder;
import org.springframework.security.core.userdetails.UserDetails;
import org.springframework.security.oauth2.jwt.Jwt;

import java.util.Optional;

@UtilityClass
public class SecurityUtils {

    public static final String AUTHORITIES_KEY = "auth";

    public Optional&#x3C;String> getCurrentUserLogin() {
        var ctx = SecurityContextHolder.getContext();
        return Optional.ofNullable(extractPrincipal(ctx.getAuthentication()));
    }

    private String extractPrincipal(Authentication authentication) {
        if (authentication == null) {
            return null;
        }
        Object principal = authentication.getPrincipal();
        if (principal instanceof Jwt jwt) {
            return jwt.getSubject();
        }
        if (principal instanceof UserDetails ud) {
            return ud.getUsername();
        }
        if (principal instanceof String username) {
            return username;
        }
        return null;
    }
}
</code></pre>
<h3>Kotlin</h3>
<pre><code class="language-kotlin">package io.github.susimsek.springbootgraphqljwedemo.security

import org.springframework.security.core.Authentication
import org.springframework.security.core.context.SecurityContextHolder
import org.springframework.security.core.userdetails.UserDetails
import org.springframework.security.oauth2.jwt.Jwt
import java.util.Optional

object SecurityUtils {
  const val AUTHORITIES_KEY = "auth"

  fun getCurrentUserLogin(): Optional&#x3C;String> {
    val authentication: Authentication? = SecurityContextHolder.getContext().authentication
    return Optional.ofNullable(extractPrincipal(authentication))
  }

  private fun extractPrincipal(authentication: Authentication?): String? {
    return when (val principal = authentication?.principal) {
      is Jwt -> principal.subject
      is UserDetails -> principal.username
      is String -> principal
      else -> null
    }
  }
}
</code></pre>
<p>DomainUserDetailsService</p>
<h3>Java</h3>
<pre><code class="language-java">package io.github.susimsek.springbootgraphqljwedemo.security;

import io.github.susimsek.springbootgraphqljwedemo.entity.User;
import io.github.susimsek.springbootgraphqljwedemo.repository.UserRepository;
import lombok.RequiredArgsConstructor;
import org.springframework.security.core.GrantedAuthority;
import org.springframework.security.core.authority.SimpleGrantedAuthority;
import org.springframework.security.core.userdetails.UserDetails;
import org.springframework.security.core.userdetails.UserDetailsService;
import org.springframework.security.core.userdetails.UsernameNotFoundException;

import java.util.List;
import java.util.stream.Collectors;

@RequiredArgsConstructor
public class DomainUserDetailsService implements UserDetailsService {

  private final UserRepository userRepository;

  @Override
  public UserDetails loadUserByUsername(String username) throws UsernameNotFoundException {
    User user = userRepository.findOneWithAuthoritiesByUsername(username)
      .orElseThrow(() -> new UsernameNotFoundException("User not found with username: " + username));

    List&#x3C;GrantedAuthority> authorities = user.getAuthorities().stream()
      .map(mapping -> mapping.getAuthority().getName())
      .map(SimpleGrantedAuthority::new)
      .collect(Collectors.toList());

    return new org.springframework.security.core.userdetails.User(
      user.getUsername(),
      user.getPassword(),
      user.isEnabled(),  // enabled
      true,              // accountNonExpired
      true,              // credentialsNonExpired
      true,              // accountNonLocked
      authorities
    );
  }
}
</code></pre>
<h3>Kotlin</h3>
<pre><code class="language-kotlin">package io.github.susimsek.springbootgraphqljwedemo.security

import io.github.susimsek.springbootgraphqljwedemo.repository.UserRepository
import org.springframework.security.core.GrantedAuthority
import org.springframework.security.core.authority.SimpleGrantedAuthority
import org.springframework.security.core.userdetails.UserDetails
import org.springframework.security.core.userdetails.UserDetailsService
import org.springframework.security.core.userdetails.UsernameNotFoundException
import java.util.stream.Collectors

class DomainUserDetailsService(
  private val userRepository: UserRepository
) : UserDetailsService {
  override fun loadUserByUsername(username: String): UserDetails {
    val user = userRepository.findOneWithAuthoritiesByUsername(username)
      .orElseThrow { UsernameNotFoundException("User not found with username: $username") }

    val authorities: List&#x3C;GrantedAuthority> = user.authorities.stream()
      .map { SimpleGrantedAuthority(it.authority.name) }
      .collect(Collectors.toList())

    return org.springframework.security.core.userdetails.User(
      user.username,
      user.password,
      user.enabled,
      true,
      true,
      true,
      authorities
    )
  }
}
</code></pre>
<p>SpringSecurityAuditorAware</p>
<h3>Java</h3>
<pre><code class="language-java">package io.github.susimsek.springbootgraphqljwedemo.security;

import org.springframework.data.domain.AuditorAware;
import org.springframework.lang.NonNull;
import org.springframework.stereotype.Component;

import java.util.Optional;

@Component
public class SpringSecurityAuditorAware implements AuditorAware&#x3C;String> {

  @Override
  @NonNull
  public Optional&#x3C;String> getCurrentAuditor() {
    return Optional.of(SecurityUtils.getCurrentUserLogin().orElse("system"));
  }
}
</code></pre>
<h3>Kotlin</h3>
<pre><code class="language-kotlin">package io.github.susimsek.springbootgraphqljwedemo.security

import org.springframework.data.domain.AuditorAware
import org.springframework.lang.NonNull
import org.springframework.stereotype.Component

@Component
class SpringSecurityAuditorAware : AuditorAware&#x3C;String> {
    @NonNull
    override fun getCurrentAuditor(): Optional&#x3C;String> =
        Optional.of(SecurityUtils.getCurrentUserLogin().orElse("system"))
}
</code></pre>
<p>GraphQlTokenCookieInterceptor</p>
<h3>Java</h3>
<pre><code class="language-java">package io.github.susimsek.springbootjweauthjpademo.security;

import graphql.GraphQLContext;
import io.github.susimsek.springbootjweauthjpademo.dto.TokenDTO;
import org.springframework.graphql.server.WebGraphQlInterceptor;
import org.springframework.graphql.server.WebGraphQlRequest;
import org.springframework.graphql.server.WebGraphQlResponse;
import org.springframework.http.HttpHeaders;
import org.springframework.http.ResponseCookie;
import org.springframework.lang.NonNull;
import org.springframework.stereotype.Component;
import reactor.core.publisher.Mono;

@Component
public class GraphQlTokenCookieInterceptor implements WebGraphQlInterceptor {

  @Override
  @NonNull
  public Mono&#x3C;WebGraphQlResponse> intercept(@NonNull WebGraphQlRequest request, Chain chain) {
    return chain.next(request)
      .doOnNext(response -> {
        GraphQLContext ctx = response.getExecutionInput().getGraphQLContext();

        if (Boolean.TRUE.equals(ctx.get("clearAccessToken"))) {
          ResponseCookie expired = CookieUtils.removeAccessTokenCookie();
          response.getResponseHeaders().add(HttpHeaders.SET_COOKIE, expired.toString());
          return;
        }

        TokenDTO tokenDto = ctx.get("accessToken");
        if (tokenDto != null) {
          ResponseCookie cookie = CookieUtils.createAccessTokenCookie(tokenDto);
          response.getResponseHeaders()
            .add(HttpHeaders.SET_COOKIE, cookie.toString());
        }
      });
  }
}
</code></pre>
<h3>Kotlin</h3>
<pre><code class="language-kotlin">package io.github.susimsek.springbootjweauthjpademo.security

import graphql.GraphQLContext
import io.github.susimsek.springbootjweauthjpademo.dto.TokenDTO
import org.springframework.graphql.server.WebGraphQlInterceptor
import org.springframework.graphql.server.WebGraphQlRequest
import org.springframework.graphql.server.WebGraphQlResponse
import org.springframework.http.HttpHeaders
import org.springframework.http.ResponseCookie
import org.springframework.stereotype.Component
import reactor.core.publisher.Mono

@Component
class GraphQlTokenCookieInterceptor : WebGraphQlInterceptor {

  override fun intercept(
    request: WebGraphQlRequest,
    chain: WebGraphQlInterceptor.Chain
  ): Mono&#x3C;WebGraphQlResponse> {
    return chain.next(request)
      .doOnNext { response ->
        val ctx: GraphQLContext = response.executionInput.graphQLContext

        if (ctx.get&#x3C;Boolean>("clearAccessToken") == true) {
          val expired: ResponseCookie = CookieUtils.removeAccessTokenCookie()
          response.responseHeaders.add(HttpHeaders.SET_COOKIE, expired.toString())
          return@doOnNext
        }

        ctx.get&#x3C;TokenDTO>("accessToken")?.let { tokenDto ->
          val cookie: ResponseCookie = CookieUtils.createAccessTokenCookie(tokenDto)
          response.responseHeaders.add(HttpHeaders.SET_COOKIE, cookie.toString())
        }
      }
  }
}
</code></pre>
<p>CookieAuthenticationWebSocketInterceptor</p>
<h3>Java</h3>
<pre><code class="language-java">package io.github.susimsek.springbootgraphqljwedemo.security;

import io.github.susimsek.springbootgraphqljwedemo.security.CookieUtils;
import lombok.RequiredArgsConstructor;
import org.springframework.graphql.server.WebGraphQlInterceptor;
import org.springframework.graphql.server.WebGraphQlRequest;
import org.springframework.graphql.server.WebGraphQlResponse;
import org.springframework.graphql.server.WebSocketGraphQlInterceptor;
import org.springframework.graphql.server.WebSocketGraphQlRequest;
import org.springframework.graphql.server.WebSocketSessionInfo;
import org.springframework.graphql.server.support.AuthenticationExtractor;
import org.springframework.lang.NonNull;
import org.springframework.security.authentication.AuthenticationManager;
import org.springframework.security.core.Authentication;
import org.springframework.security.core.context.SecurityContext;
import org.springframework.security.core.context.SecurityContextImpl;
import org.springframework.security.oauth2.server.resource.authentication.BearerTokenAuthenticationToken;
import reactor.core.publisher.Mono;
import reactor.util.context.Context;
import reactor.util.context.ContextView;

import java.util.Map;

@RequiredArgsConstructor
public class CookieAuthenticationWebSocketInterceptor implements WebSocketGraphQlInterceptor {

  private final String authenticationAttribute = this.getClass().getName() + ".AUTHENTICATION";
  private final AuthenticationExtractor authExtractor;
  private final AuthenticationManager authenticationManager;

  @Override
  @NonNull
  public Mono&#x3C;Object> handleConnectionInitialization(@NonNull WebSocketSessionInfo info,
                                                     @NonNull Map&#x3C;String, Object> payload) {

    Mono&#x3C;Authentication> headerAuth = authExtractor.getAuthentication(payload);

    Mono&#x3C;Authentication> cookieAuth = Mono.defer(() -> {
      String token = CookieUtils.resolveToken(info.getHeaders());
      return token != null
        ? Mono.just(new BearerTokenAuthenticationToken(token))
        : Mono.empty();
    });

    return headerAuth
      .switchIfEmpty(cookieAuth)
      .flatMap(this::authenticate)
      .doOnNext(auth -> {
        SecurityContext securityContext = new SecurityContextImpl(auth);
        info.getAttributes().put(this.authenticationAttribute, securityContext);
      })
      .then(Mono.empty());
  }

  @Override
  @NonNull
  public Mono&#x3C;WebGraphQlResponse> intercept(@NonNull WebGraphQlRequest request,
                                            @NonNull WebGraphQlInterceptor.Chain chain) {
    if (request instanceof WebSocketGraphQlRequest webSocketRequest) {
      Map&#x3C;String, Object> attributes = webSocketRequest.getSessionInfo().getAttributes();
      SecurityContext securityContext = (SecurityContext) attributes.get(this.authenticationAttribute);
      ContextView contextView = this.getContextToWrite(securityContext);
      return chain.next(request).contextWrite(contextView);
    } else {
      return chain.next(request);
    }
  }

  protected Mono&#x3C;Authentication> authenticate(Authentication authentication) {
    return Mono.just(this.authenticationManager.authenticate(authentication));
  }

  protected ContextView getContextToWrite(SecurityContext securityContext) {
    return Context.of(SecurityContext.class.getName(), securityContext);
  }
}
</code></pre>
<h3>Kotlin</h3>
<pre><code class="language-kotlin">package io.github.susimsek.springbootgraphqljwedemo.security

import io.github.susimsek.springbootgraphqljwedemo.security.CookieUtils
import org.springframework.graphql.server.WebGraphQlInterceptor
import org.springframework.graphql.server.WebGraphQlRequest
import org.springframework.graphql.server.WebGraphQlResponse
import org.springframework.graphql.server.WebSocketGraphQlInterceptor
import org.springframework.graphql.server.WebSocketGraphQlRequest
import org.springframework.graphql.server.WebSocketSessionInfo
import org.springframework.graphql.server.support.AuthenticationExtractor
import org.springframework.lang.NonNull
import org.springframework.security.authentication.AuthenticationManager
import org.springframework.security.core.Authentication
import org.springframework.security.core.context.SecurityContext
import org.springframework.security.core.context.SecurityContextImpl
import org.springframework.security.oauth2.server.resource.authentication.BearerTokenAuthenticationToken
import reactor.core.publisher.Mono
import reactor.util.context.Context
import reactor.util.context.ContextView

class CookieAuthenticationWebSocketInterceptor(
  private val authExtractor: AuthenticationExtractor,
  private val authenticationManager: AuthenticationManager
) : WebSocketGraphQlInterceptor {

  private val authenticationAttribute: String = "${this::class.java.name}.AUTHENTICATION"

  @NonNull
  override fun handleConnectionInitialization(
    @NonNull info: WebSocketSessionInfo,
    @NonNull payload: Map&#x3C;String, Any>
  ): Mono&#x3C;Any> {
    val headerAuth: Mono&#x3C;Authentication> = authExtractor.getAuthentication(payload)

    val cookieAuth: Mono&#x3C;Authentication> = Mono.defer {
      val token = CookieUtils.resolveToken(info.headers)
      if (token != null) {
        Mono.just(BearerTokenAuthenticationToken(token))
      } else {
        Mono.empty()
      }
    }

    return headerAuth
      .switchIfEmpty(cookieAuth)
      .flatMap { authenticate(it) }
      .doOnNext { auth ->
        val securityContext = SecurityContextImpl(auth)
        info.attributes[authenticationAttribute] = securityContext
      }
      .then(Mono.empty())
  }

  @NonNull
  override fun intercept(
    @NonNull request: WebGraphQlRequest,
    @NonNull chain: WebGraphQlInterceptor.Chain
  ): Mono&#x3C;WebGraphQlResponse> {
    return if (request is WebSocketGraphQlRequest) {
      val attributes = request.sessionInfo.attributes
      val securityContext = attributes[authenticationAttribute] as SecurityContext
      val contextView: ContextView = getContextToWrite(securityContext)
      chain.next(request).contextWrite(contextView)
    } else {
      chain.next(request)
    }
  }

  protected fun authenticate(authentication: Authentication): Mono&#x3C;Authentication> =
    Mono.just(authenticationManager.authenticate(authentication))

  protected fun getContextToWrite(securityContext: SecurityContext): ContextView =
    Context.of(SecurityContext::class.java.name, securityContext)
}
</code></pre>
<hr>
<h2>ğŸ§ª AdÄ±m 6: Kimlik DoÄŸrulama ve GÃ¼venli Endpointler</h2>
<p>Bu bÃ¶lÃ¼mde, aÅŸaÄŸÄ±daki GraphQL controller ve DTOâ€™larÄ± tanÄ±mlÄ±yoruz:</p>
<ul>
<li>AuthController: KullanÄ±cÄ±larÄ± doÄŸrular, JWE token'Ä± GraphQL mutationu ile oluÅŸturur ve GraphQLContext iÃ§ine <code>accessToken</code> veya <code>clearAccessToken</code> flaglerini ekler.</li>
<li>HelloController: KimliÄŸi doÄŸrulanmÄ±ÅŸ kullanÄ±cÄ±lar ve yalnÄ±zca adminin eriÅŸebileceÄŸi GraphQL query, subscription ve mutationlarÄ± sunar.</li>
<li>LoginInput: Login iÅŸlemi iÃ§in (kullanÄ±cÄ± adÄ±/ÅŸifre) GraphQL input tipi.</li>
<li>GreetInput &#x26; GreetDTO: greet mutationu iÃ§in GraphQL input ve yanÄ±t tipi.</li>
<li>TokenDTO: Token, tÃ¼r ve geÃ§erlilik sÃ¼resini iÃ§eren JWE token yanÄ±t modelidir.</li>
</ul>
<p>Bu bileÅŸenler, JWE tokenâ€™larÄ± ve JPA yÄ± kullanarak GraphQL APIâ€™de stateless kimlik doÄŸrulama akÄ±ÅŸÄ±nÄ± tamamlar.</p>
<p>AuthController</p>
<h3>Java</h3>
<pre><code class="language-java">package io.github.susimsek.springbootjweauthjpademo.controller;

import graphql.GraphQLContext;
import io.github.susimsek.springbootjweauthjpademo.dto.LoginInput;
import io.github.susimsek.springbootjweauthjpademo.dto.TokenDTO;
import io.github.susimsek.springbootjweauthjpademo.security.JweUtil;
import lombok.RequiredArgsConstructor;
import org.springframework.graphql.data.method.annotation.Argument;
import org.springframework.graphql.data.method.annotation.MutationMapping;
import org.springframework.security.access.prepost.PreAuthorize;
import org.springframework.security.authentication.AuthenticationManager;
import org.springframework.security.authentication.UsernamePasswordAuthenticationToken;
import org.springframework.security.core.Authentication;
import org.springframework.security.core.context.SecurityContextHolder;
import org.springframework.stereotype.Controller;

@Controller
@RequiredArgsConstructor
public class AuthController {

  private final AuthenticationManager authenticationManager;
  private final JweUtil jweUtil;

  @MutationMapping
  public TokenDTO login(@Argument LoginInput input,
                        GraphQLContext context) {
    // Authenticate user
    Authentication auth = authenticationManager.authenticate(
      new UsernamePasswordAuthenticationToken(input.username(), input.password())
    );
    SecurityContextHolder.getContext().setAuthentication(auth);

    // Generate JWE token
    TokenDTO tokenDto = jweUtil.generateToken(auth);

    // Store token in GraphQLContext for the interceptor to set cookie
    context.put("accessToken", tokenDto);

    return tokenDto;
  }

  @PreAuthorize("isAuthenticated()")
  @MutationMapping
  public Boolean logout(GraphQLContext context) {
    // Signal the interceptor to clear the cookie
    context.put("clearAccessToken", Boolean.TRUE);
    return true;
  }
}
</code></pre>
<h3>Kotlin</h3>
<pre><code class="language-kotlin">package io.github.susimsek.springbootjweauthjpademo.controller

import graphql.GraphQLContext
import io.github.susimsek.springbootjweauthjpademo.dto.LoginInput
import io.github.susimsek.springbootjweauthjpademo.dto.TokenDTO
import io.github.susimsek.springbootjweauthjpademo.security.JweUtil
import org.springframework.graphql.data.method.annotation.Argument
import org.springframework.graphql.data.method.annotation.MutationMapping
import org.springframework.security.access.prepost.PreAuthorize
import org.springframework.security.authentication.AuthenticationManager
import org.springframework.security.authentication.UsernamePasswordAuthenticationToken
import org.springframework.security.core.context.SecurityContextHolder
import org.springframework.stereotype.Controller

@Controller
class AuthController(
  private val authenticationManager: AuthenticationManager,
  private val jweUtil: JweUtil
) {

  @MutationMapping
  fun login(
    @Argument input: LoginInput,
    context: GraphQLContext
  ): TokenDTO {
    // Authenticate user
    val auth = authenticationManager.authenticate(
      UsernamePasswordAuthenticationToken(input.username, input.password)
    )
    SecurityContextHolder.getContext().authentication = auth

    // Generate JWE token
    val tokenDto = jweUtil.generateToken(auth)

    // Store token in GraphQLContext for the interceptor to set cookie
    context.put("accessToken", tokenDto)

    return tokenDto
  }

  @PreAuthorize("isAuthenticated()")
  @MutationMapping
  fun logout(context: GraphQLContext): Boolean {
    // Signal the interceptor to clear the cookie
    context.put("clearAccessToken", true)
    return true
  }
}
</code></pre>
<p>HelloController</p>
<h3>Java</h3>
<pre><code class="language-java">package io.github.susimsek.springbootgraphqljwedemo.controller;

import io.github.susimsek.springbootgraphqljwedemo.dto.GreetDTO;
import io.github.susimsek.springbootgraphqljwedemo.dto.GreetInput;
import lombok.RequiredArgsConstructor;
import org.springframework.graphql.data.method.annotation.Argument;
import org.springframework.graphql.data.method.annotation.MutationMapping;
import org.springframework.graphql.data.method.annotation.QueryMapping;
import org.springframework.graphql.data.method.annotation.SubscriptionMapping;
import org.springframework.security.access.prepost.PreAuthorize;
import org.springframework.security.core.annotation.AuthenticationPrincipal;
import org.springframework.security.oauth2.jwt.Jwt;
import org.springframework.stereotype.Controller;
import reactor.core.publisher.Flux;

import java.time.Duration;
import java.time.Instant;

import static io.github.susimsek.springbootgraphqljwedemo.security.SecurityUtils.AUTHORITIES_KEY;

@Controller
@RequiredArgsConstructor
@PreAuthorize("isAuthenticated()")
public class HelloController {

  @QueryMapping
  public String helloAll(@AuthenticationPrincipal Jwt jwt) {
    var roles = jwt.getClaimAsStringList(AUTHORITIES_KEY);
    return "Hello, " + jwt.getSubject() + "! Your roles: " + roles;
  }

  @PreAuthorize("hasAuthority('ROLE_ADMIN')")
  @QueryMapping
  public String helloAdmin(@AuthenticationPrincipal Jwt jwt) {
    return "Hello Admin, " + jwt.getSubject() + "!";
  }

  @MutationMapping
  public GreetDTO greet(
    @Argument GreetInput input,
    @AuthenticationPrincipal Jwt jwt
  ) {
    String msg = "Hello " + jwt.getSubject() + ", you said: " + input.getMessage();
    return new GreetDTO(msg, Instant.now());
  }

  @SubscriptionMapping("greetStream")
  public Flux&#x3C;GreetDTO> greetStream(
    @Argument GreetInput input,
    @AuthenticationPrincipal Jwt jwt
  ) {
    return Flux.interval(Duration.ofSeconds(1))
      .map(i -> {
        String msg = "Hello " + jwt.getSubject()
          + ", you said: " + input.getMessage()
          + " (event " + (i + 1) + ")";
        return new GreetDTO(msg, Instant.now());
      });
  }

  @PreAuthorize("hasAuthority('ROLE_ADMIN')")
  @SubscriptionMapping("greetStreamAdmin")
  public Flux&#x3C;GreetDTO> greetStreamAdmin(
    @Argument GreetInput input,
    @AuthenticationPrincipal Jwt jwt
  ) {
    return Flux.interval(Duration.ofSeconds(2))
      .map(i -> {
        String msg = "Hello Admin " + jwt.getSubject()
          + ", you said: " + input.getMessage()
          + " (admin event " + (i + 1) + ")";
        return new GreetDTO(msg, Instant.now());
      });
  }
}
</code></pre>
<h3>Kotlin</h3>
<pre><code class="language-kotlin">package io.github.susimsek.springbootgraphqljwedemo.controller

import io.github.susimsek.springbootgraphqljwedemo.dto.GreetDTO
import io.github.susimsek.springbootgraphqljwedemo.dto.GreetInput
import org.springframework.graphql.data.method.annotation.Argument
import org.springframework.graphql.data.method.annotation.MutationMapping
import org.springframework.graphql.data.method.annotation.QueryMapping
import org.springframework.graphql.data.method.annotation.SubscriptionMapping
import org.springframework.security.access.prepost.PreAuthorize
import org.springframework.security.core.annotation.AuthenticationPrincipal
import org.springframework.security.oauth2.jwt.Jwt
import org.springframework.stereotype.Controller
import reactor.core.publisher.Flux
import java.time.Duration
import java.time.Instant

@Controller
@RequiredArgsConstructor
@PreAuthorize("isAuthenticated()")
class HelloController {

  @QueryMapping
  fun helloAll(@AuthenticationPrincipal jwt: Jwt): String {
    val roles = jwt.getClaimAsStringList(SecurityUtils.AUTHORITIES_KEY)
    return "Hello, ${jwt.subject}! Your roles: $roles"
  }

  @PreAuthorize("hasAuthority('ROLE_ADMIN')")
  @QueryMapping
  fun helloAdmin(@AuthenticationPrincipal jwt: Jwt): String =
    "Hello Admin, ${jwt.subject}!"

  @MutationMapping
  fun greet(
    @Argument input: GreetInput,
    @AuthenticationPrincipal jwt: Jwt
  ): GreetDTO {
    val msg = "Hello ${jwt.subject}, you said: ${input.message}"
    return GreetDTO(msg, Instant.now())
  }

  @SubscriptionMapping("greetStream")
  fun greetStream(
    @Argument input: GreetInput,
    @AuthenticationPrincipal jwt: Jwt
  ): Flux&#x3C;GreetDTO> =
    Flux.interval(Duration.ofSeconds(1))
      .map { i ->
        val msg = "Hello ${jwt.subject}, you said: ${input.message} (event ${i + 1})"
        GreetDTO(msg, Instant.now())
      }

  @PreAuthorize("hasAuthority('ROLE_ADMIN')")
  @SubscriptionMapping("greetStreamAdmin")
  fun greetStreamAdmin(
    @Argument input: GreetInput,
    @AuthenticationPrincipal jwt: Jwt
  ): Flux&#x3C;GreetDTO> =
    Flux.interval(Duration.ofSeconds(2))
      .map { i ->
        val msg = "Hello Admin ${jwt.subject}, you said: ${input.message} (admin event ${i + 1})"
        GreetDTO(msg, Instant.now())
      }
}
</code></pre>
<p>LoginInput</p>
<h3>Java</h3>
<pre><code class="language-java">package io.github.susimsek.springbootgraphqljwedemo.dto;

public record LoginInput(
  String username,
  String password
) {}
</code></pre>
<h3>Kotlin</h3>
<pre><code class="language-kotlin">package io.github.susimsek.springbootgraphqljwedemo.dto

data class LoginInput(
  val username: String,
  val password: String
)
</code></pre>
<p>GreetInput</p>
<h3>Java</h3>
<pre><code class="language-java">package io.github.susimsek.springbootgraphqljwedemo.dto;

public record GreetInput(
  String message
) {}
</code></pre>
<h3>Kotlin</h3>
<pre><code class="language-kotlin">package io.github.susimsek.springbootgraphqljwedemo.dto

data class GreetInput(
  val message: String
)
</code></pre>
<p>GreetDTO</p>
<h3>Java</h3>
<pre><code class="language-java">package io.github.susimsek.springbootgraphqljwedemo.dto;

import java.time.Instant;

public record GreetDTO(
  String greeting,
  Instant timestamp
) {}
</code></pre>
<h3>Kotlin</h3>
<pre><code class="language-kotlin">package io.github.susimsek.springbootgraphqljwedemo.dto

import java.time.Instant

data class GreetDTO(
  val greeting: String,
  val timestamp: Instant
)
</code></pre>
<p>TokenDTO</p>
<h3>Java</h3>
<pre><code class="language-java">package io.github.susimsek.springbootgraphqljwedemo.dto;

public record TokenDTO(
  String accessToken,
  String tokenType,
  long accessTokenExpiresIn
) {}
</code></pre>
<h3>Kotlin</h3>
<pre><code class="language-kotlin">package io.github.susimsek.springbootgraphqljwedemo.dto

data class TokenDTO(
  val accessToken: String,
  val tokenType: String,
  val accessTokenExpiresIn: Long
)
</code></pre>
<hr>
<h2>â–¶ï¸ UygulamayÄ± Ã‡alÄ±ÅŸtÄ±r</h2>
<pre><code class="language-bash">./mvnw spring-boot:run
# or
gradle bootRun
</code></pre>
<p>GraalVM 22.3+ yÃ¼klÃ¼yse, <code>native</code> profili ile native-image derlemek iÃ§in ÅŸu komutu Ã§alÄ±ÅŸtÄ±r:</p>
<pre><code class="language-bash">./mvnw native:compile -Pnative
</code></pre>
<p>Native-image derlemesi baÅŸarÄ±yla tamamlandÄ±ktan sonra, Ã§alÄ±ÅŸtÄ±rÄ±labilir dosya <code>target/</code> altÄ±nda oluÅŸturulur (Ã¶rneÄŸin: <code>target/spring-boot-graphql-jwe-auth-demo</code>). DoÄŸrudan ÅŸu komut ile Ã§alÄ±ÅŸtÄ±rÄ±n:</p>
<pre><code class="language-bash">./target/spring-boot-graphql-jwe-auth-demo
</code></pre>
<p>Opsiyonel: UPX yÃ¼klÃ¼yse, yerel Ã§alÄ±ÅŸtÄ±rÄ±labilir dosyayÄ± daha kÃ¼Ã§Ã¼k boyut iÃ§in sÄ±kÄ±ÅŸtÄ±rabilirsiniz:</p>
<pre><code class="language-bash">upx --ultra-brute --lzma target/spring-boot-graphql-jwe-auth-demo
</code></pre>
<hr>
<h2>ğŸ§ª GraphQL Endpoint Testi</h2>
<p>Bu bÃ¶lÃ¼mde GraphQL Endpoint Testi konusunu netleÅŸtirip uygulamada kullanacaÄŸÄ±nÄ±z temel noktalarÄ± Ã¶zetliyoruz.</p>
<h3>Admin AkÄ±ÅŸÄ±</h3>
<p>admin olarak giriÅŸ yapÄ±n ve <code>Set-Cookie</code> baÅŸlÄ±ÄŸÄ±ndan JWE tokeni yakalayÄ±n:</p>
<pre><code class="language-bash">curl -i -X POST http://localhost:8080/graphql \
  -H "Content-Type: application/json" \
  -d '{ "query": "mutation { login(input: { username: \"admin\", password: \"adminpass\" }) { accessToken tokenType accessTokenExpiresIn } }" }'
</code></pre>
<ul>
<li>Set-Cookie baÅŸlÄ±ÄŸÄ± <code>accessToken=&#x3C;jwe-token></code> iÃ§erir</li>
<li>YanÄ±t:</li>
</ul>
<pre><code class="language-json">{
  "data": {
    "login": {
      "accessToken": "&#x3C;jwe-token>",
      "tokenType": "Bearer",
      "accessTokenExpiresIn": 3600
    }
  }
}
</code></pre>
<p>Cookie kullanarak <code>helloAll</code> sorgusuna eriÅŸin:</p>
<pre><code class="language-bash">curl -b "accessToken=&#x3C;jwe-token>" \
  -H "Content-Type: application/json" \
  -d '{ "query": "{ helloAll }" }' \
  http://localhost:8080/graphql
</code></pre>
<p>Veya Authorization baÅŸlÄ±ÄŸÄ±yla:</p>
<pre><code class="language-bash">curl -H "Authorization: Bearer &#x3C;jwe-token>" \
  -H "Content-Type: application/json" \
  -d '{ "query": "{ helloAll }" }' \
  http://localhost:8080/graphql
</code></pre>
<p>admin-Ã¶zel <code>helloAdmin</code> sorgusunu Ã§alÄ±ÅŸtÄ±rÄ±n:</p>
<pre><code class="language-bash">curl -H "Authorization: Bearer &#x3C;jwe-token>" \
  -H "Content-Type: application/json" \
  -d '{ "query": "{ helloAdmin }" }' \
  http://localhost:8080/graphql
</code></pre>
<p>Oturum Ã§erezini temizlemek iÃ§in <code>logout</code> mutationu Ã§alÄ±ÅŸtÄ±rÄ±n:</p>
<pre><code class="language-bash">curl -H "Authorization: Bearer &#x3C;jwe-token>" \
  -H "Content-Type: application/json" \
  -d '{ "query": "mutation { logout }" }' \
  http://localhost:8080/graphql
</code></pre>
<h3>User Flow</h3>
<p>user olarak giriÅŸ yapÄ±n ve cookieâ€™den JWE tokeni yakalayÄ±n:</p>
<pre><code class="language-bash">curl -i -X POST http://localhost:8080/graphql \
  -H "Content-Type: application/json" \
  -d '{ "query": "mutation { login(input: { username: \"user\", password: \"userpass\" }) { accessToken tokenType accessTokenExpiresIn } }" }'
</code></pre>
<ul>
<li>Set-Cookie baÅŸlÄ±ÄŸÄ± <code>accessToken=&#x3C;jwe-token></code> iÃ§erir</li>
</ul>
<p><code>helloAll</code> sorgusunu Ã§aÄŸÄ±rmak iÃ§in cookie kullanÄ±n:</p>
<pre><code class="language-bash">curl -b "accessToken=&#x3C;jwe-token>" \
  -H "Content-Type: application/json" \
  -d '{ "query": "{ helloAll }" }' \
  http://localhost:8080/graphql
</code></pre>
<p>Authorization baÅŸlÄ±ÄŸÄ±yla:</p>
<pre><code class="language-bash">curl -H "Authorization: Bearer &#x3C;jwe-token>" \
  -H "Content-Type: application/json" \
  -d '{ "query": "{ helloAll }" }' \
  http://localhost:8080/graphql
</code></pre>
<p><code>helloAdmin</code> sorgusunu dene (403 hata dÃ¶nmesi gerekir):</p>
<pre><code class="language-bash">curl -H "Authorization: Bearer &#x3C;jwe-token>" \
  -H "Content-Type: application/json" \
  -d '{ "query": "{ helloAdmin }" }' \
  http://localhost:8080/graphql
</code></pre>
<h3>GraphiQL Ãœzerinden Subscription Testi</h3>
<p>SubscriptionlarÄ± doÄŸrudan GraphiQL UIâ€™Ä±nda <code>http://localhost:8080/graphiql</code> adresinde test edin:</p>
<ol>
<li>
<p>GraphiQLâ€™de Token Alma</p>
</li>
<li>
<p>Sorgu (Query) paneline ÅŸunu girin:</p>
<pre><code class="language-graphql">mutation Login($in: LoginInput!) {
  login(input: $in) {
    accessToken
  }
}
</code></pre>
</li>
<li>
<p>DeÄŸiÅŸkenler (Variables) paneline geÃ§ip ekleyin:</p>
<pre><code class="language-json">{
  "in": { "username": "admin", "password": "adminpass" }
}
</code></pre>
</li>
<li>
<p>â–¶ï¸ dÃ¼ÄŸmesine tÄ±klayÄ±n ve dÃ¶nen yanÄ±ttaki <code>accessToken</code> deÄŸerini kopyalayÄ±n.</p>
</li>
<li>
<p>BaÅŸlÄ±klarÄ± (Headers) YapÄ±landÄ±rma</p>
</li>
<li>
<p>Kenar Ã§ubuÄŸunda Headers sekmesine tÄ±klayÄ±n.</p>
</li>
<li>
<p>AÅŸaÄŸÄ±daki JSONâ€™u ekleyin:</p>
<pre><code class="language-json">{
  "Authorization": "Bearer &#x3C;accessToken>"
}
</code></pre>
</li>
<li>
<p>KullanÄ±cÄ± Olarak Abone Olma (greetStream)</p>
</li>
<li>
<p>Subscriptions paneline geÃ§in.</p>
</li>
<li>
<p>AÅŸaÄŸÄ±daki subscription sorgusunu girin:</p>
<pre><code class="language-graphql">subscription UserSubscribe($in: GreetInput!) {
  greetStream(input: $in) {
    greeting
    timestamp
  }
}
</code></pre>
</li>
<li>
<p>Variables paneline:</p>
<pre><code class="language-json">{
  "in": { "message": "GraphiQL Ã¼zerinden merhaba!" }
}
</code></pre>
</li>
<li>
<p>â–¶ï¸ dÃ¼ÄŸmesine tÄ±klayarak <code>greetStream</code> akÄ±ÅŸÄ±nÄ± dinlemeye baÅŸlayÄ±n.</p>
</li>
<li>
<p>Admin Olarak Abone Olma (greetStreamAdmin)</p>
</li>
<li>
<p>AynÄ± Subscriptions panelinde aÅŸaÄŸÄ±daki sorguyu girin:</p>
<pre><code class="language-graphql">subscription AdminSubscribe($in: GreetInput!) {
  greetStreamAdmin(input: $in) {
    greeting
    timestamp
  }
}
</code></pre>
</li>
<li>
<p>AynÄ± Variables panelini kullanÄ±n.</p>
</li>
<li>
<p>â–¶ï¸ dÃ¼ÄŸmesine tÄ±klayÄ±n. Sadece <code>ROLE_ADMIN</code> yetkisine sahip tokenâ€™lar veri alacak; diÄŸerleri yetki hatasÄ± gÃ¶recektir.</p>
</li>
</ol>
<hr>
<h2>ğŸ SonuÃ§</h2>
<p>ArtÄ±k Spring Boot GraphQL JWE Kimlik DoÄŸrulama iÃ§in Ã¼retim odaklÄ± bir Spring Boot temeliniz var. Sonraki adÄ±mda ayarlarÄ± kendi domainine uyarlayÄ±p test ve gÃ¶zlemlenebilirlik katmanÄ±nÄ± ekleyerek gerÃ§ek trafik altÄ±nda doÄŸrulayÄ±n.</p>]]></content:encoded>
      <category><![CDATA[Java]]></category>
      <category><![CDATA[Kotlin]]></category>
      <category><![CDATA[Spring Boot]]></category>
      <category><![CDATA[GÃ¼venlik]]></category>
      <category><![CDATA[JWT]]></category>
      <category><![CDATA[JWE]]></category>
      <category><![CDATA[GraphQL]]></category>
      <media:thumbnail url="https://suaybsimsek.com/images/spring-boot-graphql-jwe-auth-thumbnail.webp" />
    </item>
    <item>
      <title><![CDATA[Spring Boot JPA ile JWE Kimlik DoÄŸrulamasÄ±]]></title>
      <link>https://suaybsimsek.com/tr/posts/spring-boot-jwe-authentication-with-jpa</link>
      <description><![CDATA[Stateless ÅŸifreli JWTâ€™ler (JWE) kullanarak Spring Boot APIâ€™lerinizi gÃ¼venli hale getirirken, kullanÄ±cÄ± kimliklerini ve rolleri JPA destekli bir veritabanÄ±nda nasÄ±l saklayacaÄŸÄ±nÄ±zÄ± Ã¶ÄŸrenin.]]></description>
      <pubDate>Sun, 11 May 2025 00:00:00 GMT</pubDate>
      <atom:updated>2025-05-12T00:00:00.000Z</atom:updated>
      <guid isPermaLink="true">https://suaybsimsek.com/tr/posts/spring-boot-jwe-authentication-with-jpa</guid>
      <content:encoded><![CDATA[<p>Spring Boot, stateless ÅŸifrelenmiÅŸ JWTâ€™leri (JWE) kullanarak APIâ€™lerinizi gÃ¼vence altÄ±na almanÄ±zÄ± ve kullanÄ±cÄ± kimliklerini ile rollerini JPA tabanlÄ± bir veritabanÄ±nda saklamanÄ±zÄ± saÄŸlar.</p>
<hr>
<h2>ğŸŒŸ Neden JWE + JPA Kimlik DoÄŸrulama?</h2>
<p>Bu bÃ¶lÃ¼mde Neden JWE + JPA Kimlik DoÄŸrulama? konusunu netleÅŸtirip uygulamada kullanacaÄŸÄ±nÄ±z temel noktalarÄ± Ã¶zetliyoruz.</p>
<ul>
<li>Stateless GÃ¼venlik: Tokenlar kendi iÃ§inde tÃ¼m bilgiyi barÄ±ndÄ±rÄ±r ve sunucu tarafÄ±nda saklama gerektirmez.</li>
<li>BÃ¼tÃ¼nlÃ¼k: Ä°mzalÄ± tokenlar, iÃ§eriÄŸin deÄŸiÅŸtirilmediÄŸini garanti eder.</li>
<li>Gizlilik: ÅifrelenmiÅŸ JWTâ€™ler hassas bilgileri dÄ±ÅŸarÄ±dan okunamaz halde tutar.</li>
<li>KullanÄ±cÄ± YÃ¶netimi: JPA depolarÄ± ile kullanÄ±cÄ±larÄ± ve rolleri JPA repositorylerde saklayÄ±p yÃ¶netebilirsiniz.</li>
<li>Standartlara Uygun: JOSE, Spring Security ve Spring Data JPAâ€™nÄ±n gÃ¼cÃ¼nÃ¼ bir arada kullanÄ±r.</li>
<li>Ã–lÃ§eklenebilirlik: Session replikasyonu veya sticky session gerektirmeden yatay Ã¶lÃ§eklenebilir.</li>
</ul>
<hr>
<h2>ğŸ“‹ Gereksinimler</h2>
<p>Bu bÃ¶lÃ¼mde Gereksinimler konusunu netleÅŸtirip uygulamada kullanacaÄŸÄ±nÄ±z temel noktalarÄ± Ã¶zetliyoruz.</p>
<ul>
<li>â˜• JDK 17 veya Ã¼zeri</li>
<li>ğŸ“¦ Spring Boot 3.2+</li>
<li>ğŸ”¤ IDE (IntelliJ IDEA, Eclipse)</li>
<li>ğŸ›¢ï¸ PostgreSQL (veya geliÅŸtirme iÃ§in H2)</li>
</ul>
<hr>
<h2>ğŸ› ï¸ AdÄ±m 1: BaÄŸÄ±mlÄ±lÄ±klarÄ± Ekle</h2>
<p><code>pom.xml</code> veya <code>build.gradle</code> dosyanÄ±za ÅŸunlarÄ± ekleyin.</p>
<p>Maven:</p>
<pre><code class="language-xml">&#x3C;dependency>
  &#x3C;groupId>org.springframework.boot&#x3C;/groupId>
  &#x3C;artifactId>spring-boot-starter-web&#x3C;/artifactId>
&#x3C;/dependency>
&#x3C;dependency>
  &#x3C;groupId>org.springframework.security&#x3C;/groupId>
  &#x3C;artifactId>spring-security-oauth2-resource-server&#x3C;/artifactId>
&#x3C;/dependency>
&#x3C;dependency>
  &#x3C;groupId>org.springframework.boot&#x3C;/groupId>
  &#x3C;artifactId>spring-boot-starter-data-jpa&#x3C;/artifactId>
&#x3C;/dependency>
&#x3C;dependency>
  &#x3C;groupId>org.liquibase&#x3C;/groupId>
  &#x3C;artifactId>liquibase-core&#x3C;/artifactId>
&#x3C;/dependency>
&#x3C;dependency>
  &#x3C;groupId>org.projectlombok&#x3C;/groupId>
  &#x3C;artifactId>lombok&#x3C;/artifactId>
  &#x3C;optional>true&#x3C;/optional>
&#x3C;/dependency>
&#x3C;dependency>
  &#x3C;groupId>com.h2database&#x3C;/groupId>
  &#x3C;artifactId>h2&#x3C;/artifactId>
  &#x3C;scope>runtime&#x3C;/scope>
&#x3C;/dependency>
</code></pre>
<p>Gradle:</p>
<pre><code class="language-groovy">implementation 'org.springframework.boot:spring-boot-starter-web'
implementation 'org.springframework.security:spring-security-oauth2-resource-server'
implementation 'org.springframework.boot:spring-boot-starter-data-jpa'
implementation 'org.liquibase:liquibase-core'
compileOnly 'org.projectlombok:lombok'
runtimeOnly 'com.h2database:h2'
</code></pre>
<hr>
<h2>ğŸ› ï¸ AdÄ±m 2: YapÄ±landÄ±rma DosyalarÄ±</h2>
<p>Bu bÃ¶lÃ¼mde, Spring Boot uygulamanÄ±zÄ± H2/PostgreSQL, JPA, Liquibase deÄŸiÅŸiklik changelog, veri yÃ¼klemeleri ve JWE anahtar Ã¶zellikleri ile yapÄ±landÄ±rmak iÃ§in gereken tÃ¼m uygulama ve veritabanÄ± dÃ¼zeyindeki yapÄ±landÄ±rma dosyalarÄ±nÄ± tanÄ±mlÄ±yoruz:</p>
<ul>
<li>
<p><code>application.yml</code>
Spring veri kaynaÄŸÄ± (datasource), H2 konsolu, JPA/Hibernate, Liquibase changelog pathi ve tÃ¼m JWT/JWE anahtar, issuer ve geÃ§erlilik sÃ¼resi (expiration) ayarlarÄ±nÄ± iÃ§erir.</p>
</li>
<li>
<p><code>db/master.xml</code>
Liquibase master changelog dosyasÄ±; H2 ve PostgreSQL iÃ§in DBMS Ã¶zel Ã¶zellikler ve alt changelog tanÄ±mlarÄ±nÄ± barÄ±ndÄ±rÄ±r.</p>
</li>
<li>
<p><code>db/changelog/changelog-user.xml</code>
<code>user_identity</code>, <code>authority</code> ve <code>user_authority_mapping</code> tablolarÄ±, indeksler, yabancÄ± anahtarlar (FK) ve ilk <code>&#x3C;loadData></code> adÄ±mlarÄ±nÄ± tanÄ±mlayan temel ÅŸema deÄŸiÅŸiklik changelogu.</p>
</li>
<li>
<p><code>db/data/user.csv</code>
KullanÄ±cÄ± kayÄ±tlarÄ± (UUID, kullanÄ±cÄ± adÄ±, bcrypt ile ÅŸifrelenmiÅŸ parola, e-posta, enabled flagi, zaman damgalarÄ± ve oluÅŸturan kullanÄ±cÄ± bilgisi).</p>
</li>
<li>
<p><code>db/data/authority.csv</code>
Yetki kayÄ±tlarÄ± (UUID, ad, aÃ§Ä±klama, zaman damgalarÄ± ve oluÅŸturan kullanÄ±cÄ± bilgisi).</p>
</li>
<li>
<p><code>db/data/user_authority_mapping.csv</code>
KullanÄ±cÄ±lar ile yetkiler arasÄ±ndaki mappingler (composite birincil anahtar, zaman damgalarÄ± ve oluÅŸturan kullanÄ±cÄ± bilgisi).</p>
</li>
</ul>
<p>application.yml</p>
<pre><code class="language-yaml">spring:
  datasource:
    url: jdbc:h2:mem:testdb;MODE=PostgreSQL;DB_CLOSE_DELAY=-1;DB_CLOSE_ON_EXIT=FALSE
    driver-class-name: org.h2.Driver
    username: sa
    password: password
  h2:
    console:
      enabled: true
  jpa:
    open-in-view: false
    hibernate:
      ddl-auto: none
    show-sql: true
    properties:
      hibernate.format_sql: true
  liquibase:
    change-log: classpath:db/master.xml
security:
  admin:
    username: admin
    password: adminpass
  user:
    username: user
    password: userpass
  jwt:
    issuer: demo-issuer
    expiration-duration: 3600s
    signing:
      key-id: signing-key
      public-key: |-
        -----BEGIN PUBLIC KEY-----
        MIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEAjZEcz5itWkDGOSqZdB5P
        JE0ccOCckskp0hN3kQbT1qnv+9/k66jlWgVi4HSTppwdNF/Ylu5u541Qj+Okyg+u
        8o2PvKo5CfgvTDsFLTrZHUXU6hCSGatLAQoeN6lT8wzov2r4DFecXrIqcO6SvMB5
        ecPqsfiTi4trsNKgJ4cWS6gILH62ISd1ipUadfpnUzDMO1OulV0CJNV6bcBk7Es9
        RW6AHfg9j8osSanpwvRM4MJkB0SRxYUnrN9faGpkBZISZJ8TShhaTHEGfSNgKe5y
        8iu+AMGGZu8DYczVmqS3Ske1fq6y5HEGCma7Mo019GmwKeHBo1obuET6cZRygj4y
        twIDAQAB
        -----END PUBLIC KEY-----
      private-key: |-
        -----BEGIN PRIVATE KEY-----
        MIIEvAIBADANBgkqhkiG9w0BAQEFAASCBKYwggSiAgEAAoIBAQCNkRzPmK1aQMY5
        Kpl0Hk8kTRxw4JySySnSE3eRBtPWqe/73+TrqOVaBWLgdJOmnB00X9iW7m7njVCP
        46TKD67yjY+8qjkJ+C9MOwUtOtkdRdTqEJIZq0sBCh43qVPzDOi/avgMV5xesipw
        7pK8wHl5w+qx+JOLi2uw0qAnhxZLqAgsfrYhJ3WKlRp1+mdTMMw7U66VXQIk1Xpt
        wGTsSz1FboAd+D2PyixJqenC9EzgwmQHRJHFhSes319oamQFkhJknxNKGFpMcQZ9
        I2Ap7nLyK74AwYZm7wNhzNWapLdKR7V+rrLkcQYKZrsyjTX0abAp4cGjWhu4RPpx
        lHKCPjK3AgMBAAECggEABMo/sNCIMREXA/EqjxDFecN4LmOTOK5A0YBiH9Cc01sd
        qSaavtSQqhqbjV+0bUNEA7UohXbc3s3bx3qa5VFhiIh8sBQMaQdyRkCK/MxMc16d
        BSx5XQ/8MjVO73A1zHgH2g47BWPjgRrDL94KrgNPOO0FoG76QxL9GlcOHzhFa1rf
        xbb2auLBtflKy+5TZNnB/sbFC9ISpWywzfblD2Fsvxupl0vNWtA0Y2rPbKMZRnY+
        V6NC38yxW3HHAdWQRYLGOitM59I0HBgnjQKzTBNIsjPnJA2BSZvMBtQ1e3RQV0qE
        8VVoktZ8A0KDUxqdKWYlGYAY5hIw1y3UUsPRUbS3fQKBgQDAZehu+Kb5Sw+h00Qu
        vViNHDvi0PwmhQrHVpgjrppCnWsTk6FJFm+EBLY+87usXuRCnfZ1semb6P+yjLh2
        bJ9IXIrFAztcyE+7eZfn0H7mHA7E2ICKTjNdKbjy8kHViHpgdXREnAOrFTTk/BqW
        dq+weG2OuxYczWsY4XliWaVyiwKBgQC8XYExpSmoyI37o+jr9405k30tbGUw4X+/
        xYOvSUuafI8IOSLfKTpsvkMN3hxpJO6apIRAjOALbotKUA5FrHQPenuBWOr3mBJT
        euLiaWphqU8YN5dbNd+JhC/Jh5DLhY5FpB2Fv2MKSoF7+onpjDy9pEU5aReeBB0v
        ekUw4nWiBQKBgHxyrnjxP1frFG5xMB4nfZqw04+v7BmiXsl3mqsh6kgCeNtN17pl
        17YGMjfgAdnJ+02XzW5tqRSfDp3YZgy7z//HVD+BCqnGK8SxLu/ULfD73xW2kNZl
        JNYzAZ2r06eiQr4X2x/x5nGIIxGmfDAtDxFPpFX5b6ErwgVy+sgCAoFnAoGAWSpu
        EMEdQk+FnnwNsz2g9YNSuyDXmdb08SOfXWd1yXBzCLJ7RmYuyPEbrsHYcxFPfZap
        ICFPoTm35/qTdvnWiskxE56yw3eSHUBLjF/YQtixn0YZeMy8v0z6jgyFR0I2gdLZ
        QsnBKUrxlm2XwR1oV2Eef7m2u085PZNEk4pvor0CgYA6n060r48/CgRVslAeGder
        fZ3n+2ru8q2UVB38evepjLifn5+tKdFzZ7/NckXMC0NOVzm74qG46VFLMw5TtyT4
        /hRvGSYxA6dMjXy+tcrAns9Isrz2PnYFntlbhU6hw0um809tFunbvITfyeOjAsDW
        stC4thnhzXXT1Y3RfFtYEg==
        -----END PRIVATE KEY-----
    encryption:
      key-id: encryption-key
      public-key: |-
        -----BEGIN PUBLIC KEY-----
        MIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEAtU7Vu4tML8qg9BISaUH0
        BTU0+qkHJS3TUl3R0hEPttZJGf8EgT7bpWqRjdhMC2SYt2ifNF82EgMo/eva1rLn
        wYtCsxjJ7oB4U2m16/JKHtphmMUGhSLgbp+Y8pGAQ+P6u4HLlI0qbL92Syb6QCTr
        nYIlzZ2uUAvUQg/SbuAvdS4kdauZtpMNbhryusMVvILVBC5yUhfLJAkjbU3qWo/n
        2NKPr4kjwwFh6FaAf0HLsXCFmJbPPok6WMZeDqPORPZCt5gU2t04fS7s/2SSbhQ/
        i+7yyT4pl44cUlNLLN3Qo73sai5H90q7Dvmk3M5/YMJB0Ueyb705LHyOO5xA618s
        qQIDAQAB
        -----END PUBLIC KEY-----
      private-key: |-
        -----BEGIN PRIVATE KEY-----
        MIIEvgIBADANBgkqhkiG9w0BAQEFAASCBKgwggSkAgEAAoIBAQC1TtW7i0wvyqD0
        EhJpQfQFNTT6qQclLdNSXdHSEQ+21kkZ/wSBPtulapGN2EwLZJi3aJ80XzYSAyj9
        69rWsufBi0KzGMnugHhTabXr8koe2mGYxQaFIuBun5jykYBD4/q7gcuUjSpsv3ZL
        JvpAJOudgiXNna5QC9RCD9Ju4C91LiR1q5m2kw1uGvK6wxW8gtUELnJSF8skCSNt
        Tepaj+fY0o+viSPDAWHoVoB/QcuxcIWYls8+iTpYxl4Oo85E9kK3mBTa3Th9Luz/
        ZJJuFD+L7vLJPimXjhxSU0ss3dCjvexqLkf3SrsO+aTczn9gwkHRR7JvvTksfI47
        nEDrXyypAgMBAAECggEAREnJHrY8n9OGA+e6n4KD0mJT7gUz98Dm0yMbIC/k50yW
        hAAVRkjSmd8lq3NIURI2ov342NTznJ0sF1d6OVtxBujY2nP/uqEQsPoj1xaO7Ef8
        cnnjFsooFgJurQ44bVm02mLstqrky8jhWTT5FKfTRqP6cRNu0B9kdu1WqQQvW8a/
        C8xD8XUFzzJFQsEstJ076NjlZNH3EeqFiLxyVdV7tPEJRnOe2V2BAAgda3ByA6Jc
        Nd4xYHTVr5rZ+KES9gaAgb86+S7hNigsxz5Gp58NimLEyz1Qd+d9QCgPRgKOV5Uq
        0ci6c28ZrxW9wa/2CGCpoow1V7hRy1fZ24g2Tz91cQKBgQDbSdP/FQYuem0pUf8u
        mA/niEC8Jz30FW3ix5aqbQ8YRudK48Xy8F7AWnlS0wT2k/Xaeppn9YSPK4HlsNk2
        1gnpNfzdqXpJQtuxcPPeFNzUdXzBrsLXYqtlhOX/afrzqMhp73gkqoxXtqwD7BqN
        VfMcVXsWrEZQrRPBn/RUnnLdJwKBgQDTqUGupm93UlhoPgLXHGF/seQwPPHcU6lS
        SS9l512Ie21B+vZecgO4r77BXJwbY4rZVA5/m+wrsNmsT2f8yfdbs84cBDDWiKy5
        t2Um8zrus+BCIffxc9Fck9/htK33jLLcYwdSAm3a9pJxR9f/kAdredSTGBNJ3W/2
        rfh3cdNprwKBgDi7WfBFRSsjGzi0cPth9cNlubGzyVBrdtlT34PJ4Tzboxz53o1i
        aHEFNxwZYdBVKSbTzzyUBS5xCBMfdKK+LyQ5hmjmXq+zb1jxqvXKmfMRTixhhSDp
        8wO5pTM1/Omqwea+QGvj/5j1tnzxSVFFajbrWoPcH/jhPho6wqBducPDAoGBALOJ
        MEOavZXy7TaO0w3v7uvH0wzvxR/kfw1jMqc3l2j7ePOskmoOQAXaXO3bRjcdOlua
        Jyoq8islOZ4lRMlx7zWD0OKG035GNGzbmRtu2aA8R48RDSVr3jyu2gqznZULbXPv
        M/hmQxSmbhVUoW0PmJubnaqfk0zmXeBaNRXsIS3VAoGBALdsAtqR23PVeL6sYj2l
        dRNTDXpfvjFqJ5NThRO/4mT0CrPHQVj+Mz2bTc/Dxiwi8s8m3L+g23i3hodh/QMb
        Iz+UbcJZBGAKsFbPKGOtj6Bi07y/L11mcuNJzOWe61/JbVmJss0s+N/v3XucK/Ge
        CUaGOccsMO221v6JoBh9J3Hz
        -----END PRIVATE KEY-----
</code></pre>
<p>master.xml</p>
<pre><code class="language-xml">&#x3C;?xml version="1.0" encoding="UTF-8"?>
&#x3C;databaseChangeLog
  xmlns="http://www.liquibase.org/xml/ns/dbchangelog"
  xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
  xsi:schemaLocation="
      http://www.liquibase.org/xml/ns/dbchangelog
      http://www.liquibase.org/xml/ns/dbchangelog/dbchangelog-4.9.xsd">

  &#x3C;!-- H2 defaults -->
  &#x3C;property name="now" value="now()" dbms="h2"/>
  &#x3C;property name="floatType" value="float4" dbms="h2"/>
  &#x3C;property name="uuidType" value="uuid" dbms="h2"/>
  &#x3C;property name="datetimeType" value="datetime(6)" dbms="h2"/>
  &#x3C;property name="binaryType" value="LONGVARBINARY" dbms="h2"/>
  &#x3C;property name="clobType" value="longvarchar" dbms="h2"/>
  &#x3C;property name="blobType" value="blob" dbms="h2"/>

  &#x3C;!-- PostgreSQL overrides -->
  &#x3C;property name="now" value="current_timestamp" dbms="postgresql"/>
  &#x3C;property name="floatType" value="float4" dbms="postgresql"/>
  &#x3C;property name="uuidType" value="uuid" dbms="postgresql"/>
  &#x3C;property name="datetimeType" value="datetime" dbms="postgresql"/>
  &#x3C;property name="binaryType" value="BYTEA" dbms="postgresql"/>
  &#x3C;property name="clobType" value="clob" dbms="postgresql"/>
  &#x3C;property name="blobType" value="blob" dbms="postgresql"/>

  &#x3C;!-- include the core auth changelog -->
  &#x3C;include file="classpath:db/changelog/changelog-user.xml"/>

&#x3C;/databaseChangeLog>
</code></pre>
<p>changelog-user.xml</p>
<pre><code class="language-xml">&#x3C;?xml version="1.0" encoding="UTF-8"?>
&#x3C;databaseChangeLog
  xmlns="http://www.liquibase.org/xml/ns/dbchangelog"
  xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
  xsi:schemaLocation="
      http://www.liquibase.org/xml/ns/dbchangelog
      http://www.liquibase.org/xml/ns/dbchangelog/dbchangelog-4.9.xsd">

  &#x3C;changeSet id="20250510-1" author="susimsek">
    &#x3C;createTable tableName="user_identity">
      &#x3C;column name="id" type="varchar(36)">
        &#x3C;constraints primaryKey="true" primaryKeyName="pk_user_identity" nullable="false"/>
      &#x3C;/column>
      &#x3C;column name="username" type="varchar(50)">
        &#x3C;constraints nullable="false" unique="true"/>
      &#x3C;/column>
      &#x3C;column name="password" type="varchar(100)">
        &#x3C;constraints nullable="false"/>
      &#x3C;/column>
      &#x3C;column name="email" type="varchar(100)">
        &#x3C;constraints nullable="false" unique="true"/>
      &#x3C;/column>
      &#x3C;column name="first_name" type="varchar(50)"/>
      &#x3C;column name="last_name" type="varchar(50)"/>
      &#x3C;column name="enabled" type="boolean">
        &#x3C;constraints nullable="false"/>
      &#x3C;/column>
      &#x3C;column name="created_at" type="datetime">
        &#x3C;constraints nullable="false"/>
      &#x3C;/column>
      &#x3C;column name="created_by" type="varchar(50)">
        &#x3C;constraints nullable="false"/>
      &#x3C;/column>
      &#x3C;column name="updated_at" type="datetime"/>
      &#x3C;column name="updated_by" type="varchar(50)"/>
    &#x3C;/createTable>

    &#x3C;createIndex indexName="idx_user_identity_username" tableName="user_identity">
      &#x3C;column name="username"/>
    &#x3C;/createIndex>
    &#x3C;createIndex indexName="idx_user_identity_email" tableName="user_identity">
      &#x3C;column name="email"/>
    &#x3C;/createIndex>
  &#x3C;/changeSet>

  &#x3C;changeSet id="20250510-2" author="susimsek">
    &#x3C;createTable tableName="authority">
      &#x3C;column name="id" type="varchar(36)">
        &#x3C;constraints primaryKey="true" primaryKeyName="pk_authority" nullable="false"/>
      &#x3C;/column>
      &#x3C;column name="name" type="varchar(50)">
        &#x3C;constraints nullable="false" unique="true"/>
      &#x3C;/column>
      &#x3C;column name="description" type="varchar(255)"/>
      &#x3C;column name="created_at" type="datetime">
        &#x3C;constraints nullable="false"/>
      &#x3C;/column>
      &#x3C;column name="created_by" type="varchar(50)">
        &#x3C;constraints nullable="false"/>
      &#x3C;/column>
      &#x3C;column name="updated_at" type="datetime"/>
      &#x3C;column name="updated_by" type="varchar(50)"/>
    &#x3C;/createTable>

    &#x3C;createIndex indexName="idx_authority_name" tableName="authority">
      &#x3C;column name="name"/>
    &#x3C;/createIndex>
  &#x3C;/changeSet>

  &#x3C;changeSet id="20250510-3" author="susimsek">
    &#x3C;createTable tableName="user_authority_mapping">
      &#x3C;column name="user_id" type="varchar(36)">
        &#x3C;constraints nullable="false"/>
      &#x3C;/column>
      &#x3C;column name="authority_id" type="varchar(36)">
        &#x3C;constraints nullable="false"/>
      &#x3C;/column>
      &#x3C;column name="created_at" type="datetime">
        &#x3C;constraints nullable="false"/>
      &#x3C;/column>
      &#x3C;column name="created_by" type="varchar(50)">
        &#x3C;constraints nullable="false"/>
      &#x3C;/column>
      &#x3C;column name="updated_at" type="datetime"/>
      &#x3C;column name="updated_by" type="varchar(50)"/>
    &#x3C;/createTable>

    &#x3C;addPrimaryKey
      tableName="user_authority_mapping"
      columnNames="user_id, authority_id"
      constraintName="pk_user_authority_mapping"/>
  &#x3C;/changeSet>

  &#x3C;changeSet id="20250510-4" author="susimsek">
    &#x3C;addForeignKeyConstraint
      baseTableName="user_authority_mapping"
      baseColumnNames="user_id"
      constraintName="fk_user_authority_user"
      referencedTableName="user_identity"
      referencedColumnNames="id"/>
  &#x3C;/changeSet>

  &#x3C;changeSet id="20250510-5" author="susimsek">
    &#x3C;addForeignKeyConstraint
      baseTableName="user_authority_mapping"
      baseColumnNames="authority_id"
      constraintName="fk_user_authority_authority"
      referencedTableName="authority"
      referencedColumnNames="id"/>
  &#x3C;/changeSet>

  &#x3C;changeSet id="20250510-1-data" author="susimsek">
    &#x3C;loadData
      file="db/data/user.csv"
      separator=";"
      tableName="user_identity">
      &#x3C;column name="id" type="string"/>
      &#x3C;column name="username" type="string"/>
      &#x3C;column name="password" type="string"/>
      &#x3C;column name="email" type="string"/>
      &#x3C;column name="first_name" type="string"/>
      &#x3C;column name="last_name" type="string"/>
      &#x3C;column name="enabled" type="boolean"/>
      &#x3C;column name="created_at" type="datetime"/>
      &#x3C;column name="created_by" type="string"/>
      &#x3C;column name="updated_at" type="datetime"/>
      &#x3C;column name="updated_by" type="string"/>
    &#x3C;/loadData>
  &#x3C;/changeSet>

  &#x3C;changeSet id="20250510-2-data" author="susimsek">
    &#x3C;loadData
      file="db/data/authority.csv"
      separator=";"
      tableName="authority">
      &#x3C;column name="id" type="string"/>
      &#x3C;column name="name" type="string"/>
      &#x3C;column name="description" type="string"/>
      &#x3C;column name="created_at" type="datetime"/>
      &#x3C;column name="created_by" type="string"/>
      &#x3C;column name="updated_at" type="datetime"/>
      &#x3C;column name="updated_by" type="string"/>
    &#x3C;/loadData>
  &#x3C;/changeSet>

  &#x3C;changeSet id="20250510-3-data" author="susimsek">
    &#x3C;loadData
      file="db/data/user_authority_mapping.csv"
      separator=";"
      tableName="user_authority_mapping">
      &#x3C;column name="user_id" type="string"/>
      &#x3C;column name="authority_id" type="string"/>
      &#x3C;column name="created_at" type="datetime"/>
      &#x3C;column name="created_by" type="string"/>
      &#x3C;column name="updated_at" type="datetime"/>
      &#x3C;column name="updated_by" type="string"/>
    &#x3C;/loadData>
  &#x3C;/changeSet>

&#x3C;/databaseChangeLog>
</code></pre>
<p>user.csv</p>
<pre><code class="language-csv">id;username;password;email;first_name;last_name;enabled;created_at;created_by;updated_at;updated_by
a1b2c3d4-e5f6-7890-abcd-ef1234567890;admin;$2a$10$sva6wl8pmGKJE6NIWrxwcuJK1Jaa2I/LOI43iHVpbR4YB8KjGViiK;admin@example.com;Admin;User;true;2025-05-10 12:00:00;system;2025-05-10 12:00:00;system
09876543-21fe-dcba-0987-654321fedcba;user;$2a$10$5Py4PyteLuXEqnGpSigzfu0V55C7Hi7zX18lmh.J8Bpmft.h23voG;user@example.com;Normal;User;true;2025-05-10 12:00:00;system;2025-05-10 12:00:00;system
</code></pre>
<p>authority.csv</p>
<pre><code class="language-csv">id;name;description;created_at;created_by;updated_at;updated_by
f47ac10b-58cc-4372-a567-0e02b2c3d479;ROLE_ADMIN;Administrator role;2025-05-10 12:00:00;system;2025-05-10 12:00:00;system
9c858901-8a57-4791-81fe-4c455b099bc9;ROLE_USER;User role;2025-05-10 12:00:00;system;2025-05-10 12:00:00;system
</code></pre>
<p>user_authority_mapping.csv</p>
<pre><code class="language-csv">user_id;authority_id;created_at;created_by;updated_at;updated_by
a1b2c3d4-e5f6-7890-abcd-ef1234567890;9c858901-8a57-4791-81fe-4c455b099bc9;2025-05-10 12:00:00;system;2025-05-10 12:00:00;system
a1b2c3d4-e5f6-7890-abcd-ef1234567890;f47ac10b-58cc-4372-a567-0e02b2c3d479;2025-05-10 12:00:00;system;2025-05-10 12:00:00;system
09876543-21fe-dcba-0987-654321fedcba;9c858901-8a57-4791-81fe-4c455b099bc9;2025-05-10 12:00:00;system;2025-05-10 12:00:00;system
</code></pre>
<hr>
<h2>ğŸ› ï¸ AdÄ±m 3: GÃ¼venlik &#x26; VeritabanÄ± YapÄ±landÄ±rmasÄ±</h2>
<p>Bu bÃ¶lÃ¼mde, JWE tabanlÄ± kimlik doÄŸrulama iÃ§in RSA anahtarlarÄ±, HTTP gÃ¼venlik filtreleri ve JPA repository / auditing yapÄ±landÄ±rmasÄ±nÄ± tanÄ±mlayan bean'leri ve ayarlarÄ± oluÅŸturuyoruz:</p>
<ul>
<li>JwtProperties: JWT dÃ¼zenleyicisi (issuer), geÃ§erlilik sÃ¼resi ve imzalama/ÅŸifreleme anahtar Ã§iftlerini yapÄ±landÄ±rÄ±r.</li>
<li>SecurityJwtConfig: RSA JWK nesnelerini oluÅŸturur, JWT encoder/decoderâ€™Ä±, authentication converter ve token resolveri yapÄ±landÄ±rÄ±r.</li>
<li>SecurityConfig: <code>DomainUserDetailsService</code> ile entegre olur, kimlik doÄŸrulama yÃ¶neticisi (authentication manager), password encoder ve JWE desteÄŸi ile stateless gÃ¼venlik filtre zincirini yapÄ±landÄ±rÄ±r.</li>
<li>DatabaseConfig: JPA repository'lerini, auditing ve transaction yÃ¶netimini etkinleÅŸtirir.</li>
</ul>
<p>SecurityJwtConfig</p>
<h3>Java</h3>
<pre><code class="language-java">package io.github.susimsek.springbootjweauthjpademo.config;

import com.nimbusds.jose.EncryptionMethod;
import com.nimbusds.jose.JWEAlgorithm;
import com.nimbusds.jose.JWSAlgorithm;
import com.nimbusds.jose.jwk.JWKSet;
import com.nimbusds.jose.jwk.RSAKey;
import com.nimbusds.jose.jwk.source.JWKSource;
import com.nimbusds.jose.proc.JWEDecryptionKeySelector;
import com.nimbusds.jose.proc.JWSVerificationKeySelector;
import com.nimbusds.jose.proc.SecurityContext;
import com.nimbusds.jwt.proc.DefaultJWTProcessor;
import io.github.susimsek.springbootjweauthjpademo.security.CookieBearerTokenResolver;
import io.github.susimsek.springbootjweauthjpademo.security.KeyUtils;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.security.oauth2.jwt.JwtDecoder;
import org.springframework.security.oauth2.jwt.JwtEncoder;
import org.springframework.security.oauth2.jwt.NimbusJwtDecoder;
import org.springframework.security.oauth2.jwt.NimbusJwtEncoder;
import org.springframework.security.oauth2.server.resource.authentication.JwtAuthenticationConverter;
import org.springframework.security.oauth2.server.resource.authentication.JwtGrantedAuthoritiesConverter;
import org.springframework.security.oauth2.server.resource.web.BearerTokenResolver;

import java.util.List;

import static io.github.susimsek.springbootjweauthjpademo.security.SecurityUtils.AUTHORITIES_KEY;

@Configuration
public class SecurityJwtConfig {

    private final JwtProperties props;
    public SecurityJwtConfig(JwtProperties props) { this.props = props; }

    @Bean
    public RSAKey signingKey() throws Exception {
        return KeyUtils.buildRsaKey(
            props.getSigning().getPublicKey(),
            props.getSigning().getPrivateKey(),
            props.getSigning().getKeyId(),
            true
        );
    }

    @Bean
    public RSAKey encryptionKey() throws Exception {
        return KeyUtils.buildRsaKey(
            props.getEncryption().getPublicKey(),
            props.getEncryption().getPrivateKey(),
            props.getEncryption().getKeyId(),
            false
        );
    }

    @Bean
    public JWKSource&#x3C;SecurityContext> jwkSource(RSAKey signingKey, RSAKey encryptionKey) {
        JWKSet jwkSet = new JWKSet(List.of(
            signingKey,
            encryptionKey
        ));
        return (jwkSelector, context) -> jwkSelector.select(jwkSet);
    }

    @Bean
    public JwtDecoder jwtDecoder(JWKSource&#x3C;SecurityContext> jwkSource) {
        DefaultJWTProcessor&#x3C;SecurityContext> jwtProcessor = new DefaultJWTProcessor&#x3C;>();
        JWEDecryptionKeySelector&#x3C;SecurityContext> jweKeySelector =
            new JWEDecryptionKeySelector&#x3C;>(
                JWEAlgorithm.RSA_OAEP_256,
                EncryptionMethod.A128GCM,
                jwkSource
            );
        jwtProcessor.setJWEKeySelector(jweKeySelector);

        JWSVerificationKeySelector&#x3C;SecurityContext> jwsKeySelector =
            new JWSVerificationKeySelector&#x3C;>(
                JWSAlgorithm.RS256,
                jwkSource
            );
        jwtProcessor.setJWSKeySelector(jwsKeySelector);
        jwtProcessor.setJWTClaimsSetVerifier((claims, context) -> {});

        return new NimbusJwtDecoder(jwtProcessor);
    }

    @Bean
    public JwtEncoder jwtEncoder(JWKSource&#x3C;SecurityContext> jwkSource) {
        return new NimbusJwtEncoder(jwkSource);
    }

    @Bean
    public JwtAuthenticationConverter jwtAuthenticationConverter() {
        JwtGrantedAuthoritiesConverter converter = new JwtGrantedAuthoritiesConverter();
        converter.setAuthorityPrefix("");
        converter.setAuthoritiesClaimName(AUTHORITIES_KEY);

        JwtAuthenticationConverter authConverter = new JwtAuthenticationConverter();
        authConverter.setJwtGrantedAuthoritiesConverter(converter);
        return authConverter;
    }

    @Bean
    public BearerTokenResolver bearerTokenResolver() {
        CookieBearerTokenResolver resolver = new CookieBearerTokenResolver();
        resolver.setAllowUriQueryParameter(false);
        resolver.setAllowFormEncodedBodyParameter(false);
        resolver.setAllowCookie(true);
        return resolver;
    }
}
</code></pre>
<h3>Kotlin</h3>
<pre><code class="language-kotlin">package io.github.susimsek.springbootjweauthjpademo.config

import com.nimbusds.jose.EncryptionMethod
import com.nimbusds.jose.JWEAlgorithm
import com.nimbusds.jose.JWSAlgorithm
import com.nimbusds.jose.jwk.JWKSet
import com.nimbusds.jose.jwk.RSAKey
import com.nimbusds.jose.jwk.source.JWKSource
import com.nimbusds.jose.proc.JWEDecryptionKeySelector
import com.nimbusds.jose.proc.JWSVerificationKeySelector
import com.nimbusds.jose.proc.SecurityContext
import com.nimbusds.jwt.proc.DefaultJWTProcessor
import io.github.susimsek.springbootjweauthjpademo.security.CookieBearerTokenResolver
import io.github.susimsek.springbootjweauthjpademo.security.KeyUtils
import org.springframework.context.annotation.Bean
import org.springframework.context.annotation.Configuration
import org.springframework.security.oauth2.jwt.JwtDecoder
import org.springframework.security.oauth2.jwt.JwtEncoder
import org.springframework.security.oauth2.jwt.NimbusJwtDecoder
import org.springframework.security.oauth2.jwt.NimbusJwtEncoder
import org.springframework.security.oauth2.server.resource.authentication.JwtAuthenticationConverter
import org.springframework.security.oauth2.server.resource.authentication.JwtGrantedAuthoritiesConverter
import org.springframework.security.oauth2.server.resource.web.BearerTokenResolver

@Configuration
class SecurityJwtConfig(private val props: JwtProperties) {

    @Bean
    @Throws(Exception::class)
    fun signingKey(): RSAKey =
        KeyUtils.buildRsaKey(
            props.signing.publicKey,
            props.signing.privateKey,
            props.signing.keyId,
            true
        )

    @Bean
    @Throws(Exception::class)
    fun encryptionKey(): RSAKey =
        KeyUtils.buildRsaKey(
            props.encryption.publicKey,
            props.encryption.privateKey,
            props.encryption.keyId,
            false
        )

    @Bean
    fun jwkSource(signingKey: RSAKey, encryptionKey: RSAKey): JWKSource&#x3C;SecurityContext> {
        val jwkSet = JWKSet(listOf(signingKey, encryptionKey))
        return JWKSource { jwkSelector, context -> jwkSelector.select(jwkSet) }
    }

    @Bean
    fun jwtDecoder(jwkSource: JWKSource&#x3C;SecurityContext>): JwtDecoder {
        val jwtProcessor = DefaultJWTProcessor&#x3C;SecurityContext>()
        val jweKeySelector = JWEDecryptionKeySelector(
            JWEAlgorithm.RSA_OAEP_256,
            EncryptionMethod.A128GCM,
            jwkSource
        )
        jwtProcessor.jweKeySelector = jweKeySelector
        val jwsKeySelector = JWSVerificationKeySelector(
            JWSAlgorithm.RS256,
            jwkSource
        )
        jwtProcessor.jwsKeySelector = jwsKeySelector
        jwtProcessor.jwtClaimsSetVerifier = { _, _ -> }
        return NimbusJwtDecoder(jwtProcessor)
    }

    @Bean
    fun jwtEncoder(jwkSource: JWKSource&#x3C;SecurityContext>): JwtEncoder =
        NimbusJwtEncoder(jwkSource)

    @Bean
    fun jwtAuthenticationConverter(): JwtAuthenticationConverter {
        val converter = JwtGrantedAuthoritiesConverter().apply {
            setAuthorityPrefix("")
            setAuthoritiesClaimName(AUTHORITIES_KEY)
        }
        return JwtAuthenticationConverter().apply {
            setJwtGrantedAuthoritiesConverter(converter)
        }
    }

    @Bean
    fun bearerTokenResolver(): BearerTokenResolver =
        CookieBearerTokenResolver().apply {
            setAllowUriQueryParameter(false)
            setAllowFormEncodedBodyParameter(false)
            setAllowCookie(true)
        }
}
</code></pre>
<p>SecurityConfig</p>
<h3>Java</h3>
<pre><code class="language-java">package io.github.susimsek.springbootjweauthjpademo.config;

import io.github.susimsek.springbootjweauthjpademo.repository.UserRepository;
import io.github.susimsek.springbootjweauthjpademo.security.AuthoritiesConstants;
import io.github.susimsek.springbootjweauthjpademo.security.DomainUserDetailsService;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.security.authentication.AuthenticationManager;
import org.springframework.security.authentication.ProviderManager;
import org.springframework.security.authentication.dao.DaoAuthenticationProvider;
import org.springframework.security.config.annotation.method.configuration.EnableMethodSecurity;
import org.springframework.security.config.annotation.web.builders.HttpSecurity;
import org.springframework.security.config.annotation.web.configurers.AbstractHttpConfigurer;
import org.springframework.security.config.http.SessionCreationPolicy;
import org.springframework.security.core.userdetails.UserDetailsService;
import org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder;
import org.springframework.security.crypto.password.PasswordEncoder;
import org.springframework.security.web.SecurityFilterChain;
import org.springframework.security.web.servlet.util.matcher.MvcRequestMatcher;
import org.springframework.web.servlet.handler.HandlerMappingIntrospector;

import static org.springframework.security.config.Customizer.withDefaults;

@Configuration
@EnableMethodSecurity(securedEnabled = true)
public class SecurityConfig {

  @Bean
  public SecurityFilterChain securityFilterChain(HttpSecurity http,
                                                 MvcRequestMatcher.Builder mvc) throws Exception {
    http
      .cors(withDefaults())
      .csrf(AbstractHttpConfigurer::disable)
      .authorizeHttpRequests(authz -> authz
        .requestMatchers(
          mvc.pattern("/webjars/**"),
          mvc.pattern("/css/**"),
          mvc.pattern("/js/**")
        ).permitAll()
        .requestMatchers(
          mvc.pattern("/*.ico"),
          mvc.pattern("/*.png"),
          mvc.pattern("/*.svg"),
          mvc.pattern("/*.webapp")
        ).permitAll()
        .requestMatchers("/actuator/**").permitAll()
        .requestMatchers(
          "/v3/api-docs/**",
          "/swagger-ui.html",
          "/swagger-ui/**"
        ).permitAll()
        .requestMatchers(mvc.pattern("/api/auth/login")).permitAll()
        .requestMatchers(mvc.pattern("/api/hello/admin")).hasAuthority(AuthoritiesConstants.ADMIN)
        .anyRequest().authenticated()
      )
      .sessionManagement(session ->
        session.sessionCreationPolicy(SessionCreationPolicy.STATELESS)
      )
      .oauth2ResourceServer(oauth2 -> oauth2.jwt(withDefaults()));

    return http.build();
  }

  @Bean
  public UserDetailsService userDetailsService(UserRepository userRepository) {
    return new DomainUserDetailsService(userRepository);
  }

  @Bean
  public PasswordEncoder passwordEncoder() {
    return new BCryptPasswordEncoder();
  }

  @Bean
  public AuthenticationManager authenticationManager(
    UserDetailsService userDetailsService,
    PasswordEncoder passwordEncoder) {
    DaoAuthenticationProvider authenticationProvider = new DaoAuthenticationProvider();
    authenticationProvider.setUserDetailsService(userDetailsService);
    authenticationProvider.setPasswordEncoder(passwordEncoder);

    return new ProviderManager(authenticationProvider);
  }

  @Bean
  public MvcRequestMatcher.Builder mvc(HandlerMappingIntrospector introspector) {
    return new MvcRequestMatcher.Builder(introspector);
  }
}
</code></pre>
<h3>Kotlin</h3>
<pre><code class="language-kotlin">package io.github.susimsek.springbootjweauthjpademo.config

import io.github.susimsek.springbootjweauthjpademo.repository.UserRepository
import io.github.susimsek.springbootjweauthjpademo.security.AuthoritiesConstants
import io.github.susimsek.springbootjweauthjpademo.security.DomainUserDetailsService
import org.springframework.context.annotation.Bean
import org.springframework.context.annotation.Configuration
import org.springframework.security.authentication.AuthenticationManager
import org.springframework.security.authentication.ProviderManager
import org.springframework.security.authentication.dao.DaoAuthenticationProvider
import org.springframework.security.config.annotation.method.configuration.EnableMethodSecurity
import org.springframework.security.config.annotation.web.builders.HttpSecurity
import org.springframework.security.config.configurers.AbstractHttpConfigurer
import org.springframework.security.config.http.SessionCreationPolicy
import org.springframework.security.core.userdetails.UserDetailsService
import org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder
import org.springframework.security.crypto.password.PasswordEncoder
import org.springframework.security.web.SecurityFilterChain
import org.springframework.security.web.servlet.util.matcher.MvcRequestMatcher
import org.springframework.web.servlet.handler.HandlerMappingIntrospector

@Configuration
@EnableMethodSecurity(securedEnabled = true)
class SecurityConfig {

  @Bean
  @Throws(Exception::class)
  fun securityFilterChain(http: HttpSecurity,
                          mvc: MvcRequestMatcher.Builder): SecurityFilterChain {
    http
      .cors(withDefaults())
      .csrf { it.disable() }
      .authorizeHttpRequests { authz ->
        authz
          .requestMatchers(
            mvc.pattern("/webjars/**"),
            mvc.pattern("/css/**"),
            mvc.pattern("/js/**")
          ).permitAll()
          .requestMatchers(
            mvc.pattern("/*.ico"),
            mvc.pattern("/*.png"),
            mvc.pattern("/*.svg"),
            mvc.pattern("/*.webapp")
          ).permitAll()
          .requestMatchers("/actuator/**").permitAll()
          .requestMatchers(
            "/v3/api-docs/**",
            "/swagger-ui.html",
            "/swagger-ui/**"
          ).permitAll()
          .requestMatchers(mvc.pattern("/api/auth/login")).permitAll()
          .requestMatchers(mvc.pattern("/api/hello/admin")).hasAuthority(AuthoritiesConstants.ADMIN)
          .anyRequest().authenticated()
      }
      .sessionManagement { it.sessionCreationPolicy(SessionCreationPolicy.STATELESS) }
      .oauth2ResourceServer { it.jwt(withDefaults()) }

    return http.build()
  }

  @Bean
  fun userDetailsService(userRepository: UserRepository): UserDetailsService =
    DomainUserDetailsService(userRepository)

  @Bean
  fun passwordEncoder(): PasswordEncoder = BCryptPasswordEncoder()

  @Bean
  fun authenticationManager(
    userDetailsService: UserDetailsService,
    passwordEncoder: PasswordEncoder
  ): AuthenticationManager {
    val provider = DaoAuthenticationProvider().apply {
      setUserDetailsService(userDetailsService)
      setPasswordEncoder(passwordEncoder)
    }
    return ProviderManager(provider)
  }

  @Bean
  fun mvc(introspector: HandlerMappingIntrospector): MvcRequestMatcher.Builder =
    MvcRequestMatcher.Builder(introspector)
}
</code></pre>
<p>JwtProperties</p>
<h3>Java</h3>
<pre><code class="language-java">package io.github.susimsek.springbootjweauthjpademo.config;

import lombok.Data;
import org.springframework.boot.context.properties.ConfigurationProperties;
import org.springframework.context.annotation.Configuration;

import java.time.Duration;

@Configuration
@ConfigurationProperties(prefix = "security.jwt")
@Data
public class JwtProperties {

    @Data
    public static class Pair {
        private String publicKey;
        private String privateKey;
        private String keyId;
    }

    private Pair signing;
    private Pair encryption;
    private String issuer;
    private Duration expirationDuration;
}
</code></pre>
<h3>Kotlin</h3>
<pre><code class="language-kotlin">package io.github.susimsek.springbootjweauthjpademo.config

import org.springframework.boot.context.properties.ConfigurationProperties
import org.springframework.context.annotation.Configuration
import java.time.Duration

@Configuration
@ConfigurationProperties(prefix = "security.jwt")
class JwtProperties {

  class Pair {
    lateinit var publicKey: String
    lateinit var privateKey: String
    lateinit var keyId: String
  }

  lateinit var signing: Pair
  lateinit var encryption: Pair
  lateinit var issuer: String
  lateinit var expirationDuration: Duration
}
</code></pre>
<p>DatabaseConfig</p>
<h3>Java</h3>
<pre><code class="language-java">package io.github.susimsek.springbootjweauthjpademo.config;

import org.springframework.context.annotation.Configuration;
import org.springframework.data.jpa.repository.config.EnableJpaAuditing;
import org.springframework.data.jpa.repository.config.EnableJpaRepositories;
import org.springframework.transaction.annotation.EnableTransactionManagement;

@Configuration
@EnableJpaRepositories("io.github.susimsek.springbootjweauthjpademo.repository")
@EnableJpaAuditing(auditorAwareRef = "springSecurityAuditorAware")
@EnableTransactionManagement
public class DatabaseConfig {

}
</code></pre>
<h3>Kotlin</h3>
<pre><code class="language-kotlin">package io.github.susimsek.springbootjweauthjpademo.config

import org.springframework.context.annotation.Configuration
import org.springframework.data.jpa.repository.config.EnableJpaAuditing
import org.springframework.data.jpa.repository.config.EnableJpaRepositories
import org.springframework.transaction.annotation.EnableTransactionManagement

@Configuration
@EnableJpaRepositories("io.github.susimsek.springbootjweauthjpademo.repository")
@EnableJpaAuditing(auditorAwareRef = "springSecurityAuditorAware")
@EnableTransactionManagement
class DatabaseConfig
</code></pre>
<hr>
<h2>ğŸ› ï¸ AdÄ±m 4: JPA Entegrasyonu</h2>
<p>Bu bÃ¶lÃ¼mde, kullanÄ±cÄ±larÄ±, rollerleri ve bunlarÄ±n eÅŸlemelerini temsil eden JPA entityâ€™lerini ve kullanÄ±cÄ±larÄ± yetkileriyle birlikte yÃ¼klemek iÃ§in Spring Data JPA deposunu tanÄ±mlÄ±yoruz.</p>
<ul>
<li>BaseEntity: Audit alanlarÄ± (<code>createdAt</code>, <code>createdBy</code>, <code>updatedAt</code>, <code>updatedBy</code>) saÄŸlayan soyut Ã¼st sÄ±nÄ±f.</li>
<li>Authority: Rol verilerini saklayan <code>authority</code> tablosu entityâ€™si.</li>
<li>User: KullanÄ±cÄ± kimlik bilgileri ve profili saklayan <code>user_identity</code> tablosu entityâ€™si.</li>
<li>UserAuthorityMapping: KullanÄ±cÄ±larÄ± ve rolleri birbirine baÄŸlayan <code>user_authority_mapping</code> iliÅŸki tablosunun entityâ€™si.</li>
<li>UserAuthorityMappingId: <code>UserAuthorityMapping</code> iÃ§in composite anahtar sÄ±nÄ±fÄ±.</li>
<li>UserRepository: Entity graph kullanarak kullanÄ±cÄ± ve yetkilerini getiren Spring Data JPA repository.</li>
</ul>
<p>BaseEntity</p>
<h3>Java</h3>
<pre><code class="language-java">package io.github.susimsek.springbootjweauthjpademo.entity;

import jakarta.persistence.Column;
import jakarta.persistence.EntityListeners;
import jakarta.persistence.MappedSuperclass;
import lombok.Getter;
import lombok.Setter;
import org.springframework.data.annotation.CreatedBy;
import org.springframework.data.annotation.CreatedDate;
import org.springframework.data.annotation.LastModifiedBy;
import org.springframework.data.annotation.LastModifiedDate;
import org.springframework.data.jpa.domain.support.AuditingEntityListener;

import java.time.Instant;

@MappedSuperclass
@EntityListeners(AuditingEntityListener.class)
@Getter
@Setter
public abstract class BaseEntity {

  @CreatedDate
  @Column(name = "created_at", nullable = false, updatable = false)
  private Instant createdAt;

  @CreatedBy
  @Column(name = "created_by", nullable = false, updatable = false, length = 50)
  private String createdBy;

  @LastModifiedDate
  @Column(name = "updated_at")
  private Instant updatedAt;

  @LastModifiedBy
  @Column(name = "updated_by", length = 50)
  private String updatedBy;
}
</code></pre>
<h3>Kotlin</h3>
<pre><code class="language-kotlin">package io.github.susimsek.springbootjweauthjpademo.entity

import jakarta.persistence.Column
import jakarta.persistence.EntityListeners
import jakarta.persistence.MappedSuperclass
import org.springframework.data.annotation.CreatedBy
import org.springframework.data.annotation.CreatedDate
import org.springframework.data.annotation.LastModifiedBy
import org.springframework.data.annotation.LastModifiedDate
import org.springframework.data.jpa.domain.support.AuditingEntityListener
import java.time.Instant

@MappedSuperclass
@EntityListeners(AuditingEntityListener::class)
abstract class BaseEntity {

  @CreatedDate
  @Column(name = "created_at", nullable = false, updatable = false)
  lateinit var createdAt: Instant

  @CreatedBy
  @Column(name = "created_by", nullable = false, updatable = false, length = 50)
  lateinit var createdBy: String

  @LastModifiedDate
  @Column(name = "updated_at")
  var updatedAt: Instant? = null

  @LastModifiedBy
  @Column(name = "updated_by", length = 50)
  var updatedBy: String? = null
}
</code></pre>
<p>Authority</p>
<h3>Java</h3>
<pre><code class="language-java">package io.github.susimsek.springbootjweauthjpademo.entity;

import jakarta.persistence.Column;
import jakarta.persistence.Entity;
import jakarta.persistence.Id;
import jakarta.persistence.Table;
import lombok.AllArgsConstructor;
import lombok.Getter;
import lombok.NoArgsConstructor;
import lombok.Setter;
import org.hibernate.proxy.HibernateProxy;

import java.util.Objects;

@Entity
@Table(name = "authority")
@Getter
@Setter
@NoArgsConstructor
@AllArgsConstructor
public class Authority extends BaseEntity {

  @Id
  @Column(length = 36, nullable = false)
  private String id;

  @Column(length = 50, nullable = false, unique = true)
  private String name;

  @Column(length = 255)
  private String description;

  @Override
  public final boolean equals(Object obj) {
    if (this == obj) {
      return true;
    }
    if (!(obj instanceof Authority other)) {
      return false;
    }
    Class&#x3C;?> objClass = obj instanceof HibernateProxy proxy
      ? proxy.getHibernateLazyInitializer().getPersistentClass()
      : obj.getClass();
    Class&#x3C;?> thisClass = this instanceof HibernateProxy proxy
      ? proxy.getHibernateLazyInitializer().getPersistentClass()
      : this.getClass();
    if (!thisClass.equals(objClass)) {
      return false;
    }
    return id != null &#x26;&#x26; Objects.equals(id, other.id);
  }

  @Override
  public final int hashCode() {
    return this instanceof HibernateProxy proxy
      ? proxy.getHibernateLazyInitializer().getPersistentClass().hashCode()
      : getClass().hashCode();
  }
}
</code></pre>
<h3>Kotlin</h3>
<pre><code class="language-kotlin">package io.github.susimsek.springbootjweauthjpademo.entity

import jakarta.persistence.Column
import jakarta.persistence.Entity
import jakarta.persistence.Id
import jakarta.persistence.Table
import org.hibernate.proxy.HibernateProxy
import java.util.Objects

@Entity
@Table(name = "authority")
class Authority(
  @Id
  @Column(length = 36, nullable = false)
  var id: String,

  @Column(length = 50, nullable = false, unique = true)
  var name: String,

  @Column(length = 255)
  var description: String?
) : BaseEntity() {

  override fun equals(other: Any?): Boolean {
    if (this === other) return true
    if (other !is Authority) return false
    val objClass = (other as? HibernateProxy)?.hibernateLazyInitializer?.persistentClass ?: other::class.java
    val thisClass = (this as? HibernateProxy)?.hibernateLazyInitializer?.persistentClass ?: this::class.java
    if (thisClass != objClass) return false
    return id == other.id
  }

  override fun hashCode(): Int {
    return (this as? HibernateProxy)?.hibernateLazyInitializer?.persistentClass?.hashCode()
      ?: javaClass.hashCode()
  }
}
</code></pre>
<p>User</p>
<h3>Java</h3>
<pre><code class="language-java">package io.github.susimsek.springbootjweauthjpademo.entity;

import jakarta.persistence.CascadeType;
import jakarta.persistence.Column;
import jakarta.persistence.Entity;
import jakarta.persistence.FetchType;
import jakarta.persistence.Id;
import jakarta.persistence.NamedAttributeNode;
import jakarta.persistence.NamedEntityGraph;
import jakarta.persistence.NamedSubgraph;
import jakarta.persistence.OneToMany;
import jakarta.persistence.Table;
import lombok.AllArgsConstructor;
import lombok.Getter;
import lombok.NoArgsConstructor;
import lombok.Setter;
import org.hibernate.proxy.HibernateProxy;

import java.util.HashSet;
import java.util.Objects;
import java.util.Set;

@Entity
@Table(name = "user_identity")
@Getter
@Setter
@NoArgsConstructor
@AllArgsConstructor
@NamedEntityGraph(
  name = "User.withAuthorities",
  attributeNodes = @NamedAttributeNode(value = "authorities", subgraph = "auth-subgraph"),
  subgraphs = @NamedSubgraph(
    name = "auth-subgraph",
    attributeNodes = @NamedAttributeNode("authority")
  )
)
public class User extends BaseEntity {

  @Id
  @Column(name = "id", length = 36, nullable = false, updatable = false)
  private String id;

  @Column(name = "username", length = 50, nullable = false, unique = true)
  private String username;

  @Column(name = "password", length = 100, nullable = false)
  private String password;

  @Column(name = "email", length = 100, nullable = false, unique = true)
  private String email;

  @Column(name = "first_name", length = 50)
  private String firstName;

  @Column(name = "last_name", length = 50)
  private String lastName;

  @Column(name = "enabled", nullable = false)
  private boolean enabled;

  @OneToMany(mappedBy = "user", fetch = FetchType.LAZY,
    cascade = CascadeType.ALL, orphanRemoval = true)
  private Set&#x3C;UserAuthorityMapping> authorities = new HashSet&#x3C;>();

  @Override
  public final boolean equals(Object obj) {
    if (this == obj) return true;
    if (!(obj instanceof User other)) return false;
    Class&#x3C;?> objClass = (obj instanceof HibernateProxy hp
      ? hp.getHibernateLazyInitializer().getPersistentClass()
      : obj.getClass());
    Class&#x3C;?> thisClass = (this instanceof HibernateProxy hp
      ? hp.getHibernateLazyInitializer().getPersistentClass()
      : this.getClass());
    if (!thisClass.equals(objClass)) return false;
    return id != null &#x26;&#x26; id.equals(other.id);
  }

  @Override
  public final int hashCode() {
    return (this instanceof HibernateProxy hp
      ? hp.getHibernateLazyInitializer().getPersistentClass().hashCode()
      : getClass().hashCode());
  }
}
</code></pre>
<h3>Kotlin</h3>
<pre><code class="language-kotlin">package io.github.susimsek.springbootjweauthjpademo.entity

import jakarta.persistence.CascadeType
import jakarta.persistence.Column
import jakarta.persistence.Entity
import jakarta.persistence.FetchType
import jakarta.persistence.Id
import jakarta.persistence.NamedAttributeNode
import jakarta.persistence.NamedEntityGraph
import jakarta.persistence.NamedSubgraph
import jakarta.persistence.OneToMany
import jakarta.persistence.Table
import org.hibernate.proxy.HibernateProxy
import java.util.*

@Entity
@Table(name = "user_identity")
@NamedEntityGraph(
  name = "User.withAuthorities",
  attributeNodes = [NamedAttributeNode(value = "authorities", subgraph = "auth-subgraph")],
  subgraphs = [
    NamedSubgraph(
      name = "auth-subgraph",
      attributeNodes = [NamedAttributeNode("authority")]
    )
  ]
)
class User(

  @Id
  @Column(name = "id", length = 36, nullable = false, updatable = false)
  var id: String,

  @Column(name = "username", length = 50, nullable = false, unique = true)
  var username: String,

  @Column(name = "password", length = 100, nullable = false)
  var password: String,

  @Column(name = "email", length = 100, nullable = false, unique = true)
  var email: String,

  @Column(name = "first_name", length = 50)
  var firstName: String? = null,

  @Column(name = "last_name", length = 50)
  var lastName: String? = null,

  @Column(name = "enabled", nullable = false)
  var enabled: Boolean = true

) : BaseEntity() {

  @OneToMany(
    mappedBy = "user",
    fetch = FetchType.LAZY,
    cascade = [CascadeType.ALL],
    orphanRemoval = true
  )
  var authorities: MutableSet&#x3C;UserAuthorityMapping> = HashSet()

  override fun equals(other: Any?): Boolean {
    if (this === other) return true
    if (other !is User) return false
    val objClass = (other as? HibernateProxy)?.hibernateLazyInitializer?.persistentClass
      ?: other::class.java
    val thisClass = (this as? HibernateProxy)?.hibernateLazyInitializer?.persistentClass
      ?: this::class.java
    if (thisClass != objClass) return false
    return id == other.id
  }

  override fun hashCode(): Int =
    ((this as? HibernateProxy)?.hibernateLazyInitializer?.persistentClass?.hashCode()
      ?: javaClass.hashCode())
}
</code></pre>
<p>UserAuthorityMapping</p>
<h3>Java</h3>
<pre><code class="language-java">package io.github.susimsek.springbootjweauthjpademo.entity;

import jakarta.persistence.Column;
import jakarta.persistence.Entity;
import jakarta.persistence.FetchType;
import jakarta.persistence.Id;
import jakarta.persistence.IdClass;
import jakarta.persistence.JoinColumn;
import jakarta.persistence.ManyToOne;
import jakarta.persistence.Table;
import lombok.AllArgsConstructor;
import lombok.Getter;
import lombok.NoArgsConstructor;
import lombok.Setter;
import org.hibernate.proxy.HibernateProxy;

import java.util.Objects;

@Entity
@Table(name = "user_authority_mapping")
@IdClass(UserAuthorityMappingId.class)
@Getter
@Setter
@NoArgsConstructor
@AllArgsConstructor
public class UserAuthorityMapping extends BaseEntity {

  @Id
  @Column(name = "user_id", length = 36, nullable = false)
  private String userId;

  @Id
  @Column(name = "authority_id", length = 36, nullable = false)
  private String authorityId;

  @ManyToOne(fetch = FetchType.LAZY)
  @JoinColumn(name = "user_id", insertable = false, updatable = false)
  private User user;

  @ManyToOne(fetch = FetchType.LAZY)
  @JoinColumn(name = "authority_id", insertable = false, updatable = false)
  private Authority authority;

  @Override
  public final boolean equals(Object obj) {
    if (this == obj) return true;
    if (!(obj instanceof UserAuthorityMapping other)) return false;
    Class&#x3C;?> objCls = (obj instanceof HibernateProxy hp
      ? hp.getHibernateLazyInitializer().getPersistentClass()
      : obj.getClass());
    Class&#x3C;?> thisCls = (this instanceof HibernateProxy hp
      ? hp.getHibernateLazyInitializer().getPersistentClass()
      : this.getClass());
    if (!thisCls.equals(objCls)) return false;
    return userId != null &#x26;&#x26; userId.equals(other.userId)
      &#x26;&#x26; authorityId != null &#x26;&#x26; authorityId.equals(other.authorityId);
  }

  @Override
  public final int hashCode() {
    return (this instanceof HibernateProxy hp
      ? hp.getHibernateLazyInitializer().getPersistentClass().hashCode()
      : Objects.hash(userId, authorityId));
  }
}
</code></pre>
<h3>Kotlin</h3>
<pre><code class="language-kotlin">package io.github.susimsek.springbootjweauthjpademo.entity

import jakarta.persistence.*
import org.hibernate.proxy.HibernateProxy
import java.util.*

@Entity
@Table(name = "user_authority_mapping")
@IdClass(UserAuthorityMappingId::class)
data class UserAuthorityMapping(

  @Id
  @Column(name = "user_id", length = 36, nullable = false)
  var userId: String = "",

  @Id
  @Column(name = "authority_id", length = 36, nullable = false)
  var authorityId: String = "",

  @ManyToOne(fetch = FetchType.LAZY)
  @JoinColumn(name = "user_id", insertable = false, updatable = false)
  var user: User? = null,

  @ManyToOne(fetch = FetchType.LAZY)
  @JoinColumn(name = "authority_id", insertable = false, updatable = false)
  var authority: Authority? = null

) : BaseEntity() {

  override fun equals(other: Any?): Boolean {
    if (this === other) return true
    if (other !is UserAuthorityMapping) return false

    val objCls = (other as? HibernateProxy)?.hibernateLazyInitializer?.persistentClass
      ?: other::class.java
    val thisCls = (this as? HibernateProxy)?.hibernateLazyInitializer?.persistentClass
      ?: this::class.java

    if (thisCls != objCls) return false
    return userId == other.userId &#x26;&#x26; authorityId == other.authorityId
  }

  override fun hashCode(): Int {
    return (this as? HibernateProxy)?.hibernateLazyInitializer?.persistentClass?.hashCode()
      ?: Objects.hash(userId, authorityId)
  }
}
</code></pre>
<p>UserAuthorityMappingId</p>
<h3>Java</h3>
<pre><code class="language-java">package io.github.susimsek.springbootjweauthjpademo.entity;

import java.io.Serializable;
import java.util.Objects;
import lombok.AllArgsConstructor;
import lombok.Getter;
import lombok.NoArgsConstructor;
import lombok.Setter;

@Getter
@Setter
@NoArgsConstructor
@AllArgsConstructor
public class UserAuthorityMappingId implements Serializable {

  private String userId;
  private String authorityId;

  @Override
  public boolean equals(Object o) {
    if (this == o) return true;
    if (o == null || getClass() != o.getClass()) return false;
    UserAuthorityMappingId that = (UserAuthorityMappingId) o;
    return Objects.equals(userId, that.userId) &#x26;&#x26;
      Objects.equals(authorityId, that.authorityId);
  }

  @Override
  public int hashCode() {
    return Objects.hash(userId, authorityId);
  }
}
</code></pre>
<h3>Kotlin</h3>
<pre><code class="language-kotlin">package io.github.susimsek.springbootjweauthjpademo.entity

import java.io.Serializable
import java.util.Objects

data class UserAuthorityMappingId(
  var userId: String = "",
  var authorityId: String = ""
) : Serializable {

  override fun equals(other: Any?): Boolean {
    if (this === other) return true
    if (other == null || this::class != other::class) return false
    other as UserAuthorityMappingId
    return userId == other.userId &#x26;&#x26; authorityId == other.authorityId
  }

  override fun hashCode(): Int {
    return Objects.hash(userId, authorityId)
  }
}
</code></pre>
<p>UserRepository</p>
<h3>Java</h3>
<pre><code class="language-java">package io.github.susimsek.springbootjweauthjpademo.repository;

import io.github.susimsek.springbootjweauthjpademo.entity.User;
import org.springframework.data.jpa.repository.EntityGraph;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.stereotype.Repository;

import java.util.Optional;

@Repository
public interface UserRepository extends JpaRepository&#x3C;User, String> {

  @EntityGraph("User.withAuthorities")
  Optional&#x3C;User> findOneWithAuthoritiesByUsername(String username);
}
</code></pre>
<h3>Kotlin</h3>
<pre><code class="language-kotlin">package io.github.susimsek.springbootjweauthjpademo.repository

import io.github.susimsek.springbootjweauthjpademo.entity.User
import org.springframework.data.jpa.repository.EntityGraph
import org.springframework.data.jpa.repository.JpaRepository
import org.springframework.stereotype.Repository
import java.util.Optional

@Repository
interface UserRepository : JpaRepository&#x3C;User, String> {

  @EntityGraph("User.withAuthorities")
  fun findOneWithAuthoritiesByUsername(username: String): Optional&#x3C;User>
}
</code></pre>
<hr>
<h2>ğŸ› ï¸ AdÄ±m 5: GÃ¼venli JWE Token YardÄ±mcÄ± SÄ±nÄ±flarÄ± OluÅŸturun</h2>
<p>Bu bÃ¶lÃ¼mde, Spring Boot uygulamanÄ±zda JSON Web Encryption (JWE) tokenlarÄ± oluÅŸturmak, ÅŸifrelemek ve Ã§Ã¶zmek iÃ§in gerekli temel yardÄ±mcÄ± sÄ±nÄ±flarÄ± ve sabitleri tanÄ±mlÄ±yoruz. AyrÄ±ca auditing entegrasyonu ve JPA tabanlÄ± UserDetailsService de ekliyoruz:</p>
<ul>
<li>AuthoritiesConstants: <code>ROLE_</code> Ã¶n ekiyle rol isimlerini merkezileÅŸtirir.</li>
<li>CookieBearerTokenResolver: Bearer tokenâ€™larÄ± yetkilendirme baÅŸlÄ±klarÄ±ndan veya HTTP Ã§erezlerinden Ã§Ã¶zer.</li>
<li>CookieUtils: EriÅŸim tokenâ€™larÄ± iÃ§in HTTP-only ve secure Ã§erezler oluÅŸturur.</li>
<li>JweUtil: Nimbus kÃ¼tÃ¼phanesi ile RSA anahtarlarÄ± kullanarak JWTâ€™leri imzalar (JWS) ve ÅŸifreler (JWE).</li>
<li>KeyUtils: PEM formatÄ±ndaki anahtar Ã§iftinden RSA JWKâ€™leri oluÅŸturur.</li>
<li>SecurityUtils: SecurityContext oturum aÃ§an kullanÄ±cÄ±nÄ±n bilgisini sunar.</li>
<li>SpringSecurityAuditorAware: Auditing iÃ§in oturum aÃ§an kullanÄ±cÄ±yÄ± saÄŸlayan <code>AuditorAware</code> implementasyonu.</li>
<li>DomainUserDetailsService: JPA tabanlÄ± <code>UserDetailsService</code>, kullanÄ±cÄ± kimlik bilgilerini ve yetkilerini getirir.</li>
</ul>
<p>Bu yardÄ±mcÄ±lar, Spring Security ile durumsuz (stateless) JWE tabanlÄ± bir kimlik doÄŸrulama akÄ±ÅŸÄ±nÄ±n temelini oluÅŸturur.</p>
<p>AuthoritiesConstants</p>
<h3>Java</h3>
<pre><code class="language-java">
package io.github.susimsek.springbootjweauthjpademo.security;

import lombok.AccessLevel;
import lombok.NoArgsConstructor;

@NoArgsConstructor(access = AccessLevel.PRIVATE)
public final class AuthoritiesConstants {
    public static final String ADMIN = "ROLE_ADMIN";
    public static final String USER = "ROLE_USER";
    public static final String ANONYMOUS = "ROLE_ANONYMOUS";
}
</code></pre>
<h3>Kotlin</h3>
<pre><code class="language-kotlin">
package io.github.susimsek.springbootjweauthjpademo.security

object AuthoritiesConstants {
  const val ADMIN = "ROLE_ADMIN"
  const val USER = "ROLE_USER"
  const val ANONYMOUS = "ROLE_ANONYMOUS"
}
</code></pre>
<p>CookieBearerTokenResolver</p>
<h3>Java</h3>
<pre><code class="language-java">package io.github.susimsek.springbootjweauthjpademo.security;

import jakarta.servlet.http.Cookie;
import jakarta.servlet.http.HttpServletRequest;
import lombok.Setter;
import org.springframework.http.HttpMethod;
import org.springframework.security.oauth2.core.OAuth2AuthenticationException;
import org.springframework.security.oauth2.server.resource.BearerTokenError;
import org.springframework.security.oauth2.server.resource.BearerTokenErrors;
import org.springframework.security.oauth2.server.resource.web.BearerTokenResolver;
import org.springframework.util.StringUtils;

import java.util.regex.Matcher;
import java.util.regex.Pattern;

@Setter
public class CookieBearerTokenResolver implements BearerTokenResolver {
    private static final String ACCESS_TOKEN_PARAMETER_NAME = "access_token";
    private static final Pattern AUTHORIZATION_PATTERN =
        Pattern.compile("^Bearer (?&#x3C;token>[A-Za-z0-9-._~+/]+=*)$", Pattern.CASE_INSENSITIVE);

    private boolean allowFormEncodedBodyParameter = false;
    private boolean allowUriQueryParameter       = false;
    private boolean allowCookie                  = true;
    private String  bearerTokenHeaderName       = "Authorization";
    private String  cookieName                  = "accessToken";

    @Override
    public String resolve(HttpServletRequest request) {
        String headerToken = resolveFromAuthorizationHeader(request);
        String queryToken  = resolveAccessTokenFromQueryString(request);
        String bodyToken   = resolveAccessTokenFromBody(request);
        String cookieToken = (headerToken == null &#x26;&#x26; queryToken == null &#x26;&#x26; bodyToken == null)
            ? resolveFromCookie(request)
            : null;

        return resolveToken(headerToken, queryToken, bodyToken, cookieToken);
    }

    private String resolveFromAuthorizationHeader(HttpServletRequest request) {
        String authorization = request.getHeader(this.bearerTokenHeaderName);
        if (!StringUtils.hasText(authorization) || !authorization.toLowerCase().startsWith("bearer")) {
            return null;
        }
        Matcher matcher = AUTHORIZATION_PATTERN.matcher(authorization.trim());
        if (!matcher.matches()) {
            BearerTokenError error = BearerTokenErrors.invalidToken("Bearer token is malformed");
            throw new OAuth2AuthenticationException(error);
        }
        return matcher.group("token");
    }

    private String resolveAccessTokenFromQueryString(HttpServletRequest request) {
        if (allowUriQueryParameter &#x26;&#x26; HttpMethod.GET.matches(request.getMethod())) {
            return resolveToken(request.getParameterValues(ACCESS_TOKEN_PARAMETER_NAME));
        }
        return null;
    }

    private String resolveAccessTokenFromBody(HttpServletRequest request) {
        if (allowFormEncodedBodyParameter
            &#x26;&#x26; HttpMethod.POST.matches(request.getMethod())
            &#x26;&#x26; "application/x-www-form-urlencoded".equals(request.getContentType())) {
            return resolveToken(request.getParameterValues(ACCESS_TOKEN_PARAMETER_NAME));
        }
        return null;
    }

    private String resolveFromCookie(HttpServletRequest request) {
        if (!allowCookie || request.getCookies() == null) {
            return null;
        }
        for (Cookie cookie : request.getCookies()) {
            if (cookieName.equals(cookie.getName())) {
                String val = cookie.getValue();
                return StringUtils.hasText(val) ? val : null;
            }
        }
        return null;
    }

    private String resolveToken(String... tokens) {
        String found = null;
        for (String token : tokens) {
            if (token == null) continue;
            if (found != null) {
                BearerTokenError error = BearerTokenErrors.invalidRequest("Found multiple bearer tokens in the request");
                throw new OAuth2AuthenticationException(error);
            }
            found = token;
        }
        if (found != null &#x26;&#x26; found.isBlank()) {
            BearerTokenError error = BearerTokenErrors.invalidRequest("The requested token parameter is an empty string");
            throw new OAuth2AuthenticationException(error);
        }
        return found;
    }
</code></pre>
<h3>Kotlin</h3>
<pre><code class="language-kotlin">package io.github.susimsek.springbootjweauthjpademo.security

import jakarta.servlet.http.Cookie
import jakarta.servlet.http.HttpServletRequest
import org.springframework.http.HttpMethod
import org.springframework.security.oauth2.core.OAuth2AuthenticationException
import org.springframework.security.oauth2.server.resource.BearerTokenError
import org.springframework.security.oauth2.server.resource.BearerTokenErrors
import org.springframework.security.oauth2.server.resource.web.BearerTokenResolver
import org.springframework.util.StringUtils
import java.util.regex.Pattern

class CookieBearerTokenResolver {
    var allowFormEncodedBodyParameter: Boolean = false
    var allowUriQueryParameter: Boolean = false
    var allowCookie: Boolean = true
    var bearerTokenHeaderName: String = "Authorization"
    var cookieName: String = "accessToken"

    companion object {
        private const val ACCESS_TOKEN_PARAMETER_NAME = "access_token"
        private val AUTHORIZATION_PATTERN =
            Pattern.compile("^Bearer (?&#x3C;token>[A-Za-z0-9-._~+/]+=*)$", Pattern.CASE_INSENSITIVE)
    }

    fun resolve(request: HttpServletRequest): String? {
        val header = resolveFromAuthorizationHeader(request)
        val query  = if (allowUriQueryParameter &#x26;&#x26; HttpMethod.GET.matches(request.method))
            request.getParameterValues(ACCESS_TOKEN_PARAMETER_NAME)?.let(::resolveToken)
        else null
        val body   = if (allowFormEncodedBodyParameter &#x26;&#x26; HttpMethod.POST.matches(request.method)
            &#x26;&#x26; request.contentType == "application/x-www-form-urlencoded")
            request.getParameterValues(ACCESS_TOKEN_PARAMETER_NAME)?.let(::resolveToken)
        else null
        val cookie = if (header == null &#x26;&#x26; query == null &#x26;&#x26; body == null)
            resolveFromCookie(request)
        else null
      return listOf(header, query, body, cookie).filterNotNull().let {
            if (it.size > 1) throw OAuth2AuthenticationException(BearerTokenErrors.invalidRequest("Found multiple bearer tokens"))
            it.firstOrNull()?: null
        }
    }

    private fun resolveFromAuthorizationHeader(request: HttpServletRequest): String? {
        val auth = request.getHeader(bearerTokenHeaderName) ?: return null
        if (!auth.startsWith("Bearer ", true)) return null
        val matcher = AUTHORIZATION_PATTERN.matcher(auth.trim())
        return if (matcher.matches()) matcher.group("token")
        else throw OAuth2AuthenticationException(BearerTokenErrors.invalidToken("Malformed token"))
    }

    private fun resolveFromCookie(request: HttpServletRequest): String? {
        if (!allowCookie) return null
        return request.cookies?.firstOrNull { it.name == cookieName }?.value?.takeIf { it.isNotBlank() }
    }

    private fun resolveToken(tokens: Array&#x3C;String>): String? {
        return tokens.filter { it.isNotBlank() }.let {
            when {
                it.isEmpty() -> null
                it.size > 1   -> throw OAuth2AuthenticationException(BearerTokenErrors.invalidRequest("Multiple tokens"))
                else          -> it[0]
            }
        }
    }
</code></pre>
<p>CookieUtils</p>
<h3>Java</h3>
<pre><code class="language-java">package io.github.susimsek.springbootjweauthjpademo.security;

import io.github.susimsek.springbootjweauthjpademo.dto.TokenDTO;
import lombok.experimental.UtilityClass;
import org.springframework.http.ResponseCookie;

@UtilityClass
public class CookieUtils {

    private static final String COOKIE_NAME = "accessToken";

    public ResponseCookie createAccessTokenCookie(TokenDTO tokenDto) {
        return ResponseCookie.from(COOKIE_NAME, tokenDto.accessToken())
            .httpOnly(true)
            .secure(true)
            .path("/")
            .maxAge(tokenDto.accessTokenExpiresIn())
            .sameSite("Strict")
            .build();
    }
}
</code></pre>
<h3>Kotlin</h3>
<pre><code class="language-kotlin">package io.github.susimsek.springbootjweauthjpademo.security

import io.github.susimsek.springbootjweauthjpademo.dto.TokenDTO
import org.springframework.http.ResponseCookie

object CookieUtils {

  private const val COOKIE_NAME = "accessToken"

  fun createAccessTokenCookie(tokenDto: TokenDTO): ResponseCookie {
    return ResponseCookie.from(COOKIE_NAME, tokenDto.accessToken())
      .httpOnly(true)
      .secure(true)
      .path("/")
      .maxAge(tokenDto.accessTokenExpiresIn())
      .sameSite("Strict")
      .build()
  }
}
</code></pre>
<p>JweUtil</p>
<h3>Java</h3>
<pre><code class="language-java">package io.github.susimsek.springbootjweauthjpademo.security;

import com.nimbusds.jose.EncryptionMethod;
import com.nimbusds.jose.JOSEException;
import com.nimbusds.jose.JWEAlgorithm;
import com.nimbusds.jose.JWEHeader;
import com.nimbusds.jose.JWEObject;
import com.nimbusds.jose.Payload;
import com.nimbusds.jose.crypto.RSAEncrypter;
import com.nimbusds.jose.jwk.RSAKey;
import io.github.susimsek.springbootjweauthjpademo.config.JwtProperties;
import io.github.susimsek.springbootjweauthjpademo.dto.TokenDTO;
import lombok.RequiredArgsConstructor;
import org.springframework.security.core.Authentication;
import org.springframework.security.core.GrantedAuthority;
import org.springframework.security.oauth2.jose.jws.SignatureAlgorithm;
import org.springframework.security.oauth2.jwt.*;
import org.springframework.stereotype.Component;

import java.time.Instant;
import java.util.List;

import static io.github.susimsek.springbootjweauthjpademo.security.SecurityUtils.AUTHORITIES_KEY;

@Component
@RequiredArgsConstructor
public class JweUtil {

    private final JwtEncoder jwtEncoder;
    private final RSAKey signingKey;
    private final RSAKey encryptionKey;
    private final JwtProperties props;

    public TokenDTO generateToken(Authentication authentication) throws JOSEException {
        String subject = authentication.getName();
        List&#x3C;String> roles = authentication.getAuthorities()
            .stream()
            .map(GrantedAuthority::getAuthority)
            .toList();

        Instant now = Instant.now();
        long expiresIn = props.getExpirationDuration().getSeconds();
        Instant exp = now.plusSeconds(expiresIn);

        JwtClaimsSet claims = JwtClaimsSet.builder()
            .issuer(props.getIssuer())
            .issuedAt(now)
            .expiresAt(exp)
            .subject(subject)
            .claim(AUTHORITIES_KEY, roles)
            .build();

        JwsHeader jwsHeader = JwsHeader.with(SignatureAlgorithm.RS256)
            .keyId(signingKey.getKeyID())
            .build();

        String jws = jwtEncoder
            .encode(JwtEncoderParameters.from(jwsHeader, claims))
            .getTokenValue();

        JWEHeader jweHeader = new JWEHeader.Builder(JWEAlgorithm.RSA_OAEP_256, EncryptionMethod.A128GCM)
            .contentType("JWT")
            .keyID(encryptionKey.getKeyID())
            .build();

        JWEObject jweObject = new JWEObject(jweHeader, new Payload(jws));
        jweObject.encrypt(new RSAEncrypter(encryptionKey.toRSAPublicKey()));
        String token = jweObject.serialize();

        return new TokenDTO(token, "Bearer", expiresIn);
    }
}
</code></pre>
<h3>Kotlin</h3>
<pre><code class="language-kotlin">package io.github.susimsek.springbootjweauthjpademo.security

import com.nimbusds.jose.EncryptionMethod
import com.nimbusds.jose.JOSEException
import com.nimbusds.jose.JWEAlgorithm
import com.nimbusds.jose.JWEHeader
import com.nimbusds.jose.JWEObject
import com.nimbusds.jose.Payload
import com.nimbusds.jose.crypto.RSAEncrypter
import com.nimbusds.jose.jwk.RSAKey
import io.github.susimsek.springbootjweauthjpademo.config.JwtProperties
import io.github.susimsek.springbootjweauthjpademo.dto.TokenDTO
import lombok.RequiredArgsConstructor
import org.springframework.security.core.Authentication
import org.springframework.security.oauth2.jose.jws.SignatureAlgorithm
import org.springframework.security.oauth2.jwt.JwtClaimsSet
import org.springframework.security.oauth2.jwt.JwtEncoder
import org.springframework.security.oauth2.jwt.JwtEncoderParameters
import org.springframework.stereotype.Component

import java.time.Instant

@Component
@RequiredArgsConstructor
class JweUtil(
    private val jwtEncoder: JwtEncoder,
    private val signingKey: RSAKey,
    private val encryptionKey: RSAKey,
    private val props: JwtProperties
) {
    fun generateToken(authentication: Authentication): TokenDTO {
        val subject = authentication.name
        val roles = authentication.authorities.map { it.authority }

        val now = Instant.now()
        val expiresIn = props.expirationDuration.seconds
        val exp = now.plusSeconds(expiresIn)

        val claims = JwtClaimsSet.builder()
            .issuer(props.issuer)
            .issuedAt(now)
            .expiresAt(exp)
            .subject(subject)
            .claim(AUTHORITIES_KEY, roles)
            .build()

        val jwsHeader = org.springframework.security.oauth2.jwt.JwsHeader.with(SignatureAlgorithm.RS256)
            .keyId(signingKey.keyID)
            .build()

        val jws = jwtEncoder
            .encode(JwtEncoderParameters.from(jwsHeader, claims))
            .tokenValue

        val jweHeader = JWEHeader.Builder(JWEAlgorithm.RSA_OAEP_256, EncryptionMethod.A128GCM)
            .contentType("JWT")
            .keyID(encryptionKey.keyID)
            .build()

        val jweObject = JWEObject(jweHeader, Payload(jws))
        jweObject.encrypt(RSAEncrypter(encryptionKey.toRSAPublicKey()))
        val token = jweObject.serialize()

        return TokenDTO(token, "Bearer", expiresIn)
    }
}
</code></pre>
<p>KeyUtils</p>
<h3>Java</h3>
<pre><code class="language-java">package io.github.susimsek.springbootjweauthjpademo.security;

import com.nimbusds.jose.JWEAlgorithm;
import com.nimbusds.jose.JWSAlgorithm;
import com.nimbusds.jose.jwk.KeyUse;
import com.nimbusds.jose.jwk.RSAKey;
import lombok.experimental.UtilityClass;

import java.security.KeyFactory;
import java.security.interfaces.RSAPrivateKey;
import java.security.interfaces.RSAPublicKey;
import java.security.spec.PKCS8EncodedKeySpec;
import java.security.spec.X509EncodedKeySpec;
import java.util.Base64;

@UtilityClass
public class KeyUtils {
    public RSAKey buildRsaKey(
            String pubPem,
            String privPem,
            String kid,
            boolean forSign
    ) throws Exception {
        String pubContent = pubPem
            .replace("-----BEGIN PUBLIC KEY-----", "")
            .replace("-----END PUBLIC KEY-----", "")
            .replaceAll("\\s", "");
        String privContent = privPem
            .replace("-----BEGIN PRIVATE KEY-----", "")
            .replace("-----END PRIVATE KEY-----", "")
            .replaceAll("\\s", "");

        byte[] decodedPub = Base64.getDecoder().decode(pubContent);
        byte[] decodedPriv = Base64.getDecoder().decode(privContent);

        KeyFactory kf = KeyFactory.getInstance("RSA");
        RSAPublicKey publicKey = (RSAPublicKey) kf.generatePublic(new X509EncodedKeySpec(decodedPub));
        RSAPrivateKey privateKey = (RSAPrivateKey) kf.generatePrivate(new PKCS8EncodedKeySpec(decodedPriv));

        RSAKey.Builder builder = new RSAKey.Builder(publicKey)
            .privateKey(privateKey)
            .keyID(kid);

        if (forSign) {
            builder
                .algorithm(JWSAlgorithm.RS256)
                .keyUse(KeyUse.SIGNATURE);
        } else {
            builder
                .algorithm(JWEAlgorithm.RSA_OAEP_256)
                .keyUse(KeyUse.ENCRYPTION);
        }

        return builder.build();
    }
}
</code></pre>
<h3>Kotlin</h3>
<pre><code class="language-kotlin">package io.github.susimsek.springbootjweauthjpademo.security

import com.nimbusds.jose.JWEAlgorithm
import com.nimbusds.jose.JWSAlgorithm
import com.nimbusds.jose.jwk.KeyUse
import com.nimbusds.jose.jwk.RSAKey
import java.security.KeyFactory
import java.security.interfaces.RSAPrivateKey
import java.security.interfaces.RSAPublicKey
import java.security.spec.PKCS8EncodedKeySpec
import java.security.spec.X509EncodedKeySpec
import java.util.Base64

object KeyUtils {
    @JvmStatic
    @Throws(Exception::class)
    fun buildRsaKey(
        pubPem: String,
        privPem: String,
        kid: String,
        forSign: Boolean
    ): RSAKey {
        val pubContent = pubPem
            .replace("-----BEGIN PUBLIC KEY-----", "")
            .replace("-----END PUBLIC KEY-----", "")
            .replace(Regex("\\s"), "")
        val privContent = privPem
            .replace("-----BEGIN PRIVATE KEY-----", "")
            .replace("-----END PRIVATE KEY-----", "")
            .replace(Regex("\\s"), "")

        val decodedPub = Base64.getDecoder().decode(pubContent)
        val decodedPriv = Base64.getDecoder().decode(privContent)

        val kf = KeyFactory.getInstance("RSA")
        val publicKey = kf.generatePublic(X509EncodedKeySpec(decodedPub)) as RSAPublicKey
        val privateKey = kf.generatePrivate(PKCS8EncodedKeySpec(decodedPriv)) as RSAPrivateKey

        val builder = RSAKey.Builder(publicKey)
            .privateKey(privateKey)
            .keyID(kid)

        if (forSign) {
            builder
                .algorithm(JWSAlgorithm.RS256)
                .keyUse(KeyUse.SIGNATURE)
        } else {
            builder
                .algorithm(JWEAlgorithm.RSA_OAEP_256)
                .keyUse(KeyUse.ENCRYPTION)
        }

        return builder.build()
    }
}
</code></pre>
<p>SecurityUtils</p>
<h3>Java</h3>
<pre><code class="language-java">package io.github.susimsek.springbootjweauthjpademo.security;

import lombok.experimental.UtilityClass;
import org.springframework.security.core.Authentication;
import org.springframework.security.core.context.SecurityContextHolder;
import org.springframework.security.core.userdetails.UserDetails;
import org.springframework.security.oauth2.jwt.Jwt;

import java.util.Optional;

@UtilityClass
public class SecurityUtils {

    public static final String AUTHORITIES_KEY = "auth";

    public Optional&#x3C;String> getCurrentUserLogin() {
        var ctx = SecurityContextHolder.getContext();
        return Optional.ofNullable(extractPrincipal(ctx.getAuthentication()));
    }

    private String extractPrincipal(Authentication authentication) {
        if (authentication == null) {
            return null;
        }
        Object principal = authentication.getPrincipal();
        if (principal instanceof Jwt jwt) {
            return jwt.getSubject();
        }
        if (principal instanceof UserDetails ud) {
            return ud.getUsername();
        }
        if (principal instanceof String username) {
            return username;
        }
        return null;
    }
}
</code></pre>
<h3>Kotlin</h3>
<pre><code class="language-kotlin">package io.github.susimsek.springbootjweauthjpademo.security

import org.springframework.security.core.Authentication
import org.springframework.security.core.context.SecurityContextHolder
import org.springframework.security.core.userdetails.UserDetails
import org.springframework.security.oauth2.jwt.Jwt
import java.util.Optional

object SecurityUtils {
  const val AUTHORITIES_KEY = "auth"

  fun getCurrentUserLogin(): Optional&#x3C;String> {
    val authentication: Authentication? = SecurityContextHolder.getContext().authentication
    return Optional.ofNullable(extractPrincipal(authentication))
  }

  private fun extractPrincipal(authentication: Authentication?): String? {
    return when (val principal = authentication?.principal) {
      is Jwt -> principal.subject
      is UserDetails -> principal.username
      is String -> principal
      else -> null
    }
  }
}
</code></pre>
<p>DomainUserDetailsService</p>
<h3>Java</h3>
<pre><code class="language-java">package io.github.susimsek.springbootjweauthjpademo.security;

import io.github.susimsek.springbootjweauthjpademo.entity.User;
import io.github.susimsek.springbootjweauthjpademo.repository.UserRepository;
import lombok.RequiredArgsConstructor;
import org.springframework.security.core.GrantedAuthority;
import org.springframework.security.core.authority.SimpleGrantedAuthority;
import org.springframework.security.core.userdetails.UserDetails;
import org.springframework.security.core.userdetails.UserDetailsService;
import org.springframework.security.core.userdetails.UsernameNotFoundException;

import java.util.List;
import java.util.stream.Collectors;

@RequiredArgsConstructor
public class DomainUserDetailsService implements UserDetailsService {

  private final UserRepository userRepository;

  @Override
  public UserDetails loadUserByUsername(String username) throws UsernameNotFoundException {
    User user = userRepository.findOneWithAuthoritiesByUsername(username)
      .orElseThrow(() -> new UsernameNotFoundException("User not found with username: " + username));

    List&#x3C;GrantedAuthority> authorities = user.getAuthorities().stream()
      .map(mapping -> mapping.getAuthority().getName())
      .map(SimpleGrantedAuthority::new)
      .collect(Collectors.toList());

    return new org.springframework.security.core.userdetails.User(
      user.getUsername(),
      user.getPassword(),
      user.isEnabled(),  // enabled
      true,              // accountNonExpired
      true,              // credentialsNonExpired
      true,              // accountNonLocked
      authorities
    );
  }
}
</code></pre>
<h3>Kotlin</h3>
<pre><code class="language-kotlin">package io.github.susimsek.springbootjweauthjpademo.security

import io.github.susimsek.springbootjweauthjpademo.repository.UserRepository
import org.springframework.security.core.GrantedAuthority
import org.springframework.security.core.authority.SimpleGrantedAuthority
import org.springframework.security.core.userdetails.UserDetails
import org.springframework.security.core.userdetails.UserDetailsService
import org.springframework.security.core.userdetails.UsernameNotFoundException
import java.util.stream.Collectors

class DomainUserDetailsService(
  private val userRepository: UserRepository
) : UserDetailsService {
  override fun loadUserByUsername(username: String): UserDetails {
    val user = userRepository.findOneWithAuthoritiesByUsername(username)
      .orElseThrow { UsernameNotFoundException("User not found with username: $username") }

    val authorities: List&#x3C;GrantedAuthority> = user.authorities.stream()
      .map { SimpleGrantedAuthority(it.authority.name) }
      .collect(Collectors.toList())

    return org.springframework.security.core.userdetails.User(
      user.username,
      user.password,
      user.enabled,
      true,
      true,
      true,
      authorities
    )
  }
}
</code></pre>
<p>SpringSecurityAuditorAware</p>
<h3>Java</h3>
<pre><code class="language-java">package io.github.susimsek.springbootjweauthjpademo.security;

import org.springframework.data.domain.AuditorAware;
import org.springframework.lang.NonNull;
import org.springframework.stereotype.Component;

import java.util.Optional;

@Component
public class SpringSecurityAuditorAware implements AuditorAware&#x3C;String> {

  @Override
  @NonNull
  public Optional&#x3C;String> getCurrentAuditor() {
    return Optional.of(SecurityUtils.getCurrentUserLogin().orElse("system"));
  }
}
</code></pre>
<h3>Kotlin</h3>
<pre><code class="language-kotlin">package io.github.susimsek.springbootjweauthjpademo.security

import org.springframework.data.domain.AuditorAware
import org.springframework.lang.NonNull
import org.springframework.stereotype.Component

@Component
class SpringSecurityAuditorAware : AuditorAware&#x3C;String> {
    @NonNull
    override fun getCurrentAuditor(): Optional&#x3C;String> =
        Optional.of(SecurityUtils.getCurrentUserLogin().orElse("system"))
}
</code></pre>
<hr>
<h2>ğŸ§ª AdÄ±m 6: Kimlik DoÄŸrulama ve GÃ¼venli Endpointler</h2>
<p>Bu bÃ¶lÃ¼mde, aÅŸaÄŸÄ±dakileri gerÃ§ekleÅŸtirmek iÃ§in gerekli REST controller ve DTOâ€™larÄ± tanÄ±mlÄ±yoruz:</p>
<ul>
<li>AuthController: KullanÄ±cÄ±larÄ± doÄŸrular, JWE tokenâ€™larÄ± oluÅŸturur ve gÃ¼venli cookie ayarlar.</li>
<li>HelloController: KimliÄŸi doÄŸrulanmÄ±ÅŸ kullanÄ±cÄ±lar ve yalnÄ±zca admine Ã¶zel pathler iÃ§in gÃ¼venli endpointler sunar.</li>
<li>LoginRequestDTO: Login isteÄŸi payloadÄ±nÄ± (kullanÄ±cÄ± adÄ±/parola) modelleyen DTO.</li>
<li>TokenDTO: Token ve geÃ§erlilik sÃ¼resini iÃ§eren kimlik doÄŸrulama yanÄ±tÄ±nÄ± modelleyen DTO.</li>
</ul>
<p>Bu bileÅŸenler, login iÅŸlemi, token oluÅŸturma, cookie yÃ¶netimi ve kaynak korumasÄ±nÄ± iÅŸleyerek stateless(durumsuz) kimlik doÄŸrulama akÄ±ÅŸÄ±nÄ± tamamlar.</p>
<p>Bu bÃ¶lÃ¼mde, kullanÄ±cÄ± kimlik doÄŸrulamasÄ±nÄ±, token oluÅŸturmayÄ± ve korunan kaynak eriÅŸimini yÃ¶netmek iÃ§in REST controller ve DTOâ€™larÄ± oluÅŸturuyoruz.</p>
<p>AuthController</p>
<h3>Java</h3>
<pre><code class="language-java">package io.github.susimsek.springbootjweauthjpademo.controller;

import io.github.susimsek.springbootjweauthjpademo.dto.LoginRequestDTO;
import io.github.susimsek.springbootjweauthjpademo.dto.TokenDTO;
import io.github.susimsek.springbootjweauthjpademo.security.CookieUtils;
import io.github.susimsek.springbootjweauthjpademo.security.JweUtil;
import lombok.RequiredArgsConstructor;
import org.springframework.http.HttpHeaders;
import org.springframework.http.ResponseCookie;
import org.springframework.http.ResponseEntity;
import org.springframework.security.authentication.AuthenticationManager;
import org.springframework.security.authentication.UsernamePasswordAuthenticationToken;
import org.springframework.security.core.Authentication;
import org.springframework.security.core.context.SecurityContextHolder;
import org.springframework.web.bind.annotation.PostMapping;
import org.springframework.web.bind.annotation.RequestBody;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;

@RestController
@RequiredArgsConstructor
@RequestMapping("/api/auth")
public class AuthController {

    private final AuthenticationManager authenticationManager;
    private final JweUtil jweUtil;

    @PostMapping("/login")
    public ResponseEntity&#x3C;TokenDTO> login(@RequestBody LoginRequestDTO loginRequest) throws Exception {
        // Authenticate user
        var authToken = new UsernamePasswordAuthenticationToken(
            loginRequest.username(), loginRequest.password()
        );
        Authentication auth = authenticationManager.authenticate(authToken);
        SecurityContextHolder.getContext().setAuthentication(auth);

        // Generate JWE token and cookie
        TokenDTO tokenDto = jweUtil.generateToken(auth);
        ResponseCookie cookie = CookieUtils.createAccessTokenCookie(tokenDto);

        return ResponseEntity.ok()
            .header(HttpHeaders.SET_COOKIE, cookie.toString())
            .body(tokenDto);
    }
}
</code></pre>
<h3>Kotlin</h3>
<pre><code class="language-kotlin">package io.github.susimsek.springbootjweauthjpademo.controller

import io.github.susimsek.springbootjweauthjpademo.dto.LoginRequestDTO
import io.github.susimsek.springbootjweauthjpademo.dto.TokenDTO
import io.github.susimsek.springbootjweauthjpademo.security.CookieUtils
import io.github.susimsek.springbootjweauthjpademo.security.JweUtil
import lombok.RequiredArgsConstructor
import org.springframework.http.HttpHeaders
import org.springframework.http.ResponseCookie
import org.springframework.http.ResponseEntity
import org.springframework.security.authentication.AuthenticationManager
import org.springframework.security.authentication.UsernamePasswordAuthenticationToken
import org.springframework.security.core.Authentication
import org.springframework.security.core.context.SecurityContextHolder
import org.springframework.web.bind.annotation.PostMapping
import org.springframework.web.bind.annotation.RequestBody
import org.springframework.web.bind.annotation.RequestMapping
import org.springframework.web.bind.annotation.RestController

@RestController
@RequiredArgsConstructor
@RequestMapping("/api/auth")
class AuthController(
    private val authenticationManager: AuthenticationManager,
    private val jweUtil: JweUtil
) {

    @PostMapping("/login")
    fun login(@RequestBody loginRequest: LoginRequestDTO): ResponseEntity&#x3C;TokenDTO> {
        val authToken = UsernamePasswordAuthenticationToken(
            loginRequest.username, loginRequest.password
        )
        val auth: Authentication = authenticationManager.authenticate(authToken)
        SecurityContextHolder.getContext().authentication = auth

        val tokenDto: TokenDTO = jweUtil.generateToken(auth)
        val cookie: ResponseCookie = CookieUtils.createAccessTokenCookie(tokenDto)

        return ResponseEntity.ok()
            .header(HttpHeaders.SET_COOKIE, cookie.toString())
            .body(tokenDto)
    }
}
</code></pre>
<p>HelloController</p>
<h3>Java</h3>
<pre><code class="language-java">package io.github.susimsek.springbootjweauthjpademo.controller;

import org.springframework.security.core.annotation.AuthenticationPrincipal;
import org.springframework.security.oauth2.jwt.Jwt;
import org.springframework.web.bind.annotation.*;

import static io.github.susimsek.springbootjweauthjpademo.security.SecurityUtils.AUTHORITIES_KEY;

@RestController
@RequestMapping("/api/hello")
public class HelloController {

    @GetMapping
    public String helloAll(@AuthenticationPrincipal Jwt jwt) {
        String user = jwt.getSubject();
        var roles = jwt.getClaimAsStringList(AUTHORITIES_KEY);
        return "Hello, " + user + "! Your roles: " + roles;
    }

    @GetMapping("/admin")
    public String helloAdmin(@AuthenticationPrincipal Jwt jwt) {
        return "Hello Admin, " + jwt.getSubject() + "!";
    }
}
</code></pre>
<h3>Kotlin</h3>
<pre><code class="language-kotlin">package io.github.susimsek.springbootjweauthjpademo.controller

import org.springframework.security.core.annotation.AuthenticationPrincipal
import org.springframework.security.oauth2.jwt.Jwt
import org.springframework.web.bind.annotation.*

import io.github.susimsek.springbootjweauthjpademo.security.SecurityUtils.AUTHORITIES_KEY

@RestController
@RequestMapping("/api/hello")
class HelloController {

    @GetMapping
    fun helloAll(@AuthenticationPrincipal jwt: Jwt): String {
        val user = jwt.subject
        val roles = jwt.getClaimAsStringList(AUTHORITIES_KEY)
        return "Hello, \$user! Your roles: \$roles"
    }

    @GetMapping("/admin")
    fun helloAdmin(@AuthenticationPrincipal jwt: Jwt): String {
        return "Hello Admin, \${jwt.subject}!"
    }
}
</code></pre>
<p>LoginRequestDTO</p>
<h3>Java</h3>
<pre><code class="language-java">package io.github.susimsek.springbootjweauthjpademo.dto;

public record LoginRequestDTO(
    String username,
    String password
) { }
</code></pre>
<h3>Kotlin</h3>
<pre><code class="language-kotlin">package io.github.susimsek.springbootjweauthjpademo.dto

data class LoginRequestDTO(
    val username: String,
    val password: String
)
</code></pre>
<p>TokenDTO</p>
<h3>Java</h3>
<pre><code class="language-java">package io.github.susimsek.springbootjweauthjpademo.dto;

public record TokenDTO(
    String accessToken,
    String tokenType,
    long accessTokenExpiresIn
) {}
</code></pre>
<h3>Kotlin</h3>
<pre><code class="language-kotlin">package io.github.susimsek.springbootjweauthjpademo.dto

import kotlin.Long

data class TokenDTO(
    val accessToken: String,
    val tokenType: String,
    val accessTokenExpiresIn: Long
)
</code></pre>
<hr>
<h2>â–¶ï¸ UygulamayÄ± Ã‡alÄ±ÅŸtÄ±r</h2>
<pre><code class="language-bash">./mvnw spring-boot:run
# or
gradle bootRun
</code></pre>
<hr>
<h2>ğŸ§ª Endpoint Testi</h2>
<p>Bu bÃ¶lÃ¼mde Endpoint Testi konusunu netleÅŸtirip uygulamada kullanacaÄŸÄ±nÄ±z temel noktalarÄ± Ã¶zetliyoruz.</p>
<h3>Admin AkÄ±ÅŸÄ±</h3>
<p>admin olarak giriÅŸ yapÄ±n ve <code>Set-Cookie</code> baÅŸlÄ±ÄŸÄ±ndan JWE tokeni yakalayÄ±n:</p>
<pre><code class="language-bash">curl -i -X POST http://localhost:8080/api/auth/login \
  -H "Content-Type: application/json" \
  -d '{"username":"admin","password":"adminpass"}'
</code></pre>
<ul>
<li>Set-Cookie baÅŸlÄ±ÄŸÄ± <code>accessToken=&#x3C;jwe-token></code> iÃ§erir</li>
<li>YanÄ±t:</li>
</ul>
<pre><code class="language-json">{
  "accessToken": "&#x3C;jwe-token>",
  "tokenType": "Bearer",
  "accessTokenExpiresIn": 3600
}
</code></pre>
<p>cookie kullanarak <code>hello</code> endpointine eriÅŸin:</p>
<pre><code class="language-bash">curl -b "accessToken=&#x3C;jwe-token>" http://localhost:8080/api/hello
</code></pre>
<p>Veya Authorization baÅŸlÄ±ÄŸÄ±yla:</p>
<pre><code class="language-bash">curl -H "Authorization: Bearer &#x3C;jwe-token>" http://localhost:8080/api/hello
</code></pre>
<p>admin-Ã¶zel endpointine eriÅŸin:</p>
<pre><code class="language-bash">curl -H "Authorization: Bearer &#x3C;jwe-token>" http://localhost:8080/api/hello/admin
</code></pre>
<h3>KullanÄ±cÄ± AkÄ±ÅŸÄ±</h3>
<p>user olarak giriÅŸ yapÄ±n ve cookieâ€™den JWE tokeni yakalayÄ±n:</p>
<pre><code class="language-bash">curl -i -X POST http://localhost:8080/api/auth/login \
  -H "Content-Type: application/json" \
  -d '{"username":"user","password":"userpass"}'
</code></pre>
<ul>
<li>Set-Cookie baÅŸlÄ±ÄŸÄ± <code>accessToken=&#x3C;jwe-token></code> iÃ§erir</li>
</ul>
<p>cookie kullanarak <code>hello</code> endpointine eriÅŸin:</p>
<pre><code class="language-bash">curl -b "accessToken=&#x3C;jwe-token>" http://localhost:8080/api/hello
</code></pre>
<p>Authorization baÅŸlÄ±ÄŸÄ±yla:</p>
<pre><code class="language-bash">curl -H "Authorization: Bearer &#x3C;jwe-token>" http://localhost:8080/api/hello
</code></pre>
<p>Admin endpointini deneyince (403 Forbidden dÃ¶ner):</p>
<pre><code class="language-bash">curl -H "Authorization: Bearer &#x3C;jwe-token>" http://localhost:8080/api/hello/admin
# HTTP/1.1 403 Forbidden
</code></pre>
<hr>
<h2>ğŸ SonuÃ§</h2>
<p>ArtÄ±k Spring Boot JPA ile JWE Kimlik DoÄŸrulamasÄ± iÃ§in Ã¼retim odaklÄ± bir Spring Boot temeliniz var. Sonraki adÄ±mda ayarlarÄ± kendi domainine uyarlayÄ±p test ve gÃ¶zlemlenebilirlik katmanÄ±nÄ± ekleyerek gerÃ§ek trafik altÄ±nda doÄŸrulayÄ±n.</p>]]></content:encoded>
      <category><![CDATA[Java]]></category>
      <category><![CDATA[Kotlin]]></category>
      <category><![CDATA[Spring Boot]]></category>
      <category><![CDATA[GÃ¼venlik]]></category>
      <category><![CDATA[JWT]]></category>
      <category><![CDATA[JWE]]></category>
      <category><![CDATA[JPA]]></category>
      <media:thumbnail url="https://suaybsimsek.com/images/spring-boot-jwe-auth-with-jpa-thumbnail.webp" />
    </item>
    <item>
      <title><![CDATA[Spring Boot LDAP ve JWE Kimlik DoÄŸrulama]]></title>
      <link>https://suaybsimsek.com/tr/posts/spring-boot-ldap-jwe-authentication</link>
      <description><![CDATA[LDAP kimlik doÄŸrulama ve JWE ÅŸifreli JWTâ€™lerle Spring Boot APIâ€™lerinizi external directory entegrasyonu ve token gizliliÄŸi ile nasÄ±l gÃ¼vene alacaÄŸÄ±nÄ±zÄ± Ã¶ÄŸrenin.]]></description>
      <pubDate>Sat, 10 May 2025 00:00:00 GMT</pubDate>
      <atom:updated>2025-05-11T00:00:00.000Z</atom:updated>
      <guid isPermaLink="true">https://suaybsimsek.com/tr/posts/spring-boot-ldap-jwe-authentication</guid>
      <content:encoded><![CDATA[<p>Spring Boot, LDAP kimlik doÄŸrulamasÄ±nÄ± JWE ile ÅŸifrelenmiÅŸ JWTâ€™lerle birleÅŸtirerek APIâ€™larÄ±nÄ±zÄ± hem external directory hem de token gizliliÄŸiyle gÃ¼vence altÄ±na almanÄ±zÄ± saÄŸlar.</p>
<hr>
<h2>ğŸŒŸ Neden LDAP ve JWE?</h2>
<p>Bu bÃ¶lÃ¼mde Neden LDAP ve JWE? konusunu netleÅŸtirip uygulamada kullanacaÄŸÄ±nÄ±z temel noktalarÄ± Ã¶zetliyoruz.</p>
<ul>
<li>DÄ±ÅŸ Directory: LDAP ile kullanÄ±cÄ± yÃ¶netimini merkezi hale getirin (kurumsal veya gÃ¶mÃ¼lÃ¼ directory).</li>
<li>BÃ¼tÃ¼nlÃ¼k &#x26; Gizlilik: Tokenâ€™larÄ± imzalayÄ±n (JWS) ve ÅŸifreleyin (JWE) â€” gÃ¼venli taÅŸÄ±ma.</li>
<li>Standartlara Uygun: JOSE (JWS &#x26; JWE) ve Spring Security OAuth2 Resource Server.</li>
<li>Rol TabanlÄ± EriÅŸim: LDAP gruplarÄ±nÄ± <code>ROLE_USER</code> / <code>ROLE_ADMIN</code> rollerine otomatik eÅŸleyin.</li>
</ul>
<hr>
<h2>ğŸ“‹ Gereksinimler</h2>
<p>Bu bÃ¶lÃ¼mde Gereksinimler konusunu netleÅŸtirip uygulamada kullanacaÄŸÄ±nÄ±z temel noktalarÄ± Ã¶zetliyoruz.</p>
<ul>
<li>â˜• Java Development Kit (JDK) 17 veya Ã¼zeri</li>
<li>ğŸ“¦ Spring Boot 3.2+</li>
<li>ğŸ—„ï¸ LDAP (Embedded veya harici)</li>
<li>ğŸ”¤ IDE (IntelliJ IDEA, Eclipse vb.)</li>
</ul>
<hr>
<h2>ğŸ› ï¸ AdÄ±m 1: BaÄŸÄ±mlÄ±lÄ±klarÄ± Ekle</h2>
<p>Bu satÄ±rlarÄ± <code>pom.xml</code> veya <code>build.gradle</code> dosyanÄ±za ekleyin.</p>
<p>Maven:</p>
<pre><code class="language-xml">&#x3C;dependency>
  &#x3C;groupId>org.springframework.boot&#x3C;/groupId>
  &#x3C;artifactId>spring-boot-starter-web&#x3C;/artifactId>
&#x3C;/dependency>
&#x3C;dependency>
  &#x3C;groupId>org.springframework.security&#x3C;/groupId>
  &#x3C;artifactId>spring-security-oauth2-resource-server&#x3C;/artifactId>
&#x3C;/dependency>
&#x3C;dependency>
  &#x3C;groupId>org.springframework.security&#x3C;/groupId>
  &#x3C;artifactId>spring-security-ldap&#x3C;/artifactId>
&#x3C;/dependency>
&#x3C;dependency>
  &#x3C;groupId>com.unboundid&#x3C;/groupId>
  &#x3C;artifactId>unboundid-ldapsdk&#x3C;/artifactId>
&#x3C;/dependency>
&#x3C;dependency>
  &#x3C;groupId>org.projectlombok&#x3C;/groupId>
  &#x3C;artifactId>lombok&#x3C;/artifactId>
  &#x3C;optional>true&#x3C;/optional>
&#x3C;/dependency>
</code></pre>
<p>Gradle:</p>
<pre><code class="language-groovy">implementation 'org.springframework.boot:spring-boot-starter-web'
implementation 'org.springframework.security:spring-security-oauth2-resource-server'
implementation 'org.springframework.security:spring-security-ldap'
implementation 'com.unboundid:unboundid-ldapsdk'
compileOnly 'org.projectlombok:lombok'
</code></pre>
<hr>
<h2>ğŸ› ï¸ AdÄ±m 2: Anahtar ve LDAP YapÄ±landÄ±rmasÄ±</h2>
<p>Embeded LDAP directory, kullanÄ±cÄ±/grup yapÄ±nÄ±zÄ± ve RSA anahtar Ã¶zelliklerinizi <code>application.yml</code> ve <code>schema.ldif</code> dosyalarÄ±nda tanÄ±mlayÄ±n:</p>
<p>application.yml</p>
<pre><code class="language-yaml">spring:
  ldap:
    embedded:
      ldif: classpath:schema.ldif
      base-dn: dc=suaybsimsek,dc=com
      port: 8389
    urls: ldap://localhost:8389
    base: dc=suaybsimsek,dc=com
security:
  jwt:
    issuer: demo-issuer
    expiration-duration: 3600s
    signing:
      key-id: signing-key
      public-key: |-
        -----BEGIN PUBLIC KEY-----
        MIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEAjZEcz5itWkDGOSqZdB5P
        JE0ccOCckskp0hN3kQbT1qnv+9/k66jlWgVi4HSTppwdNF/Ylu5u541Qj+Okyg+u
        8o2PvKo5CfgvTDsFLTrZHUXU6hCSGatLAQoeN6lT8wzov2r4DFecXrIqcO6SvMB5
        ecPqsfiTi4trsNKgJ4cWS6gILH62ISd1ipUadfpnUzDMO1OulV0CJNV6bcBk7Es9
        RW6AHfg9j8osSanpwvRM4MJkB0SRxYUnrN9faGpkBZISZJ8TShhaTHEGfSNgKe5y
        8iu+AMGGZu8DYczVmqS3Ske1fq6y5HEGCma7Mo019GmwKeHBo1obuET6cZRygj4y
        twIDAQAB
        -----END PUBLIC KEY-----
      private-key: |-
        -----BEGIN PRIVATE KEY-----
        MIIEvAIBADANBgkqhkiG9w0BAQEFAASCBKYwggSiAgEAAoIBAQCNkRzPmK1aQMY5
        Kpl0Hk8kTRxw4JySySnSE3eRBtPWqe/73+TrqOVaBWLgdJOmnB00X9iW7m7njVCP
        46TKD67yjY+8qjkJ+C9MOwUtOtkdRdTqEJIZq0sBCh43qVPzDOi/avgMV5xesipw
        7pK8wHl5w+qx+JOLi2uw0qAnhxZLqAgsfrYhJ3WKlRp1+mdTMMw7U66VXQIk1Xpt
        wGTsSz1FboAd+D2PyixJqenC9EzgwmQHRJHFhSes319oamQFkhJknxNKGFpMcQZ9
        I2Ap7nLyK74AwYZm7wNhzNWapLdKR7V+rrLkcQYKZrsyjTX0abAp4cGjWhu4RPpx
        lHKCPjK3AgMBAAECggEABMo/sNCIMREXA/EqjxDFecN4LmOTOK5A0YBiH9Cc01sd
        qSaavtSQqhqbjV+0bUNEA7UohXbc3s3bx3qa5VFhiIh8sBQMaQdyRkCK/MxMc16d
        BSx5XQ/8MjVO73A1zHgH2g47BWPjgRrDL94KrgNPOO0FoG76QxL9GlcOHzhFa1rf
        xbb2auLBtflKy+5TZNnB/sbFC9ISpWywzfblD2Fsvxupl0vNWtA0Y2rPbKMZRnY+
        V6NC38yxW3HHAdWQRYLGOitM59I0HBgnjQKzTBNIsjPnJA2BSZvMBtQ1e3RQV0qE
        8VVoktZ8A0KDUxqdKWYlGYAY5hIw1y3UUsPRUbS3fQKBgQDAZehu+Kb5Sw+h00Qu
        vViNHDvi0PwmhQrHVpgjrppCnWsTk6FJFm+EBLY+87usXuRCnfZ1semb6P+yjLh2
        bJ9IXIrFAztcyE+7eZfn0H7mHA7E2ICKTjNdKbjy8kHViHpgdXREnAOrFTTk/BqW
        dq+weG2OuxYczWsY4XliWaVyiwKBgQC8XYExpSmoyI37o+jr9405k30tbGUw4X+/
        xYOvSUuafI8IOSLfKTpsvkMN3hxpJO6apIRAjOALbotKUA5FrHQPenuBWOr3mBJT
        euLiaWphqU8YN5dbNd+JhC/Jh5DLhY5FpB2Fv2MKSoF7+onpjDy9pEU5aReeBB0v
        ekUw4nWiBQKBgHxyrnjxP1frFG5xMB4nfZqw04+v7BmiXsl3mqsh6kgCeNtN17pl
        17YGMjfgAdnJ+02XzW5tqRSfDp3YZgy7z//HVD+BCqnGK8SxLu/ULfD73xW2kNZl
        JNYzAZ2r06eiQr4X2x/x5nGIIxGmfDAtDxFPpFX5b6ErwgVy+sgCAoFnAoGAWSpu
        EMEdQk+FnnwNsz2g9YNSuyDXmdb08SOfXWd1yXBzCLJ7RmYuyPEbrsHYcxFPfZap
        ICFPoTm35/qTdvnWiskxE56yw3eSHUBLjF/YQtixn0YZeMy8v0z6jgyFR0I2gdLZ
        QsnBKUrxlm2XwR1oV2Eef7m2u085PZNEk4pvor0CgYA6n060r48/CgRVslAeGder
        fZ3n+2ru8q2UVB38evepjLifn5+tKdFzZ7/NckXMC0NOVzm74qG46VFLMw5TtyT4
        /hRvGSYxA6dMjXy+tcrAns9Isrz2PnYFntlbhU6hw0um809tFunbvITfyeOjAsDW
        stC4thnhzXXT1Y3RfFtYEg==
        -----END PRIVATE KEY-----
    encryption:
      key-id: encryption-key
      public-key: |-
        -----BEGIN PUBLIC KEY-----
        MIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEAtU7Vu4tML8qg9BISaUH0
        BTU0+qkHJS3TUl3R0hEPttZJGf8EgT7bpWqRjdhMC2SYt2ifNF82EgMo/eva1rLn
        wYtCsxjJ7oB4U2m16/JKHtphmMUGhSLgbp+Y8pGAQ+P6u4HLlI0qbL92Syb6QCTr
        nYIlzZ2uUAvUQg/SbuAvdS4kdauZtpMNbhryusMVvILVBC5yUhfLJAkjbU3qWo/n
        2NKPr4kjwwFh6FaAf0HLsXCFmJbPPok6WMZeDqPORPZCt5gU2t04fS7s/2SSbhQ/
        i+7yyT4pl44cUlNLLN3Qo73sai5H90q7Dvmk3M5/YMJB0Ueyb705LHyOO5xA618s
        qQIDAQAB
        -----END PUBLIC KEY-----
      private-key: |-
        -----BEGIN PRIVATE KEY-----
        MIIEvgIBADANBgkqhkiG9w0BAQEFAASCBKgwggSkAgEAAoIBAQC1TtW7i0wvyqD0
        EhJpQfQFNTT6qQclLdNSXdHSEQ+21kkZ/wSBPtulapGN2EwLZJi3aJ80XzYSAyj9
        69rWsufBi0KzGMnugHhTabXr8koe2mGYxQaFIuBun5jykYBD4/q7gcuUjSpsv3ZL
        JvpAJOudgiXNna5QC9RCD9Ju4C91LiR1q5m2kw1uGvK6wxW8gtUELnJSF8skCSNt
        Tepaj+fY0o+viSPDAWHoVoB/QcuxcIWYls8+iTpYxl4Oo85E9kK3mBTa3Th9Luz/
        ZJJuFD+L7vLJPimXjhxSU0ss3dCjvexqLkf3SrsO+aTczn9gwkHRR7JvvTksfI47
        nEDrXyypAgMBAAECggEAREnJHrY8n9OGA+e6n4KD0mJT7gUz98Dm0yMbIC/k50yW
        hAAVRkjSmd8lq3NIURI2ov342NTznJ0sF1d6OVtxBujY2nP/uqEQsPoj1xaO7Ef8
        cnnjFsooFgJurQ44bVm02mLstqrky8jhWTT5FKfTRqP6cRNu0B9kdu1WqQQvW8a/
        C8xD8XUFzzJFQsEstJ076NjlZNH3EeqFiLxyVdV7tPEJRnOe2V2BAAgda3ByA6Jc
        Nd4xYHTVr5rZ+KES9gaAgb86+S7hNigsxz5Gp58NimLEyz1Qd+d9QCgPRgKOV5Uq
        0ci6c28ZrxW9wa/2CGCpoow1V7hRy1fZ24g2Tz91cQKBgQDbSdP/FQYuem0pUf8u
        mA/niEC8Jz30FW3ix5aqbQ8YRudK48Xy8F7AWnlS0wT2k/Xaeppn9YSPK4HlsNk2
        1gnpNfzdqXpJQtuxcPPeFNzUdXzBrsLXYqtlhOX/afrzqMhp73gkqoxXtqwD7BqN
        VfMcVXsWrEZQrRPBn/RUnnLdJwKBgQDTqUGupm93UlhoPgLXHGF/seQwPPHcU6lS
        SS9l512Ie21B+vZecgO4r77BXJwbY4rZVA5/m+wrsNmsT2f8yfdbs84cBDDWiKy5
        t2Um8zrus+BCIffxc9Fck9/htK33jLLcYwdSAm3a9pJxR9f/kAdredSTGBNJ3W/2
        rfh3cdNprwKBgDi7WfBFRSsjGzi0cPth9cNlubGzyVBrdtlT34PJ4Tzboxz53o1i
        aHEFNxwZYdBVKSbTzzyUBS5xCBMfdKK+LyQ5hmjmXq+zb1jxqvXKmfMRTixhhSDp
        8wO5pTM1/Omqwea+QGvj/5j1tnzxSVFFajbrWoPcH/jhPho6wqBducPDAoGBALOJ
        MEOavZXy7TaO0w3v7uvH0wzvxR/kfw1jMqc3l2j7ePOskmoOQAXaXO3bRjcdOlua
        Jyoq8islOZ4lRMlx7zWD0OKG035GNGzbmRtu2aA8R48RDSVr3jyu2gqznZULbXPv
        M/hmQxSmbhVUoW0PmJubnaqfk0zmXeBaNRXsIS3VAoGBALdsAtqR23PVeL6sYj2l
        dRNTDXpfvjFqJ5NThRO/4mT0CrPHQVj+Mz2bTc/Dxiwi8s8m3L+g23i3hodh/QMb
        Iz+UbcJZBGAKsFbPKGOtj6Bi07y/L11mcuNJzOWe61/JbVmJss0s+N/v3XucK/Ge
        CUaGOccsMO221v6JoBh9J3Hz
        -----END PRIVATE KEY-----
</code></pre>
<p>LDAP Schema (schema.ldif)</p>
<pre><code class="language-ldif"># 1) Root DN
 dn: dc=suaybsimsek,dc=com
 objectClass: top
 objectClass: domain
 objectClass: extensibleObject
 dc: suaybsimsek

# 2) People OU
 dn: ou=people,dc=suaybsimsek,dc=com
 objectClass: top
 objectClass: organizationalUnit
 ou: people

# 3) Admin user
 dn: uid=admin,ou=people,dc=suaybsimsek,dc=com
 objectClass: top
 objectClass: person
 objectClass: inetOrgPerson
 cn: Admin User
 sn: User
 uid: admin
 userPassword: $2a$10$sva6wl8pmGKJE6NIWrxwcuJK1Jaa2I/LOI43iHVpbR4YB8KjGViiK

# 4) Normal user
 dn: uid=user,ou=people,dc=suaybsimsek,dc=com
 objectClass: top
 objectClass: person
 objectClass: inetOrgPerson
 cn: Normal User
 sn: User
 uid: user
 userPassword: $2a$10$5Py4PyteLuXEqnGpSigzfu0V55C7Hi7zX18lmh.J8Bpmft.h23voG

# 5) Groups OU
 dn: ou=groups,dc=suaybsimsek,dc=com
 objectClass: top
 objectClass: organizationalUnit
 ou: groups

# 6) USER group â†’ maps to ROLE_USER
 dn: cn=USER,ou=groups,dc=suaybsimsek,dc=com
 objectClass: top
 objectClass: groupOfUniqueNames
 cn: USER
 uniqueMember: uid=user,ou=people,dc=suaybsimsek,dc=com
 uniqueMember: uid=admin,ou=people,dc=suaybsimsek,dc=com

# 7) ADMIN group â†’ maps to ROLE_ADMIN
 dn: cn=ADMIN,ou=groups,dc=suaybsimsek,dc=com
 objectClass: top
 objectClass: groupOfUniqueNames
 cn: ADMIN
 uniqueMember: uid=admin,ou=people,dc=suaybsimsek,dc=com
</code></pre>
<p>Bu yapÄ±landÄ±rma, tanÄ±mlÄ± ÅŸema ile embedded bir LDAP sunucusunu ayaÄŸa kaldÄ±rÄ±r ve JWE imzalama ile ÅŸifreleme iÃ§in RSA anahtarlarÄ±nÄ± yÃ¼kler. ArtÄ±k Spring Securityâ€™yi LDAP kimlik doÄŸrulamasÄ± ve JWE tabanlÄ± token oluÅŸturma iÃ§in yapÄ±landÄ±rabilirsiniz.</p>
<hr>
<h2>ğŸ› ï¸ AdÄ±m 3: GÃ¼venlik YapÄ±landÄ±rmasÄ±</h2>
<p>Bu bÃ¶lÃ¼mde, LDAP kimlik doÄŸrulamasÄ±nÄ± yapÄ±landÄ±rmak, RSA anahtarlarÄ±nÄ± ayarlamak ve JWE tabanlÄ± kimlik doÄŸrulama iÃ§in HTTP gÃ¼venlik filtrelerini uygulamak Ã¼zere gerekli beanâ€™leri ve Ã¶zellikleri tanÄ±mlÄ±yoruz:</p>
<ul>
<li>JwtProperties: JWT encoder/decoder iÃ§in imzalama ve ÅŸifreleme anahtar Ã§iftlerini, issuer bilgisini ve expire sÃ¼resini tanÄ±mlar.</li>
<li>SecurityJwtConfig: RSA JWK nesnelerini oluÅŸturur, JWT encoder/decoderâ€™Ä±, authentication converter ve token resolveri yapÄ±landÄ±rÄ±r.</li>
<li>SecurityConfig: Embedded LDAP kimlik doÄŸrulamasÄ±nÄ± tanÄ±mlar ve stateless bir gÃ¼venlik filtresi zinciri kurarak ilgili URLâ€™leri yetkilendirmeye tabi tutar.</li>
</ul>
<p>SecurityJwtConfig</p>
<h3>Java</h3>
<pre><code class="language-java">package io.github.susimsek.springbootldapjwedemo.config;

import com.nimbusds.jose.EncryptionMethod;
import com.nimbusds.jose.JWEAlgorithm;
import com.nimbusds.jose.JWSAlgorithm;
import com.nimbusds.jose.jwk.JWKSet;
import com.nimbusds.jose.jwk.RSAKey;
import com.nimbusds.jose.jwk.source.JWKSource;
import com.nimbusds.jose.proc.JWEDecryptionKeySelector;
import com.nimbusds.jose.proc.JWSVerificationKeySelector;
import com.nimbusds.jose.proc.SecurityContext;
import com.nimbusds.jwt.proc.DefaultJWTProcessor;
import io.github.susimsek.springbootldapjwedemo.security.CookieBearerTokenResolver;
import io.github.susimsek.springbootldapjwedemo.security.KeyUtils;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.security.oauth2.jwt.JwtDecoder;
import org.springframework.security.oauth2.jwt.JwtEncoder;
import org.springframework.security.oauth2.jwt.NimbusJwtDecoder;
import org.springframework.security.oauth2.jwt.NimbusJwtEncoder;
import org.springframework.security.oauth2.server.resource.authentication.JwtAuthenticationConverter;
import org.springframework.security.oauth2.server.resource.authentication.JwtGrantedAuthoritiesConverter;
import org.springframework.security.oauth2.server.resource.web.BearerTokenResolver;

import java.util.List;

import static io.github.susimsek.springbootldapjwedemo.security.SecurityUtils.AUTHORITIES_KEY;

@Configuration
public class SecurityJwtConfig {

    private final JwtProperties props;
    public SecurityJwtConfig(JwtProperties props) { this.props = props; }

    @Bean
    public RSAKey signingKey() throws Exception {
        return KeyUtils.buildRsaKey(
            props.getSigning().getPublicKey(),
            props.getSigning().getPrivateKey(),
            props.getSigning().getKeyId(),
            true
        );
    }

    @Bean
    public RSAKey encryptionKey() throws Exception {
        return KeyUtils.buildRsaKey(
            props.getEncryption().getPublicKey(),
            props.getEncryption().getPrivateKey(),
            props.getEncryption().getKeyId(),
            false
        );
    }

    @Bean
    public JWKSource&#x3C;SecurityContext> jwkSource(RSAKey signingKey, RSAKey encryptionKey) {
        JWKSet jwkSet = new JWKSet(List.of(
            signingKey,
            encryptionKey
        ));
        return (jwkSelector, context) -> jwkSelector.select(jwkSet);
    }

    @Bean
    public JwtDecoder jwtDecoder(JWKSource&#x3C;SecurityContext> jwkSource) {
        DefaultJWTProcessor&#x3C;SecurityContext> jwtProcessor = new DefaultJWTProcessor&#x3C;>();
        JWEDecryptionKeySelector&#x3C;SecurityContext> jweKeySelector =
            new JWEDecryptionKeySelector&#x3C;>(
                JWEAlgorithm.RSA_OAEP_256,
                EncryptionMethod.A128GCM,
                jwkSource
            );
        jwtProcessor.setJWEKeySelector(jweKeySelector);

        JWSVerificationKeySelector&#x3C;SecurityContext> jwsKeySelector =
            new JWSVerificationKeySelector&#x3C;>(
                JWSAlgorithm.RS256,
                jwkSource
            );
        jwtProcessor.setJWSKeySelector(jwsKeySelector);
        jwtProcessor.setJWTClaimsSetVerifier((claims, context) -> {});

        return new NimbusJwtDecoder(jwtProcessor);
    }

    @Bean
    public JwtEncoder jwtEncoder(JWKSource&#x3C;SecurityContext> jwkSource) {
        return new NimbusJwtEncoder(jwkSource);
    }

    @Bean
    public JwtAuthenticationConverter jwtAuthenticationConverter() {
        JwtGrantedAuthoritiesConverter converter = new JwtGrantedAuthoritiesConverter();
        converter.setAuthorityPrefix("");
        converter.setAuthoritiesClaimName(AUTHORITIES_KEY);

        JwtAuthenticationConverter authConverter = new JwtAuthenticationConverter();
        authConverter.setJwtGrantedAuthoritiesConverter(converter);
        return authConverter;
    }

    @Bean
    public BearerTokenResolver bearerTokenResolver() {
        CookieBearerTokenResolver resolver = new CookieBearerTokenResolver();
        resolver.setAllowUriQueryParameter(false);
        resolver.setAllowFormEncodedBodyParameter(false);
        resolver.setAllowCookie(true);
        return resolver;
    }
}
</code></pre>
<h3>Kotlin</h3>
<pre><code class="language-kotlin">package io.github.susimsek.springbootldapjwedemo.config

import com.nimbusds.jose.EncryptionMethod
import com.nimbusds.jose.JWEAlgorithm
import com.nimbusds.jose.JWSAlgorithm
import com.nimbusds.jose.jwk.JWKSet
import com.nimbusds.jose.jwk.RSAKey
import com.nimbusds.jose.jwk.source.JWKSource
import com.nimbusds.jose.proc.JWEDecryptionKeySelector
import com.nimbusds.jose.proc.JWSVerificationKeySelector
import com.nimbusds.jose.proc.SecurityContext
import com.nimbusds.jwt.proc.DefaultJWTProcessor
import io.github.susimsek.springbootldapjwedemo.security.CookieBearerTokenResolver
import io.github.susimsek.springbootldapjwedemo.security.KeyUtils
import org.springframework.context.annotation.Bean
import org.springframework.context.annotation.Configuration
import org.springframework.security.oauth2.jwt.JwtDecoder
import org.springframework.security.oauth2.jwt.JwtEncoder
import org.springframework.security.oauth2.jwt.NimbusJwtDecoder
import org.springframework.security.oauth2.jwt.NimbusJwtEncoder
import org.springframework.security.oauth2.server.resource.authentication.JwtAuthenticationConverter
import org.springframework.security.oauth2.server.resource.authentication.JwtGrantedAuthoritiesConverter
import org.springframework.security.oauth2.server.resource.web.BearerTokenResolver

@Configuration
class SecurityJwtConfig(private val props: JwtProperties) {

    @Bean
    @Throws(Exception::class)
    fun signingKey(): RSAKey =
        KeyUtils.buildRsaKey(
            props.signing.publicKey,
            props.signing.privateKey,
            props.signing.keyId,
            true
        )

    @Bean
    @Throws(Exception::class)
    fun encryptionKey(): RSAKey =
        KeyUtils.buildRsaKey(
            props.encryption.publicKey,
            props.encryption.privateKey,
            props.encryption.keyId,
            false
        )

    @Bean
    fun jwkSource(signingKey: RSAKey, encryptionKey: RSAKey): JWKSource&#x3C;SecurityContext> {
        val jwkSet = JWKSet(listOf(signingKey, encryptionKey))
        return JWKSource { jwkSelector, context -> jwkSelector.select(jwkSet) }
    }

    @Bean
    fun jwtDecoder(jwkSource: JWKSource&#x3C;SecurityContext>): JwtDecoder {
        val jwtProcessor = DefaultJWTProcessor&#x3C;SecurityContext>()
        val jweKeySelector = JWEDecryptionKeySelector(
            JWEAlgorithm.RSA_OAEP_256,
            EncryptionMethod.A128GCM,
            jwkSource
        )
        jwtProcessor.jweKeySelector = jweKeySelector
        val jwsKeySelector = JWSVerificationKeySelector(
            JWSAlgorithm.RS256,
            jwkSource
        )
        jwtProcessor.jwsKeySelector = jwsKeySelector
        jwtProcessor.jwtClaimsSetVerifier = { _, _ -> }
        return NimbusJwtDecoder(jwtProcessor)
    }

    @Bean
    fun jwtEncoder(jwkSource: JWKSource&#x3C;SecurityContext>): JwtEncoder =
        NimbusJwtEncoder(jwkSource)

    @Bean
    fun jwtAuthenticationConverter(): JwtAuthenticationConverter {
        val converter = JwtGrantedAuthoritiesConverter().apply {
            setAuthorityPrefix("")
            setAuthoritiesClaimName(AUTHORITIES_KEY)
        }
        return JwtAuthenticationConverter().apply {
            setJwtGrantedAuthoritiesConverter(converter)
        }
    }

    @Bean
    fun bearerTokenResolver(): BearerTokenResolver =
        CookieBearerTokenResolver().apply {
            setAllowUriQueryParameter(false)
            setAllowFormEncodedBodyParameter(false)
            setAllowCookie(true)
        }
}
</code></pre>
<p>SecurityConfig</p>
<h3>Java</h3>
<pre><code class="language-java">package io.github.susimsek.springbootldapjwedemo.config;

import io.github.susimsek.springbootldapjwedemo.security.AuthoritiesConstants;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.ldap.core.support.BaseLdapPathContextSource;
import org.springframework.security.authentication.AuthenticationManager;
import org.springframework.security.config.annotation.method.configuration.EnableMethodSecurity;
import org.springframework.security.config.annotation.web.builders.HttpSecurity;
import org.springframework.security.config.annotation.web.configurers.AbstractHttpConfigurer;
import org.springframework.security.config.http.SessionCreationPolicy;
import org.springframework.security.config.ldap.LdapPasswordComparisonAuthenticationManagerFactory;
import org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder;
import org.springframework.security.crypto.password.PasswordEncoder;
import org.springframework.security.ldap.userdetails.DefaultLdapAuthoritiesPopulator;
import org.springframework.security.ldap.userdetails.LdapAuthoritiesPopulator;
import org.springframework.security.web.SecurityFilterChain;
import org.springframework.security.web.servlet.util.matcher.MvcRequestMatcher;
import org.springframework.web.servlet.handler.HandlerMappingIntrospector;

import static org.springframework.security.config.Customizer.withDefaults;

@Configuration
@EnableMethodSecurity(securedEnabled = true)
public class SecurityConfig {

  @Bean
  public SecurityFilterChain securityFilterChain(HttpSecurity http,
                                                 MvcRequestMatcher.Builder mvc) throws Exception {
    http
      .cors(withDefaults())
      .csrf(AbstractHttpConfigurer::disable)
      .authorizeHttpRequests(authz ->
        authz
          .requestMatchers(
            mvc.pattern("/webjars/**"),
            mvc.pattern("/css/**"),
            mvc.pattern("/js/**")
          ).permitAll()
          .requestMatchers(
            mvc.pattern("/*.ico"),
            mvc.pattern("/*.png"),
            mvc.pattern("/*.svg"),
            mvc.pattern("/*.webapp")
          ).permitAll()
          .requestMatchers("/actuator/**").permitAll()
          .requestMatchers(
            "/v3/api-docs/**",
            "/swagger-ui.html",
            "/swagger-ui/**"
          ).permitAll()
          .requestMatchers(mvc.pattern("/api/auth/login")).permitAll()
          .requestMatchers(mvc.pattern("/api/hello/admin"))
          .hasAuthority(AuthoritiesConstants.ADMIN)
          .anyRequest().authenticated()
      )
      .sessionManagement(session ->
        session.sessionCreationPolicy(SessionCreationPolicy.STATELESS))
      .oauth2ResourceServer(oauth2 -> oauth2
        .jwt(withDefaults())
      );
    return http.build();
  }

  @Bean
  public PasswordEncoder passwordEncoder() {
    return new BCryptPasswordEncoder();
  }

  @Bean
  public LdapAuthoritiesPopulator authorities(BaseLdapPathContextSource contextSource) {
    DefaultLdapAuthoritiesPopulator populator =
      new DefaultLdapAuthoritiesPopulator(contextSource, "ou=groups");
    populator.setGroupSearchFilter("uniqueMember={0}");
    populator.setGroupRoleAttribute("cn");
    populator.setRolePrefix("ROLE_");
    return populator;
  }

  @Bean
  public AuthenticationManager authenticationManager(
    BaseLdapPathContextSource contextSource,
    PasswordEncoder passwordEncoder,
    LdapAuthoritiesPopulator authorities
  ) {
    LdapPasswordComparisonAuthenticationManagerFactory factory =
      new LdapPasswordComparisonAuthenticationManagerFactory(contextSource, passwordEncoder);
    factory.setUserDnPatterns("uid={0},ou=people");
    factory.setPasswordAttribute("userPassword");
    factory.setLdapAuthoritiesPopulator(authorities);
    return factory.createAuthenticationManager();
  }

  @Bean
  public MvcRequestMatcher.Builder mvc(HandlerMappingIntrospector introspector) {
    return new MvcRequestMatcher.Builder(introspector);
  }
}
</code></pre>
<h3>Kotlin</h3>
<pre><code class="language-kotlin">package io.github.susimsek.springbootldapjwedemo.config

import io.github.susimsek.springbootldapjwedemo.security.AuthoritiesConstants
import org.springframework.context.annotation.Bean
import org.springframework.context.annotation.Configuration
import org.springframework.ldap.core.support.BaseLdapPathContextSource
import org.springframework.security.authentication.AuthenticationManager
import org.springframework.security.config.annotation.method.configuration.EnableMethodSecurity
import org.springframework.security.config.annotation.web.builders.HttpSecurity
import org.springframework.security.config.annotation.web.configurers.AbstractHttpConfigurer
import org.springframework.security.config.http.SessionCreationPolicy
import org.springframework.security.config.ldap.LdapPasswordComparisonAuthenticationManagerFactory
import org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder
import org.springframework.security.crypto.password.PasswordEncoder
import org.springframework.security.ldap.userdetails.DefaultLdapAuthoritiesPopulator
import org.springframework.security.ldap.userdetails.LdapAuthoritiesPopulator
import org.springframework.security.web.SecurityFilterChain
import org.springframework.security.web.servlet.util.matcher.MvcRequestMatcher
import org.springframework.web.servlet.handler.HandlerMappingIntrospector
import org.springframework.security.config.Customizer.withDefaults

@Configuration
@EnableMethodSecurity(securedEnabled = true)
class SecurityConfig {

  @Bean
  fun securityFilterChain(
    http: HttpSecurity,
    mvc: MvcRequestMatcher.Builder
  ): SecurityFilterChain = http
    .cors(withDefaults())
    .csrf { it.disable() }
    .authorizeHttpRequests { authz ->
      authz
        .requestMatchers(
          mvc.pattern("/webjars/**"),
          mvc.pattern("/css/**"),
          mvc.pattern("/js/**")
        ).permitAll()
        .requestMatchers(
          mvc.pattern("/*.ico"),
          mvc.pattern("/*.png"),
          mvc.pattern("/*.svg"),
          mvc.pattern("/*.webapp")
        ).permitAll()
        .requestMatchers("/actuator/**").permitAll()
        .requestMatchers("/v3/api-docs/**", "/swagger-ui.html", "/swagger-ui/**")
        .permitAll()
        .requestMatchers(mvc.pattern("/api/auth/login")).permitAll()
        .requestMatchers(mvc.pattern("/api/hello/admin"))
        .hasAuthority(AuthoritiesConstants.ADMIN)
        .anyRequest().authenticated()
    }
    .sessionManagement { it.sessionCreationPolicy(SessionCreationPolicy.STATELESS) }
    .oauth2ResourceServer { it.jwt(withDefaults()) }
    .build()

  @Bean
  fun passwordEncoder(): PasswordEncoder = BCryptPasswordEncoder()

  @Bean
  fun authorities(contextSource: BaseLdapPathContextSource): LdapAuthoritiesPopulator {
    return DefaultLdapAuthoritiesPopulator(contextSource, "ou=groups").apply {
      setGroupSearchFilter("uniqueMember={0}")
      setGroupRoleAttribute("cn")
      setRolePrefix("ROLE_")
    }
  }

  @Bean
  fun authenticationManager(
    contextSource: BaseLdapPathContextSource,
    passwordEncoder: PasswordEncoder,
    authorities: LdapAuthoritiesPopulator
  ): AuthenticationManager {
    return LdapPasswordComparisonAuthenticationManagerFactory(contextSource, passwordEncoder).apply {
      setUserDnPatterns("uid={0},ou=people")
      setPasswordAttribute("userPassword")
      setLdapAuthoritiesPopulator(authorities)
    }.createAuthenticationManager()
  }

  @Bean
  fun mvc(introspector: HandlerMappingIntrospector): MvcRequestMatcher.Builder =
    MvcRequestMatcher.Builder(introspector)
}
</code></pre>
<p>JwtProperties</p>
<h3>Java</h3>
<pre><code class="language-java">package io.github.susimsek.springbootldapjwedemo.config;

import lombok.Data;
import org.springframework.boot.context.properties.ConfigurationProperties;
import org.springframework.context.annotation.Configuration;

import java.time.Duration;

@Configuration
@ConfigurationProperties(prefix = "security.jwt")
@Data
public class JwtProperties {

    @Data
    public static class Pair {
        private String publicKey;
        private String privateKey;
        private String keyId;
    }

    private Pair signing;
    private Pair encryption;
    private String issuer;
    private Duration expirationDuration;
}
</code></pre>
<h3>Kotlin</h3>
<pre><code class="language-kotlin">package io.github.susimsek.springbootldapjwedemo.config

import org.springframework.boot.context.properties.ConfigurationProperties
import org.springframework.context.annotation.Configuration
import java.time.Duration

@Configuration
@ConfigurationProperties(prefix = "security.jwt")
class JwtProperties {

  class Pair {
    lateinit var publicKey: String
    lateinit var privateKey: String
    lateinit var keyId: String
  }

  lateinit var signing: Pair
  lateinit var encryption: Pair
  lateinit var issuer: String
  lateinit var expirationDuration: Duration
}
</code></pre>
<p>UserProperties</p>
<h3>Java</h3>
<pre><code class="language-java">package io.github.susimsek.springbootldapjwedemo.config;

import lombok.Data;
import org.springframework.boot.context.properties.ConfigurationProperties;
import org.springframework.context.annotation.Configuration;

@Configuration
@ConfigurationProperties(prefix = "security.user")
@Data
public class UserProperties {
    private String username;
    private String password;
}
</code></pre>
<h3>Kotlin</h3>
<pre><code class="language-kotlin">package io.github.susimsek.springbootldapjwedemo.config

import org.springframework.boot.context.properties.ConfigurationProperties
import org.springframework.context.annotation.Configuration

@Configuration
@ConfigurationProperties(prefix = "security.user")
class UserProperties {
  lateinit var username: String
  lateinit var password: String
}
</code></pre>
<hr>
<h2>ğŸ› ï¸ AdÄ±m 4: GÃ¼venli JWE Token YardÄ±mcÄ± SÄ±nÄ±flarÄ± OluÅŸturun</h2>
<p>Bu bÃ¶lÃ¼mde, Spring Boot uygulamanÄ±zda JSON Web Encryption (JWE) tokenlarÄ± oluÅŸturmak, ÅŸifrelemek ve Ã§Ã¶zmek iÃ§in gereken temel yardÄ±mcÄ± sÄ±nÄ±flarÄ± ve sabitleri tanÄ±mlÄ±yoruz. Bu bileÅŸenler ÅŸunlarÄ± saÄŸlar:</p>
<ul>
<li>AuthoritiesConstants: <code>ROLE_</code> Ã¶n ekiyle rol isimlerini merkezileÅŸtirir.</li>
<li>CookieBearerTokenResolver: Bearer tokenâ€™larÄ± yetkilendirme baÅŸlÄ±klarÄ±ndan veya HTTP Ã§erezlerinden Ã§Ã¶zer.</li>
<li>CookieUtils: EriÅŸim tokenâ€™larÄ± iÃ§in HTTP-only ve secure Ã§erezler oluÅŸturur.</li>
<li>JweUtil: Nimbus kÃ¼tÃ¼phanesi ile RSA anahtarlarÄ± kullanarak JWTâ€™leri imzalar (JWS) ve ÅŸifreler (JWE).</li>
<li>KeyUtils: PEM formatÄ±ndaki anahtar Ã§iftinden RSA JWKâ€™leri oluÅŸturur.</li>
<li>SecurityUtils: SecurityContext oturum aÃ§an kullanÄ±cÄ±nÄ±n bilgisini sunar.</li>
</ul>
<p>Bu yardÄ±mcÄ±lar, Spring Security ile durumsuz (stateless) JWE tabanlÄ± bir kimlik doÄŸrulama akÄ±ÅŸÄ±nÄ±n temelini oluÅŸturur.</p>
<p>AuthoritiesConstants</p>
<h3>Java</h3>
<pre><code class="language-java">
package io.github.susimsek.springbootldapjwedemo.security;

import lombok.AccessLevel;
import lombok.NoArgsConstructor;

@NoArgsConstructor(access = AccessLevel.PRIVATE)
public final class AuthoritiesConstants {
    public static final String ADMIN = "ROLE_ADMIN";
    public static final String USER = "ROLE_USER";
    public static final String ANONYMOUS = "ROLE_ANONYMOUS";
}
</code></pre>
<h3>Kotlin</h3>
<pre><code class="language-kotlin">
package io.github.susimsek.springbootldapjwedemo.security

object AuthoritiesConstants {
  const val ADMIN = "ROLE_ADMIN"
  const val USER = "ROLE_USER"
  const val ANONYMOUS = "ROLE_ANONYMOUS"
}
</code></pre>
<p>CookieBearerTokenResolver</p>
<h3>Java</h3>
<pre><code class="language-java">package io.github.susimsek.springbootldapjwedemo.security;

import jakarta.servlet.http.Cookie;
import jakarta.servlet.http.HttpServletRequest;
import lombok.Setter;
import org.springframework.http.HttpMethod;
import org.springframework.security.oauth2.core.OAuth2AuthenticationException;
import org.springframework.security.oauth2.server.resource.BearerTokenError;
import org.springframework.security.oauth2.server.resource.BearerTokenErrors;
import org.springframework.security.oauth2.server.resource.web.BearerTokenResolver;
import org.springframework.util.StringUtils;

import java.util.regex.Matcher;
import java.util.regex.Pattern;

@Setter
public class CookieBearerTokenResolver implements BearerTokenResolver {
    private static final String ACCESS_TOKEN_PARAMETER_NAME = "access_token";
    private static final Pattern AUTHORIZATION_PATTERN =
        Pattern.compile("^Bearer (?&#x3C;token>[A-Za-z0-9-._~+/]+=*)$", Pattern.CASE_INSENSITIVE);

    private boolean allowFormEncodedBodyParameter = false;
    private boolean allowUriQueryParameter       = false;
    private boolean allowCookie                  = true;
    private String  bearerTokenHeaderName       = "Authorization";
    private String  cookieName                  = "accessToken";

    @Override
    public String resolve(HttpServletRequest request) {
        String headerToken = resolveFromAuthorizationHeader(request);
        String queryToken  = resolveAccessTokenFromQueryString(request);
        String bodyToken   = resolveAccessTokenFromBody(request);
        String cookieToken = (headerToken == null &#x26;&#x26; queryToken == null &#x26;&#x26; bodyToken == null)
            ? resolveFromCookie(request)
            : null;

        return resolveToken(headerToken, queryToken, bodyToken, cookieToken);
    }

    private String resolveFromAuthorizationHeader(HttpServletRequest request) {
        String authorization = request.getHeader(this.bearerTokenHeaderName);
        if (!StringUtils.hasText(authorization) || !authorization.toLowerCase().startsWith("bearer")) {
            return null;
        }
        Matcher matcher = AUTHORIZATION_PATTERN.matcher(authorization.trim());
        if (!matcher.matches()) {
            BearerTokenError error = BearerTokenErrors.invalidToken("Bearer token is malformed");
            throw new OAuth2AuthenticationException(error);
        }
        return matcher.group("token");
    }

    private String resolveAccessTokenFromQueryString(HttpServletRequest request) {
        if (allowUriQueryParameter &#x26;&#x26; HttpMethod.GET.matches(request.getMethod())) {
            return resolveToken(request.getParameterValues(ACCESS_TOKEN_PARAMETER_NAME));
        }
        return null;
    }

    private String resolveAccessTokenFromBody(HttpServletRequest request) {
        if (allowFormEncodedBodyParameter
            &#x26;&#x26; HttpMethod.POST.matches(request.getMethod())
            &#x26;&#x26; "application/x-www-form-urlencoded".equals(request.getContentType())) {
            return resolveToken(request.getParameterValues(ACCESS_TOKEN_PARAMETER_NAME));
        }
        return null;
    }

    private String resolveFromCookie(HttpServletRequest request) {
        if (!allowCookie || request.getCookies() == null) {
            return null;
        }
        for (Cookie cookie : request.getCookies()) {
            if (cookieName.equals(cookie.getName())) {
                String val = cookie.getValue();
                return StringUtils.hasText(val) ? val : null;
            }
        }
        return null;
    }

    private String resolveToken(String... tokens) {
        String found = null;
        for (String token : tokens) {
            if (token == null) continue;
            if (found != null) {
                BearerTokenError error = BearerTokenErrors.invalidRequest("Found multiple bearer tokens in the request");
                throw new OAuth2AuthenticationException(error);
            }
            found = token;
        }
        if (found != null &#x26;&#x26; found.isBlank()) {
            BearerTokenError error = BearerTokenErrors.invalidRequest("The requested token parameter is an empty string");
            throw new OAuth2AuthenticationException(error);
        }
        return found;
    }
</code></pre>
<h3>Kotlin</h3>
<pre><code class="language-kotlin">package io.github.susimsek.springbootldapjwedemo.security

import jakarta.servlet.http.Cookie
import jakarta.servlet.http.HttpServletRequest
import org.springframework.http.HttpMethod
import org.springframework.security.oauth2.core.OAuth2AuthenticationException
import org.springframework.security.oauth2.server.resource.BearerTokenError
import org.springframework.security.oauth2.server.resource.BearerTokenErrors
import org.springframework.security.oauth2.server.resource.web.BearerTokenResolver
import org.springframework.util.StringUtils
import java.util.regex.Pattern

class CookieBearerTokenResolver {
    var allowFormEncodedBodyParameter: Boolean = false
    var allowUriQueryParameter: Boolean = false
    var allowCookie: Boolean = true
    var bearerTokenHeaderName: String = "Authorization"
    var cookieName: String = "accessToken"

    companion object {
        private const val ACCESS_TOKEN_PARAMETER_NAME = "access_token"
        private val AUTHORIZATION_PATTERN =
            Pattern.compile("^Bearer (?&#x3C;token>[A-Za-z0-9-._~+/]+=*)$", Pattern.CASE_INSENSITIVE)
    }

    fun resolve(request: HttpServletRequest): String? {
        val header = resolveFromAuthorizationHeader(request)
        val query  = if (allowUriQueryParameter &#x26;&#x26; HttpMethod.GET.matches(request.method))
            request.getParameterValues(ACCESS_TOKEN_PARAMETER_NAME)?.let(::resolveToken)
        else null
        val body   = if (allowFormEncodedBodyParameter &#x26;&#x26; HttpMethod.POST.matches(request.method)
            &#x26;&#x26; request.contentType == "application/x-www-form-urlencoded")
            request.getParameterValues(ACCESS_TOKEN_PARAMETER_NAME)?.let(::resolveToken)
        else null
        val cookie = if (header == null &#x26;&#x26; query == null &#x26;&#x26; body == null)
            resolveFromCookie(request)
        else null
        return listOf(header, query, body, cookie).filterNotNull().let {
            if (it.size > 1) throw OAuth2AuthenticationException(BearerTokenErrors.invalidRequest("Found multiple bearer tokens"))
            it.firstOrNull()?: null
        }
    }

    private fun resolveFromAuthorizationHeader(request: HttpServletRequest): String? {
        val auth = request.getHeader(bearerTokenHeaderName) ?: return null
        if (!auth.startsWith("Bearer ", true)) return null
        val matcher = AUTHORIZATION_PATTERN.matcher(auth.trim())
        return if (matcher.matches()) matcher.group("token")
        else throw OAuth2AuthenticationException(BearerTokenErrors.invalidToken("Malformed token"))
    }

    private fun resolveFromCookie(request: HttpServletRequest): String? {
        if (!allowCookie) return null
        return request.cookies?.firstOrNull { it.name == cookieName }?.value?.takeIf { it.isNotBlank() }
    }

    private fun resolveToken(tokens: Array&#x3C;String>): String? {
        return tokens.filter { it.isNotBlank() }.let {
            when {
                it.isEmpty() -> null
                it.size > 1   -> throw OAuth2AuthenticationException(BearerTokenErrors.invalidRequest("Multiple tokens"))
                else          -> it[0]
            }
        }
    }
</code></pre>
<p>CookieUtils</p>
<h3>Java</h3>
<pre><code class="language-java">package io.github.susimsek.springbootldapjwedemo.security;

import io.github.susimsek.springbootldapjwedemo.dto.TokenDTO;
import lombok.experimental.UtilityClass;
import org.springframework.http.ResponseCookie;

@UtilityClass
public class CookieUtils {

    private static final String COOKIE_NAME = "accessToken";

    public ResponseCookie createAccessTokenCookie(TokenDTO tokenDto) {
        return ResponseCookie.from(COOKIE_NAME, tokenDto.accessToken())
            .httpOnly(true)
            .secure(true)
            .path("/")
            .maxAge(tokenDto.accessTokenExpiresIn())
            .sameSite("Strict")
            .build();
    }
}
</code></pre>
<h3>Kotlin</h3>
<pre><code class="language-kotlin">package io.github.susimsek.springbootldapjwedemo.security

import io.github.susimsek.springbootldapjwedemo.dto.TokenDTO
import org.springframework.http.ResponseCookie

object CookieUtils {

  private const val COOKIE_NAME = "accessToken"

  fun createAccessTokenCookie(tokenDto: TokenDTO): ResponseCookie {
    return ResponseCookie.from(COOKIE_NAME, tokenDto.accessToken())
      .httpOnly(true)
      .secure(true)
      .path("/")
      .maxAge(tokenDto.accessTokenExpiresIn())
      .sameSite("Strict")
      .build()
  }
}
</code></pre>
<p>JweUtil</p>
<h3>Java</h3>
<pre><code class="language-java">package io.github.susimsek.springbootldapjwedemo.security;

import com.nimbusds.jose.EncryptionMethod;
import com.nimbusds.jose.JOSEException;
import com.nimbusds.jose.JWEAlgorithm;
import com.nimbusds.jose.JWEHeader;
import com.nimbusds.jose.JWEObject;
import com.nimbusds.jose.Payload;
import com.nimbusds.jose.crypto.RSAEncrypter;
import com.nimbusds.jose.jwk.RSAKey;
import io.github.susimsek.springbootldapjwedemo.config.JwtProperties;
import io.github.susimsek.springbootldapjwedemo.dto.TokenDTO;
import lombok.RequiredArgsConstructor;
import org.springframework.security.core.Authentication;
import org.springframework.security.core.GrantedAuthority;
import org.springframework.security.oauth2.jose.jws.SignatureAlgorithm;
import org.springframework.security.oauth2.jwt.*;
import org.springframework.stereotype.Component;

import java.time.Instant;
import java.util.List;

import static io.github.susimsek.springbootldapjwedemo.security.SecurityUtils.AUTHORITIES_KEY;

@Component
@RequiredArgsConstructor
public class JweUtil {

    private final JwtEncoder jwtEncoder;
    private final RSAKey signingKey;
    private final RSAKey encryptionKey;
    private final JwtProperties props;

    public TokenDTO generateToken(Authentication authentication) throws JOSEException {
        String subject = authentication.getName();
        List&#x3C;String> roles = authentication.getAuthorities()
            .stream()
            .map(GrantedAuthority::getAuthority)
            .toList();

        Instant now = Instant.now();
        long expiresIn = props.getExpirationDuration().getSeconds();
        Instant exp = now.plusSeconds(expiresIn);

        JwtClaimsSet claims = JwtClaimsSet.builder()
            .issuer(props.getIssuer())
            .issuedAt(now)
            .expiresAt(exp)
            .subject(subject)
            .claim(AUTHORITIES_KEY, roles)
            .build();

        JwsHeader jwsHeader = JwsHeader.with(SignatureAlgorithm.RS256)
            .keyId(signingKey.getKeyID())
            .build();

        String jws = jwtEncoder
            .encode(JwtEncoderParameters.from(jwsHeader, claims))
            .getTokenValue();

        JWEHeader jweHeader = new JWEHeader.Builder(JWEAlgorithm.RSA_OAEP_256, EncryptionMethod.A128GCM)
            .contentType("JWT")
            .keyID(encryptionKey.getKeyID())
            .build();

        JWEObject jweObject = new JWEObject(jweHeader, new Payload(jws));
        jweObject.encrypt(new RSAEncrypter(encryptionKey.toRSAPublicKey()));
        String token = jweObject.serialize();

        return new TokenDTO(token, "Bearer", expiresIn);
    }
}
</code></pre>
<h3>Kotlin</h3>
<pre><code class="language-kotlin">package io.github.susimsek.springbootldapjwedemo.security

import com.nimbusds.jose.EncryptionMethod
import com.nimbusds.jose.JOSEException
import com.nimbusds.jose.JWEAlgorithm
import com.nimbusds.jose.JWEHeader
import com.nimbusds.jose.JWEObject
import com.nimbusds.jose.Payload
import com.nimbusds.jose.crypto.RSAEncrypter
import com.nimbusds.jose.jwk.RSAKey
import io.github.susimsek.springbootldapjwedemo.config.JwtProperties
import io.github.susimsek.springbootldapjwedemo.dto.TokenDTO
import lombok.RequiredArgsConstructor
import org.springframework.security.core.Authentication
import org.springframework.security.oauth2.jose.jws.SignatureAlgorithm
import org.springframework.security.oauth2.jwt.JwtClaimsSet
import org.springframework.security.oauth2.jwt.JwtEncoder
import org.springframework.security.oauth2.jwt.JwtEncoderParameters
import org.springframework.stereotype.Component

import java.time.Instant

@Component
@RequiredArgsConstructor
class JweUtil(
    private val jwtEncoder: JwtEncoder,
    private val signingKey: RSAKey,
    private val encryptionKey: RSAKey,
    private val props: JwtProperties
) {
    fun generateToken(authentication: Authentication): TokenDTO {
        val subject = authentication.name
        val roles = authentication.authorities.map { it.authority }

        val now = Instant.now()
        val expiresIn = props.expirationDuration.seconds
        val exp = now.plusSeconds(expiresIn)

        val claims = JwtClaimsSet.builder()
            .issuer(props.issuer)
            .issuedAt(now)
            .expiresAt(exp)
            .subject(subject)
            .claim(AUTHORITIES_KEY, roles)
            .build()

        val jwsHeader = org.springframework.security.oauth2.jwt.JwsHeader.with(SignatureAlgorithm.RS256)
            .keyId(signingKey.keyID)
            .build()

        val jws = jwtEncoder
            .encode(JwtEncoderParameters.from(jwsHeader, claims))
            .tokenValue

        val jweHeader = JWEHeader.Builder(JWEAlgorithm.RSA_OAEP_256, EncryptionMethod.A128GCM)
            .contentType("JWT")
            .keyID(encryptionKey.keyID)
            .build()

        val jweObject = JWEObject(jweHeader, Payload(jws))
        jweObject.encrypt(RSAEncrypter(encryptionKey.toRSAPublicKey()))
        val token = jweObject.serialize()

        return TokenDTO(token, "Bearer", expiresIn)
    }
}
</code></pre>
<p>KeyUtils</p>
<h3>Java</h3>
<pre><code class="language-java">package io.github.susimsek.springbootldapjwedemo.security;

import com.nimbusds.jose.JWEAlgorithm;
import com.nimbusds.jose.JWSAlgorithm;
import com.nimbusds.jose.jwk.KeyUse;
import com.nimbusds.jose.jwk.RSAKey;
import lombok.experimental.UtilityClass;

import java.security.KeyFactory;
import java.security.interfaces.RSAPrivateKey;
import java.security.interfaces.RSAPublicKey;
import java.security.spec.PKCS8EncodedKeySpec;
import java.security.spec.X509EncodedKeySpec;
import java.util.Base64;

@UtilityClass
public class KeyUtils {
    public RSAKey buildRsaKey(
            String pubPem,
            String privPem,
            String kid,
            boolean forSign
    ) throws Exception {
        String pubContent = pubPem
            .replace("-----BEGIN PUBLIC KEY-----", "")
            .replace("-----END PUBLIC KEY-----", "")
            .replaceAll("\\s", "");
        String privContent = privPem
            .replace("-----BEGIN PRIVATE KEY-----", "")
            .replace("-----END PRIVATE KEY-----", "")
            .replaceAll("\\s", "");

        byte[] decodedPub = Base64.getDecoder().decode(pubContent);
        byte[] decodedPriv = Base64.getDecoder().decode(privContent);

        KeyFactory kf = KeyFactory.getInstance("RSA");
        RSAPublicKey publicKey = (RSAPublicKey) kf.generatePublic(new X509EncodedKeySpec(decodedPub));
        RSAPrivateKey privateKey = (RSAPrivateKey) kf.generatePrivate(new PKCS8EncodedKeySpec(decodedPriv));

        RSAKey.Builder builder = new RSAKey.Builder(publicKey)
            .privateKey(privateKey)
            .keyID(kid);

        if (forSign) {
            builder
                .algorithm(JWSAlgorithm.RS256)
                .keyUse(KeyUse.SIGNATURE);
        } else {
            builder
                .algorithm(JWEAlgorithm.RSA_OAEP_256)
                .keyUse(KeyUse.ENCRYPTION);
        }

        return builder.build();
    }
}
</code></pre>
<h3>Kotlin</h3>
<pre><code class="language-kotlin">package io.github.susimsek.springbootldapjwedemo.security

import com.nimbusds.jose.JWEAlgorithm
import com.nimbusds.jose.JWSAlgorithm
import com.nimbusds.jose.jwk.KeyUse
import com.nimbusds.jose.jwk.RSAKey
import java.security.KeyFactory
import java.security.interfaces.RSAPrivateKey
import java.security.interfaces.RSAPublicKey
import java.security.spec.PKCS8EncodedKeySpec
import java.security.spec.X509EncodedKeySpec
import java.util.Base64

object KeyUtils {
    @JvmStatic
    @Throws(Exception::class)
    fun buildRsaKey(
        pubPem: String,
        privPem: String,
        kid: String,
        forSign: Boolean
    ): RSAKey {
        val pubContent = pubPem
            .replace("-----BEGIN PUBLIC KEY-----", "")
            .replace("-----END PUBLIC KEY-----", "")
            .replace(Regex("\\s"), "")
        val privContent = privPem
            .replace("-----BEGIN PRIVATE KEY-----", "")
            .replace("-----END PRIVATE KEY-----", "")
            .replace(Regex("\\s"), "")

        val decodedPub = Base64.getDecoder().decode(pubContent)
        val decodedPriv = Base64.getDecoder().decode(privContent)

        val kf = KeyFactory.getInstance("RSA")
        val publicKey = kf.generatePublic(X509EncodedKeySpec(decodedPub)) as RSAPublicKey
        val privateKey = kf.generatePrivate(PKCS8EncodedKeySpec(decodedPriv)) as RSAPrivateKey

        val builder = RSAKey.Builder(publicKey)
            .privateKey(privateKey)
            .keyID(kid)

        if (forSign) {
            builder
                .algorithm(JWSAlgorithm.RS256)
                .keyUse(KeyUse.SIGNATURE)
        } else {
            builder
                .algorithm(JWEAlgorithm.RSA_OAEP_256)
                .keyUse(KeyUse.ENCRYPTION)
        }

        return builder.build()
    }
}
</code></pre>
<p>SecurityUtils</p>
<h3>Java</h3>
<pre><code class="language-java">package io.github.susimsek.springbootldapjwedemo.security;

import lombok.experimental.UtilityClass;
import org.springframework.security.core.Authentication;
import org.springframework.security.core.context.SecurityContextHolder;
import org.springframework.security.core.userdetails.UserDetails;
import org.springframework.security.oauth2.jwt.Jwt;

import java.util.Optional;

@UtilityClass
public class SecurityUtils {

    public static final String AUTHORITIES_KEY = "auth";

    public Optional&#x3C;String> getCurrentUserLogin() {
        var ctx = SecurityContextHolder.getContext();
        return Optional.ofNullable(extractPrincipal(ctx.getAuthentication()));
    }

    private String extractPrincipal(Authentication authentication) {
        if (authentication == null) {
            return null;
        }
        Object principal = authentication.getPrincipal();
        if (principal instanceof Jwt jwt) {
            return jwt.getSubject();
        }
        if (principal instanceof UserDetails ud) {
            return ud.getUsername();
        }
        if (principal instanceof String username) {
            return username;
        }
        return null;
    }
}
</code></pre>
<h3>Kotlin</h3>
<pre><code class="language-kotlin">package io.github.susimsek.springbootldapjwedemo.security

import org.springframework.security.core.Authentication
import org.springframework.security.core.context.SecurityContextHolder
import org.springframework.security.core.userdetails.UserDetails
import org.springframework.security.oauth2.jwt.Jwt
import java.util.Optional

object SecurityUtils {
  const val AUTHORITIES_KEY = "auth"

  fun getCurrentUserLogin(): Optional&#x3C;String> {
    val authentication: Authentication? = SecurityContextHolder.getContext().authentication
    return Optional.ofNullable(extractPrincipal(authentication))
  }

  private fun extractPrincipal(authentication: Authentication?): String? {
    return when (val principal = authentication?.principal) {
      is Jwt -> principal.subject
      is UserDetails -> principal.username
      is String -> principal
      else -> null
    }
  }
}
</code></pre>
<hr>
<h2>ğŸ§ª AdÄ±m 5: Kimlik DoÄŸrulama ve GÃ¼venli Endpointler</h2>
<p>Bu bÃ¶lÃ¼mde, aÅŸaÄŸÄ±dakileri gerÃ§ekleÅŸtirmek iÃ§in gerekli REST controller ve DTOâ€™larÄ± tanÄ±mlÄ±yoruz:</p>
<ul>
<li>AuthController: KullanÄ±cÄ±larÄ± doÄŸrular, JWE tokenâ€™larÄ± oluÅŸturur ve gÃ¼venli cookie ayarlar.</li>
<li>HelloController: KimliÄŸi doÄŸrulanmÄ±ÅŸ kullanÄ±cÄ±lar ve yalnÄ±zca admine Ã¶zel pathler iÃ§in gÃ¼venli endpointler sunar.</li>
<li>LoginRequestDTO: Login isteÄŸi payloadÄ±nÄ± (kullanÄ±cÄ± adÄ±/parola) modelleyen DTO.</li>
<li>TokenDTO: Token ve geÃ§erlilik sÃ¼resini iÃ§eren kimlik doÄŸrulama yanÄ±tÄ±nÄ± modelleyen DTO.</li>
</ul>
<p>Bu bileÅŸenler, login iÅŸlemi, token oluÅŸturma, cookie yÃ¶netimi ve kaynak korumasÄ±nÄ± iÅŸleyerek stateless(durumsuz) kimlik doÄŸrulama akÄ±ÅŸÄ±nÄ± tamamlar.</p>
<p>Bu bÃ¶lÃ¼mde, kullanÄ±cÄ± kimlik doÄŸrulamasÄ±nÄ±, token oluÅŸturmayÄ± ve korunan kaynak eriÅŸimini yÃ¶netmek iÃ§in REST controller ve DTOâ€™larÄ± oluÅŸturuyoruz.</p>
<p>AuthController</p>
<h3>Java</h3>
<pre><code class="language-java">package io.github.susimsek.springbootldapjwedemo.controller;

import io.github.susimsek.springbootldapjwedemo.dto.LoginRequestDTO;
import io.github.susimsek.springbootldapjwedemo.dto.TokenDTO;
import io.github.susimsek.springbootldapjwedemo.security.CookieUtils;
import io.github.susimsek.springbootldapjwedemo.security.JweUtil;
import lombok.RequiredArgsConstructor;
import org.springframework.http.HttpHeaders;
import org.springframework.http.ResponseCookie;
import org.springframework.http.ResponseEntity;
import org.springframework.security.authentication.AuthenticationManager;
import org.springframework.security.authentication.UsernamePasswordAuthenticationToken;
import org.springframework.security.core.Authentication;
import org.springframework.security.core.context.SecurityContextHolder;
import org.springframework.web.bind.annotation.PostMapping;
import org.springframework.web.bind.annotation.RequestBody;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;

@RestController
@RequiredArgsConstructor
@RequestMapping("/api/auth")
public class AuthController {

    private final AuthenticationManager authenticationManager;
    private final JweUtil jweUtil;

    @PostMapping("/login")
    public ResponseEntity&#x3C;TokenDTO> login(@RequestBody LoginRequestDTO loginRequest) throws Exception {
        // Authenticate user
        var authToken = new UsernamePasswordAuthenticationToken(
            loginRequest.username(), loginRequest.password()
        );
        Authentication auth = authenticationManager.authenticate(authToken);
        SecurityContextHolder.getContext().setAuthentication(auth);

        // Generate JWE token and cookie
        TokenDTO tokenDto = jweUtil.generateToken(auth);
        ResponseCookie cookie = CookieUtils.createAccessTokenCookie(tokenDto);

        return ResponseEntity.ok()
            .header(HttpHeaders.SET_COOKIE, cookie.toString())
            .body(tokenDto);
    }
}
</code></pre>
<h3>Kotlin</h3>
<pre><code class="language-kotlin">package io.github.susimsek.springbootldapjwedemo.controller

import io.github.susimsek.springbootldapjwedemo.dto.LoginRequestDTO
import io.github.susimsek.springbootldapjwedemo.dto.TokenDTO
import io.github.susimsek.springbootldapjwedemo.security.CookieUtils
import io.github.susimsek.springbootldapjwedemo.security.JweUtil
import lombok.RequiredArgsConstructor
import org.springframework.http.HttpHeaders
import org.springframework.http.ResponseCookie
import org.springframework.http.ResponseEntity
import org.springframework.security.authentication.AuthenticationManager
import org.springframework.security.authentication.UsernamePasswordAuthenticationToken
import org.springframework.security.core.Authentication
import org.springframework.security.core.context.SecurityContextHolder
import org.springframework.web.bind.annotation.PostMapping
import org.springframework.web.bind.annotation.RequestBody
import org.springframework.web.bind.annotation.RequestMapping
import org.springframework.web.bind.annotation.RestController

@RestController
@RequiredArgsConstructor
@RequestMapping("/api/auth")
class AuthController(
    private val authenticationManager: AuthenticationManager,
    private val jweUtil: JweUtil
) {

    @PostMapping("/login")
    fun login(@RequestBody loginRequest: LoginRequestDTO): ResponseEntity&#x3C;TokenDTO> {
        val authToken = UsernamePasswordAuthenticationToken(
            loginRequest.username, loginRequest.password
        )
        val auth: Authentication = authenticationManager.authenticate(authToken)
        SecurityContextHolder.getContext().authentication = auth

        val tokenDto: TokenDTO = jweUtil.generateToken(auth)
        val cookie: ResponseCookie = CookieUtils.createAccessTokenCookie(tokenDto)

        return ResponseEntity.ok()
            .header(HttpHeaders.SET_COOKIE, cookie.toString())
            .body(tokenDto)
    }
}
</code></pre>
<p>HelloController</p>
<h3>Java</h3>
<pre><code class="language-java">package io.github.susimsek.springbootldapjwedemo.controller;

import org.springframework.security.core.annotation.AuthenticationPrincipal;
import org.springframework.security.oauth2.jwt.Jwt;
import org.springframework.web.bind.annotation.*;

import static io.github.susimsek.springbootldapjwedemo.security.SecurityUtils.AUTHORITIES_KEY;

@RestController
@RequestMapping("/api/hello")
public class HelloController {

    @GetMapping
    public String helloAll(@AuthenticationPrincipal Jwt jwt) {
        String user = jwt.getSubject();
        var roles = jwt.getClaimAsStringList(AUTHORITIES_KEY);
        return "Hello, " + user + "! Your roles: " + roles;
    }

    @GetMapping("/admin")
    public String helloAdmin(@AuthenticationPrincipal Jwt jwt) {
        return "Hello Admin, " + jwt.getSubject() + "!";
    }
}
</code></pre>
<h3>Kotlin</h3>
<pre><code class="language-kotlin">package io.github.susimsek.springbootldapjwedemo.controller

import org.springframework.security.core.annotation.AuthenticationPrincipal
import org.springframework.security.oauth2.jwt.Jwt
import org.springframework.web.bind.annotation.*

import io.github.susimsek.springbootldapjwedemo.security.SecurityUtils.AUTHORITIES_KEY

@RestController
@RequestMapping("/api/hello")
class HelloController {

    @GetMapping
    fun helloAll(@AuthenticationPrincipal jwt: Jwt): String {
        val user = jwt.subject
        val roles = jwt.getClaimAsStringList(AUTHORITIES_KEY)
        return "Hello, \$user! Your roles: \$roles"
    }

    @GetMapping("/admin")
    fun helloAdmin(@AuthenticationPrincipal jwt: Jwt): String {
        return "Hello Admin, \${jwt.subject}!"
    }
}
</code></pre>
<p>LoginRequestDTO</p>
<h3>Java</h3>
<pre><code class="language-java">package io.github.susimsek.springbootldapjwedemo.dto;

public record LoginRequestDTO(
    String username,
    String password
) { }
</code></pre>
<h3>Kotlin</h3>
<pre><code class="language-kotlin">package io.github.susimsek.springbootldapjwedemo.dto

data class LoginRequestDTO(
    val username: String,
    val password: String
)
</code></pre>
<p>TokenDTO</p>
<h3>Java</h3>
<pre><code class="language-java">package io.github.susimsek.springbootldapjwedemo.dto;

public record TokenDTO(
    String accessToken,
    String tokenType,
    long accessTokenExpiresIn
) {}
</code></pre>
<h3>Kotlin</h3>
<pre><code class="language-kotlin">package io.github.susimsek.springbootldapjwedemo.dto

import kotlin.Long

data class TokenDTO(
    val accessToken: String,
    val tokenType: String,
    val accessTokenExpiresIn: Long
)
</code></pre>
<hr>
<h2>â–¶ï¸ UygulamayÄ± Ã‡alÄ±ÅŸtÄ±r</h2>
<pre><code class="language-bash">./mvnw spring-boot:run
# or
gradle bootRun
</code></pre>
<hr>
<h2>ğŸ§ª Endpoint Testi</h2>
<p>Bu bÃ¶lÃ¼mde Endpoint Testi konusunu netleÅŸtirip uygulamada kullanacaÄŸÄ±nÄ±z temel noktalarÄ± Ã¶zetliyoruz.</p>
<h3>Admin AkÄ±ÅŸÄ±</h3>
<p>admin olarak giriÅŸ yapÄ±n ve <code>Set-Cookie</code> baÅŸlÄ±ÄŸÄ±ndan JWE tokeni yakalayÄ±n:</p>
<pre><code class="language-bash">curl -i -X POST http://localhost:8080/api/auth/login \
  -H "Content-Type: application/json" \
  -d '{"username":"admin","password":"adminpass"}'
</code></pre>
<ul>
<li>Set-Cookie baÅŸlÄ±ÄŸÄ± <code>accessToken=&#x3C;jwe-token></code> iÃ§erir</li>
<li>YanÄ±t:</li>
</ul>
<pre><code class="language-json">{
  "accessToken": "&#x3C;jwe-token>",
  "tokenType": "Bearer",
  "accessTokenExpiresIn": 3600
}
</code></pre>
<p>cookie kullanarak <code>hello</code> endpointine eriÅŸin:</p>
<pre><code class="language-bash">curl -b "accessToken=&#x3C;jwe-token>" http://localhost:8080/api/hello
</code></pre>
<p>Veya Authorization baÅŸlÄ±ÄŸÄ±yla:</p>
<pre><code class="language-bash">curl -H "Authorization: Bearer &#x3C;jwe-token>" http://localhost:8080/api/hello
</code></pre>
<p>admin-Ã¶zel endpointine eriÅŸin:</p>
<pre><code class="language-bash">curl -H "Authorization: Bearer &#x3C;jwe-token>" http://localhost:8080/api/hello/admin
</code></pre>
<h3>KullanÄ±cÄ± AkÄ±ÅŸÄ±</h3>
<p>user olarak giriÅŸ yapÄ±n ve cookieâ€™den JWE tokeni yakalayÄ±n:</p>
<pre><code class="language-bash">curl -i -X POST http://localhost:8080/api/auth/login \
  -H "Content-Type: application/json" \
  -d '{"username":"user","password":"userpass"}'
</code></pre>
<ul>
<li>Set-Cookie baÅŸlÄ±ÄŸÄ± <code>accessToken=&#x3C;jwe-token></code> iÃ§erir</li>
</ul>
<p>cookie kullanarak <code>hello</code> endpointine eriÅŸin:</p>
<pre><code class="language-bash">curl -b "accessToken=&#x3C;jwe-token>" http://localhost:8080/api/hello
</code></pre>
<p>Authorization baÅŸlÄ±ÄŸÄ±yla:</p>
<pre><code class="language-bash">curl -H "Authorization: Bearer &#x3C;jwe-token>" http://localhost:8080/api/hello
</code></pre>
<p>Admin endpointini deneyince (403 Forbidden dÃ¶ner):</p>
<pre><code class="language-bash">curl -H "Authorization: Bearer &#x3C;jwe-token>" http://localhost:8080/api/hello/admin
# HTTP/1.1 403 Forbidden
</code></pre>
<hr>
<h2>ğŸ SonuÃ§</h2>
<p>ArtÄ±k Spring Boot LDAP ve JWE Kimlik DoÄŸrulama iÃ§in Ã¼retim odaklÄ± bir Spring Boot temeliniz var. Sonraki adÄ±mda ayarlarÄ± kendi domainine uyarlayÄ±p test ve gÃ¶zlemlenebilirlik katmanÄ±nÄ± ekleyerek gerÃ§ek trafik altÄ±nda doÄŸrulayÄ±n.</p>]]></content:encoded>
      <category><![CDATA[Java]]></category>
      <category><![CDATA[Kotlin]]></category>
      <category><![CDATA[Spring Boot]]></category>
      <category><![CDATA[GÃ¼venlik]]></category>
      <category><![CDATA[JWT]]></category>
      <category><![CDATA[JWE]]></category>
      <category><![CDATA[LDAP]]></category>
      <media:thumbnail url="https://suaybsimsek.com/images/spring-boot-ldap-jwe-auth-thumbnail.webp" />
    </item>
    <item>
      <title><![CDATA[Spring Boot JWE Kimlik DoÄŸrulama]]></title>
      <link>https://suaybsimsek.com/tr/posts/spring-boot-jwe-authentication</link>
      <description><![CDATA[JWTâ€™lerinizi JWE ile ÅŸifreleyerek gizlilik ve bÃ¼tÃ¼nlÃ¼ÄŸÃ¼ saÄŸlamak iÃ§in Spring Boot APIâ€™lerinizi nasÄ±l gÃ¼vence altÄ±na alacaÄŸÄ±nÄ±zÄ± Ã¶ÄŸrenin.]]></description>
      <pubDate>Sat, 03 May 2025 00:00:00 GMT</pubDate>
      <atom:updated>2025-05-04T00:00:00.000Z</atom:updated>
      <guid isPermaLink="true">https://suaybsimsek.com/tr/posts/spring-boot-jwe-authentication</guid>
      <content:encoded><![CDATA[<p>Spring Boot, mikroservislerinizdeki JWTâ€™lerin bÃ¼tÃ¼nlÃ¼ÄŸÃ¼nÃ¼ ve gizliliÄŸini korumak iÃ§in JWS imzalama ile JWE ÅŸifrelemeyi bir arada kullanmanÄ±za olanak tanÄ±r.</p>
<hr>
<h2>ğŸŒŸ Neden JWE Kimlik DoÄŸrulama KullanmalÄ±?</h2>
<p>Bu bÃ¶lÃ¼mde Neden JWE Kimlik DoÄŸrulama KullanmalÄ±? konusunu netleÅŸtirip uygulamada kullanacaÄŸÄ±nÄ±z temel noktalarÄ± Ã¶zetliyoruz.</p>
<ul>
<li>BÃ¼tÃ¼nlÃ¼k: Tokenâ€™larÄ±n imzalanmasÄ±nÄ± (JWS) saÄŸlayarak tahrifatÄ± Ã¶nler.</li>
<li>Gizlilik: Hassas token alanlarÄ±nÄ± yalnÄ±zca Ã¶zel anahtara sahip olanlarÄ±n okuyabileceÄŸi ÅŸekilde ÅŸifreler (JWE).</li>
<li>Standartlara DayalÄ±: JOSE (JWS, JWE) spesifikasyonlarÄ±na uygundur.</li>
<li>Spring DesteÄŸi: Spring Securityâ€™nin OAuth2 Resource Server Ã¶zelliÄŸi, JWE+JWS iÅŸ akÄ±ÅŸÄ±nÄ± sorunsuzca yÃ¶netir.</li>
</ul>
<hr>
<h2>ğŸ“‹ Gereksinimler</h2>
<p>Bu bÃ¶lÃ¼mde Gereksinimler konusunu netleÅŸtirip uygulamada kullanacaÄŸÄ±nÄ±z temel noktalarÄ± Ã¶zetliyoruz.</p>
<ul>
<li>â˜• Java Development Kit (JDK) 17 veya Ã¼zeri</li>
<li>ğŸ“¦ Spring Boot 3.2+</li>
<li>ğŸ”¤ IDE (IntelliJ IDEA, Eclipse vb.)</li>
</ul>
<hr>
<h2>ğŸ› ï¸ AdÄ±m 1: BaÄŸÄ±mlÄ±lÄ±klarÄ± Ekle</h2>
<p>Bu satÄ±rlarÄ± <code>pom.xml</code> veya <code>build.gradle</code> dosyanÄ±za ekleyin.</p>
<p>Maven:</p>
<pre><code class="language-xml">&#x3C;dependency>
  &#x3C;groupId>org.springframework.boot&#x3C;/groupId>
  &#x3C;artifactId>spring-boot-starter-web&#x3C;/artifactId>
&#x3C;/dependency>
&#x3C;dependency>
  &#x3C;groupId>org.springframework.security&#x3C;/groupId>
  &#x3C;artifactId>spring-security-oauth2-resource-server&#x3C;/artifactId>
&#x3C;/dependency>
&#x3C;dependency>
  &#x3C;groupId>org.projectlombok&#x3C;/groupId>
  &#x3C;artifactId>lombok&#x3C;/artifactId>
  &#x3C;optional>true&#x3C;/optional>
&#x3C;/dependency>
</code></pre>
<p>Gradle:</p>
<pre><code class="language-groovy">implementation 'org.springframework.boot:spring-boot-starter-web'
implementation 'org.springframework.security:spring-security-oauth2-resource-server'
compileOnly 'org.projectlombok:lombok'
</code></pre>
<hr>
<h2>ğŸ› ï¸ AdÄ±m 2: Anahtar YapÄ±landÄ±rmasÄ±</h2>
<p>RSA anahtarlarÄ±nÄ± ve kullanÄ±cÄ± kimlik bilgilerini <code>application.yml</code> dosyasÄ±nda tanÄ±mlayÄ±n:</p>
<pre><code class="language-yaml">security:
  admin:
    username: admin
    password: adminpass
  user:
    username: user
    password: userpass
  jwt:
    issuer: demo-issuer
    expiration-duration: 3600s
    signing:
      key-id: signing-key
      public-key: |-
        -----BEGIN PUBLIC KEY-----
        MIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEAjZEcz5itWkDGOSqZdB5P
        JE0ccOCckskp0hN3kQbT1qnv+9/k66jlWgVi4HSTppwdNF/Ylu5u541Qj+Okyg+u
        8o2PvKo5CfgvTDsFLTrZHUXU6hCSGatLAQoeN6lT8wzov2r4DFecXrIqcO6SvMB5
        ecPqsfiTi4trsNKgJ4cWS6gILH62ISd1ipUadfpnUzDMO1OulV0CJNV6bcBk7Es9
        RW6AHfg9j8osSanpwvRM4MJkB0SRxYUnrN9faGpkBZISZJ8TShhaTHEGfSNgKe5y
        8iu+AMGGZu8DYczVmqS3Ske1fq6y5HEGCma7Mo019GmwKeHBo1obuET6cZRygj4y
        twIDAQAB
        -----END PUBLIC KEY-----
      private-key: |-
        -----BEGIN PRIVATE KEY-----
        MIIEvAIBADANBgkqhkiG9w0BAQEFAASCBKYwggSiAgEAAoIBAQCNkRzPmK1aQMY5
        Kpl0Hk8kTRxw4JySySnSE3eRBtPWqe/73+TrqOVaBWLgdJOmnB00X9iW7m7njVCP
        46TKD67yjY+8qjkJ+C9MOwUtOtkdRdTqEJIZq0sBCh43qVPzDOi/avgMV5xesipw
        7pK8wHl5w+qx+JOLi2uw0qAnhxZLqAgsfrYhJ3WKlRp1+mdTMMw7U66VXQIk1Xpt
        wGTsSz1FboAd+D2PyixJqenC9EzgwmQHRJHFhSes319oamQFkhJknxNKGFpMcQZ9
        I2Ap7nLyK74AwYZm7wNhzNWapLdKR7V+rrLkcQYKZrsyjTX0abAp4cGjWhu4RPpx
        lHKCPjK3AgMBAAECggEABMo/sNCIMREXA/EqjxDFecN4LmOTOK5A0YBiH9Cc01sd
        qSaavtSQqhqbjV+0bUNEA7UohXbc3s3bx3qa5VFhiIh8sBQMaQdyRkCK/MxMc16d
        BSx5XQ/8MjVO73A1zHgH2g47BWPjgRrDL94KrgNPOO0FoG76QxL9GlcOHzhFa1rf
        xbb2auLBtflKy+5TZNnB/sbFC9ISpWywzfblD2Fsvxupl0vNWtA0Y2rPbKMZRnY+
        V6NC38yxW3HHAdWQRYLGOitM59I0HBgnjQKzTBNIsjPnJA2BSZvMBtQ1e3RQV0qE
        8VVoktZ8A0KDUxqdKWYlGYAY5hIw1y3UUsPRUbS3fQKBgQDAZehu+Kb5Sw+h00Qu
        vViNHDvi0PwmhQrHVpgjrppCnWsTk6FJFm+EBLY+87usXuRCnfZ1semb6P+yjLh2
        bJ9IXIrFAztcyE+7eZfn0H7mHA7E2ICKTjNdKbjy8kHViHpgdXREnAOrFTTk/BqW
        dq+weG2OuxYczWsY4XliWaVyiwKBgQC8XYExpSmoyI37o+jr9405k30tbGUw4X+/
        xYOvSUuafI8IOSLfKTpsvkMN3hxpJO6apIRAjOALbotKUA5FrHQPenuBWOr3mBJT
        euLiaWphqU8YN5dbNd+JhC/Jh5DLhY5FpB2Fv2MKSoF7+onpjDy9pEU5aReeBB0v
        ekUw4nWiBQKBgHxyrnjxP1frFG5xMB4nfZqw04+v7BmiXsl3mqsh6kgCeNtN17pl
        17YGMjfgAdnJ+02XzW5tqRSfDp3YZgy7z//HVD+BCqnGK8SxLu/ULfD73xW2kNZl
        JNYzAZ2r06eiQr4X2x/x5nGIIxGmfDAtDxFPpFX5b6ErwgVy+sgCAoFnAoGAWSpu
        EMEdQk+FnnwNsz2g9YNSuyDXmdb08SOfXWd1yXBzCLJ7RmYuyPEbrsHYcxFPfZap
        ICFPoTm35/qTdvnWiskxE56yw3eSHUBLjF/YQtixn0YZeMy8v0z6jgyFR0I2gdLZ
        QsnBKUrxlm2XwR1oV2Eef7m2u085PZNEk4pvor0CgYA6n060r48/CgRVslAeGder
        fZ3n+2ru8q2UVB38evepjLifn5+tKdFzZ7/NckXMC0NOVzm74qG46VFLMw5TtyT4
        /hRvGSYxA6dMjXy+tcrAns9Isrz2PnYFntlbhU6hw0um809tFunbvITfyeOjAsDW
        stC4thnhzXXT1Y3RfFtYEg==
        -----END PRIVATE KEY-----
    encryption:
      key-id: encryption-key
      public-key: |-
        -----BEGIN PUBLIC KEY-----
        MIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEAtU7Vu4tML8qg9BISaUH0
        BTU0+qkHJS3TUl3R0hEPttZJGf8EgT7bpWqRjdhMC2SYt2ifNF82EgMo/eva1rLn
        wYtCsxjJ7oB4U2m16/JKHtphmMUGhSLgbp+Y8pGAQ+P6u4HLlI0qbL92Syb6QCTr
        nYIlzZ2uUAvUQg/SbuAvdS4kdauZtpMNbhryusMVvILVBC5yUhfLJAkjbU3qWo/n
        2NKPr4kjwwFh6FaAf0HLsXCFmJbPPok6WMZeDqPORPZCt5gU2t04fS7s/2SSbhQ/
        i+7yyT4pl44cUlNLLN3Qo73sai5H90q7Dvmk3M5/YMJB0Ueyb705LHyOO5xA618s
        qQIDAQAB
        -----END PUBLIC KEY-----
      private-key: |-
        -----BEGIN PRIVATE KEY-----
        MIIEvgIBADANBgkqhkiG9w0BAQEFAASCBKgwggSkAgEAAoIBAQC1TtW7i0wvyqD0
        EhJpQfQFNTT6qQclLdNSXdHSEQ+21kkZ/wSBPtulapGN2EwLZJi3aJ80XzYSAyj9
        69rWsufBi0KzGMnugHhTabXr8koe2mGYxQaFIuBun5jykYBD4/q7gcuUjSpsv3ZL
        JvpAJOudgiXNna5QC9RCD9Ju4C91LiR1q5m2kw1uGvK6wxW8gtUELnJSF8skCSNt
        Tepaj+fY0o+viSPDAWHoVoB/QcuxcIWYls8+iTpYxl4Oo85E9kK3mBTa3Th9Luz/
        ZJJuFD+L7vLJPimXjhxSU0ss3dCjvexqLkf3SrsO+aTczn9gwkHRR7JvvTksfI47
        nEDrXyypAgMBAAECggEAREnJHrY8n9OGA+e6n4KD0mJT7gUz98Dm0yMbIC/k50yW
        hAAVRkjSmd8lq3NIURI2ov342NTznJ0sF1d6OVtxBujY2nP/uqEQsPoj1xaO7Ef8
        cnnjFsooFgJurQ44bVm02mLstqrky8jhWTT5FKfTRqP6cRNu0B9kdu1WqQQvW8a/
        C8xD8XUFzzJFQsEstJ076NjlZNH3EeqFiLxyVdV7tPEJRnOe2V2BAAgda3ByA6Jc
        Nd4xYHTVr5rZ+KES9gaAgb86+S7hNigsxz5Gp58NimLEyz1Qd+d9QCgPRgKOV5Uq
        0ci6c28ZrxW9wa/2CGCpoow1V7hRy1fZ24g2Tz91cQKBgQDbSdP/FQYuem0pUf8u
        mA/niEC8Jz30FW3ix5aqbQ8YRudK48Xy8F7AWnlS0wT2k/Xaeppn9YSPK4HlsNk2
        1gnpNfzdqXpJQtuxcPPeFNzUdXzBrsLXYqtlhOX/afrzqMhp73gkqoxXtqwD7BqN
        VfMcVXsWrEZQrRPBn/RUnnLdJwKBgQDTqUGupm93UlhoPgLXHGF/seQwPPHcU6lS
        SS9l512Ie21B+vZecgO4r77BXJwbY4rZVA5/m+wrsNmsT2f8yfdbs84cBDDWiKy5
        t2Um8zrus+BCIffxc9Fck9/htK33jLLcYwdSAm3a9pJxR9f/kAdredSTGBNJ3W/2
        rfh3cdNprwKBgDi7WfBFRSsjGzi0cPth9cNlubGzyVBrdtlT34PJ4Tzboxz53o1i
        aHEFNxwZYdBVKSbTzzyUBS5xCBMfdKK+LyQ5hmjmXq+zb1jxqvXKmfMRTixhhSDp
        8wO5pTM1/Omqwea+QGvj/5j1tnzxSVFFajbrWoPcH/jhPho6wqBducPDAoGBALOJ
        MEOavZXy7TaO0w3v7uvH0wzvxR/kfw1jMqc3l2j7ePOskmoOQAXaXO3bRjcdOlua
        Jyoq8islOZ4lRMlx7zWD0OKG035GNGzbmRtu2aA8R48RDSVr3jyu2gqznZULbXPv
        M/hmQxSmbhVUoW0PmJubnaqfk0zmXeBaNRXsIS3VAoGBALdsAtqR23PVeL6sYj2l
        dRNTDXpfvjFqJ5NThRO/4mT0CrPHQVj+Mz2bTc/Dxiwi8s8m3L+g23i3hodh/QMb
        Iz+UbcJZBGAKsFbPKGOtj6Bi07y/L11mcuNJzOWe61/JbVmJss0s+N/v3XucK/Ge
        CUaGOccsMO221v6JoBh9J3Hz
        -----END PRIVATE KEY-----
</code></pre>
<hr>
<h2>ğŸ› ï¸ AdÄ±m 3: GÃ¼venlik YapÄ±landÄ±rmasÄ±</h2>
<p>Bu bÃ¶lÃ¼mde, JWE tabanlÄ± kimlik doÄŸrulama iÃ§in gerekli olan beanâ€™leri ve ayarlarÄ± tanÄ±mlÄ±yoruz:</p>
<ul>
<li>AdminProperties: Admin kullanÄ±cÄ± adÄ± ve ÅŸifresini <code>application.properties</code> veya <code>application.yml</code> Ã¼zerinden okur.</li>
<li>UserProperties: KullanÄ±cÄ± kimlik bilgilerini yapÄ±landÄ±rmadan yÃ¼kler.</li>
<li>JwtProperties: JWT encoder/decoder iÃ§in imzalama ve ÅŸifreleme anahtar Ã§iftlerini, issuer bilgisini ve expire sÃ¼resini tanÄ±mlar.</li>
<li>SecurityJwtConfig: RSA JWK nesnelerini oluÅŸturur, JWT encoder/decoderâ€™Ä±, authentication converter ve token resolveri yapÄ±landÄ±rÄ±r.</li>
<li>SecurityConfig: Bellek iÃ§i (in-memory) kullanÄ±cÄ±larÄ± tanÄ±mlar ve stateless bir gÃ¼venlik filtresi zinciri kurarak ilgili URLâ€™leri yetkilendirmeye tabi tutar.</li>
</ul>
<p>AdminProperties</p>
<h3>Java</h3>
<pre><code class="language-java">package io.github.susimsek.springbootjwedemo.config;

import lombok.Data;
import org.springframework.boot.context.properties.ConfigurationProperties;
import org.springframework.context.annotation.Configuration;

@Configuration
@ConfigurationProperties(prefix = "security.admin")
@Data
public class AdminProperties {
    private String username;
    private String password;
}
</code></pre>
<h3>Kotlin</h3>
<pre><code class="language-kotlin">package io.github.susimsek.springbootjwedemo.config

import org.springframework.boot.context.properties.ConfigurationProperties
import org.springframework.context.annotation.Configuration

@Configuration
@ConfigurationProperties(prefix = "security.admin")
class AdminProperties {
  lateinit var username: String
  lateinit var password: String
}
</code></pre>
<p>SecurityJwtConfig</p>
<h3>Java</h3>
<pre><code class="language-java">package io.github.susimsek.springbootjwedemo.config;

import com.nimbusds.jose.EncryptionMethod;
import com.nimbusds.jose.JWEAlgorithm;
import com.nimbusds.jose.JWSAlgorithm;
import com.nimbusds.jose.jwk.JWKSet;
import com.nimbusds.jose.jwk.RSAKey;
import com.nimbusds.jose.jwk.source.JWKSource;
import com.nimbusds.jose.proc.JWEDecryptionKeySelector;
import com.nimbusds.jose.proc.JWSVerificationKeySelector;
import com.nimbusds.jose.proc.SecurityContext;
import com.nimbusds.jwt.proc.DefaultJWTProcessor;
import io.github.susimsek.springbootjwedemo.security.CookieBearerTokenResolver;
import io.github.susimsek.springbootjwedemo.security.KeyUtils;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.security.oauth2.jwt.JwtDecoder;
import org.springframework.security.oauth2.jwt.JwtEncoder;
import org.springframework.security.oauth2.jwt.NimbusJwtDecoder;
import org.springframework.security.oauth2.jwt.NimbusJwtEncoder;
import org.springframework.security.oauth2.server.resource.authentication.JwtAuthenticationConverter;
import org.springframework.security.oauth2.server.resource.authentication.JwtGrantedAuthoritiesConverter;
import org.springframework.security.oauth2.server.resource.web.BearerTokenResolver;

import java.util.List;

import static io.github.susimsek.springbootjwedemo.security.SecurityUtils.AUTHORITIES_KEY;

@Configuration
public class SecurityJwtConfig {

    private final JwtProperties props;
    public SecurityJwtConfig(JwtProperties props) { this.props = props; }

    @Bean
    public RSAKey signingKey() throws Exception {
        return KeyUtils.buildRsaKey(
            props.getSigning().getPublicKey(),
            props.getSigning().getPrivateKey(),
            props.getSigning().getKeyId(),
            true
        );
    }

    @Bean
    public RSAKey encryptionKey() throws Exception {
        return KeyUtils.buildRsaKey(
            props.getEncryption().getPublicKey(),
            props.getEncryption().getPrivateKey(),
            props.getEncryption().getKeyId(),
            false
        );
    }

    @Bean
    public JWKSource&#x3C;SecurityContext> jwkSource(RSAKey signingKey, RSAKey encryptionKey) {
        JWKSet jwkSet = new JWKSet(List.of(
            signingKey,
            encryptionKey
        ));
        return (jwkSelector, context) -> jwkSelector.select(jwkSet);
    }

    @Bean
    public JwtDecoder jwtDecoder(JWKSource&#x3C;SecurityContext> jwkSource) {
        DefaultJWTProcessor&#x3C;SecurityContext> jwtProcessor = new DefaultJWTProcessor&#x3C;>();
        JWEDecryptionKeySelector&#x3C;SecurityContext> jweKeySelector =
            new JWEDecryptionKeySelector&#x3C;>(
                JWEAlgorithm.RSA_OAEP_256,
                EncryptionMethod.A128GCM,
                jwkSource
            );
        jwtProcessor.setJWEKeySelector(jweKeySelector);

        JWSVerificationKeySelector&#x3C;SecurityContext> jwsKeySelector =
            new JWSVerificationKeySelector&#x3C;>(
                JWSAlgorithm.RS256,
                jwkSource
            );
        jwtProcessor.setJWSKeySelector(jwsKeySelector);
        jwtProcessor.setJWTClaimsSetVerifier((claims, context) -> {});

        return new NimbusJwtDecoder(jwtProcessor);
    }

    @Bean
    public JwtEncoder jwtEncoder(JWKSource&#x3C;SecurityContext> jwkSource) {
        return new NimbusJwtEncoder(jwkSource);
    }

    @Bean
    public JwtAuthenticationConverter jwtAuthenticationConverter() {
        JwtGrantedAuthoritiesConverter converter = new JwtGrantedAuthoritiesConverter();
        converter.setAuthorityPrefix("");
        converter.setAuthoritiesClaimName(AUTHORITIES_KEY);

        JwtAuthenticationConverter authConverter = new JwtAuthenticationConverter();
        authConverter.setJwtGrantedAuthoritiesConverter(converter);
        return authConverter;
    }

    @Bean
    public BearerTokenResolver bearerTokenResolver() {
        CookieBearerTokenResolver resolver = new CookieBearerTokenResolver();
        resolver.setAllowUriQueryParameter(false);
        resolver.setAllowFormEncodedBodyParameter(false);
        resolver.setAllowCookie(true);
        return resolver;
    }
}
</code></pre>
<h3>Kotlin</h3>
<pre><code class="language-kotlin">package io.github.susimsek.springbootjwedemo.config

import com.nimbusds.jose.EncryptionMethod
import com.nimbusds.jose.JWEAlgorithm
import com.nimbusds.jose.JWSAlgorithm
import com.nimbusds.jose.jwk.JWKSet
import com.nimbusds.jose.jwk.RSAKey
import com.nimbusds.jose.jwk.source.JWKSource
import com.nimbusds.jose.proc.JWEDecryptionKeySelector
import com.nimbusds.jose.proc.JWSVerificationKeySelector
import com.nimbusds.jose.proc.SecurityContext
import com.nimbusds.jwt.proc.DefaultJWTProcessor
import io.github.susimsek.springbootjwedemo.security.CookieBearerTokenResolver
import io.github.susimsek.springbootjwedemo.security.KeyUtils
import org.springframework.context.annotation.Bean
import org.springframework.context.annotation.Configuration
import org.springframework.security.oauth2.jwt.JwtDecoder
import org.springframework.security.oauth2.jwt.JwtEncoder
import org.springframework.security.oauth2.jwt.NimbusJwtDecoder
import org.springframework.security.oauth2.jwt.NimbusJwtEncoder
import org.springframework.security.oauth2.server.resource.authentication.JwtAuthenticationConverter
import org.springframework.security.oauth2.server.resource.authentication.JwtGrantedAuthoritiesConverter
import org.springframework.security.oauth2.server.resource.web.BearerTokenResolver

@Configuration
class SecurityJwtConfig(private val props: JwtProperties) {

    @Bean
    @Throws(Exception::class)
    fun signingKey(): RSAKey =
        KeyUtils.buildRsaKey(
            props.signing.publicKey,
            props.signing.privateKey,
            props.signing.keyId,
            true
        )

    @Bean
    @Throws(Exception::class)
    fun encryptionKey(): RSAKey =
        KeyUtils.buildRsaKey(
            props.encryption.publicKey,
            props.encryption.privateKey,
            props.encryption.keyId,
            false
        )

    @Bean
    fun jwkSource(signingKey: RSAKey, encryptionKey: RSAKey): JWKSource&#x3C;SecurityContext> {
        val jwkSet = JWKSet(listOf(signingKey, encryptionKey))
        return JWKSource { jwkSelector, context -> jwkSelector.select(jwkSet) }
    }

    @Bean
    fun jwtDecoder(jwkSource: JWKSource&#x3C;SecurityContext>): JwtDecoder {
        val jwtProcessor = DefaultJWTProcessor&#x3C;SecurityContext>()
        val jweKeySelector = JWEDecryptionKeySelector(
            JWEAlgorithm.RSA_OAEP_256,
            EncryptionMethod.A128GCM,
            jwkSource
        )
        jwtProcessor.jweKeySelector = jweKeySelector
        val jwsKeySelector = JWSVerificationKeySelector(
            JWSAlgorithm.RS256,
            jwkSource
        )
        jwtProcessor.jwsKeySelector = jwsKeySelector
        jwtProcessor.jwtClaimsSetVerifier = { _, _ -> }
        return NimbusJwtDecoder(jwtProcessor)
    }

    @Bean
    fun jwtEncoder(jwkSource: JWKSource&#x3C;SecurityContext>): JwtEncoder =
        NimbusJwtEncoder(jwkSource)

    @Bean
    fun jwtAuthenticationConverter(): JwtAuthenticationConverter {
        val converter = JwtGrantedAuthoritiesConverter().apply {
            setAuthorityPrefix("")
            setAuthoritiesClaimName(AUTHORITIES_KEY)
        }
        return JwtAuthenticationConverter().apply {
            setJwtGrantedAuthoritiesConverter(converter)
        }
    }

    @Bean
    fun bearerTokenResolver(): BearerTokenResolver =
        CookieBearerTokenResolver().apply {
            setAllowUriQueryParameter(false)
            setAllowFormEncodedBodyParameter(false)
            setAllowCookie(true)
        }
}
</code></pre>
<p>SecurityConfig</p>
<h3>Java</h3>
<pre><code class="language-java">package io.github.susimsek.springbootjwedemo.config;

import io.github.susimsek.springbootjwedemo.security.AuthoritiesConstants;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.security.authentication.AuthenticationManager;
import org.springframework.security.authentication.ProviderManager;
import org.springframework.security.authentication.dao.DaoAuthenticationProvider;
import org.springframework.security.config.annotation.method.configuration.EnableMethodSecurity;
import org.springframework.security.config.annotation.web.builders.HttpSecurity;
import org.springframework.security.config.annotation.web.configurers.AbstractHttpConfigurer;
import org.springframework.security.config.http.SessionCreationPolicy;
import org.springframework.security.core.userdetails.User;
import org.springframework.security.core.userdetails.UserDetailsService;
import org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder;
import org.springframework.security.crypto.password.PasswordEncoder;
import org.springframework.security.provisioning.InMemoryUserDetailsManager;
import org.springframework.security.web.SecurityFilterChain;
import org.springframework.security.web.servlet.util.matcher.MvcRequestMatcher;
import org.springframework.web.servlet.handler.HandlerMappingIntrospector;

import static org.springframework.security.config.Customizer.withDefaults;

@Configuration
@EnableMethodSecurity(securedEnabled = true)
public class SecurityConfig {

    @Bean
    public InMemoryUserDetailsManager userDetailsService(AdminProperties adminProps,
                                                         UserProperties userProps,
                                                         PasswordEncoder passwordEncoder) {
        var admin = User.withUsername(adminProps.getUsername())
            .password(passwordEncoder.encode(adminProps.getPassword()))
            .authorities(AuthoritiesConstants.ADMIN)
            .build();

        var user = User.withUsername(userProps.getUsername())
            .password(passwordEncoder.encode(userProps.getPassword()))
            .authorities(AuthoritiesConstants.USER)
            .build();

        return new InMemoryUserDetailsManager(admin, user);
    }

    @Bean public PasswordEncoder passwordEncoder() { return new BCryptPasswordEncoder(); }

    @Bean
    public AuthenticationManager authenticationManager(UserDetailsService uds) {
        var provider = new DaoAuthenticationProvider();
        provider.setUserDetailsService(uds);
        provider.setPasswordEncoder(passwordEncoder());
        return new ProviderManager(provider);
    }

    @Bean
    public SecurityFilterChain filterChain(HttpSecurity http,
                                           MvcRequestMatcher.Builder mvc) throws Exception {
        http
            .cors(withDefaults())
            .csrf(AbstractHttpConfigurer::disable)
            .authorizeHttpRequests(authz ->
                authz
                    .requestMatchers(mvc.pattern("/*.ico"), mvc.pattern("/*.png"), mvc.pattern("/*.svg"),
                        mvc.pattern("/*.webapp")
                    ).permitAll()
                    .requestMatchers("/actuator/**").permitAll()
                    .requestMatchers(
                        "/v3/api-docs/**",
                        "/swagger-ui.html",
                        "/swagger-ui/**"
                    ).permitAll()
                    .requestMatchers(mvc.pattern("/api/auth/login")).permitAll()
                    .requestMatchers(mvc.pattern("/api/hello/admin")).hasAuthority(AuthoritiesConstants.ADMIN)
                .anyRequest().authenticated()
            )
            .sessionManagement(session ->
                session.sessionCreationPolicy(SessionCreationPolicy.STATELESS))
            .oauth2ResourceServer(oauth2 -> oauth2
                .jwt(withDefaults())
            );
        return http.build();
    }

    @Bean
    public MvcRequestMatcher.Builder mvc(HandlerMappingIntrospector introspector) {
        return new MvcRequestMatcher.Builder(introspector);
    }
}
</code></pre>
<h3>Kotlin</h3>
<pre><code class="language-kotlin">package io.github.susimsek.springbootjwedemo.config

import io.github.susimsek.springbootjwedemo.security.AuthoritiesConstants
import org.springframework.context.annotation.Bean
import org.springframework.context.annotation.Configuration
import org.springframework.security.authentication.AuthenticationManager
import org.springframework.security.authentication.ProviderManager
import org.springframework.security.authentication.dao.DaoAuthenticationProvider
import org.springframework.security.config.annotation.method.configuration.EnableMethodSecurity
import org.springframework.security.config.annotation.web.builders.HttpSecurity
import org.springframework.security.config.http.SessionCreationPolicy
import org.springframework.security.core.userdetails.User
import org.springframework.security.core.userdetails.UserDetailsService
import org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder
import org.springframework.security.crypto.password.PasswordEncoder
import org.springframework.security.provisioning.InMemoryUserDetailsManager
import org.springframework.security.web.SecurityFilterChain
import org.springframework.security.web.servlet.util.matcher.MvcRequestMatcher
import org.springframework.web.servlet.handler.HandlerMappingIntrospector
import org.springframework.security.config.Customizer.withDefaults

@Configuration
@EnableMethodSecurity(securedEnabled = true)
class SecurityConfig {

    @Bean
    fun userDetailsService(
        adminProps: AdminProperties,
        userProps: UserProperties,
        passwordEncoder: PasswordEncoder
    ): UserDetailsService {
        val admin = User.withUsername(adminProps.username)
            .password(passwordEncoder.encode(adminProps.password))
            .authorities(AuthoritiesConstants.ADMIN)
            .build()
        val user = User.withUsername(userProps.username)
            .password(passwordEncoder.encode(userProps.password))
            .authorities(AuthoritiesConstants.USER)
            .build()
        return InMemoryUserDetailsManager(admin, user)
    }

    @Bean
    fun passwordEncoder(): PasswordEncoder = BCryptPasswordEncoder()

    @Bean
    fun authenticationManager(uds: UserDetailsService): AuthenticationManager {
        val provider = DaoAuthenticationProvider().apply {
            setUserDetailsService(uds)
            setPasswordEncoder(passwordEncoder())
        }
        return ProviderManager(provider)
    }

    @Bean
    fun filterChain(http: HttpSecurity, mvc: MvcRequestMatcher.Builder): SecurityFilterChain =
        http.cors(withDefaults())
            .csrf { it.disable() }
            .authorizeHttpRequests { authz ->
                authz
                    .requestMatchers(mvc.pattern("/*.ico"), mvc.pattern("/*.png"), mvc.pattern("/*.svg"), mvc.pattern("/*.webapp")).permitAll()
                    .requestMatchers("/actuator/**").permitAll()
                    .requestMatchers("/v3/api-docs/**", "/swagger-ui.html", "/swagger-ui/**").permitAll()
                    .requestMatchers(mvc.pattern("/api/auth/login")).permitAll()
                    .requestMatchers(mvc.pattern("/api/hello/admin")).hasAuthority(AuthoritiesConstants.ADMIN)
                    .anyRequest().authenticated()
            }
            .sessionManagement { it.sessionCreationPolicy(SessionCreationPolicy.STATELESS) }
            .oauth2ResourceServer { it.jwt(withDefaults()) }
            .build()

    @Bean
    fun mvc(introspector: HandlerMappingIntrospector): MvcRequestMatcher.Builder =
        MvcRequestMatcher.Builder(introspector)
}
</code></pre>
<p>JwtProperties</p>
<h3>Java</h3>
<pre><code class="language-java">package io.github.susimsek.springbootjwedemo.config;

import lombok.Data;
import org.springframework.boot.context.properties.ConfigurationProperties;
import org.springframework.context.annotation.Configuration;

import java.time.Duration;

@Configuration
@ConfigurationProperties(prefix = "security.jwt")
@Data
public class JwtProperties {

    @Data
    public static class Pair {
        private String publicKey;
        private String privateKey;
        private String keyId;
    }

    private Pair signing;
    private Pair encryption;
    private String issuer;
    private Duration expirationDuration;
}
</code></pre>
<h3>Kotlin</h3>
<pre><code class="language-kotlin">package io.github.susimsek.springbootjwedemo.config

import org.springframework.boot.context.properties.ConfigurationProperties
import org.springframework.context.annotation.Configuration
import java.time.Duration

@Configuration
@ConfigurationProperties(prefix = "security.jwt")
class JwtProperties {

  class Pair {
    lateinit var publicKey: String
    lateinit var privateKey: String
    lateinit var keyId: String
  }

  lateinit var signing: Pair
  lateinit var encryption: Pair
  lateinit var issuer: String
  lateinit var expirationDuration: Duration
}
</code></pre>
<p>UserProperties</p>
<h3>Java</h3>
<pre><code class="language-java">package io.github.susimsek.springbootjwedemo.config;

import lombok.Data;
import org.springframework.boot.context.properties.ConfigurationProperties;
import org.springframework.context.annotation.Configuration;

@Configuration
@ConfigurationProperties(prefix = "security.user")
@Data
public class UserProperties {
    private String username;
    private String password;
}
</code></pre>
<h3>Kotlin</h3>
<pre><code class="language-kotlin">package io.github.susimsek.springbootjwedemo.config

import org.springframework.boot.context.properties.ConfigurationProperties
import org.springframework.context.annotation.Configuration

@Configuration
@ConfigurationProperties(prefix = "security.user")
class UserProperties {
  lateinit var username: String
  lateinit var password: String
}
</code></pre>
<hr>
<h2>ğŸ› ï¸ AdÄ±m 4: GÃ¼venli JWE Token YardÄ±mcÄ± SÄ±nÄ±flarÄ± OluÅŸturun</h2>
<p>Bu bÃ¶lÃ¼mde, Spring Boot uygulamanÄ±zda JSON Web Encryption (JWE) tokenlarÄ± oluÅŸturmak, ÅŸifrelemek ve Ã§Ã¶zmek iÃ§in gereken temel yardÄ±mcÄ± sÄ±nÄ±flarÄ± ve sabitleri tanÄ±mlÄ±yoruz. Bu bileÅŸenler ÅŸunlarÄ± saÄŸlar:</p>
<ul>
<li>AuthoritiesConstants: <code>ROLE_</code> Ã¶n ekiyle rol isimlerini merkezileÅŸtirir.</li>
<li>CookieBearerTokenResolver: Bearer tokenâ€™larÄ± yetkilendirme baÅŸlÄ±klarÄ±ndan veya HTTP Ã§erezlerinden Ã§Ã¶zer.</li>
<li>CookieUtils: EriÅŸim tokenâ€™larÄ± iÃ§in HTTP-only ve secure Ã§erezler oluÅŸturur.</li>
<li>JweUtil: Nimbus kÃ¼tÃ¼phanesi ile RSA anahtarlarÄ± kullanarak JWTâ€™leri imzalar (JWS) ve ÅŸifreler (JWE).</li>
<li>KeyUtils: PEM formatÄ±ndaki anahtar Ã§iftinden RSA JWKâ€™leri oluÅŸturur.</li>
<li>SecurityUtils: SecurityContext oturum aÃ§an kullanÄ±cÄ±nÄ±n bilgisini sunar.</li>
</ul>
<p>Bu yardÄ±mcÄ±lar, Spring Security ile durumsuz (stateless) JWE tabanlÄ± bir kimlik doÄŸrulama akÄ±ÅŸÄ±nÄ±n temelini oluÅŸturur.</p>
<p>AuthoritiesConstants</p>
<h3>Java</h3>
<pre><code class="language-java">
package io.github.susimsek.springbootjwedemo.security;

import lombok.AccessLevel;
import lombok.NoArgsConstructor;

@NoArgsConstructor(access = AccessLevel.PRIVATE)
public final class AuthoritiesConstants {
    public static final String ADMIN = "ROLE_ADMIN";
    public static final String USER = "ROLE_USER";
    public static final String ANONYMOUS = "ROLE_ANONYMOUS";
}
</code></pre>
<h3>Kotlin</h3>
<pre><code class="language-kotlin">
package io.github.susimsek.springbootjwedemo.security

object AuthoritiesConstants {
  const val ADMIN = "ROLE_ADMIN"
  const val USER = "ROLE_USER"
  const val ANONYMOUS = "ROLE_ANONYMOUS"
}
</code></pre>
<p>CookieBearerTokenResolver</p>
<h3>Java</h3>
<pre><code class="language-java">package io.github.susimsek.springbootjwedemo.security;

import jakarta.servlet.http.Cookie;
import jakarta.servlet.http.HttpServletRequest;
import lombok.Setter;
import org.springframework.http.HttpMethod;
import org.springframework.security.oauth2.core.OAuth2AuthenticationException;
import org.springframework.security.oauth2.server.resource.BearerTokenError;
import org.springframework.security.oauth2.server.resource.BearerTokenErrors;
import org.springframework.security.oauth2.server.resource.web.BearerTokenResolver;
import org.springframework.util.StringUtils;

import java.util.regex.Matcher;
import java.util.regex.Pattern;

@Setter
public class CookieBearerTokenResolver implements BearerTokenResolver {
    private static final String ACCESS_TOKEN_PARAMETER_NAME = "access_token";
    private static final Pattern AUTHORIZATION_PATTERN =
        Pattern.compile("^Bearer (?&#x3C;token>[A-Za-z0-9-._~+/]+=*)$", Pattern.CASE_INSENSITIVE);

    private boolean allowFormEncodedBodyParameter = false;
    private boolean allowUriQueryParameter       = false;
    private boolean allowCookie                  = true;
    private String  bearerTokenHeaderName       = "Authorization";
    private String  cookieName                  = "accessToken";

    @Override
    public String resolve(HttpServletRequest request) {
        String headerToken = resolveFromAuthorizationHeader(request);
        String queryToken  = resolveAccessTokenFromQueryString(request);
        String bodyToken   = resolveAccessTokenFromBody(request);
        String cookieToken = (headerToken == null &#x26;&#x26; queryToken == null &#x26;&#x26; bodyToken == null)
            ? resolveFromCookie(request)
            : null;

        return resolveToken(headerToken, queryToken, bodyToken, cookieToken);
    }

    private String resolveFromAuthorizationHeader(HttpServletRequest request) {
        String authorization = request.getHeader(this.bearerTokenHeaderName);
        if (!StringUtils.hasText(authorization) || !authorization.toLowerCase().startsWith("bearer")) {
            return null;
        }
        Matcher matcher = AUTHORIZATION_PATTERN.matcher(authorization.trim());
        if (!matcher.matches()) {
            BearerTokenError error = BearerTokenErrors.invalidToken("Bearer token is malformed");
            throw new OAuth2AuthenticationException(error);
        }
        return matcher.group("token");
    }

    private String resolveAccessTokenFromQueryString(HttpServletRequest request) {
        if (allowUriQueryParameter &#x26;&#x26; HttpMethod.GET.matches(request.getMethod())) {
            return resolveToken(request.getParameterValues(ACCESS_TOKEN_PARAMETER_NAME));
        }
        return null;
    }

    private String resolveAccessTokenFromBody(HttpServletRequest request) {
        if (allowFormEncodedBodyParameter
            &#x26;&#x26; HttpMethod.POST.matches(request.getMethod())
            &#x26;&#x26; "application/x-www-form-urlencoded".equals(request.getContentType())) {
            return resolveToken(request.getParameterValues(ACCESS_TOKEN_PARAMETER_NAME));
        }
        return null;
    }

    private String resolveFromCookie(HttpServletRequest request) {
        if (!allowCookie || request.getCookies() == null) {
            return null;
        }
        for (Cookie cookie : request.getCookies()) {
            if (cookieName.equals(cookie.getName())) {
                String val = cookie.getValue();
                return StringUtils.hasText(val) ? val : null;
            }
        }
        return null;
    }

    private String resolveToken(String... tokens) {
        String found = null;
        for (String token : tokens) {
            if (token == null) continue;
            if (found != null) {
                BearerTokenError error = BearerTokenErrors.invalidRequest("Found multiple bearer tokens in the request");
                throw new OAuth2AuthenticationException(error);
            }
            found = token;
        }
        if (found != null &#x26;&#x26; found.isBlank()) {
            BearerTokenError error = BearerTokenErrors.invalidRequest("The requested token parameter is an empty string");
            throw new OAuth2AuthenticationException(error);
        }
        return found;
    }
</code></pre>
<h3>Kotlin</h3>
<pre><code class="language-kotlin">package io.github.susimsek.springbootjwedemo.security

import jakarta.servlet.http.Cookie
import jakarta.servlet.http.HttpServletRequest
import org.springframework.http.HttpMethod
import org.springframework.security.oauth2.core.OAuth2AuthenticationException
import org.springframework.security.oauth2.server.resource.BearerTokenError
import org.springframework.security.oauth2.server.resource.BearerTokenErrors
import org.springframework.security.oauth2.server.resource.web.BearerTokenResolver
import org.springframework.util.StringUtils
import java.util.regex.Pattern

class CookieBearerTokenResolver {
    var allowFormEncodedBodyParameter: Boolean = false
    var allowUriQueryParameter: Boolean = false
    var allowCookie: Boolean = true
    var bearerTokenHeaderName: String = "Authorization"
    var cookieName: String = "accessToken"

    companion object {
        private const val ACCESS_TOKEN_PARAMETER_NAME = "access_token"
        private val AUTHORIZATION_PATTERN =
            Pattern.compile("^Bearer (?&#x3C;token>[A-Za-z0-9-._~+/]+=*)$", Pattern.CASE_INSENSITIVE)
    }

    fun resolve(request: HttpServletRequest): String? {
        val header = resolveFromAuthorizationHeader(request)
        val query  = if (allowUriQueryParameter &#x26;&#x26; HttpMethod.GET.matches(request.method))
            request.getParameterValues(ACCESS_TOKEN_PARAMETER_NAME)?.let(::resolveToken)
        else null
        val body   = if (allowFormEncodedBodyParameter &#x26;&#x26; HttpMethod.POST.matches(request.method)
            &#x26;&#x26; request.contentType == "application/x-www-form-urlencoded")
            request.getParameterValues(ACCESS_TOKEN_PARAMETER_NAME)?.let(::resolveToken)
        else null
        val cookie = if (header == null &#x26;&#x26; query == null &#x26;&#x26; body == null)
            resolveFromCookie(request)
        else null
        return listOf(header, query, body, cookie).filterNotNull().let {
            if (it.size > 1) throw OAuth2AuthenticationException(BearerTokenErrors.invalidRequest("Found multiple bearer tokens"))
            it.firstOrNull()?: null
        }
    }

    private fun resolveFromAuthorizationHeader(request: HttpServletRequest): String? {
        val auth = request.getHeader(bearerTokenHeaderName) ?: return null
        if (!auth.startsWith("Bearer ", true)) return null
        val matcher = AUTHORIZATION_PATTERN.matcher(auth.trim())
        return if (matcher.matches()) matcher.group("token")
        else throw OAuth2AuthenticationException(BearerTokenErrors.invalidToken("Malformed token"))
    }

    private fun resolveFromCookie(request: HttpServletRequest): String? {
        if (!allowCookie) return null
        return request.cookies?.firstOrNull { it.name == cookieName }?.value?.takeIf { it.isNotBlank() }
    }

    private fun resolveToken(tokens: Array&#x3C;String>): String? {
        return tokens.filter { it.isNotBlank() }.let {
            when {
                it.isEmpty() -> null
                it.size > 1   -> throw OAuth2AuthenticationException(BearerTokenErrors.invalidRequest("Multiple tokens"))
                else          -> it[0]
            }
        }
    }
</code></pre>
<p>CookieUtils</p>
<h3>Java</h3>
<pre><code class="language-java">package io.github.susimsek.springbootjwedemo.security;

import io.github.susimsek.springbootjwedemo.dto.TokenDTO;
import lombok.experimental.UtilityClass;
import org.springframework.http.ResponseCookie;

@UtilityClass
public class CookieUtils {

    private static final String COOKIE_NAME = "accessToken";

    public ResponseCookie createAccessTokenCookie(TokenDTO tokenDto) {
        return ResponseCookie.from(COOKIE_NAME, tokenDto.accessToken())
            .httpOnly(true)
            .secure(true)
            .path("/")
            .maxAge(tokenDto.accessTokenExpiresIn())
            .sameSite("Strict")
            .build();
    }
}
</code></pre>
<h3>Kotlin</h3>
<pre><code class="language-kotlin">package io.github.susimsek.springbootjwedemo.security

import io.github.susimsek.springbootjwedemo.dto.TokenDTO
import org.springframework.http.ResponseCookie

object CookieUtils {

  private const val COOKIE_NAME = "accessToken"

  fun createAccessTokenCookie(tokenDto: TokenDTO): ResponseCookie {
    return ResponseCookie.from(COOKIE_NAME, tokenDto.accessToken())
      .httpOnly(true)
      .secure(true)
      .path("/")
      .maxAge(tokenDto.accessTokenExpiresIn())
      .sameSite("Strict")
      .build()
  }
}
</code></pre>
<p>JweUtil</p>
<h3>Java</h3>
<pre><code class="language-java">package io.github.susimsek.springbootjwedemo.security;

import com.nimbusds.jose.EncryptionMethod;
import com.nimbusds.jose.JOSEException;
import com.nimbusds.jose.JWEAlgorithm;
import com.nimbusds.jose.JWEHeader;
import com.nimbusds.jose.JWEObject;
import com.nimbusds.jose.Payload;
import com.nimbusds.jose.crypto.RSAEncrypter;
import com.nimbusds.jose.jwk.RSAKey;
import io.github.susimsek.springbootjwedemo.config.JwtProperties;
import io.github.susimsek.springbootjwedemo.dto.TokenDTO;
import lombok.RequiredArgsConstructor;
import org.springframework.security.core.Authentication;
import org.springframework.security.core.GrantedAuthority;
import org.springframework.security.oauth2.jose.jws.SignatureAlgorithm;
import org.springframework.security.oauth2.jwt.*;
import org.springframework.stereotype.Component;

import java.time.Instant;
import java.util.List;

import static io.github.susimsek.springbootjwedemo.security.SecurityUtils.AUTHORITIES_KEY;

@Component
@RequiredArgsConstructor
public class JweUtil {

    private final JwtEncoder jwtEncoder;
    private final RSAKey signingKey;
    private final RSAKey encryptionKey;
    private final JwtProperties props;

    public TokenDTO generateToken(Authentication authentication) throws JOSEException {
        String subject = authentication.getName();
        List&#x3C;String> roles = authentication.getAuthorities()
            .stream()
            .map(GrantedAuthority::getAuthority)
            .toList();

        Instant now = Instant.now();
        long expiresIn = props.getExpirationDuration().getSeconds();
        Instant exp = now.plusSeconds(expiresIn);

        JwtClaimsSet claims = JwtClaimsSet.builder()
            .issuer(props.getIssuer())
            .issuedAt(now)
            .expiresAt(exp)
            .subject(subject)
            .claim(AUTHORITIES_KEY, roles)
            .build();

        JwsHeader jwsHeader = JwsHeader.with(SignatureAlgorithm.RS256)
            .keyId(signingKey.getKeyID())
            .build();

        String jws = jwtEncoder
            .encode(JwtEncoderParameters.from(jwsHeader, claims))
            .getTokenValue();

        JWEHeader jweHeader = new JWEHeader.Builder(JWEAlgorithm.RSA_OAEP_256, EncryptionMethod.A128GCM)
            .contentType("JWT")
            .keyID(encryptionKey.getKeyID())
            .build();

        JWEObject jweObject = new JWEObject(jweHeader, new Payload(jws));
        jweObject.encrypt(new RSAEncrypter(encryptionKey.toRSAPublicKey()));
        String token = jweObject.serialize();

        return new TokenDTO(token, "Bearer", expiresIn);
    }
}
</code></pre>
<h3>Kotlin</h3>
<pre><code class="language-kotlin">package io.github.susimsek.springbootjwedemo.security

import com.nimbusds.jose.EncryptionMethod
import com.nimbusds.jose.JOSEException
import com.nimbusds.jose.JWEAlgorithm
import com.nimbusds.jose.JWEHeader
import com.nimbusds.jose.JWEObject
import com.nimbusds.jose.Payload
import com.nimbusds.jose.crypto.RSAEncrypter
import com.nimbusds.jose.jwk.RSAKey
import io.github.susimsek.springbootjwedemo.config.JwtProperties
import io.github.susimsek.springbootjwedemo.dto.TokenDTO
import lombok.RequiredArgsConstructor
import org.springframework.security.core.Authentication
import org.springframework.security.oauth2.jose.jws.SignatureAlgorithm
import org.springframework.security.oauth2.jwt.JwtClaimsSet
import org.springframework.security.oauth2.jwt.JwtEncoder
import org.springframework.security.oauth2.jwt.JwtEncoderParameters
import org.springframework.stereotype.Component

import java.time.Instant

@Component
@RequiredArgsConstructor
class JweUtil(
    private val jwtEncoder: JwtEncoder,
    private val signingKey: RSAKey,
    private val encryptionKey: RSAKey,
    private val props: JwtProperties
) {
    fun generateToken(authentication: Authentication): TokenDTO {
        val subject = authentication.name
        val roles = authentication.authorities.map { it.authority }

        val now = Instant.now()
        val expiresIn = props.expirationDuration.seconds
        val exp = now.plusSeconds(expiresIn)

        val claims = JwtClaimsSet.builder()
            .issuer(props.issuer)
            .issuedAt(now)
            .expiresAt(exp)
            .subject(subject)
            .claim(AUTHORITIES_KEY, roles)
            .build()

        val jwsHeader = org.springframework.security.oauth2.jwt.JwsHeader.with(SignatureAlgorithm.RS256)
            .keyId(signingKey.keyID)
            .build()

        val jws = jwtEncoder
            .encode(JwtEncoderParameters.from(jwsHeader, claims))
            .tokenValue

        val jweHeader = JWEHeader.Builder(JWEAlgorithm.RSA_OAEP_256, EncryptionMethod.A128GCM)
            .contentType("JWT")
            .keyID(encryptionKey.keyID)
            .build()

        val jweObject = JWEObject(jweHeader, Payload(jws))
        jweObject.encrypt(RSAEncrypter(encryptionKey.toRSAPublicKey()))
        val token = jweObject.serialize()

        return TokenDTO(token, "Bearer", expiresIn)
    }
}
</code></pre>
<p>KeyUtils</p>
<h3>Java</h3>
<pre><code class="language-java">package io.github.susimsek.springbootjwedemo.security;

import com.nimbusds.jose.JWEAlgorithm;
import com.nimbusds.jose.JWSAlgorithm;
import com.nimbusds.jose.jwk.KeyUse;
import com.nimbusds.jose.jwk.RSAKey;
import lombok.experimental.UtilityClass;

import java.security.KeyFactory;
import java.security.interfaces.RSAPrivateKey;
import java.security.interfaces.RSAPublicKey;
import java.security.spec.PKCS8EncodedKeySpec;
import java.security.spec.X509EncodedKeySpec;
import java.util.Base64;

@UtilityClass
public class KeyUtils {
    public RSAKey buildRsaKey(
            String pubPem,
            String privPem,
            String kid,
            boolean forSign
    ) throws Exception {
        String pubContent = pubPem
            .replace("-----BEGIN PUBLIC KEY-----", "")
            .replace("-----END PUBLIC KEY-----", "")
            .replaceAll("\\s", "");
        String privContent = privPem
            .replace("-----BEGIN PRIVATE KEY-----", "")
            .replace("-----END PRIVATE KEY-----", "")
            .replaceAll("\\s", "");

        byte[] decodedPub = Base64.getDecoder().decode(pubContent);
        byte[] decodedPriv = Base64.getDecoder().decode(privContent);

        KeyFactory kf = KeyFactory.getInstance("RSA");
        RSAPublicKey publicKey = (RSAPublicKey) kf.generatePublic(new X509EncodedKeySpec(decodedPub));
        RSAPrivateKey privateKey = (RSAPrivateKey) kf.generatePrivate(new PKCS8EncodedKeySpec(decodedPriv));

        RSAKey.Builder builder = new RSAKey.Builder(publicKey)
            .privateKey(privateKey)
            .keyID(kid);

        if (forSign) {
            builder
                .algorithm(JWSAlgorithm.RS256)
                .keyUse(KeyUse.SIGNATURE);
        } else {
            builder
                .algorithm(JWEAlgorithm.RSA_OAEP_256)
                .keyUse(KeyUse.ENCRYPTION);
        }

        return builder.build();
    }
}
</code></pre>
<h3>Kotlin</h3>
<pre><code class="language-kotlin">package io.github.susimsek.springbootjwedemo.security

import com.nimbusds.jose.JWEAlgorithm
import com.nimbusds.jose.JWSAlgorithm
import com.nimbusds.jose.jwk.KeyUse
import com.nimbusds.jose.jwk.RSAKey
import java.security.KeyFactory
import java.security.interfaces.RSAPrivateKey
import java.security.interfaces.RSAPublicKey
import java.security.spec.PKCS8EncodedKeySpec
import java.security.spec.X509EncodedKeySpec
import java.util.Base64

object KeyUtils {
    @JvmStatic
    @Throws(Exception::class)
    fun buildRsaKey(
        pubPem: String,
        privPem: String,
        kid: String,
        forSign: Boolean
    ): RSAKey {
        val pubContent = pubPem
            .replace("-----BEGIN PUBLIC KEY-----", "")
            .replace("-----END PUBLIC KEY-----", "")
            .replace(Regex("\\s"), "")
        val privContent = privPem
            .replace("-----BEGIN PRIVATE KEY-----", "")
            .replace("-----END PRIVATE KEY-----", "")
            .replace(Regex("\\s"), "")

        val decodedPub = Base64.getDecoder().decode(pubContent)
        val decodedPriv = Base64.getDecoder().decode(privContent)

        val kf = KeyFactory.getInstance("RSA")
        val publicKey = kf.generatePublic(X509EncodedKeySpec(decodedPub)) as RSAPublicKey
        val privateKey = kf.generatePrivate(PKCS8EncodedKeySpec(decodedPriv)) as RSAPrivateKey

        val builder = RSAKey.Builder(publicKey)
            .privateKey(privateKey)
            .keyID(kid)

        if (forSign) {
            builder
                .algorithm(JWSAlgorithm.RS256)
                .keyUse(KeyUse.SIGNATURE)
        } else {
            builder
                .algorithm(JWEAlgorithm.RSA_OAEP_256)
                .keyUse(KeyUse.ENCRYPTION)
        }

        return builder.build()
    }
}
</code></pre>
<p>SecurityUtils</p>
<h3>Java</h3>
<pre><code class="language-java">package io.github.susimsek.springbootjwedemo.security;

import lombok.experimental.UtilityClass;
import org.springframework.security.core.Authentication;
import org.springframework.security.core.context.SecurityContextHolder;
import org.springframework.security.core.userdetails.UserDetails;
import org.springframework.security.oauth2.jwt.Jwt;

import java.util.Optional;

@UtilityClass
public class SecurityUtils {

    public static final String AUTHORITIES_KEY = "auth";

    public Optional&#x3C;String> getCurrentUserLogin() {
        var ctx = SecurityContextHolder.getContext();
        return Optional.ofNullable(extractPrincipal(ctx.getAuthentication()));
    }

    private String extractPrincipal(Authentication authentication) {
        if (authentication == null) {
            return null;
        }
        Object principal = authentication.getPrincipal();
        if (principal instanceof Jwt jwt) {
            return jwt.getSubject();
        }
        if (principal instanceof UserDetails ud) {
            return ud.getUsername();
        }
        if (principal instanceof String username) {
            return username;
        }
        return null;
    }
}
</code></pre>
<h3>Kotlin</h3>
<pre><code class="language-kotlin">package io.github.susimsek.springbootjwedemo.security

import org.springframework.security.core.Authentication
import org.springframework.security.core.context.SecurityContextHolder
import org.springframework.security.core.userdetails.UserDetails
import org.springframework.security.oauth2.jwt.Jwt
import java.util.Optional

object SecurityUtils {
  const val AUTHORITIES_KEY = "auth"

  fun getCurrentUserLogin(): Optional&#x3C;String> {
    val authentication: Authentication? = SecurityContextHolder.getContext().authentication
    return Optional.ofNullable(extractPrincipal(authentication))
  }

  private fun extractPrincipal(authentication: Authentication?): String? {
    return when (val principal = authentication?.principal) {
      is Jwt -> principal.subject
      is UserDetails -> principal.username
      is String -> principal
      else -> null
    }
  }
}
</code></pre>
<hr>
<h2>ğŸ§ª AdÄ±m 5: Kimlik DoÄŸrulama ve GÃ¼venli Endpointler</h2>
<p>Bu bÃ¶lÃ¼mde, aÅŸaÄŸÄ±dakileri gerÃ§ekleÅŸtirmek iÃ§in gerekli REST controller ve DTOâ€™larÄ± tanÄ±mlÄ±yoruz:</p>
<ul>
<li>AuthController: KullanÄ±cÄ±larÄ± doÄŸrular, JWE tokenâ€™larÄ± oluÅŸturur ve gÃ¼venli cookie ayarlar.</li>
<li>HelloController: KimliÄŸi doÄŸrulanmÄ±ÅŸ kullanÄ±cÄ±lar ve yalnÄ±zca admine Ã¶zel pathler iÃ§in gÃ¼venli endpointler sunar.</li>
<li>LoginRequestDTO: Login isteÄŸi payloadÄ±nÄ± (kullanÄ±cÄ± adÄ±/parola) modelleyen DTO.</li>
<li>TokenDTO: Token ve geÃ§erlilik sÃ¼resini iÃ§eren kimlik doÄŸrulama yanÄ±tÄ±nÄ± modelleyen DTO.</li>
</ul>
<p>Bu bileÅŸenler, login iÅŸlemi, token oluÅŸturma, cookie yÃ¶netimi ve kaynak korumasÄ±nÄ± iÅŸleyerek stateless(durumsuz) kimlik doÄŸrulama akÄ±ÅŸÄ±nÄ± tamamlar.</p>
<p>Bu bÃ¶lÃ¼mde, kullanÄ±cÄ± kimlik doÄŸrulamasÄ±nÄ±, token oluÅŸturmayÄ± ve korunan kaynak eriÅŸimini yÃ¶netmek iÃ§in REST controller ve DTOâ€™larÄ± oluÅŸturuyoruz.</p>
<p>AuthController</p>
<h3>Java</h3>
<pre><code class="language-java">package io.github.susimsek.springbootjwedemo.controller;

import io.github.susimsek.springbootjwedemo.dto.LoginRequestDTO;
import io.github.susimsek.springbootjwedemo.dto.TokenDTO;
import io.github.susimsek.springbootjwedemo.security.CookieUtils;
import io.github.susimsek.springbootjwedemo.security.JweUtil;
import lombok.RequiredArgsConstructor;
import org.springframework.http.HttpHeaders;
import org.springframework.http.ResponseCookie;
import org.springframework.http.ResponseEntity;
import org.springframework.security.authentication.AuthenticationManager;
import org.springframework.security.authentication.UsernamePasswordAuthenticationToken;
import org.springframework.security.core.Authentication;
import org.springframework.security.core.context.SecurityContextHolder;
import org.springframework.web.bind.annotation.PostMapping;
import org.springframework.web.bind.annotation.RequestBody;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;

@RestController
@RequiredArgsConstructor
@RequestMapping("/api/auth")
public class AuthController {

    private final AuthenticationManager authenticationManager;
    private final JweUtil jweUtil;

    @PostMapping("/login")
    public ResponseEntity&#x3C;TokenDTO> login(@RequestBody LoginRequestDTO loginRequest) throws Exception {
        // Authenticate user
        var authToken = new UsernamePasswordAuthenticationToken(
            loginRequest.username(), loginRequest.password()
        );
        Authentication auth = authenticationManager.authenticate(authToken);
        SecurityContextHolder.getContext().setAuthentication(auth);

        // Generate JWE token and cookie
        TokenDTO tokenDto = jweUtil.generateToken(auth);
        ResponseCookie cookie = CookieUtils.createAccessTokenCookie(tokenDto);

        return ResponseEntity.ok()
            .header(HttpHeaders.SET_COOKIE, cookie.toString())
            .body(tokenDto);
    }
}
</code></pre>
<h3>Kotlin</h3>
<pre><code class="language-kotlin">package io.github.susimsek.springbootjwedemo.controller

import io.github.susimsek.springbootjwedemo.dto.LoginRequestDTO
import io.github.susimsek.springbootjwedemo.dto.TokenDTO
import io.github.susimsek.springbootjwedemo.security.CookieUtils
import io.github.susimsek.springbootjwedemo.security.JweUtil
import lombok.RequiredArgsConstructor
import org.springframework.http.HttpHeaders
import org.springframework.http.ResponseCookie
import org.springframework.http.ResponseEntity
import org.springframework.security.authentication.AuthenticationManager
import org.springframework.security.authentication.UsernamePasswordAuthenticationToken
import org.springframework.security.core.Authentication
import org.springframework.security.core.context.SecurityContextHolder
import org.springframework.web.bind.annotation.PostMapping
import org.springframework.web.bind.annotation.RequestBody
import org.springframework.web.bind.annotation.RequestMapping
import org.springframework.web.bind.annotation.RestController

@RestController
@RequiredArgsConstructor
@RequestMapping("/api/auth")
class AuthController(
    private val authenticationManager: AuthenticationManager,
    private val jweUtil: JweUtil
) {

    @PostMapping("/login")
    fun login(@RequestBody loginRequest: LoginRequestDTO): ResponseEntity&#x3C;TokenDTO> {
        val authToken = UsernamePasswordAuthenticationToken(
            loginRequest.username, loginRequest.password
        )
        val auth: Authentication = authenticationManager.authenticate(authToken)
        SecurityContextHolder.getContext().authentication = auth

        val tokenDto: TokenDTO = jweUtil.generateToken(auth)
        val cookie: ResponseCookie = CookieUtils.createAccessTokenCookie(tokenDto)

        return ResponseEntity.ok()
            .header(HttpHeaders.SET_COOKIE, cookie.toString())
            .body(tokenDto)
    }
}
</code></pre>
<p>HelloController</p>
<h3>Java</h3>
<pre><code class="language-java">package io.github.susimsek.springbootjwedemo.controller;

import org.springframework.security.core.annotation.AuthenticationPrincipal;
import org.springframework.security.oauth2.jwt.Jwt;
import org.springframework.web.bind.annotation.*;

import static io.github.susimsek.springbootjwedemo.security.SecurityUtils.AUTHORITIES_KEY;

@RestController
@RequestMapping("/api/hello")
public class HelloController {

    @GetMapping
    public String helloAll(@AuthenticationPrincipal Jwt jwt) {
        String user = jwt.getSubject();
        var roles = jwt.getClaimAsStringList(AUTHORITIES_KEY);
        return "Hello, " + user + "! Your roles: " + roles;
    }

    @GetMapping("/admin")
    public String helloAdmin(@AuthenticationPrincipal Jwt jwt) {
        return "Hello Admin, " + jwt.getSubject() + "!";
    }
}
</code></pre>
<h3>Kotlin</h3>
<pre><code class="language-kotlin">package io.github.susimsek.springbootjwedemo.controller

import org.springframework.security.core.annotation.AuthenticationPrincipal
import org.springframework.security.oauth2.jwt.Jwt
import org.springframework.web.bind.annotation.*

import io.github.susimsek.springbootjwedemo.security.SecurityUtils.AUTHORITIES_KEY

@RestController
@RequestMapping("/api/hello")
class HelloController {

    @GetMapping
    fun helloAll(@AuthenticationPrincipal jwt: Jwt): String {
        val user = jwt.subject
        val roles = jwt.getClaimAsStringList(AUTHORITIES_KEY)
        return "Hello, \$user! Your roles: \$roles"
    }

    @GetMapping("/admin")
    fun helloAdmin(@AuthenticationPrincipal jwt: Jwt): String {
        return "Hello Admin, \${jwt.subject}!"
    }
}
</code></pre>
<p>LoginRequestDTO</p>
<h3>Java</h3>
<pre><code class="language-java">package io.github.susimsek.springbootjwedemo.dto;

public record LoginRequestDTO(
    String username,
    String password
) { }
</code></pre>
<h3>Kotlin</h3>
<pre><code class="language-kotlin">package io.github.susimsek.springbootjwedemo.dto

data class LoginRequestDTO(
    val username: String,
    val password: String
)
</code></pre>
<p>TokenDTO</p>
<h3>Java</h3>
<pre><code class="language-java">package io.github.susimsek.springbootjwedemo.dto;

public record TokenDTO(
    String accessToken,
    String tokenType,
    long accessTokenExpiresIn
) {}
</code></pre>
<h3>Kotlin</h3>
<pre><code class="language-kotlin">package io.github.susimsek.springbootjwedemo.dto

import kotlin.Long

data class TokenDTO(
    val accessToken: String,
    val tokenType: String,
    val accessTokenExpiresIn: Long
)
</code></pre>
<hr>
<h2>â–¶ï¸ UygulamayÄ± Ã‡alÄ±ÅŸtÄ±r</h2>
<pre><code class="language-bash">./mvnw spring-boot:run
# or
gradle bootRun
</code></pre>
<hr>
<h2>ğŸ§ª Endpoint Testi</h2>
<p>Bu bÃ¶lÃ¼mde Endpoint Testi konusunu netleÅŸtirip uygulamada kullanacaÄŸÄ±nÄ±z temel noktalarÄ± Ã¶zetliyoruz.</p>
<h3>Admin AkÄ±ÅŸÄ±</h3>
<p>admin olarak giriÅŸ yapÄ±n ve <code>Set-Cookie</code> baÅŸlÄ±ÄŸÄ±ndan JWE tokeni yakalayÄ±n:</p>
<pre><code class="language-bash">curl -i -X POST http://localhost:8080/api/auth/login \
  -H "Content-Type: application/json" \
  -d '{"username":"admin","password":"adminpass"}'
</code></pre>
<ul>
<li>Set-Cookie baÅŸlÄ±ÄŸÄ± <code>accessToken=&#x3C;jwe-token></code> iÃ§erir</li>
<li>YanÄ±t:</li>
</ul>
<pre><code class="language-json">{
  "accessToken": "&#x3C;jwe-token>",
  "tokenType": "Bearer",
  "accessTokenExpiresIn": 3600
}
</code></pre>
<p>cookie kullanarak <code>hello</code> endpointine eriÅŸin:</p>
<pre><code class="language-bash">curl -b "accessToken=&#x3C;jwe-token>" http://localhost:8080/api/hello
</code></pre>
<p>Veya Authorization baÅŸlÄ±ÄŸÄ±yla:</p>
<pre><code class="language-bash">curl -H "Authorization: Bearer &#x3C;jwe-token>" http://localhost:8080/api/hello
</code></pre>
<p>admin-Ã¶zel endpointine eriÅŸin:</p>
<pre><code class="language-bash">curl -H "Authorization: Bearer &#x3C;jwe-token>" http://localhost:8080/api/hello/admin
</code></pre>
<h3>KullanÄ±cÄ± AkÄ±ÅŸÄ±</h3>
<p>user olarak giriÅŸ yapÄ±n ve cookieâ€™den JWE tokeni yakalayÄ±n:</p>
<pre><code class="language-bash">curl -i -X POST http://localhost:8080/api/auth/login \
  -H "Content-Type: application/json" \
  -d '{"username":"user","password":"userpass"}'
</code></pre>
<ul>
<li>Set-Cookie baÅŸlÄ±ÄŸÄ± <code>accessToken=&#x3C;jwe-token></code> iÃ§erir</li>
</ul>
<p>cookie kullanarak <code>hello</code> endpointine eriÅŸin:</p>
<pre><code class="language-bash">curl -b "accessToken=&#x3C;jwe-token>" http://localhost:8080/api/hello
</code></pre>
<p>Authorization baÅŸlÄ±ÄŸÄ±yla:</p>
<pre><code class="language-bash">curl -H "Authorization: Bearer &#x3C;jwe-token>" http://localhost:8080/api/hello
</code></pre>
<p>Admin endpointini deneyince (403 Forbidden dÃ¶ner):</p>
<pre><code class="language-bash">curl -H "Authorization: Bearer &#x3C;jwe-token>" http://localhost:8080/api/hello/admin
# HTTP/1.1 403 Forbidden
</code></pre>
<hr>
<h2>ğŸ SonuÃ§</h2>
<p>ArtÄ±k Spring Boot JWE Kimlik DoÄŸrulama iÃ§in Ã¼retim odaklÄ± bir Spring Boot temeliniz var. Sonraki adÄ±mda ayarlarÄ± kendi domainine uyarlayÄ±p test ve gÃ¶zlemlenebilirlik katmanÄ±nÄ± ekleyerek gerÃ§ek trafik altÄ±nda doÄŸrulayÄ±n.</p>]]></content:encoded>
      <category><![CDATA[Java]]></category>
      <category><![CDATA[Kotlin]]></category>
      <category><![CDATA[Spring Boot]]></category>
      <category><![CDATA[GÃ¼venlik]]></category>
      <category><![CDATA[JWT]]></category>
      <category><![CDATA[JWE]]></category>
      <media:thumbnail url="https://suaybsimsek.com/images/spring-boot-jwe-auth-thumbnail.webp" />
    </item>
    <item>
      <title><![CDATA[Spring Boot HTTP Interface Client]]></title>
      <link>https://suaybsimsek.com/tr/posts/spring-boot-http-interface-client</link>
      <description><![CDATA[Deklaratif, tip gÃ¼venli HTTP Ã§aÄŸrÄ±larÄ± iÃ§in Spring Boot 3.2+ HTTP Interface Client nasÄ±l kullanÄ±lÄ±r Ã¶ÄŸrenin.]]></description>
      <pubDate>Sun, 27 Apr 2025 00:00:00 GMT</pubDate>
      <atom:updated>2025-04-28T00:00:00.000Z</atom:updated>
      <guid isPermaLink="true">https://suaybsimsek.com/tr/posts/spring-boot-http-interface-client</guid>
      <content:encoded><![CDATA[<p>Spring Boot 3.2+ ile Java veya Kotlin arayÃ¼zleri Ã¼zerinden deklaratif ve tip gÃ¼venli HTTP istemcileri tanÄ±mlayabilirsiniz. Bu makalede JSONPlaceholder API Ã¶rneÄŸi ile baÅŸtan sona nasÄ±l yapÄ±landÄ±racaÄŸÄ±nÄ±zÄ± Ã¶ÄŸreneceksiniz.</p>
<hr>
<h2>ğŸŒŸ Neden HTTP ArayÃ¼z Ä°stemcisi?</h2>
<p>Bu bÃ¶lÃ¼mde Neden HTTP ArayÃ¼z Ä°stemcisi? konusunu netleÅŸtirip uygulamada kullanacaÄŸÄ±nÄ±z temel noktalarÄ± Ã¶zetliyoruz.</p>
<ul>
<li>Deklaratif: Bir arayÃ¼z tanÄ±mlayÄ±p HTTP Ã§aÄŸrÄ±larÄ±nÄ± yÃ¶ntem anotasyonlarÄ±yla eÅŸleyin.</li>
<li>Tip gÃ¼venli: YanlÄ±ÅŸ imzalar veya hatalÄ± yol konfigÃ¼rasyonlarÄ± derleme zamanÄ±nda yakalanÄ±r.</li>
<li>AzaltÄ±lmÄ±ÅŸ tekrar eden kod: Tek bir bean tanÄ±mÄ±, manuel proxy veya template koduna gerek yok.</li>
<li>Spring Dostu: Spring Framework 6.2â€™nin <code>@HttpExchange</code>, <code>@GetExchange</code> ve <code>WebClientAdapter</code> bileÅŸenlerini kullanÄ±r.</li>
</ul>
<hr>
<h2>ğŸ“‹ Gereksinimler</h2>
<p>Bu bÃ¶lÃ¼mde Gereksinimler konusunu netleÅŸtirip uygulamada kullanacaÄŸÄ±nÄ±z temel noktalarÄ± Ã¶zetliyoruz.</p>
<ul>
<li>â˜• Java Development Kit (JDK) 21 veya Ã¼stÃ¼</li>
<li>ğŸ“¦ Spring Boot 3.2+</li>
<li>ğŸ”¤ IDE (IntelliJ IDEA, Eclipse vb.)</li>
</ul>
<hr>
<h2>ğŸ› ï¸ AdÄ±m 1: BaÄŸÄ±mlÄ±lÄ±klarÄ± Ekle</h2>
<p>Projenizin yapÄ± dosyasÄ±na Web starterâ€™Ä± ekleyin:</p>
<p>Maven:</p>
<pre><code class="language-xml">&#x3C;dependency>
  &#x3C;groupId>org.springframework.boot&#x3C;/groupId>
  &#x3C;artifactId>spring-boot-starter-web&#x3C;/artifactId>
&#x3C;/dependency>
</code></pre>
<p>Gradle:</p>
<pre><code class="language-groovy">implementation 'org.springframework.boot:spring-boot-starter-web'
</code></pre>
<hr>
<h2>ğŸ› ï¸ AdÄ±m 2: Temel URL AyarÄ±</h2>
<p><code>application.yml</code> veya <code>application.properties</code> dosyanÄ±za ekleyin:</p>
<pre><code class="language-yaml">jsonplaceholder:
  base-url: https://jsonplaceholder.typicode.com
</code></pre>
<pre><code class="language-properties">jsonplaceholder.base-url=https://jsonplaceholder.typicode.com
</code></pre>
<hr>
<h2>ğŸ› ï¸ AdÄ±m 3: DTO ve Ä°stemci ArayÃ¼zÃ¼ TanÄ±mla</h2>
<h3>Java</h3>
<pre><code class="language-java">// src/main/java/com/example/client/dto/PostDTO.java
package com.example.client.dto;

public record PostDTO(
    Integer userId,
    Integer id,
    String title,
    String body
) {}

// src/main/java/com/example/client/JsonPlaceholderClient.java
package com.example.client;

import com.example.client.dto.PostDTO;
import org.springframework.web.service.annotation.GetExchange;
import org.springframework.web.service.annotation.HttpExchange;
import org.springframework.web.bind.annotation.PathVariable;
import java.util.List;

@HttpExchange(url = "${jsonplaceholder.base-url}", accept = "application/json")
public interface JsonPlaceholderClient {

    @GetExchange("/posts")
    List&#x3C;PostDTO> getPosts();

    @GetExchange("/posts/{id}")
    PostDTO getPost(@PathVariable("id") Integer id);
}
</code></pre>
<h3>Kotlin</h3>
<pre><code class="language-kotlin">// src/main/kotlin/com/example/client/dto/PostDTO.kt
package com.example.client.dto

data class PostDTO(
    val userId: Int,
    val id: Int,
    val title: String,
    val body: String
)

// src/main/kotlin/com/example/client/JsonPlaceholderClient.kt
package com.example.client

import com.example.client.dto.PostDTO
import org.springframework.web.service.annotation.GetExchange
import org.springframework.web.service.annotation.HttpExchange
import org.springframework.web.bind.annotation.PathVariable

@HttpExchange(url = "${jsonplaceholder.base-url}", accept = "application/json")
interface JsonPlaceholderClient {

    @GetExchange("/posts")
    fun getPosts(): List&#x3C;PostDTO>

    @GetExchange("/posts/{id}")
    fun getPost(@PathVariable("id") id: Int): PostDTO
}
</code></pre>
<hr>
<h2>ğŸ› ï¸ AdÄ±m 4: Ä°stemci Beanâ€™ini YapÄ±landÄ±r</h2>
<h3>Java</h3>
<pre><code class="language-java">// src/main/java/com/example/config/HttpClientConfig.java
package com.example.config;

import com.example.client.JsonPlaceholderClient;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.web.client.support.RestClientAdapter;
import org.springframework.web.service.invoker.HttpServiceProxyFactory;
import org.springframework.web.service.invoker.RestClient;

@Configuration
public class HttpClientConfig {

    @Bean
    public JsonPlaceholderClient jsonPlaceholderClient(RestClient.Builder restClientBuilder) {
        RestClient restClient = restClientBuilder
            .baseUrl("https://jsonplaceholder.typicode.com")
            .build();

        var factory = HttpServiceProxyFactory
            .builderFor(RestClientAdapter.create(restClient))
            .build();

        return factory.createClient(JsonPlaceholderClient.class);
    }
}
</code></pre>
<h3>Kotlin</h3>
<pre><code class="language-kotlin">// src/main/kotlin/com/example/config/HttpClientConfig.kt
package com.example.config

import com.example.client.JsonPlaceholderClient
import org.springframework.context.annotation.Bean
import org.springframework.context.annotation.Configuration
import org.springframework.web.client.support.RestClientAdapter
import org.springframework.web.service.invoker.HttpServiceProxyFactory
import org.springframework.web.service.invoker.RestClient

@Configuration
class HttpClientConfig {

    @Bean
    fun jsonPlaceholderClient(restClientBuilder: RestClient.Builder): JsonPlaceholderClient {
        val restClient = restClientBuilder
            .baseUrl("https://jsonplaceholder.typicode.com")
            .build()

        val factory = HttpServiceProxyFactory
            .builderFor(RestClientAdapter.create(restClient))
            .build()

        return factory.createClient(JsonPlaceholderClient::class.java)
    }
}
</code></pre>
<hr>
<h2>ğŸ› ï¸ AdÄ±m 5: Servis ve Controller OluÅŸturun</h2>
<h3>Java</h3>
<pre><code class="language-java">// src/main/java/com/example/service/PostService.java
package com.example.service;

import com.example.client.JsonPlaceholderClient;
import com.example.client.dto.PostDTO;
import lombok.RequiredArgsConstructor;
import org.springframework.stereotype.Service;
import java.util.List;

@Service
@RequiredArgsConstructor
public class PostService {
    private final JsonPlaceholderClient client;

    public List&#x3C;PostDTO> getAllPosts() {
        return client.getPosts();
    }

    public PostDTO getPostById(Integer id) {
        return client.getPost(id);
    }
}

// src/main/java/com/example/controller/PostController.java
package com.example.controller;

import com.example.client.dto.PostDTO;
import com.example.service.PostService;
import lombok.RequiredArgsConstructor;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.*;
import java.util.List;

@RestController
@RequestMapping("/posts")
@RequiredArgsConstructor
public class PostController {
    private final PostService postService;

    @GetMapping
    public List&#x3C;PostDTO> getAllPosts() {
        return postService.getAllPosts();
    }

    @GetMapping("/{id}")
    public ResponseEntity&#x3C;PostDTO> getPostById(@PathVariable Integer id) {
        PostDTO post = postService.getPostById(id);
        return post != null ? ResponseEntity.ok(post) : ResponseEntity.notFound().build();
    }
}
</code></pre>
<h3>Kotlin</h3>
<pre><code class="language-kotlin">// src/main/kotlin/com/example/service/PostService.kt
package com.example.service

import com.example.client.JsonPlaceholderClient
import com.example.client.dto.PostDTO
import org.springframework.stereotype.Service

@Service
class PostService(private val client: JsonPlaceholderClient) {
    fun getAllPosts(): List&#x3C;PostDTO> = client.getPosts()
    fun getPostById(id: Int): PostDTO = client.getPost(id)
}

// src/main/kotlin/com/example/controller/PostController.kt
package com.example.controller

import com.example.client.dto.PostDTO
import com.example.service.PostService
import org.springframework.http.ResponseEntity
import org.springframework.web.bind.annotation.*

@RestController
@RequestMapping("/posts")
class PostController(private val postService: PostService) {
    @GetMapping
    fun getAllPosts(): List&#x3C;PostDTO> = postService.getAllPosts()

    @GetMapping("/{id}")
    fun getPostById(@PathVariable id: Int): ResponseEntity&#x3C;PostDTO> =
        ResponseEntity.ok(postService.getPostById(id))
}
</code></pre>
<hr>
<h2>â–¶ï¸ UygulamayÄ± Ã‡alÄ±ÅŸtÄ±r</h2>
<pre><code class="language-bash">./mvnw spring-boot:run
# veya
gradle bootRun
</code></pre>
<hr>
<h2>ğŸ§ª Endpointleri Test Et</h2>
<pre><code class="language-bash">curl http://localhost:8080/posts
curl http://localhost:8080/posts/1
</code></pre>
<hr>
<h2>ğŸ SonuÃ§</h2>
<p>ArtÄ±k Spring Boot HTTP Interface Client iÃ§in Ã¼retim odaklÄ± bir Spring Boot temeliniz var. Sonraki adÄ±mda ayarlarÄ± kendi domainine uyarlayÄ±p test ve gÃ¶zlemlenebilirlik katmanÄ±nÄ± ekleyerek gerÃ§ek trafik altÄ±nda doÄŸrulayÄ±n.</p>]]></content:encoded>
      <category><![CDATA[Java]]></category>
      <category><![CDATA[Kotlin]]></category>
      <category><![CDATA[Spring Boot]]></category>
      <category><![CDATA[REST API]]></category>
      <category><![CDATA[Rest Client]]></category>
      <media:thumbnail url="https://suaybsimsek.com/images/spring-boot-http-interface-thumbnail.webp" />
    </item>
    <item>
      <title><![CDATA[Spring Boot Sanal Threadâ€™li Asenkron GÃ¶revler]]></title>
      <link>https://suaybsimsek.com/tr/posts/spring-boot-async-tasks-virtual</link>
      <description><![CDATA[Spring Bootâ€™ta JDK 21 sanal threadâ€™leri ve `@Async` anotasyonunu kullanarak hafif ve Ã¶lÃ§eklenebilir asenkron gÃ¶revleri nasÄ±l oluÅŸturacaÄŸÄ±nÄ±zÄ± Ã¶ÄŸrenin.]]></description>
      <pubDate>Sat, 26 Apr 2025 00:00:00 GMT</pubDate>
      <atom:updated>2025-04-27T00:00:00.000Z</atom:updated>
      <guid isPermaLink="true">https://suaybsimsek.com/tr/posts/spring-boot-async-tasks-virtual</guid>
      <content:encoded><![CDATA[<p>Spring Boot 3.2 ve Ã¼zeri sÃ¼rÃ¼mler, JDK 21â€™in sanal thread desteÄŸini otomatik olarak yapÄ±landÄ±rarak <code>@Async</code> anotasyonuyla basit ve yÃ¼ksek performanslÄ± asenkron iÅŸlemler yapmanÄ±za imkan tanÄ±r.</p>
<hr>
<h2>ğŸŒŸ Neden Spring Boot'ta Sanal Thread KullanmalÄ±yÄ±z?</h2>
<p>Bu bÃ¶lÃ¼mde Neden Spring Boot'ta Sanal Thread KullanmalÄ±yÄ±z? konusunu netleÅŸtirip uygulamada kullanacaÄŸÄ±nÄ±z temel noktalarÄ± Ã¶zetliyoruz.</p>
<ul>
<li>Hafif Maliyet: Sanal threadâ€™ler, geleneksel platform threadâ€™lere kÄ±yasla Ã§ok daha az kaynak kullanÄ±r.</li>
<li>BloklamasÄ±z: <code>@Async</code> ile iÅŸaretlenen metodlar ana threadâ€™i meÅŸgul etmeden Ã§alÄ±ÅŸÄ±r.</li>
<li>YÃ¼ksek Ã–lÃ§eklenebilirlik: Binlerce concurrent iÅŸ yÃ¼kÃ¼nÃ¼ dÃ¼ÅŸÃ¼k bellek ayak iziyle yÃ¶netir.</li>
<li>Basit KonfigÃ¼rasyon: Tek bir Ã¶zellik (property) ekleyerek tÃ¼m executor ve schedulerâ€™larÄ± sanal threadâ€™li yapar.</li>
</ul>
<hr>
<h2>ğŸ“‹ Gereksinimler</h2>
<p>Bu bÃ¶lÃ¼mde Gereksinimler konusunu netleÅŸtirip uygulamada kullanacaÄŸÄ±nÄ±z temel noktalarÄ± Ã¶zetliyoruz.</p>
<ul>
<li>â˜• Java Development Kit (JDK) 21 veya Ã¼zeri</li>
<li>ğŸ“¦ Spring Boot 3.2+</li>
<li>ğŸ”¤ IDE (IntelliJ IDEA, Eclipse vb.)</li>
</ul>
<hr>
<h2>ğŸ› ï¸ AdÄ±m 1: BaÄŸÄ±mlÄ±lÄ±klarÄ± Ekle</h2>
<p>Asenkron iÅŸleme olanak tanÄ±yan <code>spring-boot-starter-web</code> paketini projenize ekleyin.</p>
<p>Maven:</p>
<pre><code class="language-xml">&#x3C;dependency>
    &#x3C;groupId>org.springframework.boot&#x3C;/groupId>
    &#x3C;artifactId>spring-boot-starter-web&#x3C;/artifactId>
&#x3C;/dependency>
</code></pre>
<p>Gradle:</p>
<pre><code class="language-groovy">implementation 'org.springframework.boot:spring-boot-starter-web'
</code></pre>
<hr>
<h2>ğŸ› ï¸ AdÄ±m 2: Sanal Threadâ€™leri AktifleÅŸtir</h2>
<p><code>application.yml</code> veya <code>application.properties</code> dosyanÄ±za ÅŸu satÄ±rÄ± ekleyin:</p>
<pre><code class="language-yaml">spring:
  threads:
    virtual:
      enabled: true
</code></pre>
<pre><code class="language-properties">spring.threads.virtual.enabled=true
</code></pre>
<p>Bu ayar, aÅŸaÄŸÄ±dakileri otomatik yapÄ±landÄ±rÄ±r:</p>
<ul>
<li><code>applicationTaskExecutor</code> (Async)</li>
<li>Task scheduler (<code>@Scheduled</code>)</li>
<li>HTTP sunucu thread havuzlarÄ± (Tomcat/Jetty)</li>
</ul>
<hr>
<h2>ğŸ› ï¸ AdÄ±m 3: Asenkron DesteÄŸi Aktif Etme</h2>
<p>Ana uygulama sÄ±nÄ±fÄ±nÄ±za <code>@EnableAsync</code> ekleyin:</p>
<h3>Java</h3>
<pre><code class="language-java">package com.example.async;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;
import org.springframework.scheduling.annotation.EnableAsync;

@SpringBootApplication
@EnableAsync
public class AsyncVirtualApplication {
    public static void main(String[] args) {
        SpringApplication.run(AsyncVirtualApplication.class, args);
    }
}
</code></pre>
<h3>Kotlin</h3>
<pre><code class="language-kotlin">package com.example.async

import org.springframework.boot.autoconfigure.SpringBootApplication
import org.springframework.boot.runApplication
import org.springframework.scheduling.annotation.EnableAsync

@SpringBootApplication
@EnableAsync
class AsyncVirtualApplication

fun main(args: Array&#x3C;String>) {
    runApplication&#x3C;AsyncVirtualApplication>(*args)
}
</code></pre>
<hr>
<h2>ğŸ› ï¸ AdÄ±m 4: Asenkron Servis TanÄ±mla</h2>
<p><code>@Async</code> anotasyonlu metodlar sanal thread Ã¼zerinde Ã§alÄ±ÅŸÄ±r:</p>
<h3>Java</h3>
<pre><code class="language-java">package com.example.async;

import lombok.extern.slf4j.Slf4j;
import org.springframework.scheduling.annotation.Async;
import org.springframework.stereotype.Service;

import java.time.LocalTime;
import java.util.concurrent.CompletableFuture;

@Slf4j
@Service
public class AsyncVirtualService {

    @Async
    public void runTask() {
        log.info("[{}] Asenkron baÅŸlatÄ±ldÄ±: {}", LocalTime.now(), Thread.currentThread());
        try { Thread.sleep(1000); } catch (InterruptedException ignored) {}
        log.info("[{}] Asenkron tamamlandÄ±: {}", LocalTime.now(), Thread.currentThread());
    }

    @Async
    public CompletableFuture&#x3C;String> runAndReturn() throws InterruptedException {
        Thread.sleep(500);
        return CompletableFuture.completedFuture("TamamlandÄ±");
    }
}
</code></pre>
<h3>Kotlin</h3>
<pre><code class="language-kotlin">package com.example.async

import org.slf4j.LoggerFactory
import org.springframework.scheduling.annotation.Async
import org.springframework.stereotype.Service

import java.time.LocalTime
import java.util.concurrent.CompletableFuture

@Service
class AsyncVirtualService {
    private val log = LoggerFactory.getLogger(AsyncVirtualService::class.java)

    @Async
    fun runTask() {
        log.info("[{}] Asenkron baÅŸlatÄ±ldÄ±: {}", LocalTime.now(), Thread.currentThread())
        try { Thread.sleep(1000) } catch (_: InterruptedException) {}
        log.info("[{}] Asenkron tamamlandÄ±: {}", LocalTime.now(), Thread.currentThread())
    }

    @Async
    fun runAndReturn(): CompletableFuture&#x3C;String> {
        Thread.sleep(500)
        return CompletableFuture.completedFuture("TamamlandÄ±")
    }
}
</code></pre>
<hr>
<h2>ğŸ› ï¸ AdÄ±m 5: REST Controller ile Tetikle</h2>
<p>AÅŸaÄŸÄ±daki endpointâ€™leri kullanarak servis metodlarÄ±nÄ± tetikleyin:</p>
<h3>Java</h3>
<pre><code class="language-java">package com.example.async;

import lombok.RequiredArgsConstructor;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;

@RestController
@RequestMapping("/async")
@RequiredArgsConstructor
public class AsyncVirtualController {

    private final AsyncVirtualService service;

    @GetMapping("/run")
    public String triggerRun() {
        service.runTask();
        return "Asenkron sanal thread gÃ¶revi tetiklendi";
    }

    @GetMapping("/run-return")
    public String triggerRunAndReturn() throws Exception {
        var future = service.runAndReturn();
        return future.get();
    }
}
</code></pre>
<h3>Kotlin</h3>
<pre><code class="language-kotlin">package com.example.async

import org.springframework.web.bind.annotation.GetMapping
import org.springframework.web.bind.annotation.RequestMapping
import org.springframework.web.bind.annotation.RestController

import lombok.RequiredArgsConstructor

@RestController
@RequestMapping("/async")
@RequiredArgsConstructor
class AsyncVirtualController(private val service: AsyncVirtualService) {

    @GetMapping("/run")
    fun triggerRun(): String {
        service.runTask()
        return "Asenkron sanal thread gÃ¶revi tetiklendi"
    }

    @GetMapping("/run-return")
    @Throws(Exception::class)
    fun triggerRunAndReturn(): String {
        val future = service.runAndReturn()
        return future.get()
    }
}
</code></pre>
<hr>
<h2>â–¶ï¸ UygulamayÄ± Ã‡alÄ±ÅŸtÄ±r</h2>
<pre><code class="language-bash">./mvnw spring-boot:run
# veya
gradle bootRun
</code></pre>
<hr>
<h2>ğŸ§ª Endpointleri Test Et</h2>
<p>Void gÃ¶revi tetikle</p>
<pre><code class="language-bash">curl http://localhost:8080/async/run
</code></pre>
<p>Sanal thread baÅŸlangÄ±Ã§/bitiÅŸ logâ€™larÄ±nÄ± kontrol edin.</p>
<p>SonuÃ§ dÃ¶ndÃ¼ren gÃ¶revi tetikle</p>
<pre><code class="language-bash">curl http://localhost:8080/async/run-return
# dÃ¶nen: "TamamlandÄ±"
</code></pre>
<hr>
<h2>ğŸ SonuÃ§</h2>
<p>ArtÄ±k Spring Boot Sanal Threadâ€™li Asenkron GÃ¶revler iÃ§in Ã¼retim odaklÄ± bir Spring Boot temeliniz var. Sonraki adÄ±mda ayarlarÄ± kendi domainine uyarlayÄ±p test ve gÃ¶zlemlenebilirlik katmanÄ±nÄ± ekleyerek gerÃ§ek trafik altÄ±nda doÄŸrulayÄ±n.</p>]]></content:encoded>
      <category><![CDATA[Java]]></category>
      <category><![CDATA[Kotlin]]></category>
      <category><![CDATA[Spring Boot]]></category>
      <category><![CDATA[Asenkron GÃ¶revler]]></category>
      <category><![CDATA[Sanal Thread]]></category>
      <media:thumbnail url="https://suaybsimsek.com/images/spring-boot-async-virtual-thumbnail.webp" />
    </item>
    <item>
      <title><![CDATA[Spring Boot AI Entegrasyonu]]></title>
      <link>https://suaybsimsek.com/tr/posts/spring-boot-ai</link>
      <description><![CDATA[ModÃ¼ler, taÅŸÄ±nabilir ve gÃ¶zlemlenebilir AI iÅŸ akÄ±ÅŸlarÄ± iÃ§in Spring AI kullanarak Spring Boot uygulamalarÄ±na AI modellerini nasÄ±l entegre edeceÄŸinizi Ã¶ÄŸrenin.]]></description>
      <pubDate>Wed, 23 Apr 2025 00:00:00 GMT</pubDate>
      <atom:updated>2025-04-24T00:00:00.000Z</atom:updated>
      <guid isPermaLink="true">https://suaybsimsek.com/tr/posts/spring-boot-ai</guid>
      <content:encoded><![CDATA[<p>Spring AI, AI mÃ¼hendisliÄŸi iÃ§in Springâ€™in taÅŸÄ±nabilirlik ve modÃ¼ler tasarÄ±m ilkelerini AI iÅŸ yÃ¼klerine uygulayan bir Ã§erÃ§evedir. TanÄ±dÄ±k Spring kalÄ±plarÄ± ve POJOâ€™larÄ± kullanarak AI odaklÄ± uygulamalar geliÅŸtirmenizi saÄŸlar.</p>
<hr>
<h2>ğŸŒŸ Neden Spring AI KullanÄ±lmalÄ±?</h2>
<p>Bu bÃ¶lÃ¼mde Neden Spring AI KullanÄ±lmalÄ±? konusunu netleÅŸtirip uygulamada kullanacaÄŸÄ±nÄ±z temel noktalarÄ± Ã¶zetliyoruz.</p>
<ul>
<li>SaÄŸlayÄ±cÄ±dan baÄŸÄ±msÄ±z taÅŸÄ±nabilirlik: Kodunuzu bir kez yazÄ±n, AI saÄŸlayÄ±cÄ±larÄ± (OpenAI, Anthropic, Azure vb.) arasÄ±nda deÄŸiÅŸtirmeler yapmadan geÃ§iÅŸ yapÄ±n.</li>
<li>POJO tabanlÄ± tasarÄ±m: AI girdi ve Ã§Ä±ktÄ±larÄ±nÄ±zÄ± dÃ¼z Java/Kotlin nesneleri olarak modelleyerek tÃ¼r gÃ¼venliÄŸi ve kolay entegrasyon saÄŸlayÄ±n.</li>
<li>YapÄ±landÄ±rÄ±lmÄ±ÅŸ Ã§Ä±ktÄ±lar: Model yanÄ±tlarÄ±nÄ± alan nesnelerinize otomatik olarak eÅŸleyin.</li>
<li>VektÃ¶r veri deposu entegrasyonu: Chroma, Pinecone, Redis gibi Ã¶nde gelen vektÃ¶r veritabanlarÄ± iÃ§in birleÅŸik API desteÄŸi.</li>
<li>AraÃ§/fonksiyon Ã§aÄŸrÄ±sÄ±: LLMâ€™lerin gerÃ§ek zamanlÄ± veri iÃ§in Ã¶zel fonksiyonlarÄ± veya servisleri Ã§aÄŸÄ±rmasÄ±na izin verin.</li>
<li>GÃ¶zlemlenebilirlik ve deÄŸerlendirme: AI iÅŸlemlerini izlemeniz ve halÃ¼sinasyonlarÄ± tespit etmeniz iÃ§in yerleÅŸik metrikler ve deÄŸerlendirme araÃ§larÄ±.</li>
<li>Sohbet soyutlamalarÄ±: WebClient benzeri akÄ±cÄ± bir ChatClient APIâ€™si ile chat agentlar oluÅŸturun.</li>
<li>Retrieval-augmented generation (RAG): Advisorler ve bellek APIâ€™leri ile belgelere dayalÄ± QA ve geÃ§miÅŸ sohbete dayalÄ± sohbeti basitleÅŸtirin.</li>
</ul>
<hr>
<h2>ğŸ“‹ Gereksinimler</h2>
<p>AÅŸaÄŸÄ±dakilere sahip olduÄŸunuzdan emin olun:</p>
<ul>
<li>â˜• Java Development Kit (JDK) 17+</li>
<li>ğŸ“¦ Maven veya Gradle kurulumu</li>
<li>ğŸ³ Spring Boot 3+</li>
<li>ğŸ”‘ OpenAI API AnahtarÄ± (Ã§evre deÄŸiÅŸkeni <code>OPENAI_API_KEY</code> olarak tanÄ±mlÄ±)</li>
</ul>
<hr>
<h2>ğŸ› ï¸ AdÄ±m 1: BaÄŸÄ±mlÄ±lÄ±klarÄ± Ekleyin</h2>
<p>Spring AI OpenAI baÅŸlatÄ±cÄ±sÄ±, Spring Web ve Lombokâ€™u projenize ekleyin.</p>
<h3>Maven</h3>
<pre><code class="language-xml">&#x3C;dependencies>
  &#x3C;dependency>
    &#x3C;groupId>org.springframework.boot&#x3C;/groupId>
    &#x3C;artifactId>spring-boot-starter-web&#x3C;/artifactId>
  &#x3C;/dependency>
  &#x3C;dependency>
    &#x3C;groupId>org.springframework.ai&#x3C;/groupId>
    &#x3C;artifactId>spring-ai-starter-model-openai&#x3C;/artifactId>
  &#x3C;/dependency>
  &#x3C;dependency>
    &#x3C;groupId>org.projectlombok&#x3C;/groupId>
    &#x3C;artifactId>lombok&#x3C;/artifactId>
    &#x3C;scope>provided&#x3C;/scope>
  &#x3C;/dependency>
&#x3C;/dependencies>
</code></pre>
<h3>Gradle</h3>
<pre><code class="language-groovy">plugins {
  id 'org.springframework.boot' version '3.2.0'
}

dependencies {
  implementation 'org.springframework.boot:spring-boot-starter-web'
  implementation 'org.springframework.ai:spring-ai-starter-model-openai'
  compileOnly 'org.projectlombok:lombok'
  annotationProcessor 'org.projectlombok:lombok'
}
</code></pre>
<hr>
<h2>ğŸ› ï¸ AdÄ±m 2: YapÄ±landÄ±rma</h2>
<p><code>application.yml</code> dosyanÄ±za OpenAI anahtarÄ±nÄ±zÄ± ve ChatClient model ayarlarÄ±nÄ± ekleyin:</p>
<pre><code class="language-yaml">spring:
  ai:
    openai:
      api-key: ${OPENAI_API_KEY}
      chat:
        options:
          model: gpt-4.1-mini
</code></pre>
<hr>
<h2>ğŸ› ï¸ AdÄ±m 3: Servis KatmanÄ±nÄ± Uygulama</h2>
<p><code>ChatClient.Builder</code> ile ChatClientâ€™i oluÅŸturup sarmalayan bir <code>AIService</code> sÄ±nÄ±fÄ± yazÄ±n.</p>
<h3>Java</h3>
<pre><code class="language-java">package com.example.ai.service;

import org.springframework.ai.chat.client.ChatClient;
import org.springframework.stereotype.Service;

@Service
public class AIService {
    private final ChatClient chatClient;

    public AIService(ChatClient.Builder builder) {
        this.chatClient = builder.build();
    }

    public String getJoke(String topic) {
        return chatClient.prompt()
                .user(u -> u.text("Tell me a joke about {topic}").param("topic", topic))
                .call()
                .content();
    }
}
</code></pre>
<h3>Kotlin</h3>
<pre><code class="language-kotlin">package com.example.ai.service

import org.springframework.ai.chat.client.ChatClient
import org.springframework.stereotype.Service

@Service
class AIService(builder: ChatClient.Builder) {
    private val chatClient: ChatClient = builder.build()

    fun getJoke(topic: String): String =
        chatClient.prompt()
            .user { it.text("Tell me a joke about {topic}").param("topic", topic) }
            .call()
            .content()
</code></pre>
<hr>
<h2>ğŸ› ï¸ AdÄ±m 4: REST Controller OluÅŸturma</h2>
<p><code>AIService</code>â€™i HTTP Ã¼zerinden sunmak iÃ§in bir <code>ChatController</code> sÄ±nÄ±fÄ± oluÅŸturun.</p>
<h3>Java</h3>
<pre><code class="language-java">package com.example.ai.controller;

import com.example.ai.service.AIService;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RequestParam;
import org.springframework.web.bind.annotation.RestController;

@RestController
public class ChatController {

    private final AIService aiService;

    public ChatController(AIService aiService) {
        this.aiService = aiService;
    }

    @GetMapping("/joke")
    public String getJoke(@RequestParam(defaultValue = "dogs") String topic) {
        return aiService.getJoke(topic);
    }
}
</code></pre>
<h3>Kotlin</h3>
<pre><code class="language-kotlin">package com.example.ai.controller

import com.example.ai.service.AIService
import org.springframework.web.bind.annotation.GetMapping
import org.springframework.web.bind.annotation.RequestParam
import org.springframework.web.bind.annotation.RestController

@RestController
class ChatController(private val aiService: AIService) {

    @GetMapping("/joke")
    fun getJoke(@RequestParam(defaultValue = "dogs") topic: String): String =
        aiService.getJoke(topic)
</code></pre>
<hr>
<h2>â–¶ï¸ UygulamayÄ± Ã‡alÄ±ÅŸtÄ±rma</h2>
<p>Spring Boot uygulamanÄ±zÄ± baÅŸlatÄ±n:</p>
<pre><code class="language-bash">./mvnw spring-boot:run
# veya
gradle bootRun
</code></pre>
<hr>
<h2>ğŸ§ª Entegrasyonu Test Etme</h2>
<p>HTTP Ã¼zerinden servisinizi Ã§aÄŸÄ±rÄ±n:</p>
<pre><code class="language-bash">curl -X GET "http://localhost:8080/joke?topic=dogs"
# AI modelinin dÃ¶ndÃ¼rdÃ¼ÄŸÃ¼ kÃ¶pek ÅŸakasÄ±
</code></pre>
<hr>
<h2>ğŸ SonuÃ§</h2>
<p>ArtÄ±k Spring Boot AI Entegrasyonu iÃ§in Ã¼retim odaklÄ± bir Spring Boot temeliniz var. Sonraki adÄ±mda ayarlarÄ± kendi domainine uyarlayÄ±p test ve gÃ¶zlemlenebilirlik katmanÄ±nÄ± ekleyerek gerÃ§ek trafik altÄ±nda doÄŸrulayÄ±n.</p>]]></content:encoded>
      <category><![CDATA[Java]]></category>
      <category><![CDATA[Kotlin]]></category>
      <category><![CDATA[Spring Boot]]></category>
      <category><![CDATA[Spring AI]]></category>
      <category><![CDATA[Yapay Zeka]]></category>
      <media:thumbnail url="https://suaybsimsek.com/images/spring-boot-ai-thumbnail.webp" />
    </item>
    <item>
      <title><![CDATA[Spring Boot JPA Auditing]]></title>
      <link>https://suaybsimsek.com/tr/posts/spring-boot-jpa-auditing</link>
      <description><![CDATA[Spring Boot uygulamalarÄ±nda JPA Auditing ile oluÅŸturulma/deÄŸiÅŸtirilme tarihlerini ve kullanÄ±cÄ±larÄ±nÄ± otomatik olarak nasÄ±l yakalayacaÄŸÄ±nÄ±zÄ± Ã¶ÄŸrenin.]]></description>
      <pubDate>Thu, 10 Apr 2025 00:00:00 GMT</pubDate>
      <atom:updated>2025-04-11T00:00:00.000Z</atom:updated>
      <guid isPermaLink="true">https://suaybsimsek.com/tr/posts/spring-boot-jpa-auditing</guid>
      <content:encoded><![CDATA[<p>Spring Boot'ta JPA Auditing, bir varlÄ±ÄŸÄ±n kim tarafÄ±ndan ve ne zaman oluÅŸturulduÄŸunu veya deÄŸiÅŸtirildiÄŸini otomatik olarak izlemenizi saÄŸlar. Bu, denetim kayÄ±tlarÄ±, geÃ§miÅŸ izleme ve hata ayÄ±klama iÃ§in oldukÃ§a kullanÄ±ÅŸlÄ±dÄ±r.</p>
<hr>
<h2>ğŸŒŸ Neden JPA Auditing KullanmalÄ±yÄ±m?</h2>
<p>Bu bÃ¶lÃ¼mde Neden JPA Auditing KullanmalÄ±yÄ±m? konusunu netleÅŸtirip uygulamada kullanacaÄŸÄ±nÄ±z temel noktalarÄ± Ã¶zetliyoruz.</p>
<ul>
<li>ğŸ“… <code>createdDate</code>, <code>lastModifiedDate</code> alanlarÄ±nÄ± otomatik takip edin</li>
<li>ğŸ‘¤ <code>createdBy</code>, <code>modifiedBy</code> bilgilerini kaydedin</li>
<li>ğŸ§¼ AlanlarÄ± manuel ayarlamadan kaÃ§Ä±narak temiz kod yazÄ±n</li>
</ul>
<hr>
<h2>ğŸ“‹ Gereksinimler</h2>
<p>BaÅŸlamadan Ã¶nce aÅŸaÄŸÄ±dakileri hazÄ±rlayÄ±n:</p>
<ul>
<li>Java 17+</li>
<li>Spring Data JPA iÃ§eren Spring Boot 3.x projesi</li>
<li>YapÄ±landÄ±rÄ±lmÄ±ÅŸ bir veritabanÄ± baÄŸlantÄ±sÄ± (H2, PostgreSQL, MySQL vb.)</li>
<li>JPA entity ve repository akÄ±ÅŸÄ± hakkÄ±nda temel bilgi</li>
</ul>
<hr>
<h2>ğŸ› ï¸ AdÄ±m 1: BaÄŸÄ±mlÄ±lÄ±klarÄ± Ekleyin</h2>
<p>Projenize aÅŸaÄŸÄ±daki baÄŸÄ±mlÄ±lÄ±klarÄ± ekleyin:</p>
<p>Maven:</p>
<pre><code class="language-xml">&#x3C;dependency>
  &#x3C;groupId>org.springframework.boot&#x3C;/groupId>
  &#x3C;artifactId>spring-boot-starter-data-jpa&#x3C;/artifactId>
&#x3C;/dependency>
</code></pre>
<p>Gradle:</p>
<pre><code class="language-groovy">dependencies {
  implementation 'org.springframework.boot:spring-boot-starter-data-jpa'
}
</code></pre>
<hr>
<h2>ğŸ› ï¸ AdÄ±m 2: JPA Auditing Ã–zelliÄŸini EtkinleÅŸtirme</h2>
<p>Ana sÄ±nÄ±fÄ±nÄ±za veya yapÄ±landÄ±rma sÄ±nÄ±fÄ±nÄ±za <code>@EnableJpaAuditing</code> ekleyin.</p>
<h3>Java</h3>
<pre><code class="language-java">import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;
import org.springframework.data.jpa.repository.config.EnableJpaAuditing;

@SpringBootApplication
@EnableJpaAuditing(auditorAwareRef = "auditorProvider")
public class DemoApplication {
  public static void main(String[] args) {
    SpringApplication.run(DemoApplication.class, args);
  }
}
</code></pre>
<h3>Kotlin</h3>
<pre><code class="language-kotlin">import org.springframework.boot.autoconfigure.SpringBootApplication
import org.springframework.boot.runApplication
import org.springframework.data.jpa.repository.config.EnableJpaAuditing

@SpringBootApplication
@EnableJpaAuditing(auditorAwareRef = "auditorProvider")
class DemoApplication

fun main(args: Array&#x3C;String>) {
    runApplication&#x3C;DemoApplication>(*args)
}
</code></pre>
<hr>
<h2>ğŸ› ï¸ AdÄ±m 3: AuditorAware Bean'i OluÅŸturun</h2>
<p>Bu bean, Spring'e geÃ§erli kullanÄ±cÄ±yÄ± bildirir. Statik bir kullanÄ±cÄ± Ã¶rneÄŸi aÅŸaÄŸÄ±da:</p>
<h3>Java</h3>
<pre><code class="language-java">@Configuration
public class AuditingConfig {

  @Bean
  public AuditorAware&#x3C;String> auditorProvider() {
    return () -> Optional.of("Åuayb");
  }
}
</code></pre>
<h3>Kotlin</h3>
<pre><code class="language-kotlin">@Configuration
class AuditingConfig {

  @Bean
  fun auditorProvider(): AuditorAware&#x3C;String> = AuditorAware { Optional.of("Åuayb") }
}
</code></pre>
<hr>
<h2>ğŸ› ï¸ AdÄ±m 4: Entity SÄ±nÄ±fÄ±na AnotasyonlarÄ± Ekle</h2>
<p>AÅŸaÄŸÄ±daki gibi denetim anotasyonlarÄ±nÄ± kullanÄ±n: <code>@CreatedDate</code>, <code>@LastModifiedDate</code>, vb.</p>
<h3>Java</h3>
<pre><code class="language-java">@Entity
@EntityListeners(AuditingEntityListener.class)
public class Article {

  @Id
  @GeneratedValue(strategy = GenerationType.IDENTITY)
  private Long id;

  private String title;

  @CreatedDate
  private LocalDateTime createdDate;

  @LastModifiedDate
  private LocalDateTime lastModifiedDate;

  @CreatedBy
  private String createdBy;

  @LastModifiedBy
  private String lastModifiedBy;

  // getter &#x26; setter
}
</code></pre>
<h3>Kotlin</h3>
<pre><code class="language-kotlin">@Entity
@EntityListeners(AuditingEntityListener::class)
data class Article(
  @Id
  @GeneratedValue(strategy = GenerationType.IDENTITY)
  val id: Long? = null,

  var title: String? = null,

  @CreatedDate
  var createdDate: LocalDateTime? = null,

  @LastModifiedDate
  var lastModifiedDate: LocalDateTime? = null,

  @CreatedBy
  var createdBy: String? = null,

  @LastModifiedBy
  var lastModifiedBy: String? = null
)
</code></pre>
<hr>
<h2>â–¶ï¸ UygulamayÄ± Ã‡alÄ±ÅŸtÄ±rma</h2>
<p>ArtÄ±k bir entityi <code>JpaRepository</code> ile kaydettiÄŸinizde, denetim alanlarÄ± otomatik olarak doldurulacaktÄ±r.</p>
<hr>
<h2>ğŸ§ª Test Etme</h2>
<p>Bir entity kaydederek denetim alanlarÄ±nÄ±n otomatik olarak doldurulup doldurulmadÄ±ÄŸÄ±nÄ± test edebilirsiniz.</p>
<h3>Java</h3>
<pre><code class="language-java">@SpringBootTest
@AutoConfigureTestDatabase
@Transactional
class ArticleRepositoryTest {

  @Autowired
  private ArticleRepository articleRepository;

  @Test
  void testAuditFieldsAreSet() {
    Article article = new Article();
    article.setTitle("Test BaÅŸlÄ±ÄŸÄ±");

    Article saved = articleRepository.save(article);

    assertNotNull(saved.getCreatedDate());
    assertNotNull(saved.getLastModifiedDate());
    assertEquals("Åuayb", saved.getCreatedBy());
    assertEquals("Åuayb", saved.getLastModifiedBy());
  }
}
</code></pre>
<h3>Kotlin</h3>
<pre><code class="language-kotlin">@SpringBootTest
@AutoConfigureTestDatabase
@Transactional
class ArticleRepositoryTest {

  @Autowired
  lateinit var articleRepository: ArticleRepository

  @Test
  fun `denetim alanlarÄ± ayarlanmalÄ±`() {
    val article = Article().apply {
      title = "Test BaÅŸlÄ±ÄŸÄ±"
    }

    val saved = articleRepository.save(article)

    assertNotNull(saved.createdDate)
    assertNotNull(saved.lastModifiedDate)
    assertEquals("Åuayb", saved.createdBy)
    assertEquals("Åuayb", saved.lastModifiedBy)
  }
}
</code></pre>
<hr>
<h2>ğŸ SonuÃ§</h2>
<p>ArtÄ±k Spring Boot JPA Auditing iÃ§in Ã¼retim odaklÄ± bir Spring Boot temeliniz var. Sonraki adÄ±mda ayarlarÄ± kendi domainine uyarlayÄ±p test ve gÃ¶zlemlenebilirlik katmanÄ±nÄ± ekleyerek gerÃ§ek trafik altÄ±nda doÄŸrulayÄ±n.</p>]]></content:encoded>
      <category><![CDATA[Java]]></category>
      <category><![CDATA[Kotlin]]></category>
      <category><![CDATA[Spring Boot]]></category>
      <category><![CDATA[Spring Data]]></category>
      <category><![CDATA[JPA]]></category>
      <category><![CDATA[Auditing]]></category>
      <media:thumbnail url="https://suaybsimsek.com/images/spring-boot-jpa-auditing-thumbnail.webp" />
    </item>
    <item>
      <title><![CDATA[Spring Boot ile Test OdaklÄ± GeliÅŸtirme]]></title>
      <link>https://suaybsimsek.com/tr/posts/spring-boot-tdd</link>
      <description><![CDATA[Spring Boot ile TDD yaklaÅŸÄ±mÄ±nÄ± uygulamayÄ±; Ã¶nce test yazarak, iÅŸ mantÄ±ÄŸÄ±nÄ± geliÅŸtirerek ve testlerle kaliteyi garanti altÄ±na alarak Ã¶ÄŸrenin.]]></description>
      <pubDate>Wed, 09 Apr 2025 00:00:00 GMT</pubDate>
      <atom:updated>2025-04-10T00:00:00.000Z</atom:updated>
      <guid isPermaLink="true">https://suaybsimsek.com/tr/posts/spring-boot-tdd</guid>
      <content:encoded><![CDATA[<p>Test OdaklÄ± GeliÅŸtirme (TDD), iÅŸ mantÄ±ÄŸÄ±nÄ± uygulamadan Ã¶nce testler yazarak saÄŸlam uygulamalar geliÅŸtirmeni saÄŸlar. Spring Boot ile birim testler yazmak hÄ±zlÄ±, temiz ve etkilidir.</p>
<hr>
<h2>ğŸŒŸ Neden Spring Boot ile TDD?</h2>
<p>Bu bÃ¶lÃ¼mde Neden Spring Boot ile TDD? konusunu netleÅŸtirip uygulamada kullanacaÄŸÄ±nÄ±z temel noktalarÄ± Ã¶zetliyoruz.</p>
<ul>
<li>HatalarÄ± Erken Yakala: GeliÅŸtirme aÅŸamasÄ±nda problemleri fark et.</li>
<li>Temiz TasarÄ±m: ModÃ¼ler ve test edilebilir kod yapÄ±sÄ± zorunlu olur.</li>
<li>GÃ¼venle Refactor Et: Testler deÄŸiÅŸikliklerde gÃ¼ven saÄŸlar.</li>
<li>DokÃ¼mantasyon: Testler, beklenen davranÄ±ÅŸÄ± anlatÄ±r.</li>
</ul>
<hr>
<h2>ğŸ“‹ Gereksinimler</h2>
<p>Åunlara sahip olduÄŸundan emin ol:</p>
<ul>
<li>â˜• JDK 17+ kurulu</li>
<li>ğŸ“¦ Maven veya Gradle</li>
<li>ğŸ”¤ Java IDE (IntelliJ IDEA, Eclipse vb.)</li>
</ul>
<hr>
<h2>ğŸ§ª AdÄ±m 1: Test BaÄŸÄ±mlÄ±lÄ±klarÄ±nÄ± Ekle</h2>
<p>Projene Spring Boot test starter'Ä±nÄ± ekle.</p>
<p>Maven:</p>
<pre><code class="language-xml">&#x3C;dependency>
  &#x3C;groupId>org.springframework.boot&#x3C;/groupId>
  &#x3C;artifactId>spring-boot-starter-test&#x3C;/artifactId>
  &#x3C;scope>test&#x3C;/scope>
&#x3C;/dependency>
</code></pre>
<p>Gradle:</p>
<pre><code class="language-groovy">testImplementation 'org.springframework.boot:spring-boot-starter-test'
</code></pre>
<hr>
<h2>ğŸ› ï¸ AdÄ±m 2: Ä°lk Testini Yaz</h2>
<p>Servisi yazmadan Ã¶nce basit birim test oluÅŸtur.</p>
<h3>Java</h3>
<pre><code class="language-java">package com.example.tdd;

import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

class GreetingServiceTest {

    @Test
    void shouldReturnGreetingMessage() {
        GreetingService service = new GreetingService();
        String result = service.greet("World");
        assertEquals("Hello, World!", result);
    }
}
</code></pre>
<h3>Kotlin</h3>
<pre><code class="language-kotlin">package com.example.tdd

import org.junit.jupiter.api.Assertions.assertEquals
import org.junit.jupiter.api.Test

class GreetingServiceTest {

    @Test
    fun shouldReturnGreetingMessage() {
        val service = GreetingService()
        val result = service.greet("World")
        assertEquals("Hello, World!", result)
    }
}
</code></pre>
<hr>
<h2>ğŸ› ï¸ AdÄ±m 3: Servisi OluÅŸturun</h2>
<p>Testi geÃ§ecek ÅŸekilde <code>GreetingService</code> sÄ±nÄ±fÄ±nÄ± oluÅŸtur.</p>
<h3>Java</h3>
<pre><code class="language-java">package com.example.tdd;

public class GreetingService {
    public String greet(String name) {
        return "Hello, " + name + "!";
    }
}
</code></pre>
<h3>Kotlin</h3>
<pre><code class="language-kotlin">package com.example.tdd

class GreetingService {
    fun greet(name: String): String {
        return "Hello, $name!"
    }
}
</code></pre>
<hr>
<h2>â–¶ï¸ UygulamayÄ± Test Et</h2>
<p>Testleri Ã§alÄ±ÅŸtÄ±rmak iÃ§in aÅŸaÄŸÄ±daki komutu kullan:</p>
<pre><code class="language-bash">./mvnw test
</code></pre>
<p>veya</p>
<pre><code class="language-bash">gradle test
</code></pre>
<p>Test baÅŸarÄ±yla geÃ§meli âœ…</p>
<hr>
<h3>Refactor ve Tekrarla</h3>
<p>Test geÃ§tikten sonra kodu gÃ¼venle refactor edebilirsin. TDD dÃ¶ngÃ¼sÃ¼ ÅŸÃ¶yledir:</p>
<ol>
<li>Red â€“ BaÅŸarÄ±sÄ±z test yaz</li>
<li>Green â€“ Testi geÃ§ir</li>
<li>Refactor â€“ Kodu temizle</li>
</ol>
<hr>
<h2>ğŸ SonuÃ§</h2>
<p>ArtÄ±k Test OdaklÄ± GeliÅŸtirme iÃ§in Ã¼retim odaklÄ± bir Spring Boot temeliniz var. Sonraki adÄ±mda ayarlarÄ± kendi domainine uyarlayÄ±p test ve gÃ¶zlemlenebilirlik katmanÄ±nÄ± ekleyerek gerÃ§ek trafik altÄ±nda doÄŸrulayÄ±n.</p>]]></content:encoded>
      <category><![CDATA[Java]]></category>
      <category><![CDATA[Kotlin]]></category>
      <category><![CDATA[Spring Boot]]></category>
      <category><![CDATA[TDD]]></category>
      <category><![CDATA[Test]]></category>
      <media:thumbnail url="https://suaybsimsek.com/images/spring-boot-tdd-thumbnail.webp" />
    </item>
    <item>
      <title><![CDATA[Spring Boot Circuit Breaker]]></title>
      <link>https://suaybsimsek.com/tr/posts/spring-boot-circuit-breaker</link>
      <description><![CDATA[Spring Boot uygulamalarÄ±nda Circuit Breaker kullanÄ±mÄ±nÄ± Ã¶ÄŸrenerek mikro hizmetlerin dayanÄ±klÄ±lÄ±ÄŸÄ±nÄ± artÄ±rÄ±n.]]></description>
      <pubDate>Thu, 13 Mar 2025 00:00:00 GMT</pubDate>
      <atom:updated>2025-03-14T00:00:00.000Z</atom:updated>
      <guid isPermaLink="true">https://suaybsimsek.com/tr/posts/spring-boot-circuit-breaker</guid>
      <content:encoded><![CDATA[<p>Spring Boot Circuit Breaker, mikro hizmetler mimarisinde ardÄ±ÅŸÄ±k hatalarÄ±n Ã¶nlenmesi iÃ§in kullanÄ±lan bir hata toleransÄ± mekanizmasÄ±dÄ±r. HatalarÄ± algÄ±layarak ve saÄŸlÄ±ksÄ±z hizmetlere aÅŸÄ±rÄ± istekleri durdurarak uygulamalarÄ±n hatalarÄ± zarif bir ÅŸekilde yÃ¶netmesine yardÄ±mcÄ± olur. Bu kÄ±lavuz, Spring Boot'ta Resilience4j kullanarak Circuit Breaker uygulamasÄ±nÄ± adÄ±m adÄ±m aÃ§Ä±klamaktadÄ±r.</p>
<hr>
<h2>ğŸŒŸ Neden Circuit Breaker KullanmalÄ±yÄ±z?</h2>
<p>Bu bÃ¶lÃ¼mde Neden Circuit Breaker KullanmalÄ±yÄ±z? konusunu netleÅŸtirip uygulamada kullanacaÄŸÄ±nÄ±z temel noktalarÄ± Ã¶zetliyoruz.</p>
<ul>
<li>Mikro hizmetlerde zincirleme hatalarÄ± Ã¶nler.</li>
<li>Uygulama dayanÄ±klÄ±lÄ±ÄŸÄ±nÄ± artÄ±rÄ±r, aÅŸÄ±rÄ± hatalÄ± istekleri durdurur.</li>
<li>Hizmet saÄŸlÄ±ÄŸÄ± geri kazandÄ±ÄŸÄ±nda otomatik olarak iyileÅŸir.</li>
<li>Gereksiz bekleme sÃ¼relerini Ã¶nleyerek gecikmeyi azaltÄ±r.</li>
<li>HatalarÄ± yÃ¶netmek iÃ§in yapÄ±landÄ±rÄ±labilir yeniden deneme stratejileri sunar.</li>
</ul>
<hr>
<h2>ğŸ“‹ Gereksinimler</h2>
<p>AÅŸaÄŸÄ±dakilere sahip olduÄŸunuzdan emin olun:</p>
<ul>
<li>â˜• Java Development Kit (JDK) 17+</li>
<li>ğŸ“ Maven veya Gradle kurulu</li>
<li>ğŸŒ Spring Boot &#x26; Spring Cloud</li>
<li>ğŸ§ Circuit Breaker davranÄ±ÅŸÄ±nÄ± gÃ¶stermek iÃ§in bir REST API</li>
</ul>
<hr>
<h2>ğŸ› ï¸ AdÄ±m 1: BaÄŸÄ±mlÄ±lÄ±klarÄ± Ekleyin</h2>
<p>Bu bÃ¶lÃ¼mde AdÄ±m 1: BaÄŸÄ±mlÄ±lÄ±klarÄ± Ekleyin konusunu netleÅŸtirip uygulamada kullanacaÄŸÄ±nÄ±z temel noktalarÄ± Ã¶zetliyoruz.</p>
<p>Maven:</p>
<pre><code class="language-xml">&#x3C;dependency>
  &#x3C;groupId>org.springframework.cloud&#x3C;/groupId>
  &#x3C;artifactId>spring-cloud-starter-circuitbreaker-resilience4j&#x3C;/artifactId>
&#x3C;/dependency>
</code></pre>
<p>Gradle:</p>
<pre><code class="language-groovy">implementation 'org.springframework.cloud:spring-cloud-starter-circuitbreaker-resilience4j'
</code></pre>
<hr>
<h2>ğŸ› ï¸ AdÄ±m 2: Circuit Breaker Ã–zelliklerini YapÄ±landÄ±rma</h2>
<p><code>application.yml</code> dosyanÄ±zda Circuit Breaker ayarlarÄ±nÄ± tanÄ±mlayÄ±n.</p>
<pre><code class="language-yaml">resilience4j:
  circuitbreaker:
    instances:
      externalService:
        failure-rate-threshold: 50
        slow-call-rate-threshold: 50
        slow-call-duration-threshold: 2000ms
        permitted-number-of-calls-in-half-open-state: 3
        sliding-window-size: 10
        minimum-number-of-calls: 5
        wait-duration-in-open-state: 5s
</code></pre>
<hr>
<h2>ğŸ› ï¸ AdÄ±m 3: Circuit Breaker Kullanarak Bir REST Servisi Uygulama</h2>
<h3>Java</h3>
<pre><code class="language-java">package com.example.circuitbreaker.service;

import io.github.resilience4j.circuitbreaker.annotation.CircuitBreaker;
import org.springframework.stereotype.Service;
import org.springframework.web.client.RestTemplate;

@Service
public class ExternalService {

    private final RestTemplate restTemplate = new RestTemplate();

    @CircuitBreaker(name = "externalService", fallbackMethod = "fallbackResponse")
    public String callExternalAPI() {
        return restTemplate.getForObject("http://unreliable-service/api/data", String.class);
    }

    public String fallbackResponse(Exception e) {
        return "Fallback response: Service is unavailable!";
    }
}
</code></pre>
<h3>Kotlin</h3>
<pre><code class="language-kotlin">package com.example.circuitbreaker.service

import io.github.resilience4j.circuitbreaker.annotation.CircuitBreaker
import org.springframework.stereotype.Service
import org.springframework.web.client.RestTemplate

@Service
class ExternalService {
    private val restTemplate = RestTemplate()

    @CircuitBreaker(name = "externalService", fallbackMethod = "fallbackResponse")
    fun callExternalAPI(): String {
        return restTemplate.getForObject("http://unreliable-service/api/data", String::class.java) ?: ""
    }

    fun fallbackResponse(e: Exception): String {
        return "Fallback response: Service is unavailable!"
    }
}
</code></pre>
<hr>
<h2>ğŸ› ï¸ AdÄ±m 4: Bir REST Controller OluÅŸturun</h2>
<h3>Java</h3>
<pre><code class="language-java">package com.example.circuitbreaker.controller;

import com.example.circuitbreaker.service.ExternalService;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;

@RestController
@RequestMapping("/api")
public class CircuitBreakerController {

    private final ExternalService externalService;

    public CircuitBreakerController(ExternalService externalService) {
        this.externalService = externalService;
    }

    @GetMapping("/data")
    public String fetchData() {
        return externalService.callExternalAPI();
    }
}
</code></pre>
<h3>Kotlin</h3>
<pre><code class="language-kotlin">package com.example.circuitbreaker.controller

import com.example.circuitbreaker.service.ExternalService
import org.springframework.web.bind.annotation.GetMapping
import org.springframework.web.bind.annotation.RequestMapping
import org.springframework.web.bind.annotation.RestController

@RestController
@RequestMapping("/api")
class CircuitBreakerController(private val externalService: ExternalService) {

    @GetMapping("/data")
    fun fetchData(): String {
        return externalService.callExternalAPI()
    }
}
</code></pre>
<hr>
<h2>â–¶ï¸ UygulamayÄ± Ã‡alÄ±ÅŸtÄ±rma</h2>
<p>UygulamayÄ± baÅŸlatÄ±n:</p>
<pre><code class="language-bash">./mvnw spring-boot:run
</code></pre>
<p>veya Gradle kullanarak:</p>
<pre><code class="language-bash">gradle bootRun
</code></pre>
<hr>
<h2>ğŸ§ª Circuit Breaker'Ä± Test Etme</h2>
<p>Circuit Breakerâ€™Ä± test etmek iÃ§in:</p>
<pre><code class="language-bash">curl -X GET http://localhost:8080/api/data
</code></pre>
<hr>
<h2>ğŸ SonuÃ§</h2>
<p>ArtÄ±k Spring Boot Circuit Breaker iÃ§in Ã¼retim odaklÄ± bir Spring Boot temeliniz var. Sonraki adÄ±mda ayarlarÄ± kendi domainine uyarlayÄ±p test ve gÃ¶zlemlenebilirlik katmanÄ±nÄ± ekleyerek gerÃ§ek trafik altÄ±nda doÄŸrulayÄ±n.</p>]]></content:encoded>
      <category><![CDATA[Java]]></category>
      <category><![CDATA[Kotlin]]></category>
      <category><![CDATA[Spring Boot]]></category>
      <category><![CDATA[Spring Cloud]]></category>
      <category><![CDATA[Circuit Breaker]]></category>
      <category><![CDATA[Mikroservis]]></category>
      <media:thumbnail url="https://suaybsimsek.com/images/spring-boot-circuit-breaker-thumbnail.webp" />
    </item>
    <item>
      <title><![CDATA[Spring Boot Eureka Server]]></title>
      <link>https://suaybsimsek.com/tr/posts/spring-boot-eureka-server</link>
      <description><![CDATA[Mikro hizmet mimarisinde servis keÅŸfi iÃ§in Spring Boot Eureka serverÄ±n nasÄ±l kurulacaÄŸÄ±nÄ± ve yapÄ±landÄ±rÄ±lacaÄŸÄ±nÄ± Ã¶ÄŸrenin.]]></description>
      <pubDate>Sun, 23 Feb 2025 00:00:00 GMT</pubDate>
      <atom:updated>2025-02-24T00:00:00.000Z</atom:updated>
      <guid isPermaLink="true">https://suaybsimsek.com/tr/posts/spring-boot-eureka-server</guid>
      <content:encoded><![CDATA[<p>Spring Boot Eureka Server, mikroservis mimarisinde servis kaydÄ± ve keÅŸfi saÄŸlayan bir servis kayÄ±t merkezi olarak Ã§alÄ±ÅŸÄ±r. Mikroservislerin kendilerini otomatik olarak kaydetmelerine ve diÄŸer servisleri dinamik olarak keÅŸfetmelerine olanak tanÄ±r. Bu kÄ±lavuzda, Spring Boot ile Eureka serverÄ±n nasÄ±l kurulacaÄŸÄ±nÄ± ve yapÄ±landÄ±rÄ±lacaÄŸÄ±nÄ± Ã¶ÄŸreneceksiniz.</p>
<hr>
<h2>ğŸŒŸ Neden Eureka Server KullanmalÄ±yÄ±z?</h2>
<p>Bu bÃ¶lÃ¼mde Neden Eureka Server KullanmalÄ±yÄ±z? konusunu netleÅŸtirip uygulamada kullanacaÄŸÄ±nÄ±z temel noktalarÄ± Ã¶zetliyoruz.</p>
<ul>
<li>Servis KeÅŸfi: Mikro servislerin otomatik olarak kaydolmasÄ±nÄ± ve keÅŸfedilmesini saÄŸlar.</li>
<li>YÃ¼k Dengeleme: Ribbon ile istemci taraflÄ± yÃ¼k dengeleme saÄŸlar.</li>
<li>Hata ToleransÄ±: Bir servis baÅŸarÄ±sÄ±z olursa alternatif Ã¶rnekleri bulmaya yardÄ±mcÄ± olur.</li>
<li>Ã–lÃ§eklenebilirlik: Mikroserivslerin kolayca Ã¶lÃ§eklenmesini saÄŸlar.</li>
<li>Spring Cloud Entegrasyonu: Spring Boot uygulamalarÄ±yla sorunsuz Ã§alÄ±ÅŸÄ±r.</li>
</ul>
<hr>
<h2>ğŸ“‹ Gereksinimler</h2>
<p>AÅŸaÄŸÄ±dakilerin kurulu olduÄŸundan emin olun:</p>
<ul>
<li>â˜• Java Development Kit (JDK) 17+</li>
<li>ğŸ“¦ Maven veya Gradle yÃ¼klÃ¼</li>
</ul>
<hr>
<h2>ğŸ› ï¸ AdÄ±m 1: BaÄŸÄ±mlÄ±lÄ±klarÄ± Ekleyin</h2>
<p>Bu bÃ¶lÃ¼mde AdÄ±m 1: BaÄŸÄ±mlÄ±lÄ±klarÄ± Ekleyin konusunu netleÅŸtirip uygulamada kullanacaÄŸÄ±nÄ±z temel noktalarÄ± Ã¶zetliyoruz.</p>
<p>Maven:</p>
<pre><code class="language-xml">&#x3C;dependency>
    &#x3C;groupId>org.springframework.cloud&#x3C;/groupId>
    &#x3C;artifactId>spring-cloud-starter-netflix-eureka-server&#x3C;/artifactId>
&#x3C;/dependency>
</code></pre>
<p>Gradle:</p>
<pre><code class="language-groovy">implementation 'org.springframework.cloud:spring-cloud-starter-netflix-eureka-server'
</code></pre>
<hr>
<h2>ğŸ› ï¸ AdÄ±m 2: Eureka Sunucu UygulamasÄ±nÄ± OluÅŸturun</h2>
<h3>Java</h3>
<pre><code class="language-java">package com.example.eurekaserver;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;
import org.springframework.cloud.netflix.eureka.server.EnableEurekaServer;

@SpringBootApplication
@EnableEurekaServer
public class EurekaServerApplication {
    public static void main(String[] args) {
        SpringApplication.run(EurekaServerApplication.class, args);
    }
}
</code></pre>
<h3>Kotlin</h3>
<pre><code class="language-kotlin">package com.example.eurekaserver

import org.springframework.boot.autoconfigure.SpringBootApplication
import org.springframework.boot.runApplication
import org.springframework.cloud.netflix.eureka.server.EnableEurekaServer

@SpringBootApplication
@EnableEurekaServer
class EurekaServerApplication

fun main(args: Array&#x3C;String>) {
    runApplication&#x3C;EurekaServerApplication>(*args)
}
</code></pre>
<hr>
<h2>ğŸ› ï¸ AdÄ±m 3: Eureka Server'Ä± YapÄ±landÄ±rma</h2>
<p>Bir <code>application.yml</code> dosyasÄ± oluÅŸturun ve aÅŸaÄŸÄ±daki yapÄ±landÄ±rmayÄ± ekleyin:</p>
<pre><code class="language-yaml">server:
  port: 8761
spring:
  application:
    name: eureka-server
eureka:
  client:
    register-with-eureka: false
    fetch-registry: false
  server:
    wait-time-in-ms-when-sync-empty: 5
</code></pre>
<blockquote>
<p>Not: Eureka Sunucusu kendisini kaydetmez.</p>
</blockquote>
<hr>
<h2>â–¶ï¸ Eureka Server'Ä± Ã‡alÄ±ÅŸtÄ±rma</h2>
<p>Eureka Server uygulamasÄ±nÄ± baÅŸlatÄ±n:</p>
<pre><code class="language-bash">./mvnw spring-boot:run
</code></pre>
<p>veya Gradle kullanarak:</p>
<pre><code class="language-bash">gradle bootRun
</code></pre>
<p>Eureka Server kontrol paneline eriÅŸmek iÃ§in:</p>
<pre><code class="language-bash">http://localhost:8761/
</code></pre>
<hr>
<h2>ğŸ› ï¸ AdÄ±m 4: Bir Ä°stemci UygulamasÄ±nÄ± Kaydetme</h2>
<p>Bu bÃ¶lÃ¼mde AdÄ±m 4: Bir Ä°stemci UygulamasÄ±nÄ± Kaydetme konusunu netleÅŸtirip uygulamada kullanacaÄŸÄ±nÄ±z temel noktalarÄ± Ã¶zetliyoruz.</p>
<h3>BaÄŸÄ±mlÄ±lÄ±klarÄ± Ekleyin</h3>
<p>Bu baÄŸÄ±mlÄ±lÄ±k, uygulamanÄ±n Eureka sunucusuna kayÄ±t olmasÄ± ve servis keÅŸfi sÃ¼recine katÄ±lmasÄ± iÃ§in gereklidir.</p>
<p>Maven:</p>
<pre><code class="language-xml">&#x3C;dependency>
    &#x3C;groupId>org.springframework.cloud&#x3C;/groupId>
    &#x3C;artifactId>spring-cloud-starter-netflix-eureka-client&#x3C;/artifactId>
&#x3C;/dependency>
</code></pre>
<p>Gradle:</p>
<pre><code class="language-groovy">implementation 'org.springframework.cloud:spring-cloud-starter-netflix-eureka-client'
</code></pre>
<h3>Ä°stemci Uygulama YapÄ±landÄ±rmasÄ±</h3>
<p>Ä°stemcinin <code>application.yml</code> dosyasÄ±na aÅŸaÄŸÄ±daki yapÄ±landÄ±rmayÄ± ekleyin:</p>
<pre><code class="language-yaml">spring:
  application:
    name: eureka-client
eureka:
  client:
    service-url:
      defaultZone: http://localhost:8761/eureka/
</code></pre>
<h3>Ä°stemci Uygulama Kodu</h3>
<p>AÅŸaÄŸÄ±daki Ã¶rnek, Ä°stemci Uygulama Kodu iÃ§in pratik bir baÄŸlam sunar ve doÄŸrudan uygulanabilir.</p>
<h3>Java</h3>
<pre><code class="language-java">package com.example.eurekaclient;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;

@SpringBootApplication
@RestController
@RequestMapping("/client")
public class EurekaClientApplication {

    @GetMapping
    public String getClientMessage() {
        return "Merhaba, Eureka Ä°stemcisi!";
    }

    public static void main(String[] args) {
        SpringApplication.run(EurekaClientApplication.class, args);
    }
}
</code></pre>
<h3>Kotlin</h3>
<pre><code class="language-kotlin">package com.example.eurekaclient

import org.springframework.boot.autoconfigure.SpringBootApplication
import org.springframework.boot.runApplication
import org.springframework.web.bind.annotation.GetMapping
import org.springframework.web.bind.annotation.RequestMapping
import org.springframework.web.bind.annotation.RestController

@SpringBootApplication
@RestController
@RequestMapping("/client")
class EurekaClientApplication {

    @GetMapping
    fun getClientMessage(): String {
        return "Merhaba, Eureka Ä°stemcisi!"
    }
}

fun main(args: Array&#x3C;String>) {
    runApplication&#x3C;EurekaClientApplication>(*args)
}
</code></pre>
<hr>
<h2>â–¶ï¸ Ä°stemci UygulamayÄ± Ã‡alÄ±ÅŸtÄ±rma</h2>
<p>Eureka Ä°stemci uygulamasÄ±nÄ± baÅŸlatÄ±n:</p>
<pre><code class="language-bash">./mvnw spring-boot:run
</code></pre>
<p>veya Gradle kullanarak:</p>
<pre><code class="language-bash">gradle bootRun
</code></pre>
<p>Eureka Server'a kayÄ±tlÄ± olup olmadÄ±ÄŸÄ±nÄ± kontrol etmek iÃ§in ÅŸu adresi ziyaret edin:</p>
<pre><code class="language-bash">http://localhost:8761/
</code></pre>
<hr>
<h2>ğŸ SonuÃ§</h2>
<p>ArtÄ±k Spring Boot Eureka Server iÃ§in Ã¼retim odaklÄ± bir Spring Boot temeliniz var. Sonraki adÄ±mda ayarlarÄ± kendi domainine uyarlayÄ±p test ve gÃ¶zlemlenebilirlik katmanÄ±nÄ± ekleyerek gerÃ§ek trafik altÄ±nda doÄŸrulayÄ±n.</p>]]></content:encoded>
      <category><![CDATA[Java]]></category>
      <category><![CDATA[Kotlin]]></category>
      <category><![CDATA[Spring Boot]]></category>
      <category><![CDATA[Spring Cloud]]></category>
      <category><![CDATA[Eureka Server]]></category>
      <category><![CDATA[Mikroservis]]></category>
      <media:thumbnail url="https://suaybsimsek.com/images/spring-boot-eureka-server-thumbnail.webp" />
    </item>
    <item>
      <title><![CDATA[Spring Boot Config Server]]></title>
      <link>https://suaybsimsek.com/tr/posts/spring-boot-config-server</link>
      <description><![CDATA[Spring Boot Config Server kullanarak merkezi yapÄ±landÄ±rma yÃ¶netimini nasÄ±l gerÃ§ekleÅŸtireceÄŸinizi Ã¶ÄŸrenin.]]></description>
      <pubDate>Sat, 22 Feb 2025 00:00:00 GMT</pubDate>
      <atom:updated>2025-02-23T00:00:00.000Z</atom:updated>
      <guid isPermaLink="true">https://suaybsimsek.com/tr/posts/spring-boot-config-server</guid>
      <content:encoded><![CDATA[<p>Spring Boot Config Server, daÄŸÄ±tÄ±lmÄ±ÅŸ uygulamalar iÃ§in merkezi yapÄ±landÄ±rma yÃ¶netimi saÄŸlar ve hizmetlerin yeniden baÅŸlatÄ±lmasÄ±na gerek kalmadan dinamik yapÄ±landÄ±rma gÃ¼ncellemelerine olanak tanÄ±r. Bu kÄ±lavuz, Spring Boot Config Server'Ä± nasÄ±l kuracaÄŸÄ±nÄ±zÄ± ve etkin bir ÅŸekilde kullanacaÄŸÄ±nÄ±zÄ± aÃ§Ä±klar.</p>
<hr>
<h2>ğŸŒŸ Neden Config Server KullanmalÄ±yÄ±z?</h2>
<p>Bu bÃ¶lÃ¼mde Neden Config Server KullanmalÄ±yÄ±z? konusunu netleÅŸtirip uygulamada kullanacaÄŸÄ±nÄ±z temel noktalarÄ± Ã¶zetliyoruz.</p>
<ul>
<li>Merkezi YapÄ±landÄ±rma: Uygulama ayarlarÄ±nÄ± tek bir yerde yÃ¶netin.</li>
<li>Dinamik GÃ¼ncellemeler: YapÄ±landÄ±rmalarÄ± hizmetleri yeniden baÅŸlatmadan gÃ¼ncelleyin.</li>
<li>Environment Profilleri: GeliÅŸtirme, test ve Ã¼retim ortamlarÄ± iÃ§in farklÄ± yapÄ±landÄ±rmalarÄ± destekler.</li>
<li>GÃ¼venlik ve EriÅŸim KontrolÃ¼: Hassas yapÄ±landÄ±rmalarÄ± gÃ¼venli bir ÅŸekilde saklayÄ±n.</li>
<li>Git Entegrasyonu: YapÄ±landÄ±rma sÃ¼rÃ¼mlerini yÃ¶netmek ve izlemek iÃ§in Git kullanÄ±n.</li>
</ul>
<hr>
<h2>ğŸ“‹ Gereksinimler</h2>
<p>AÅŸaÄŸÄ±daki bileÅŸenlerin sisteminizde yÃ¼klÃ¼ olduÄŸundan emin olun:</p>
<ul>
<li>â˜• Java Development Kit (JDK) 17+</li>
<li>ğŸ“¦ Maven veya Gradle yÃ¼klÃ¼</li>
<li>ğŸ“ Git Deposu (YapÄ±landÄ±rmalarÄ± saklamak iÃ§in)</li>
</ul>
<hr>
<h2>ğŸ› ï¸ AdÄ±m 1: BaÄŸÄ±mlÄ±lÄ±klarÄ± Ekleyin</h2>
<p>Spring Cloud Config Server iÃ§in gerekli baÄŸÄ±mlÄ±lÄ±klarÄ± ekleyin.</p>
<p>Maven:</p>
<pre><code class="language-xml">&#x3C;dependency>
    &#x3C;groupId>org.springframework.cloud&#x3C;/groupId>
    &#x3C;artifactId>spring-cloud-config-server&#x3C;/artifactId>
&#x3C;/dependency>
</code></pre>
<p>Gradle:</p>
<pre><code class="language-groovy">implementation 'org.springframework.cloud:spring-cloud-config-server'
</code></pre>
<hr>
<h2>ğŸ› ï¸ AdÄ±m 2: Config Server UygulamasÄ±nÄ± OluÅŸturma</h2>
<h3>Java</h3>
<pre><code class="language-java">package com.example.configserver;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;
import org.springframework.cloud.config.server.EnableConfigServer;

@SpringBootApplication
@EnableConfigServer
public class ConfigServerApplication {
    public static void main(String[] args) {
        SpringApplication.run(ConfigServerApplication.class, args);
    }
}
</code></pre>
<h3>Kotlin</h3>
<pre><code class="language-kotlin">package com.example.configserver

import org.springframework.boot.autoconfigure.SpringBootApplication
import org.springframework.boot.runApplication
import org.springframework.cloud.config.server.EnableConfigServer

@SpringBootApplication
@EnableConfigServer
class ConfigServerApplication

fun main(args: Array&#x3C;String>) {
    runApplication&#x3C;ConfigServerApplication>(*args)
}
</code></pre>
<hr>
<h2>ğŸ› ï¸ AdÄ±m 3: Config Server'Ä± YapÄ±landÄ±rma</h2>
<p>Config ayarlarÄ±nÄ± saklamak iÃ§in Git deposunu belirten bir <code>application.yml</code> dosyasÄ± oluÅŸturun.</p>
<pre><code class="language-yaml">server:
  port: 8888
spring:
  cloud:
    config:
      server:
        git:
          uri: https://github.com/example/config-repo
          default-label: main
</code></pre>
<blockquote>
<p>Not: <code>https://github.com/example/config-repo</code> adresini kendi Git deponuzla deÄŸiÅŸtirin.</p>
</blockquote>
<hr>
<h2>ğŸ› ï¸ AdÄ±m 4: KonfigÃ¼rasyon Deposu OluÅŸturma</h2>
<p>Git deposunda (<code>config-repo</code>) bir <code>application.yml</code> dosyasÄ± oluÅŸturun:</p>
<pre><code class="language-yaml">config.key: 'Merhaba, Config Server!'
</code></pre>
<p>DosyayÄ± ekleyip gÃ¶nderin:</p>
<pre><code class="language-bash">git add application.yml
git commit -m "KonfigÃ¼rasyon dosyasÄ± eklendi"
git push origin main
</code></pre>
<hr>
<h2>â–¶ï¸ Config Server'Ä± Ã‡alÄ±ÅŸtÄ±rma</h2>
<p>Config Server uygulamasÄ±nÄ± baÅŸlatÄ±n:</p>
<pre><code class="language-bash">./mvnw spring-boot:run
</code></pre>
<p>veya Gradle kullanarak:</p>
<pre><code class="language-bash">gradle bootRun
</code></pre>
<p>Config Server'Ä±n Ã§alÄ±ÅŸtÄ±ÄŸÄ±nÄ± doÄŸrulamak iÃ§in ÅŸu komutu Ã§alÄ±ÅŸtÄ±rÄ±n:</p>
<pre><code class="language-bash">curl -X GET http://localhost:8888/application/default
</code></pre>
<p>Beklenen Ã‡Ä±ktÄ±:</p>
<pre><code class="language-json">{
  "name": "application",
  "profiles": ["default"],
  "propertySources": [
    {
      "name": "https://github.com/example/config-repo/application.yml",
      "source": {
        "config.key": "Merhaba, Config Server!"
      }
    }
  ]
}
</code></pre>
<hr>
<h2>ğŸ› ï¸ AdÄ±m 5: Ä°stemci UygulamayÄ± YapÄ±landÄ±rma</h2>
<p>Bu bÃ¶lÃ¼mde AdÄ±m 5: Ä°stemci UygulamayÄ± YapÄ±landÄ±rma konusunu netleÅŸtirip uygulamada kullanacaÄŸÄ±nÄ±z temel noktalarÄ± Ã¶zetliyoruz.</p>
<h3>BaÄŸÄ±mlÄ±lÄ±klarÄ± Ekleme</h3>
<p>Bu adÄ±mda istemcinin Config Server Ã¼zerinden merkezi ayarlarÄ± Ã§ekebilmesi iÃ§in gerekli starter baÄŸÄ±mlÄ±lÄ±ÄŸÄ±nÄ± ekliyoruz.</p>
<p>Maven:</p>
<pre><code class="language-xml">&#x3C;dependency>
    &#x3C;groupId>org.springframework.cloud&#x3C;/groupId>
    &#x3C;artifactId>spring-cloud-starter-config&#x3C;/artifactId>
&#x3C;/dependency>
</code></pre>
<p>Gradle:</p>
<pre><code class="language-groovy">implementation 'org.springframework.cloud:spring-cloud-starter-config'
</code></pre>
<h3>Ä°stemci Uygulama YapÄ±landÄ±rmasÄ±</h3>
<p>Ä°stemci uygulamanÄ±n <code>bootstrap.yml</code> dosyasÄ±na aÅŸaÄŸÄ±daki ayarlarÄ± ekleyin:</p>
<pre><code class="language-yaml">spring:
  application:
    name: config-client
  cloud:
    config:
      uri: http://localhost:8888
</code></pre>
<h3>Ä°stemci Uygulama Kodu</h3>
<p>AÅŸaÄŸÄ±daki Ã¶rnek, Ä°stemci Uygulama Kodu iÃ§in pratik bir baÄŸlam sunar ve doÄŸrudan uygulanabilir.</p>
<h3>Java</h3>
<pre><code class="language-java">package com.example.configclient;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;
import org.springframework.beans.factory.annotation.Value;

@SpringBootApplication
@RestController
@RequestMapping("/config")
public class ConfigClientApplication {

  @Value("${config.key:not found}")
  private String configValue;

  @GetMapping
  public String getConfigValue() {
    return "KonfigÃ¼rasyon DeÄŸeri: " + configValue;
  }

  public static void main(String[] args) {
    SpringApplication.run(ConfigClientApplication.class, args);
  }
}
</code></pre>
<h3>Kotlin</h3>
<pre><code class="language-kotlin">package com.example.configclient

import org.springframework.boot.autoconfigure.SpringBootApplication
import org.springframework.boot.runApplication
import org.springframework.web.bind.annotation.GetMapping
import org.springframework.web.bind.annotation.RequestMapping
import org.springframework.web.bind.annotation.RestController
import org.springframework.beans.factory.annotation.Value

@SpringBootApplication
@RestController
@RequestMapping("/config")
class ConfigClientApplication {

    @Value("\${config.key:not found}")
    private lateinit var configValue: String

    @GetMapping
    fun getConfigValue(): String {
        return "KonfigÃ¼rasyon DeÄŸeri: $configValue"
    }
}

fun main(args: Array&#x3C;String>) {
    runApplication&#x3C;ConfigClientApplication>(*args)
}
</code></pre>
<hr>
<h2>â–¶ï¸ Ä°stemci UygulamayÄ± Ã‡alÄ±ÅŸtÄ±rma</h2>
<p>Ä°stemci uygulamasÄ±nÄ± baÅŸlatmak iÃ§in:</p>
<pre><code class="language-bash">./mvnw spring-boot:run
</code></pre>
<p>veya Gradle kullanarak:</p>
<pre><code class="language-bash">gradle bootRun
</code></pre>
<p>Config Server'dan konfigÃ¼rasyonu almak iÃ§in:</p>
<pre><code class="language-bash">curl -X GET http://localhost:8080/config
</code></pre>
<p>Beklenen Ã‡Ä±ktÄ±:</p>
<pre><code class="language-plaintext">KonfigÃ¼rasyon DeÄŸeri: Merhaba, Config Server!
</code></pre>
<hr>
<h2>ğŸ SonuÃ§</h2>
<p>ArtÄ±k Spring Boot Config Server iÃ§in Ã¼retim odaklÄ± bir Spring Boot temeliniz var. Sonraki adÄ±mda ayarlarÄ± kendi domainine uyarlayÄ±p test ve gÃ¶zlemlenebilirlik katmanÄ±nÄ± ekleyerek gerÃ§ek trafik altÄ±nda doÄŸrulayÄ±n.</p>]]></content:encoded>
      <category><![CDATA[Java]]></category>
      <category><![CDATA[Kotlin]]></category>
      <category><![CDATA[Spring Boot]]></category>
      <category><![CDATA[Spring Cloud]]></category>
      <category><![CDATA[Config Server]]></category>
      <category><![CDATA[Mikroservis]]></category>
      <media:thumbnail url="https://suaybsimsek.com/images/spring-boot-config-server-thumbnail.webp" />
    </item>
    <item>
      <title><![CDATA[Spring Boot Docker Entegrasyonu]]></title>
      <link>https://suaybsimsek.com/tr/posts/spring-boot-docker</link>
      <description><![CDATA[Spring Boot uygulamalarÄ±nÄ± Docker kullanarak Buildpacks ve Jib ile nasÄ±l oluÅŸturup daÄŸÄ±tabileceÄŸinizi Ã¶ÄŸrenin.]]></description>
      <pubDate>Fri, 21 Feb 2025 00:00:00 GMT</pubDate>
      <atom:updated>2025-02-22T00:00:00.000Z</atom:updated>
      <guid isPermaLink="true">https://suaybsimsek.com/tr/posts/spring-boot-docker</guid>
      <content:encoded><![CDATA[<p>Spring Boot, Docker, Buildpacks ve Jib kullanarak uygulamalarÄ± verimli bir ÅŸekilde konteynerleÅŸtirmek iÃ§in birden fazla yÃ¶ntem sunar. Bu kÄ±lavuz, Spring Boot uygulamalarÄ±nÄ± Docker kullanarak oluÅŸturma ve daÄŸÄ±tma sÃ¼reÃ§lerini ele almaktadÄ±r.</p>
<hr>
<h2>ğŸŒŸ Neden Spring Boot Ä°Ã§in Docker KullanmalÄ±yÄ±z?</h2>
<p>Bu bÃ¶lÃ¼mde Neden Spring Boot Ä°Ã§in Docker KullanmalÄ±yÄ±z? konusunu netleÅŸtirip uygulamada kullanacaÄŸÄ±nÄ±z temel noktalarÄ± Ã¶zetliyoruz.</p>
<ul>
<li>TaÅŸÄ±nabilir DaÄŸÄ±tÄ±m: UygulamalarÄ± farklÄ± ortamlar arasÄ±nda tutarlÄ± bir ÅŸekilde Ã§alÄ±ÅŸtÄ±rÄ±n.</li>
<li>Ã–lÃ§eklenebilirlik: KonteynerleÅŸtirilmiÅŸ uygulamalarÄ± kolayca Ã¶lÃ§eklendirin ve yÃ¶netin.</li>
<li>Hafif ve Verimli: Kaynak kullanÄ±mÄ±nÄ± optimize ederek gereksiz yÃ¼kÃ¼ azaltÄ±n.</li>
<li>DevOps Uyumlu: CI/CD pipeline hatlarÄ±na sorunsuz ÅŸekilde entegre edin.</li>
</ul>
<hr>
<h2>ğŸ“‹ Gereksinimler</h2>
<p>AÅŸaÄŸÄ±daki bileÅŸenlere sahip olduÄŸunuzdan emin olun:</p>
<ul>
<li>â˜• Java GeliÅŸtirme Kiti (JDK) 17+</li>
<li>ğŸ“¦ Maven veya Gradle</li>
<li>ğŸ³ Docker yÃ¼klÃ¼ ve Ã§alÄ±ÅŸÄ±r durumda</li>
</ul>
<hr>
<h2>ğŸ› ï¸ AdÄ±m 1: BaÄŸÄ±mlÄ±lÄ±klarÄ± Ekleyin</h2>
<p>Docker desteÄŸini etkinleÅŸtirmek iÃ§in Spring Boot Maven Plugin, Jib Plugin ve Spring Boot Web Starter eklentilerini yapÄ±landÄ±rma dosyanÄ±za ekleyin.</p>
<p>Maven:</p>
<pre><code class="language-xml">&#x3C;dependencies>
    &#x3C;dependency>
        &#x3C;groupId>org.springframework.boot&#x3C;/groupId>
        &#x3C;artifactId>spring-boot-starter-web&#x3C;/artifactId>
    &#x3C;/dependency>
&#x3C;/dependencies>

&#x3C;build>
    &#x3C;plugins>
        &#x3C;plugin>
            &#x3C;groupId>org.springframework.boot&#x3C;/groupId>
            &#x3C;artifactId>spring-boot-maven-plugin&#x3C;/artifactId>
        &#x3C;/plugin>
        &#x3C;plugin>
            &#x3C;groupId>com.google.cloud.tools&#x3C;/groupId>
            &#x3C;artifactId>jib-maven-plugin&#x3C;/artifactId>
            &#x3C;version>3.3.2&#x3C;/version>
        &#x3C;/plugin>
    &#x3C;/plugins>
&#x3C;/build>
</code></pre>
<p>Gradle:</p>
<pre><code class="language-groovy">plugins {
    id 'org.springframework.boot' version '3.2.0'
    id 'com.google.cloud.tools.jib' version '3.3.2'
}

dependencies {
    implementation 'org.springframework.boot:spring-boot-starter-web'
}
</code></pre>
<hr>
<h2>ğŸ› ï¸ AdÄ±m 2: Basit Bir Spring Boot UygulamasÄ± OluÅŸturun</h2>
<p>Docker konteyneri iÃ§inde daÄŸÄ±tÄ±lacak bir REST uÃ§ noktasÄ± tanÄ±mlayÄ±n.</p>
<h3>Java</h3>
<pre><code class="language-java">package com.example.docker;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RestController;

@SpringBootApplication
@RestController
public class DockerApplication {

    public static void main(String[] args) {
        SpringApplication.run(DockerApplication.class, args);
    }

    @GetMapping("/hello")
    public String hello() {
        return "Docker Ã¼zerinde Ã§alÄ±ÅŸan Spring Boot uygulamasÄ±ndan merhaba!";
    }
}
</code></pre>
<h3>Kotlin</h3>
<pre><code class="language-kotlin">package com.example.docker

import org.springframework.boot.autoconfigure.SpringBootApplication
import org.springframework.boot.runApplication
import org.springframework.web.bind.annotation.GetMapping
import org.springframework.web.bind.annotation.RestController

@SpringBootApplication
@RestController
class DockerApplication {

    @GetMapping("/hello")
    fun hello(): String = "Docker Ã¼zerinde Ã§alÄ±ÅŸan Spring Boot uygulamasÄ±ndan merhaba!"
}

fun main(args: Array&#x3C;String>) {
    runApplication&#x3C;DockerApplication>(*args)
}
</code></pre>
<hr>
<h2>â–¶ï¸ AdÄ±m 3: Docker Ä°majÄ± OluÅŸturma ve Ã‡alÄ±ÅŸtÄ±rma</h2>
<p>Bu bÃ¶lÃ¼mde AdÄ±m 3: Docker Ä°majÄ± OluÅŸturma ve Ã‡alÄ±ÅŸtÄ±rma konusunu netleÅŸtirip uygulamada kullanacaÄŸÄ±nÄ±z temel noktalarÄ± Ã¶zetliyoruz.</p>
<h3>SeÃ§enek 1: Buildpacks Kullanarak</h3>
<p>Spring Boot, Buildpacks ile <code>Dockerfile</code> kullanmadan Docker imajlarÄ± oluÅŸturmayÄ± destekler.</p>
<pre><code class="language-bash">mvn spring-boot:build-image
</code></pre>
<pre><code class="language-bash">gradle bootBuildImage
</code></pre>
<p>Konteyneri Ã§alÄ±ÅŸtÄ±rÄ±n:</p>
<pre><code class="language-bash">docker run --rm -p 8080:8080 myproject:0.0.1-SNAPSHOT
</code></pre>
<hr>
<h3>SeÃ§enek 2: Jib Kullanarak</h3>
<p>Jib, Docker daemon olmadan optimize edilmiÅŸ konteyner imajlarÄ± oluÅŸturmayÄ± saÄŸlar.</p>
<pre><code class="language-bash">mvn jib:dockerBuild
</code></pre>
<pre><code class="language-bash">gradle jibDockerBuild
</code></pre>
<p>Jib ile oluÅŸturulan konteyneri Ã§alÄ±ÅŸtÄ±rÄ±n:</p>
<pre><code class="language-bash">docker run --rm -p 8080:8080 myproject:0.0.1-SNAPSHOT
</code></pre>
<hr>
<h2>â–¶ï¸ UygulamayÄ± Ã‡alÄ±ÅŸtÄ±rma</h2>
<p>Konteyner Ã§alÄ±ÅŸtÄ±rÄ±ldÄ±ktan sonra, REST API'yi test edin:</p>
<pre><code class="language-bash">curl -X GET http://localhost:8080/hello
</code></pre>
<p>Beklenen Ã‡Ä±ktÄ±:</p>
<pre><code class="language-plaintext">Docker Ã¼zerinde Ã§alÄ±ÅŸan Spring Boot uygulamasÄ±ndan merhaba!
</code></pre>
<hr>
<h2>ğŸ SonuÃ§</h2>
<p>ArtÄ±k Spring Boot Docker Entegrasyonu iÃ§in Ã¼retim odaklÄ± bir Spring Boot temeliniz var. Sonraki adÄ±mda ayarlarÄ± kendi domainine uyarlayÄ±p test ve gÃ¶zlemlenebilirlik katmanÄ±nÄ± ekleyerek gerÃ§ek trafik altÄ±nda doÄŸrulayÄ±n.</p>]]></content:encoded>
      <category><![CDATA[Java]]></category>
      <category><![CDATA[Kotlin]]></category>
      <category><![CDATA[Spring Boot]]></category>
      <category><![CDATA[Docker]]></category>
      <category><![CDATA[Konteynerizasyon]]></category>
      <category><![CDATA[Jib]]></category>
      <media:thumbnail url="https://suaybsimsek.com/images/spring-boot-docker-thumbnail.webp" />
    </item>
    <item>
      <title><![CDATA[Spring Boot Kubernetes Entegrasyonu]]></title>
      <link>https://suaybsimsek.com/tr/posts/spring-boot-kubernetes</link>
      <description><![CDATA[Spring Boot uygulamalarÄ±nÄ± Kubernetes Ã¼zerinde nasÄ±l Ã¶lÃ§eklenebilir ve konteyner tabanlÄ± olarak daÄŸÄ±tabileceÄŸinizi Ã¶ÄŸrenin.]]></description>
      <pubDate>Fri, 21 Feb 2025 00:00:00 GMT</pubDate>
      <atom:updated>2025-02-22T00:00:00.000Z</atom:updated>
      <guid isPermaLink="true">https://suaybsimsek.com/tr/posts/spring-boot-kubernetes</guid>
      <content:encoded><![CDATA[<p>Spring Boot, Kubernetes ile sorunsuz bir ÅŸekilde bÃ¼tÃ¼nleÅŸerek konteynerleÅŸtirilmiÅŸ, Ã¶lÃ§eklenebilir uygulamalar oluÅŸturmanÄ±za olanak tanÄ±r. Bu rehberde, Spring Boot uygulamalarÄ±nÄ±n Kubernetes kÃ¼mesi iÃ§inde nasÄ±l daÄŸÄ±tÄ±lacaÄŸÄ±nÄ± ve yÃ¶netileceÄŸini Ã¶ÄŸreneceksiniz.</p>
<hr>
<h2>ğŸŒŸ Neden Spring Boot Ä°Ã§in Kubernetes KullanmalÄ±yÄ±z?</h2>
<p>Bu bÃ¶lÃ¼mde Neden Spring Boot Ä°Ã§in Kubernetes KullanmalÄ±yÄ±z? konusunu netleÅŸtirip uygulamada kullanacaÄŸÄ±nÄ±z temel noktalarÄ± Ã¶zetliyoruz.</p>
<ul>
<li>Ã–lÃ§eklenebilirlik: TrafiÄŸe gÃ¶re uygulamalarÄ± otomatik olarak Ã¶lÃ§ekleyin.</li>
<li>Kendi Kendine Ä°yileÅŸme: Kubernetes, baÅŸarÄ±sÄ±z olan konteynerleri otomatik olarak yeniden baÅŸlatÄ±r.</li>
<li>Deklaratif YapÄ±landÄ±rma: YAML dosyalarÄ±yla altyapÄ±nÄ±zÄ± kolayca yÃ¶netin.</li>
<li>YÃ¼k Dengeleme &#x26; Servis KeÅŸfi: Gelen trafiÄŸi etkin bir ÅŸekilde yÃ¶nlendirin.</li>
<li>Verimli Kaynak KullanÄ±mÄ±: CPU ve bellek tÃ¼ketimini dinamik olarak optimize edin.</li>
</ul>
<hr>
<h2>ğŸ“‹ Gereksinimler</h2>
<p>AÅŸaÄŸÄ±daki araÃ§larÄ±n sisteminizde kurulu olduÄŸundan emin olun:</p>
<ul>
<li>â˜• Java GeliÅŸtirme Kiti (JDK) 17+</li>
<li>ğŸ“¦ Maven veya Gradle</li>
<li>ğŸ›  Docker yÃ¼klÃ¼ ve Ã§alÄ±ÅŸÄ±r durumda</li>
<li>ğŸŒ Kubernetes KÃ¼mesi (Minikube veya AWS EKS, GKE, AKS gibi bulut servis saÄŸlayÄ±cÄ±larÄ±)</li>
<li>ğŸ›  kubectl komut satÄ±rÄ± aracÄ±</li>
</ul>
<hr>
<h2>ğŸ› ï¸ AdÄ±m 1: BaÄŸÄ±mlÄ±lÄ±klarÄ± Ekleyin</h2>
<p>Spring Boot Web ve Actuator baÄŸÄ±mlÄ±lÄ±klarÄ±nÄ± ekleyerek uygulamanÄ±n saÄŸlÄ±k durumu apilerini aktif edin.</p>
<p>Maven:</p>
<pre><code class="language-xml">&#x3C;dependencies>
    &#x3C;dependency>
        &#x3C;groupId>org.springframework.boot&#x3C;/groupId>
        &#x3C;artifactId>spring-boot-starter-web&#x3C;/artifactId>
    &#x3C;/dependency>
    &#x3C;dependency>
        &#x3C;groupId>org.springframework.boot&#x3C;/groupId>
        &#x3C;artifactId>spring-boot-starter-actuator&#x3C;/artifactId>
    &#x3C;/dependency>
&#x3C;/dependencies>
</code></pre>
<p>Gradle:</p>
<pre><code class="language-groovy">dependencies {
    implementation 'org.springframework.boot:spring-boot-starter-web'
    implementation 'org.springframework.boot:spring-boot-starter-actuator'
}
</code></pre>
<hr>
<h2>ğŸ› ï¸ AdÄ±m 2: Basit Bir Spring Boot UygulamasÄ± OluÅŸturun</h2>
<p>Kubernetes Ã¼zerinde Ã§alÄ±ÅŸtÄ±rÄ±lacak bir REST endpoint oluÅŸturun.</p>
<h3>Java</h3>
<pre><code class="language-java">package com.example.kubernetes;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RestController;

@SpringBootApplication
@RestController
public class KubernetesApplication {

    public static void main(String[] args) {
        SpringApplication.run(KubernetesApplication.class, args);
    }

    @GetMapping("/hello")
    public String hello() {
        return "Merhaba! Spring Boot Kubernetes Ã¼zerinde Ã§alÄ±ÅŸÄ±yor.";
    }
}
</code></pre>
<h3>Kotlin</h3>
<pre><code class="language-kotlin">package com.example.kubernetes

import org.springframework.boot.autoconfigure.SpringBootApplication
import org.springframework.boot.runApplication
import org.springframework.web.bind.annotation.GetMapping
import org.springframework.web.bind.annotation.RestController

@SpringBootApplication
@RestController
class KubernetesApplication {

    @GetMapping("/hello")
    fun hello(): String = "Merhaba! Spring Boot Kubernetes Ã¼zerinde Ã§alÄ±ÅŸÄ±yor."
}

fun main(args: Array&#x3C;String>) {
    runApplication&#x3C;KubernetesApplication>(*args)
}
</code></pre>
<hr>
<h2>ğŸ› ï¸ AdÄ±m 3: Kubernetes DaÄŸÄ±tÄ±mÄ± ve Servisi TanÄ±mlayÄ±n</h2>
<p>deployment.yaml dosyasÄ±nÄ± oluÅŸturun:</p>
<pre><code class="language-yaml">apiVersion: apps/v1
kind: Deployment
metadata:
  name: spring-boot-app
spec:
  replicas: 2
  selector:
    matchLabels:
      app: spring-boot-app
  template:
    metadata:
      labels:
        app: spring-boot-app
    spec:
      containers:
        - name: spring-boot-app
          image: myproject:0.0.1-SNAPSHOT
          ports:
            - containerPort: 8080
</code></pre>
<p>service.yaml dosyasÄ±nÄ± oluÅŸturun:</p>
<pre><code class="language-yaml">apiVersion: v1
kind: Service
metadata:
  name: spring-boot-service
spec:
  type: LoadBalancer
  selector:
    app: spring-boot-app
  ports:
    - protocol: TCP
      port: 80
      targetPort: 8080
</code></pre>
<p>YAML dosyalarÄ±nÄ± Kubernetes kÃ¼mesine uygulayÄ±n:</p>
<pre><code class="language-bash">kubectl apply -f deployment.yaml
kubectl apply -f service.yaml
</code></pre>
<hr>
<h2>â–¶ï¸ UygulamayÄ± Ã‡alÄ±ÅŸtÄ±rma</h2>
<p>DaÄŸÄ±tÄ±m tamamlandÄ±ktan sonra servis IP adresini alÄ±n:</p>
<pre><code class="language-bash">kubectl get services
</code></pre>
<p>UÃ§ noktayÄ± test edin:</p>
<pre><code class="language-bash">curl -X GET http://servis-adresi/hello
</code></pre>
<p>Beklenen Ã‡Ä±ktÄ±:</p>
<pre><code class="language-plaintext">Merhaba! Spring Boot Kubernetes Ã¼zerinde Ã§alÄ±ÅŸÄ±yor.
</code></pre>
<hr>
<h2>ğŸ SonuÃ§</h2>
<p>ArtÄ±k Spring Boot Kubernetes Entegrasyonu iÃ§in Ã¼retim odaklÄ± bir Spring Boot temeliniz var. Sonraki adÄ±mda ayarlarÄ± kendi domainine uyarlayÄ±p test ve gÃ¶zlemlenebilirlik katmanÄ±nÄ± ekleyerek gerÃ§ek trafik altÄ±nda doÄŸrulayÄ±n.</p>]]></content:encoded>
      <category><![CDATA[Java]]></category>
      <category><![CDATA[Kotlin]]></category>
      <category><![CDATA[Spring Boot]]></category>
      <category><![CDATA[Kubernetes]]></category>
      <category><![CDATA[Mikroservis]]></category>
      <category><![CDATA[Konteynerizasyon]]></category>
      <media:thumbnail url="https://suaybsimsek.com/images/spring-boot-kubernetes-thumbnail.webp" />
    </item>
    <item>
      <title><![CDATA[Spring Boot Asenkron GÃ¶revler]]></title>
      <link>https://suaybsimsek.com/tr/posts/spring-boot-async-tasks</link>
      <description><![CDATA[Spring Boot ile @Async kullanarak gÃ¶revleri ana threadi engellemeden asenkron olarak nasÄ±l Ã§alÄ±ÅŸtÄ±racaÄŸÄ±nÄ±zÄ± Ã¶ÄŸrenin.]]></description>
      <pubDate>Thu, 20 Feb 2025 00:00:00 GMT</pubDate>
      <atom:updated>2025-02-21T00:00:00.000Z</atom:updated>
      <guid isPermaLink="true">https://suaybsimsek.com/tr/posts/spring-boot-async-tasks</guid>
      <content:encoded><![CDATA[<p>Spring Boot, <code>@Async</code> anotasyonu ile arka planda asenkron gÃ¶revler Ã§alÄ±ÅŸtÄ±rmayÄ± kolaylaÅŸtÄ±rÄ±r. Bu, ana threadi engellemeden gÃ¶revleri Ã§alÄ±ÅŸtÄ±rarak uygulamanÄ±n performansÄ±nÄ± artÄ±rmak ve yanÄ±t sÃ¼resini optimize etmek iÃ§in kullanÄ±lÄ±r.</p>
<hr>
<h2>ğŸŒŸ Neden Spring Boot'ta @Async KullanmalÄ±yÄ±z?</h2>
<p>Bu bÃ¶lÃ¼mde Neden Spring Boot'ta @Async KullanmalÄ±yÄ±z? konusunu netleÅŸtirip uygulamada kullanacaÄŸÄ±nÄ±z temel noktalarÄ± Ã¶zetliyoruz.</p>
<ul>
<li>Engellenmeyen Ã‡alÄ±ÅŸtÄ±rma: GÃ¶revleri ana thread'i bekletmeden Ã§alÄ±ÅŸtÄ±rÄ±r.</li>
<li>GeliÅŸtirilmiÅŸ Performans: BaÄŸÄ±msÄ±z gÃ¶revleri paralel olarak yÃ¼rÃ¼tÃ¼r.</li>
<li>Daha Ä°yi Ã–lÃ§eklenebilirlik: DiÄŸer sÃ¼reÃ§ler iÃ§in kaynaklarÄ± serbest bÄ±rakÄ±r.</li>
<li>Kolay Entegrasyon: Spring Bootâ€™un baÄŸÄ±mlÄ±lÄ±k enjeksiyonu ve yaÅŸam dÃ¶ngÃ¼sÃ¼ yÃ¶netimiyle sorunsuz Ã§alÄ±ÅŸÄ±r.</li>
</ul>
<hr>
<h2>ğŸ“‹ Gereksinimler</h2>
<p>Åu gereksinimlere sahip olduÄŸunuzdan emin olun:</p>
<ul>
<li>â˜• Java Development Kit (JDK) 17+</li>
<li>ğŸ“¦ Maven veya Gradle kurulu</li>
<li>ğŸ”¤ Bir Java IDE (IntelliJ IDEA, Eclipse vb.)</li>
</ul>
<hr>
<h2>ğŸ› ï¸ AdÄ±m 1: BaÄŸÄ±mlÄ±lÄ±klarÄ± Ekleyin</h2>
<p>Asenkron iÅŸlemleri etkinleÅŸtirmek iÃ§in spring-boot-starter-web baÄŸÄ±mlÄ±lÄ±ÄŸÄ±nÄ± <code>pom.xml</code> veya <code>build.gradle</code> dosyanÄ±za ekleyin.</p>
<p>Maven:</p>
<pre><code class="language-xml">&#x3C;dependency>
    &#x3C;groupId>org.springframework.boot&#x3C;/groupId>
    &#x3C;artifactId>spring-boot-starter-web&#x3C;/artifactId>
&#x3C;/dependency>
</code></pre>
<p>Gradle:</p>
<pre><code class="language-groovy">implementation 'org.springframework.boot:spring-boot-starter-web'
</code></pre>
<hr>
<h2>ğŸ› ï¸ AdÄ±m 2: UygulamanÄ±zda Asenkron Ä°ÅŸlemi EtkinleÅŸtirin</h2>
<p>Ana uygulama sÄ±nÄ±fÄ±nÄ±za <code>@EnableAsync</code> anotasyonunu ekleyerek asenkron Ã§alÄ±ÅŸmayÄ± etkinleÅŸtirin.</p>
<h3>Java</h3>
<pre><code class="language-java">package com.example.async;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;
import org.springframework.scheduling.annotation.EnableAsync;

@SpringBootApplication
@EnableAsync
public class AsyncApplication {
    public static void main(String[] args) {
        SpringApplication.run(AsyncApplication.class, args);
    }
}
</code></pre>
<h3>Kotlin</h3>
<pre><code class="language-kotlin">package com.example.async

import org.springframework.boot.autoconfigure.SpringBootApplication
import org.springframework.boot.runApplication
import org.springframework.scheduling.annotation.EnableAsync

@SpringBootApplication
@EnableAsync
class AsyncApplication

fun main(args: Array&#x3C;String>) {
    runApplication&#x3C;AsyncApplication>(*args)
}
</code></pre>
<hr>
<h2>ğŸ› ï¸ AdÄ±m 3: Asenkron Bir GÃ¶rev TanÄ±mlayÄ±n</h2>
<p><code>@Async</code> anotasyonunu kullanarak bir asenkron metot tanÄ±mlayÄ±n.</p>
<h3>Java</h3>
<pre><code class="language-java">package com.example.async;

import org.springframework.scheduling.annotation.Async;
import org.springframework.stereotype.Service;
import java.time.LocalTime;

@Service
public class AsyncTask {

    @Async
    public void runTask() {
        System.out.println("Asenkron gÃ¶rev Ã§alÄ±ÅŸtÄ±rÄ±ldÄ±: " + LocalTime.now());
    }
}
</code></pre>
<h3>Kotlin</h3>
<pre><code class="language-kotlin">package com.example.async

import org.springframework.scheduling.annotation.Async
import org.springframework.stereotype.Service
import java.time.LocalTime

@Service
class AsyncTask {

    @Async
    fun runTask() {
        println("Asenkron gÃ¶rev Ã§alÄ±ÅŸtÄ±rÄ±ldÄ±: ${LocalTime.now()}")
    }
}
</code></pre>
<hr>
<h2>ğŸ› ï¸ AdÄ±m 4: Asenkron GÃ¶revleri Tetiklemek iÃ§in Bir Controller OluÅŸturun</h2>
<p>Bir REST controller oluÅŸturarak asenkron iÅŸlemi tetikleyin.</p>
<h3>Java</h3>
<pre><code class="language-java">package com.example.async;

import org.springframework.web.bind.annotation.*;
import lombok.RequiredArgsConstructor;

@RestController
@RequestMapping("/async")
@RequiredArgsConstructor
public class AsyncController {

    private final AsyncTask asyncTask;

    @GetMapping("/run")
    public String triggerAsyncTask() {
        asyncTask.runTask();
        return "Asenkron gÃ¶rev tetiklendi!";
    }
}
</code></pre>
<h3>Kotlin</h3>
<pre><code class="language-kotlin">package com.example.async

import org.springframework.web.bind.annotation.*

@RestController
@RequestMapping("/async")
class AsyncController(
    private val asyncTask: AsyncTask
) {
    @GetMapping("/run")
    fun triggerAsyncTask(): String {
        asyncTask.runTask()
        return "Asenkron gÃ¶rev tetiklendi!"
    }
}
</code></pre>
<hr>
<h2>â–¶ï¸ UygulamayÄ± Ã‡alÄ±ÅŸtÄ±rma</h2>
<p>Spring Boot uygulamasÄ±nÄ± Ã§alÄ±ÅŸtÄ±rÄ±n:</p>
<pre><code class="language-bash">./mvnw spring-boot:run
</code></pre>
<p>Veya Gradle kullanarak:</p>
<pre><code class="language-bash">gradle bootRun
</code></pre>
<hr>
<h2>ğŸ§ª Asenkron GÃ¶revi Test Etme</h2>
<p>Bu bÃ¶lÃ¼mde Asenkron GÃ¶revi Test Etme konusunu netleÅŸtirip uygulamada kullanacaÄŸÄ±nÄ±z temel noktalarÄ± Ã¶zetliyoruz.</p>
<h3>Asenkron GÃ¶revi Tetikleme:</h3>
<p>Bu Ã§aÄŸrÄ± ile asenkron akÄ±ÅŸÄ± tetikleyip gÃ¶rev yÃ¼rÃ¼tÃ¼mÃ¼nÃ¼ loglar Ã¼zerinden takip edebilirsiniz.</p>
<pre><code class="language-bash">curl -X GET http://localhost:8080/async/run
</code></pre>
<h3>Beklenen Konsol Ã‡Ä±ktÄ±sÄ±:</h3>
<p>Kendi log Ã§Ä±ktÄ±nÄ±zÄ± bu Ã¶rnekle karÅŸÄ±laÅŸtÄ±rarak davranÄ±ÅŸÄ±n doÄŸru Ã§alÄ±ÅŸtÄ±ÄŸÄ±nÄ± hÄ±zlÄ±ca teyit edin.</p>
<pre><code class="language-plaintext">Asenkron gÃ¶rev Ã§alÄ±ÅŸtÄ±rÄ±ldÄ±: 12:00:01
</code></pre>
<hr>
<h2>ğŸ SonuÃ§</h2>
<p>ArtÄ±k Spring Boot Asenkron GÃ¶revler iÃ§in Ã¼retim odaklÄ± bir Spring Boot temeliniz var. Sonraki adÄ±mda ayarlarÄ± kendi domainine uyarlayÄ±p test ve gÃ¶zlemlenebilirlik katmanÄ±nÄ± ekleyerek gerÃ§ek trafik altÄ±nda doÄŸrulayÄ±n.</p>]]></content:encoded>
      <category><![CDATA[Java]]></category>
      <category><![CDATA[Kotlin]]></category>
      <category><![CDATA[Spring Boot]]></category>
      <category><![CDATA[Asenkron GÃ¶revler]]></category>
      <media:thumbnail url="https://suaybsimsek.com/images/spring-boot-async-thumbnail.webp" />
    </item>
    <item>
      <title><![CDATA[Spring Boot PlanlanmÄ±ÅŸ GÃ¶revler]]></title>
      <link>https://suaybsimsek.com/tr/posts/spring-boot-scheduled-tasks</link>
      <description><![CDATA[Spring Boot ile @Scheduled anotasyonunu kullanarak belirli aralÄ±klarla veya cron ifadeleriyle arka plan gÃ¶revlerini nasÄ±l Ã§alÄ±ÅŸtÄ±racaÄŸÄ±nÄ±zÄ± Ã¶ÄŸrenin.]]></description>
      <pubDate>Thu, 20 Feb 2025 00:00:00 GMT</pubDate>
      <atom:updated>2025-02-21T00:00:00.000Z</atom:updated>
      <guid isPermaLink="true">https://suaybsimsek.com/tr/posts/spring-boot-scheduled-tasks</guid>
      <content:encoded><![CDATA[<p>Spring Boot, <code>@Scheduled</code> anotasyonu ile arka planda Ã§alÄ±ÅŸan gÃ¶revleri kolayca planlamanÄ±zÄ± saÄŸlar. Bu yÃ¶ntem, periyodik gÃ¶revleri, otomasyon sÃ¼reÃ§lerini ve toplu iÅŸlemleri manuel mÃ¼dahaleye gerek kalmadan yÃ¼rÃ¼tmek iÃ§in idealdir.</p>
<hr>
<h2>ğŸŒŸ Neden Spring Boot @Scheduled KullanmalÄ±yÄ±z?</h2>
<p>Bu bÃ¶lÃ¼mde Neden Spring Boot @Scheduled KullanmalÄ±yÄ±z? konusunu netleÅŸtirip uygulamada kullanacaÄŸÄ±nÄ±z temel noktalarÄ± Ã¶zetliyoruz.</p>
<ul>
<li>GÃ¶revleri OtomatikleÅŸtirin: Ä°ÅŸlemleri belirli aralÄ±klarla Ã§alÄ±ÅŸtÄ±rÄ±n.</li>
<li>KaynaklarÄ± Verimli KullanÄ±n: Ana iÅŸ parÃ§acÄ±klarÄ±nÄ± bloklamadan gÃ¶revleri planlayÄ±n.</li>
<li>FarklÄ± Zamanlama SeÃ§enekleri: Sabit oranlÄ±, sabit gecikmeli veya cron tabanlÄ± zamanlamalar.</li>
<li>Spring Boot Entegrasyonu: Uygulama yaÅŸam dÃ¶ngÃ¼sÃ¼yle sorunsuz Ã§alÄ±ÅŸÄ±r.</li>
</ul>
<hr>
<h2>ğŸ“‹ Gereksinimler</h2>
<p>Åunlara sahip olduÄŸunuzdan emin olun:</p>
<ul>
<li>â˜• Java Development Kit (JDK) 17+</li>
<li>ğŸ“¦ Maven veya Gradle kurulu</li>
<li>ğŸ”¤ Bir Java IDE (IntelliJ IDEA, Eclipse vb.)</li>
</ul>
<hr>
<h2>ğŸ› ï¸ AdÄ±m 1: BaÄŸÄ±mlÄ±lÄ±klarÄ± Ekleyin</h2>
<p>Cron desteÄŸini etkinleÅŸtirmek iÃ§in <code>spring-boot-starter-web</code> baÄŸÄ±mlÄ±lÄ±ÄŸÄ±nÄ± <code>pom.xml</code> veya <code>build.gradle</code> dosyanÄ±za ekleyin.</p>
<p>Maven:</p>
<pre><code class="language-xml">&#x3C;dependency>
    &#x3C;groupId>org.springframework.boot&#x3C;/groupId>
    &#x3C;artifactId>spring-boot-starter-web&#x3C;/artifactId>
&#x3C;/dependency>
</code></pre>
<p>Gradle:</p>
<pre><code class="language-groovy">implementation 'org.springframework.boot:spring-boot-starter-web'
</code></pre>
<blockquote>
<p>Neden <code>spring-boot-starter-web</code>? > <code>@Scheduled</code> anotasyonu Ã§alÄ±ÅŸÄ±rken Spring Context gerektirir. <code>spring-boot-starter-web</code> eklenerek uygulama yaÅŸam dÃ¶ngÃ¼sÃ¼nÃ¼n doÄŸru ÅŸekilde yÃ¶netilmesi saÄŸlanÄ±r.</p>
</blockquote>
<hr>
<h2>ğŸ› ï¸ AdÄ±m 2: Cron EtkinleÅŸtirme</h2>
<p>Cron desteÄŸini etkinleÅŸtirmek iÃ§in ana uygulama sÄ±nÄ±fÄ±nÄ±za <code>@EnableScheduling</code> anotasyonunu ekleyin.</p>
<h3>Java</h3>
<pre><code class="language-java">package com.example.scheduled;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;
import org.springframework.scheduling.annotation.EnableScheduling;

@SpringBootApplication
@EnableScheduling
public class ScheduledApplication {
    public static void main(String[] args) {
        SpringApplication.run(ScheduledApplication.class, args);
    }
}
</code></pre>
<h3>Kotlin</h3>
<pre><code class="language-kotlin">package com.example.scheduled

import org.springframework.boot.autoconfigure.SpringBootApplication
import org.springframework.boot.runApplication
import org.springframework.scheduling.annotation.EnableScheduling

@SpringBootApplication
@EnableScheduling
class ScheduledApplication

fun main(args: Array&#x3C;String>) {
    runApplication&#x3C;ScheduledApplication>(*args)
}
</code></pre>
<hr>
<h2>ğŸ› ï¸ AdÄ±m 3: PlanlanmÄ±ÅŸ Bir GÃ¶rev TanÄ±mlayÄ±n</h2>
<p><code>@Scheduled</code> kullanarak zamanlanmÄ±ÅŸ bir gÃ¶rev oluÅŸturun.</p>
<h3>Java</h3>
<pre><code class="language-java">package com.example.scheduled;

import org.springframework.scheduling.annotation.Scheduled;
import org.springframework.stereotype.Service;
import java.time.LocalTime;

@Service
public class ScheduledTask {

    @Scheduled(fixedRate = 5000)
    public void runTask() {
        System.out.println("PlanlanmÄ±ÅŸ gÃ¶rev Ã§alÄ±ÅŸtÄ±rÄ±ldÄ±: " + LocalTime.now());
    }
}
</code></pre>
<h3>Kotlin</h3>
<pre><code class="language-kotlin">package com.example.scheduled

import org.springframework.scheduling.annotation.Scheduled
import org.springframework.stereotype.Service
import java.time.LocalTime

@Service
class ScheduledTask {

    @Scheduled(fixedRate = 5000)
    fun runTask() {
        println("PlanlanmÄ±ÅŸ gÃ¶rev Ã§alÄ±ÅŸtÄ±rÄ±ldÄ±: ${LocalTime.now()}")
    }
}
</code></pre>
<hr>
<h2>â–¶ï¸ UygulamayÄ± Ã‡alÄ±ÅŸtÄ±rma</h2>
<p>Spring Boot uygulamasÄ±nÄ± Ã§alÄ±ÅŸtÄ±rÄ±n:</p>
<pre><code class="language-bash">./mvnw spring-boot:run
</code></pre>
<p>Veya Gradle kullanarak:</p>
<pre><code class="language-bash">gradle bootRun
</code></pre>
<p>PlanlanmÄ±ÅŸ gÃ¶rev her 5 saniyede bir Ã§alÄ±ÅŸtÄ±rÄ±lacaktÄ±r.</p>
<hr>
<h2>ğŸ§ª PlanlanmÄ±ÅŸ GÃ¶revi Test Etme</h2>
<p>Bu bÃ¶lÃ¼mde PlanlanmÄ±ÅŸ GÃ¶revi Test Etme konusunu netleÅŸtirip uygulamada kullanacaÄŸÄ±nÄ±z temel noktalarÄ± Ã¶zetliyoruz.</p>
<h3>Beklenen Konsol Ã‡Ä±ktÄ±sÄ±:</h3>
<p>Kendi log Ã§Ä±ktÄ±nÄ±zÄ± bu Ã¶rnekle karÅŸÄ±laÅŸtÄ±rarak davranÄ±ÅŸÄ±n doÄŸru Ã§alÄ±ÅŸtÄ±ÄŸÄ±nÄ± hÄ±zlÄ±ca teyit edin.</p>
<pre><code class="language-plaintext">PlanlanmÄ±ÅŸ gÃ¶rev Ã§alÄ±ÅŸtÄ±rÄ±ldÄ±: 12:00:01
PlanlanmÄ±ÅŸ gÃ¶rev Ã§alÄ±ÅŸtÄ±rÄ±ldÄ±: 12:00:06
PlanlanmÄ±ÅŸ gÃ¶rev Ã§alÄ±ÅŸtÄ±rÄ±ldÄ±: 12:00:11
</code></pre>
<hr>
<h2>ğŸ SonuÃ§</h2>
<p>ArtÄ±k Spring Boot PlanlanmÄ±ÅŸ GÃ¶revler iÃ§in Ã¼retim odaklÄ± bir Spring Boot temeliniz var. Sonraki adÄ±mda ayarlarÄ± kendi domainine uyarlayÄ±p test ve gÃ¶zlemlenebilirlik katmanÄ±nÄ± ekleyerek gerÃ§ek trafik altÄ±nda doÄŸrulayÄ±n.</p>]]></content:encoded>
      <category><![CDATA[Java]]></category>
      <category><![CDATA[Kotlin]]></category>
      <category><![CDATA[Spring Boot]]></category>
      <category><![CDATA[PlanlanmÄ±ÅŸ GÃ¶revler]]></category>
      <media:thumbnail url="https://suaybsimsek.com/images/spring-boot-scheduled-thumbnail.webp" />
    </item>
    <item>
      <title><![CDATA[Spring Boot Reaktif Programlama]]></title>
      <link>https://suaybsimsek.com/tr/posts/spring-boot-reactive-programming</link>
      <description><![CDATA[Spring Boot ile Project Reactor ve WebFlux kullanarak yÃ¼ksek performanslÄ±, eÅŸzamanlÄ± iÅŸleme sahip reaktif uygulamalar oluÅŸturmayÄ± Ã¶ÄŸrenin.]]></description>
      <pubDate>Wed, 19 Feb 2025 00:00:00 GMT</pubDate>
      <atom:updated>2025-02-20T00:00:00.000Z</atom:updated>
      <guid isPermaLink="true">https://suaybsimsek.com/tr/posts/spring-boot-reactive-programming</guid>
      <content:encoded><![CDATA[<p>Spring Boot ile Reaktif Programlama, geliÅŸtiricilere bloklamayan, olay gÃ¼dÃ¼mlÃ¼ ve yÃ¼ksek Ã¶lÃ§eklenebilir uygulamalar oluÅŸturma imkanÄ± sunar. Spring WebFlux ve Project Reactor kullanarak eÅŸzamanlÄ± istekleri dÃ¼ÅŸÃ¼k kaynak kullanÄ±mÄ±yla yÃ¶netebilir, mikro hizmetler ve gerÃ§ek zamanlÄ± uygulamalar geliÅŸtirebilirsiniz.</p>
<hr>
<h2>ğŸŒŸ Neden Reaktif Programlama KullanmalÄ±yÄ±z?</h2>
<p>Bu bÃ¶lÃ¼mde Neden Reaktif Programlama KullanmalÄ±yÄ±z? konusunu netleÅŸtirip uygulamada kullanacaÄŸÄ±nÄ±z temel noktalarÄ± Ã¶zetliyoruz.</p>
<ul>
<li>EÅŸzamansÄ±z &#x26; Bloklamayan Ä°ÅŸleme: Birden fazla isteÄŸi iÅŸ parÃ§acÄ±klarÄ±nÄ± bloklamadan verimli bir ÅŸekilde yÃ¶netin.</li>
<li>Daha Ä°yi Ã–lÃ§eklenebilirlik: Daha az kaynak kullanarak daha fazla eÅŸzamanlÄ± kullanÄ±cÄ±yÄ± destekleyin.</li>
<li>Olay GÃ¼dÃ¼mlÃ¼ Model: Mikro hizmetler, gerÃ§ek zamanlÄ± uygulamalar ve veri akÄ±ÅŸÄ± iÅŸleme iÃ§in idealdir.</li>
<li>Dahili Geri BasÄ±nÃ§ (Backpressure): Sistemin aÅŸÄ±rÄ± yÃ¼klenmesini Ã¶nler.</li>
</ul>
<hr>
<h2>ğŸ“‹ Gereksinimler</h2>
<p>Åunlara sahip olduÄŸunuzdan emin olun:</p>
<ul>
<li>â˜• Java Development Kit (JDK) 17+</li>
<li>ğŸ“¦ Maven veya Gradle kurulu</li>
<li>ğŸ”¤ Bir Java IDE (IntelliJ IDEA, Eclipse vb.)</li>
</ul>
<hr>
<h2>ğŸ› ï¸ AdÄ±m 1: BaÄŸÄ±mlÄ±lÄ±klarÄ± Ekleyin</h2>
<p>Spring WebFlux baÄŸÄ±mlÄ±lÄ±ÄŸÄ±nÄ± <code>pom.xml</code> veya <code>build.gradle</code> dosyanÄ±za ekleyin.</p>
<p>Maven:</p>
<pre><code class="language-xml">&#x3C;dependency>
    &#x3C;groupId>org.springframework.boot&#x3C;/groupId>
    &#x3C;artifactId>spring-boot-starter-webflux&#x3C;/artifactId>
&#x3C;/dependency>
</code></pre>
<p>Gradle:</p>
<pre><code class="language-groovy">implementation 'org.springframework.boot:spring-boot-starter-webflux'
</code></pre>
<hr>
<h2>ğŸ› ï¸ AdÄ±m 2: Reaktif REST Controller OluÅŸturun</h2>
<p>Mono ve Flux kullanarak bloklamayan bir REST endpoint'i tanÄ±mlayÄ±n.</p>
<h3>Java</h3>
<pre><code class="language-java">package com.example.reaktif;

import org.springframework.web.bind.annotation.*;
import reactor.core.publisher.Flux;
import reactor.core.publisher.Mono;

import java.time.Duration;
import java.util.List;

@RestController
@RequestMapping("/reaktif")
public class ReaktifController {

    @GetMapping("/mono")
    public Mono&#x3C;String> getMono() {
        return Mono.just("Reaktif Mono'dan Merhaba!");
    }

    @GetMapping("/flux")
    public Flux&#x3C;String> getFlux() {
        return Flux.fromIterable(List.of("Merhaba", "Reaktif", "DÃ¼nya"))
                   .delayElements(Duration.ofSeconds(1));
    }
}
</code></pre>
<h3>Kotlin</h3>
<pre><code class="language-kotlin">package com.example.reaktif

import org.springframework.web.bind.annotation.*
import reactor.core.publisher.Flux
import reactor.core.publisher.Mono
import java.time.Duration

@RestController
@RequestMapping("/reaktif")
class ReaktifController {

    @GetMapping("/mono")
    fun getMono(): Mono&#x3C;String> {
        return Mono.just("Reaktif Mono'dan Merhaba!")
    }

    @GetMapping("/flux")
    fun getFlux(): Flux&#x3C;String> {
        return Flux.just("Merhaba", "Reaktif", "DÃ¼nya")
            .delayElements(Duration.ofSeconds(1))
    }
}
</code></pre>
<hr>
<h2>â–¶ï¸ UygulamayÄ± Ã‡alÄ±ÅŸtÄ±rma</h2>
<p>Spring Boot uygulamasÄ±nÄ± Ã§alÄ±ÅŸtÄ±rÄ±n:</p>
<pre><code class="language-bash">./mvnw spring-boot:run
</code></pre>
<p>Veya Gradle kullanarak:</p>
<pre><code class="language-bash">gradle bootRun
</code></pre>
<hr>
<h2>ğŸ§ª API'yi Test Etme</h2>
<p>Bu bÃ¶lÃ¼mde API'yi Test Etme konusunu netleÅŸtirip uygulamada kullanacaÄŸÄ±nÄ±z temel noktalarÄ± Ã¶zetliyoruz.</p>
<h3>Mono Endpoint Testi:</h3>
<p>Bu kontrol adÄ±mÄ±, endpoint davranÄ±ÅŸÄ±nÄ±n beklenen Ã§Ä±ktÄ± ile uyumunu doÄŸrulamak iÃ§in kullanÄ±lÄ±r.</p>
<pre><code class="language-bash">curl -X GET http://localhost:8080/reaktif/mono
</code></pre>
<p>Beklenen Ã§Ä±ktÄ±:</p>
<pre><code class="language-plaintext">Reaktif Mono'dan Merhaba!
</code></pre>
<h3>Flux Endpoint Testi:</h3>
<p>Bu kontrol adÄ±mÄ±, endpoint davranÄ±ÅŸÄ±nÄ±n beklenen Ã§Ä±ktÄ± ile uyumunu doÄŸrulamak iÃ§in kullanÄ±lÄ±r.</p>
<pre><code class="language-bash">curl -X GET http://localhost:8080/reaktif/flux
</code></pre>
<p>Beklenen Ã§Ä±ktÄ± (her kelime iÃ§in 1 saniyelik gecikme ile):</p>
<pre><code class="language-plaintext">Merhaba
Reaktif
DÃ¼nya
</code></pre>
<hr>
<h2>ğŸ SonuÃ§</h2>
<p>ArtÄ±k Spring Boot Reaktif Programlama iÃ§in Ã¼retim odaklÄ± bir Spring Boot temeliniz var. Sonraki adÄ±mda ayarlarÄ± kendi domainine uyarlayÄ±p test ve gÃ¶zlemlenebilirlik katmanÄ±nÄ± ekleyerek gerÃ§ek trafik altÄ±nda doÄŸrulayÄ±n.</p>]]></content:encoded>
      <category><![CDATA[Java]]></category>
      <category><![CDATA[Kotlin]]></category>
      <category><![CDATA[Spring Boot]]></category>
      <category><![CDATA[Reaktif Programlama]]></category>
      <category><![CDATA[Spring WebFlux]]></category>
      <media:thumbnail url="https://suaybsimsek.com/images/spring-boot-reactive-thumbnail.webp" />
    </item>
    <item>
      <title><![CDATA[Spring Boot ile GraalVM Native Uygulama]]></title>
      <link>https://suaybsimsek.com/tr/posts/spring-boot-graalvm</link>
      <description><![CDATA[Spring Boot uygulamalarÄ±nÄ±zÄ± GraalVM native imajÄ± olarak derleyerek daha hÄ±zlÄ± baÅŸlatma sÃ¼releri ve azaltÄ±lmÄ±ÅŸ kaynak kullanÄ±mÄ± elde etmeyi Ã¶ÄŸrenin.]]></description>
      <pubDate>Sat, 28 Dec 2024 00:00:00 GMT</pubDate>
      <atom:updated>2024-12-29T00:00:00.000Z</atom:updated>
      <guid isPermaLink="true">https://suaybsimsek.com/tr/posts/spring-boot-graalvm</guid>
      <content:encoded><![CDATA[<p>Spring Boot ile GraalVM Native, geliÅŸtiricilere daha hÄ±zlÄ± baÅŸlatma sÃ¼releri, azaltÄ±lmÄ±ÅŸ bellek tÃ¼ketimi ve artÄ±rÄ±lmÄ±ÅŸ gÃ¼venlik sunan uygulamalar oluÅŸturma imkÃ¢nÄ± tanÄ±r. Native imaj desteÄŸi sayesinde, Spring Boot uygulamalarÄ±nÄ±z kaynak kÄ±sÄ±tlÄ± ortamlarda etkin bir ÅŸekilde Ã§alÄ±ÅŸabilir ve modern bulut tabanlÄ± mimariler iÃ§in ideal bir seÃ§enek haline gelir.</p>
<hr>
<h2>ğŸŒŸ Neden GraalVM ile Native Uygulama OluÅŸturalÄ±m?</h2>
<p>Bu bÃ¶lÃ¼mde Neden GraalVM ile Native Uygulama OluÅŸturalÄ±m? konusunu netleÅŸtirip uygulamada kullanacaÄŸÄ±nÄ±z temel noktalarÄ± Ã¶zetliyoruz.</p>
<ul>
<li>Daha HÄ±zlÄ± BaÅŸlatma SÃ¼releri: Native imajlar, JVM tabanlÄ± uygulamalara kÄ±yasla Ã§ok daha hÄ±zlÄ± baÅŸlatÄ±lÄ±r.</li>
<li>AzaltÄ±lmÄ±ÅŸ Kaynak KullanÄ±mÄ±: Native imajlar daha az bellek kullanÄ±r, bu da bulut ve konteynerize ortamlar iÃ§in idealdir.</li>
<li>ArtÄ±rÄ±lmÄ±ÅŸ GÃ¼venlik: Daha kÃ¼Ã§Ã¼k bir runtime ve sÄ±nÄ±rlÄ± bir yÃ¼zey alanÄ± sunar.</li>
</ul>
<hr>
<h2>ğŸ“‹ Gereksinimler</h2>
<p>AÅŸaÄŸÄ±dakilere sahip olduÄŸunuzdan emin olun:</p>
<ul>
<li>â˜• Java Development Kit (JDK) 17+</li>
<li>ğŸ›  GraalVM native-image desteÄŸi ile yÃ¼klenmiÅŸ</li>
<li>ğŸ• Maven veya Gradle</li>
<li>ğŸ³ Docker (opsiyonel, konteyner imajlarÄ± oluÅŸturmak iÃ§in)</li>
</ul>
<hr>
<h2>ğŸ› ï¸ AdÄ±m 1: BaÄŸÄ±mlÄ±lÄ±klarÄ± Ekleyin</h2>
<p><code>pom.xml</code> veya <code>build.gradle</code> dosyanÄ±za GraalVM Native Build Tools eklentisini ekleyin.</p>
<p>Maven:</p>
<pre><code class="language-xml">&#x3C;plugin>
    &#x3C;groupId>org.graalvm.buildtools&#x3C;/groupId>
    &#x3C;artifactId>native-maven-plugin&#x3C;/artifactId>
    &#x3C;version>0.9.20&#x3C;/version>
&#x3C;/plugin>
</code></pre>
<p>Gradle:</p>
<pre><code class="language-groovy">plugins {
    id 'org.graalvm.buildtools.native' version '0.9.20'
}
</code></pre>
<hr>
<h2>ğŸ› ï¸ AdÄ±m 2: Bir REST Controller YazÄ±n</h2>
<p>Native imaj fonksiyonelliÄŸini test etmek iÃ§in basit bir REST endpoint oluÅŸturun.</p>
<h3>Java</h3>
<pre><code class="language-java">package com.example.graalvmnative;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RestController;

@SpringBootApplication
@RestController
public class MyApplication {

    public static void main(String[] args) {
        SpringApplication.run(MyApplication.class, args);
    }

    @GetMapping("/greeting")
    public String greeting() {
        return "Hello from GraalVM Native!";
    }
}
</code></pre>
<h3>Kotlin</h3>
<pre><code class="language-kotlin">package com.example.graalvmnative

import org.springframework.boot.autoconfigure.SpringBootApplication
import org.springframework.boot.runApplication
import org.springframework.web.bind.annotation.GetMapping
import org.springframework.web.bind.annotation.RestController

@SpringBootApplication
@RestController
class MyApplication {

    @GetMapping("/greeting")
    fun greeting(): String = "Hello from GraalVM Native!"
}

fun main(args: Array&#x3C;String>) {
    runApplication&#x3C;MyApplication>(*args)
}
</code></pre>
<hr>
<h2>ğŸ› ï¸ AdÄ±m 3: Native Ä°maj OluÅŸturun</h2>
<p>Bu bÃ¶lÃ¼mde AdÄ±m 3: Native Ä°maj OluÅŸturun konusunu netleÅŸtirip uygulamada kullanacaÄŸÄ±nÄ±z temel noktalarÄ± Ã¶zetliyoruz.</p>
<p>Maven:
Native imaj oluÅŸturmak iÃ§in aÅŸaÄŸÄ±daki komutu Ã§alÄ±ÅŸtÄ±rÄ±n:</p>
<pre><code class="language-bash">mvn -Pnative package
</code></pre>
<p>Gradle:
AÅŸaÄŸÄ±daki komutu Ã§alÄ±ÅŸtÄ±rÄ±n:</p>
<pre><code class="language-bash">gradle nativeCompile
</code></pre>
<hr>
<h2>ğŸ› ï¸ AdÄ±m 4: Docker Ä°majÄ± OluÅŸturun</h2>
<p>Spring Boot, native yÃ¼rÃ¼tÃ¼lebilir dosyalarla Docker imajlarÄ± oluÅŸturmayÄ± destekler.</p>
<p>Maven:</p>
<pre><code class="language-bash">mvn -Pnative spring-boot:build-image
</code></pre>
<p>Gradle:</p>
<pre><code class="language-bash">gradle bootBuildImage
</code></pre>
<p>Docker imajÄ± local olarak hazÄ±r olacak ve aÅŸaÄŸÄ±daki komutla Ã§alÄ±ÅŸtÄ±rÄ±labilir:</p>
<pre><code class="language-bash">docker run --rm -p 8080:8080 myproject:0.0.1-SNAPSHOT
</code></pre>
<hr>
<h2>â–¶ï¸ UygulamayÄ± Ã‡alÄ±ÅŸtÄ±rma</h2>
<p>Bu bÃ¶lÃ¼mde UygulamayÄ± Ã‡alÄ±ÅŸtÄ±rma konusunu netleÅŸtirip uygulamada kullanacaÄŸÄ±nÄ±z temel noktalarÄ± Ã¶zetliyoruz.</p>
<h3>Yerel Olarak Ã‡alÄ±ÅŸtÄ±rma</h3>
<p>Native imajÄ± doÄŸrudan Ã§alÄ±ÅŸtÄ±rabilirsiniz:</p>
<pre><code class="language-bash">./target/myproject
</code></pre>
<h3>Docker'da Ã‡alÄ±ÅŸtÄ±rma</h3>
<p>EÄŸer Docker imajÄ± oluÅŸturduysanÄ±z, aÅŸaÄŸÄ±daki komutu kullanarak Ã§alÄ±ÅŸtÄ±rabilirsiniz:</p>
<pre><code class="language-bash">docker run --rm -p 8080:8080 myproject:0.0.1-SNAPSHOT
</code></pre>
<hr>
<h2>ğŸ§ª API'yÄ± Test Etme</h2>
<p>REST endpoint'i cURL veya Postman kullanarak test edin:</p>
<pre><code class="language-bash">curl -X GET http://localhost:8080/greeting
</code></pre>
<p>Beklenen Ã§Ä±ktÄ±:</p>
<pre><code class="language-plaintext">Hello from GraalVM Native!
</code></pre>
<hr>
<h2>ğŸ SonuÃ§</h2>
<p>ArtÄ±k GraalVM Native Uygulama iÃ§in Ã¼retim odaklÄ± bir Spring Boot temeliniz var. Sonraki adÄ±mda ayarlarÄ± kendi domainine uyarlayÄ±p test ve gÃ¶zlemlenebilirlik katmanÄ±nÄ± ekleyerek gerÃ§ek trafik altÄ±nda doÄŸrulayÄ±n.</p>]]></content:encoded>
      <category><![CDATA[Java]]></category>
      <category><![CDATA[Kotlin]]></category>
      <category><![CDATA[Spring Boot]]></category>
      <category><![CDATA[GraalVM]]></category>
      <category><![CDATA[Native Ä°maj]]></category>
      <media:thumbnail url="https://suaybsimsek.com/images/spring-boot-graalvm-thumbnail.webp" />
    </item>
    <item>
      <title><![CDATA[Spring Boot ile Kafka Entegrasyonu]]></title>
      <link>https://suaybsimsek.com/tr/posts/spring-boot-kafka</link>
      <description><![CDATA[Spring Boot uygulamanÄ±zÄ±n Kafka topicleri aracÄ±lÄ±ÄŸÄ±yla JSON mesajlarÄ± gÃ¶ndermesini ve tÃ¼ketmesini nasÄ±l entegre edeceÄŸinizi Ã¶ÄŸrenin.]]></description>
      <pubDate>Wed, 25 Dec 2024 00:00:00 GMT</pubDate>
      <atom:updated>2024-12-26T00:00:00.000Z</atom:updated>
      <guid isPermaLink="true">https://suaybsimsek.com/tr/posts/spring-boot-kafka</guid>
      <content:encoded><![CDATA[<p>Apache Kafka, gerÃ§ek zamanlÄ± veri iÅŸleme olanaÄŸÄ± saÄŸlayan daÄŸÄ±tÄ±k bir olay akÄ±ÅŸÄ± platformudur. Bu kÄ±lavuz, Spring Boot uygulamasÄ±nda Kafka kullanarak JSON mesajlarÄ±nÄ±n nasÄ±l gÃ¶nderilip tÃ¼ketileceÄŸini gÃ¶stermektedir.</p>
<hr>
<h2>ğŸŒŸ Neden Kafka KullanÄ±lmalÄ±?</h2>
<p>Bu bÃ¶lÃ¼mde Neden Kafka KullanÄ±lmalÄ±? konusunu netleÅŸtirip uygulamada kullanacaÄŸÄ±nÄ±z temel noktalarÄ± Ã¶zetliyoruz.</p>
<ul>
<li>Ã–lÃ§eklenebilir MesajlaÅŸma: BÃ¼yÃ¼k veri hacimlerini sorunsuz bir ÅŸekilde iÅŸleyin.</li>
<li>Hata ToleransÄ±: Veri dayanÄ±klÄ±lÄ±ÄŸÄ± ve yÃ¼ksek eriÅŸilebilirlik saÄŸlar.</li>
<li>GerÃ§ek ZamanlÄ± Veri Ä°ÅŸleme: Verileri anÄ±nda iÅŸleyin ve analiz edin.</li>
<li>Kolay Entegrasyon: Kafka, Spring Boot ile etkin bir geliÅŸtirme iÃ§in kolayca entegre edilebilir.</li>
</ul>
<hr>
<h2>ğŸ“‹ Gereksinimler</h2>
<p>ğŸ“‹ AÅŸaÄŸÄ±dakilere sahip olduÄŸunuzdan emin olun:</p>
<ul>
<li>â˜• Java Development Kit (JDK) 17+</li>
<li>ğŸ“¦ Maven veya Gradle yÃ¼klenmiÅŸ</li>
<li>ğŸ”  Bir Java IDE (IntelliJ IDEA, Eclipse gibi)</li>
<li>ğŸ”  Apache Kafka, yÃ¼klenmiÅŸ ve Ã§alÄ±ÅŸÄ±r durumda</li>
</ul>
<hr>
<h2>ğŸ› ï¸ AdÄ±m 1: BaÄŸÄ±mlÄ±lÄ±klarÄ± Ekleyin</h2>
<p>Kafka'yÄ± Spring Boot projenize entegre etmek iÃ§in aÅŸaÄŸÄ±daki baÄŸÄ±mlÄ±klarÄ± ekleyin:</p>
<ul>
<li>Maven:</li>
</ul>
<pre><code class="language-xml">&#x3C;dependency>
  &#x3C;groupId>org.springframework.kafka&#x3C;/groupId>
  &#x3C;artifactId>spring-kafka&#x3C;/artifactId>
&#x3C;/dependency>
</code></pre>
<ul>
<li>Gradle:</li>
</ul>
<pre><code class="language-groovy">implementation 'org.springframework.kafka:spring-kafka'
</code></pre>
<hr>
<h2>ğŸ› ï¸ AdÄ±m 2: Kafka'yÄ± YapÄ±landÄ±rÄ±n</h2>
<p>Kafka baÄŸlantÄ±sÄ±nÄ± <code>application.properties</code> veya <code>application.yml</code> dosyasÄ±nda yapÄ±landÄ±rÄ±n:</p>
<pre><code class="language-properties">spring.kafka.bootstrap-servers=localhost:9092
spring.kafka.consumer.group-id=my-group
spring.kafka.consumer.auto-offset-reset=earliest
spring.kafka.producer.key-serializer=org.apache.kafka.common.serialization.StringSerializer
spring.kafka.producer.value-serializer=org.springframework.kafka.support.serializer.JsonSerializer
spring.kafka.consumer.value-deserializer=org.springframework.kafka.support.serializer.JsonDeserializer
spring.kafka.consumer.properties.spring.json.trusted.packages=*
</code></pre>
<hr>
<h2>ğŸ› ï¸ AdÄ±m 3: JSON Mesajlar iÃ§in Bir Model OluÅŸturun</h2>
<p>Bu bÃ¶lÃ¼mde AdÄ±m 3: JSON Mesajlar iÃ§in Bir Model OluÅŸturun konusunu netleÅŸtirip uygulamada kullanacaÄŸÄ±nÄ±z temel noktalarÄ± Ã¶zetliyoruz.</p>
<h3>Model SÄ±nÄ±fÄ±</h3>
<p>Bu model, producer, consumer ve controller katmanlarÄ± arasÄ±nda taÅŸÄ±nan mesaj sÃ¶zleÅŸmesini tanÄ±mlar.</p>
<h3>Java</h3>
<pre><code class="language-java">package com.example.kafka.model;

import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;

@Data
@NoArgsConstructor
@AllArgsConstructor
public class Message {
    private String id;
    private String content;
}
</code></pre>
<h3>Kotlin</h3>
<pre><code class="language-kotlin">package com.example.kafka.model

data class Message(
    val id: String,
    val content: String
)
</code></pre>
<hr>
<h2>ğŸ› ï¸ AdÄ±m 4: Kafka Producer ve Consumer UygulamalarÄ±</h2>
<p>Bu bÃ¶lÃ¼mde AdÄ±m 4: Kafka Producer ve Consumer UygulamalarÄ± konusunu netleÅŸtirip uygulamada kullanacaÄŸÄ±nÄ±z temel noktalarÄ± Ã¶zetliyoruz.</p>
<h3>Producer Ã–rneÄŸi</h3>
<p>Bu producer Ã¶rneÄŸi, mesajlarÄ±n hedef topicâ€™e nasÄ±l tutarlÄ± biÃ§imde gÃ¶nderileceÄŸini gÃ¶sterir.</p>
<h3>Java</h3>
<pre><code class="language-java">package com.example.kafka.producer;

import com.example.kafka.model.Message;
import lombok.RequiredArgsConstructor;
import org.springframework.kafka.core.KafkaTemplate;
import org.springframework.stereotype.Service;

@Service
@RequiredArgsConstructor
public class KafkaProducer {

    private final KafkaTemplate&#x3C;String, Message> kafkaTemplate;

    public void sendMessage(String topic, Message message) {
        kafkaTemplate.send(topic, message);
    }
}
</code></pre>
<h3>Kotlin</h3>
<pre><code class="language-kotlin">package com.example.kafka.producer

import com.example.kafka.model.Message
import org.springframework.kafka.core.KafkaTemplate
import org.springframework.stereotype.Service

@Service
class KafkaProducer(private val kafkaTemplate: KafkaTemplate&#x3C;String, Message>) {

    fun sendMessage(topic: String, message: Message) {
        kafkaTemplate.send(topic, message)
    }
}
</code></pre>
<h3>Consumer Ã–rneÄŸi</h3>
<p>Bu consumer Ã¶rneÄŸi, gelen mesajlarÄ±n nasÄ±l okunup iÅŸlendiÄŸini aÃ§Ä±kÃ§a gÃ¶sterir.</p>
<h3>Java</h3>
<pre><code class="language-java">package com.example.kafka.consumer;

import com.example.kafka.model.Message;
import org.springframework.kafka.annotation.KafkaListener;
import org.springframework.stereotype.Service;

@Service
public class KafkaConsumer {

    @KafkaListener(topics = "my-topic", groupId = "my-group")
    public void consumeMessage(Message message) {
        System.out.println("Received message: " + message);
    }
}
</code></pre>
<h3>Kotlin</h3>
<pre><code class="language-kotlin">package com.example.kafka.consumer

import com.example.kafka.model.Message
import org.springframework.kafka.annotation.KafkaListener
import org.springframework.stereotype.Service

@Service
class KafkaConsumer {

    @KafkaListener(topics = ["my-topic"], groupId = "my-group")
    fun consumeMessage(message: Message) {
        println("Received message: $message")
    }
}
</code></pre>
<hr>
<h3>Controller Ã–rneÄŸi</h3>
<p>Bu controller, mesaj akÄ±ÅŸÄ±nÄ± tetiklemek ve sonucu doÄŸrulamak iÃ§in sade bir API yÃ¼zeyi saÄŸlar.</p>
<h3>Java</h3>
<pre><code class="language-java">package com.example.kafka.controller;

import com.example.kafka.model.Message;
import com.example.kafka.producer.KafkaProducer;
import lombok.RequiredArgsConstructor;
import org.springframework.web.bind.annotation.*;

@RestController
@RequestMapping("/kafka")
@RequiredArgsConstructor
public class KafkaController {

    private final KafkaProducer kafkaProducer;

    @PostMapping("/publish")
    public String publishMessage(@RequestParam String topic, @RequestBody Message message) {
        kafkaProducer.sendMessage(topic, message);
        return "Message sent to topic: " + topic;
    }
}
</code></pre>
<h3>Kotlin</h3>
<pre><code class="language-kotlin">package com.example.kafka.controller

import com.example.kafka.model.Message
import com.example.kafka.producer.KafkaProducer
import org.springframework.web.bind.annotation.*

@RestController
@RequestMapping("/kafka")
class KafkaController(private val kafkaProducer: KafkaProducer) {

    @PostMapping("/publish")
    fun publishMessage(@RequestParam topic: String, @RequestBody message: Message): String {
        kafkaProducer.sendMessage(topic, message)
        return "Message sent to topic: $topic"
    }
}
</code></pre>
<hr>
<h2>â–¶ï¸ UygulamayÄ± Ã‡alÄ±ÅŸtÄ±rma</h2>
<p>UygulamayÄ± aÅŸaÄŸÄ±daki komutla Ã§alÄ±ÅŸtÄ±rÄ±n:</p>
<pre><code class="language-bash">./mvnw spring-boot:run
</code></pre>
<hr>
<h2>ğŸ§ª API'yi Test Etme</h2>
<p>Kafka Producer apisini cURL veya Postman kullanarak test edebilirsiniz:</p>
<pre><code class="language-bash">curl -X POST "http://localhost:8080/kafka/publish" \
-H "Content-Type: application/json" \
-d '{"id": "123", "content": "Hello Kafka!"}'
</code></pre>
<hr>
<h2>ğŸ SonuÃ§</h2>
<p>ArtÄ±k Kafka Entegrasyonu iÃ§in Ã¼retim odaklÄ± bir Spring Boot temeliniz var. Sonraki adÄ±mda ayarlarÄ± kendi domainine uyarlayÄ±p test ve gÃ¶zlemlenebilirlik katmanÄ±nÄ± ekleyerek gerÃ§ek trafik altÄ±nda doÄŸrulayÄ±n.</p>]]></content:encoded>
      <category><![CDATA[Java]]></category>
      <category><![CDATA[Kotlin]]></category>
      <category><![CDATA[Spring Boot]]></category>
      <category><![CDATA[Kafka]]></category>
      <category><![CDATA[MesajlaÅŸma]]></category>
      <media:thumbnail url="https://suaybsimsek.com/images/spring-boot-kafka-thumbnail.webp" />
    </item>
    <item>
      <title><![CDATA[Spring Boot ile Redis Ã–nbellekleme]]></title>
      <link>https://suaybsimsek.com/tr/posts/spring-boot-redis-caching</link>
      <description><![CDATA[Spring Boot uygulamanÄ±za Redis Ã¶nbellekleme uygulayarak performansÄ±nÄ± ve verimliliÄŸini artÄ±rmayÄ± Ã¶ÄŸrenin.]]></description>
      <pubDate>Sun, 22 Dec 2024 00:00:00 GMT</pubDate>
      <atom:updated>2024-12-23T00:00:00.000Z</atom:updated>
      <guid isPermaLink="true">https://suaybsimsek.com/tr/posts/spring-boot-redis-caching</guid>
      <content:encoded><![CDATA[<p>Redis, genellikle Ã¶nbellekleme, mesajlaÅŸma ve gerÃ§ek zamanlÄ± veri yÃ¶netimi iÃ§in kullanÄ±lan gÃ¼Ã§lÃ¼ bir bellek iÃ§i veri deposudur. Bu kÄ±lavuz, Redis'i hem Java hem de Kotlin kullanarak bir Spring Boot uygulamasÄ±na nasÄ±l entegre edeceÄŸinizi aÃ§Ä±klar.</p>
<hr>
<h2>ğŸŒŸ Neden Redis KullanmalÄ±yÄ±z?</h2>
<p>Bu bÃ¶lÃ¼mde Neden Redis KullanmalÄ±yÄ±z? konusunu netleÅŸtirip uygulamada kullanacaÄŸÄ±nÄ±z temel noktalarÄ± Ã¶zetliyoruz.</p>
<ul>
<li>YÃ¼ksek Performans: Redis, okuma ve yazma iÅŸlemleri iÃ§in son derece dÃ¼ÅŸÃ¼k gecikme sÃ¼releri saÄŸlar.</li>
<li>Esnek Veri YapÄ±larÄ±: String, hash, liste, set ve daha fazlasÄ±nÄ± destekler.</li>
<li>Ã–lÃ§Ã¼klenebilirlik: DaÄŸÄ±tÄ±k Ã¶nbellekleme ve gerÃ§ek zamanlÄ± analitik iÃ§in idealdir.</li>
<li>Kolay Entegrasyon: Spring Boot ile kolayca entegre edilebilir.</li>
</ul>
<hr>
<h2>ğŸ“‹ Gereksinimler</h2>
<p>ğŸ‘ˆ AÅŸaÄŸÄ±dakilere sahip olduÄŸunuzdan emin olun:</p>
<ul>
<li>â˜• Java Development Kit (JDK) 17+</li>
<li>ğŸ“¦ Maven veya Gradle yÃ¼klenmiÅŸ</li>
<li>ğŸ„¤ Bir Java IDE (IntelliJ IDEA, Eclipse gibi)</li>
<li>ğŸ”  Redis Sunucusu, lokal olarak yÃ¼klenmiÅŸ veya aÄŸa eriÅŸilebilir</li>
</ul>
<hr>
<h2>ğŸ› ï¸ AdÄ±m 1: BaÄŸÄ±mlÄ±lÄ±klarÄ± Ekleyin</h2>
<p>Redis'i Spring Boot projenize entegre etmek iÃ§in aÅŸaÄŸÄ±daki baÄŸÄ±mlÄ±klarÄ± ekleyin:</p>
<ul>
<li>Maven:</li>
</ul>
<pre><code class="language-xml">&#x3C;dependency>
  &#x3C;groupId>org.springframework.boot&#x3C;/groupId>
  &#x3C;artifactId>spring-boot-starter-data-redis&#x3C;/artifactId>
&#x3C;/dependency>
</code></pre>
<ul>
<li>Gradle:</li>
</ul>
<pre><code class="language-groovy">implementation 'org.springframework.boot:spring-boot-starter-data-redis'
</code></pre>
<hr>
<h2>ğŸ› ï¸ AdÄ±m 2: Redis'i YapÄ±landÄ±rÄ±n</h2>
<p>Redis baÄŸlantÄ±sÄ±nÄ± <code>application.properties</code> veya <code>application.yml</code> dosyanÄ±zda yapÄ±landÄ±rÄ±n.</p>
<h3>Ã–rnek YapÄ±landÄ±rma:</h3>
<p>AÅŸaÄŸÄ±daki Ã¶rnek, Ã–rnek YapÄ±landÄ±rma iÃ§in pratik bir baÄŸlam sunar ve doÄŸrudan uygulanabilir.</p>
<pre><code class="language-properties">spring.redis.host=localhost
spring.redis.port=6379
</code></pre>
<p>Parola doÄŸrulama veya SSL gibi ileri dÃ¼zey kurulumlar iÃ§in ÅŸunlarÄ± ekleyin:</p>
<pre><code class="language-properties">spring.redis.password=sifre
spring.redis.ssl=true
</code></pre>
<hr>
<h2>ğŸ› ï¸ AdÄ±m 3: Ã–nbelleÄŸi EtkinleÅŸtirin</h2>
<p>Ana uygulama sÄ±nÄ±fÄ±nÄ±za <code>@EnableCaching</code> ekleyin:</p>
<h3>Java</h3>
<pre><code class="language-java">package com.example.redis;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;
import org.springframework.cache.annotation.EnableCaching;

@SpringBootApplication
@EnableCaching
public class RedisApplication {
  public static void main(String[] args) {
    SpringApplication.run(RedisApplication.class, args);
  }
}
</code></pre>
<h3>Kotlin</h3>
<pre><code class="language-kotlin">package com.example.redis

import org.springframework.boot.autoconfigure.SpringBootApplication
import org.springframework.boot.runApplication
import org.springframework.cache.annotation.EnableCaching

@SpringBootApplication
@EnableCaching
class RedisApplication

fun main(args: Array&#x3C;String>) {
  runApplication&#x3C;RedisApplication>(*args)
}
</code></pre>
<hr>
<h3>Servis KatmanÄ±nda Ã–nbellekleme Ã–rneÄŸi</h3>
<p>AÅŸaÄŸÄ±daki Ã¶rnek, Servis KatmanÄ±nda Ã–nbellekleme Ã–rneÄŸi iÃ§in pratik bir baÄŸlam sunar ve doÄŸrudan uygulanabilir.</p>
<h3>Java</h3>
<pre><code class="language-java">package com.example.redis.service;

import org.springframework.cache.annotation.Cacheable;
import org.springframework.stereotype.Service;

@Service
public class UserService {

  @Cacheable("users")
  public String getUserById(String id) {
    simulateSlowService();
    return "User with ID: " + id;
  }

  private void simulateSlowService() {
    try {
      Thread.sleep(3000L);
    } catch (InterruptedException e) {
      throw new IllegalStateException(e);
    }
  }
}
</code></pre>
<h3>Kotlin</h3>
<pre><code class="language-kotlin">package com.example.redis.service

import org.springframework.cache.annotation.Cacheable
import org.springframework.stereotype.Service

@Service
class UserService {

  @Cacheable("users")
  fun getUserById(id: String): String {
    simulateSlowService()
    return "User with ID: $id"
  }

  private fun simulateSlowService() {
    Thread.sleep(3000L)
  }
}
</code></pre>
<hr>
<h3>Ã–nbellek Zaman AÅŸÄ±mÄ± (TTL) YapÄ±landÄ±rmasÄ±</h3>
<p><code>application.properties</code> dosyasÄ±nda Ã¶nbellek sona erme sÃ¼relerini ayarlayÄ±n:</p>
<pre><code class="language-properties">spring.cache.redis.time-to-live=600000
</code></pre>
<p>Bu, zaman aÅŸÄ±mÄ±nÄ± 10 dakika (600.000 milisaniye) olarak ayarlar.</p>
<hr>
<h3>Controller Ã–rneÄŸi</h3>
<p>Ã–nbellekleme iÅŸlevini expose etmek iÃ§in bir REST Controller oluÅŸturun.</p>
<h3>Java</h3>
<pre><code class="language-java">package com.example.redis.controller;

import com.example.redis.service.UserService;
import lombok.RequiredArgsConstructor;
import org.springframework.web.bind.annotation.*;

@RestController
@RequestMapping("/users")
@RequiredArgsConstructor
public class UserController {

  private final UserService userService;

  @GetMapping("/{id}")
  public String getUser(@PathVariable String id) {
    return userService.getUserById(id);
  }
}
</code></pre>
<h3>Kotlin</h3>
<pre><code class="language-kotlin">package com.example.redis.controller

import com.example.redis.service.UserService
import org.springframework.web.bind.annotation.*

@RestController
@RequestMapping("/users")
class UserController(
  private val userService: UserService
) {
  @GetMapping("/{id}")
  fun getUser(@PathVariable id: String): String = userService.getUserById(id)
}
</code></pre>
<hr>
<h2>â–¶ï¸ UygulamayÄ± Ã‡alÄ±ÅŸtÄ±rma</h2>
<p>UygulamayÄ± aÅŸaÄŸÄ±daki komutla Ã§alÄ±ÅŸtÄ±rÄ±n:</p>
<pre><code class="language-bash">./mvnw spring-boot:run
</code></pre>
<hr>
<h2>ğŸ§ª APIâ€™yÄ± Test Etme</h2>
<p>APIâ€™yÄ± cURL veya Postman kullanarak test edebilirsiniz:</p>
<ul>
<li>Bir KullanÄ±cÄ±yÄ± Getir (Ã¶nbellekli):</li>
</ul>
<pre><code class="language-bash">curl -X GET http://localhost:8080/users/1
</code></pre>
<hr>
<h2>ğŸ SonuÃ§</h2>
<p>ArtÄ±k Redis Ã–nbellekleme iÃ§in Ã¼retim odaklÄ± bir Spring Boot temeliniz var. Sonraki adÄ±mda ayarlarÄ± kendi domainine uyarlayÄ±p test ve gÃ¶zlemlenebilirlik katmanÄ±nÄ± ekleyerek gerÃ§ek trafik altÄ±nda doÄŸrulayÄ±n.</p>]]></content:encoded>
      <category><![CDATA[Java]]></category>
      <category><![CDATA[Kotlin]]></category>
      <category><![CDATA[Spring Boot]]></category>
      <category><![CDATA[Redis]]></category>
      <category><![CDATA[Ã–nbellekleme]]></category>
      <media:thumbnail url="https://suaybsimsek.com/images/spring-boot-redis-thumbnail.webp" />
    </item>
    <item>
      <title><![CDATA[Spring Boot ile OpenAPI]]></title>
      <link>https://suaybsimsek.com/tr/posts/spring-boot-openapi</link>
      <description><![CDATA[SpringDoc kullanarak Spring Boot uygulamanÄ±zda OpenAPI entegrasyonu ile API dokÃ¼mantasyonu ve test yÃ¶ntemlerini Ã¶ÄŸrenin.]]></description>
      <pubDate>Fri, 20 Dec 2024 00:00:00 GMT</pubDate>
      <atom:updated>2024-12-21T00:00:00.000Z</atom:updated>
      <guid isPermaLink="true">https://suaybsimsek.com/tr/posts/spring-boot-openapi</guid>
      <content:encoded><![CDATA[<p>OpenAPI, API dokÃ¼mantasyonu ve test iÅŸlemlerini kolaylaÅŸtÄ±ran etkileÅŸimli bir arayÃ¼z ve makine tarafÄ±ndan okunabilir belgeler saÄŸlar. Bu kÄ±lavuz, SpringDoc kullanarak OpenAPI'yi Spring Boot uygulamanÄ±za entegre etmenin yollarÄ±nÄ± gÃ¶sterecektir.</p>
<hr>
<h2>ğŸŒŸ Neden OpenAPI KullanmalÄ±yÄ±z?</h2>
<p>Bu bÃ¶lÃ¼mde Neden OpenAPI KullanmalÄ±yÄ±z? konusunu netleÅŸtirip uygulamada kullanacaÄŸÄ±nÄ±z temel noktalarÄ± Ã¶zetliyoruz.</p>
<ul>
<li>EtkileÅŸimli DokÃ¼mantasyon: API'leri keÅŸfetmek iÃ§in kullanÄ±cÄ± dostu bir arayÃ¼z saÄŸlar.</li>
<li>StandartlaÅŸtÄ±rÄ±lmÄ±ÅŸ Format: Makine tarafÄ±ndan okunabilir API tanÄ±mlarÄ± oluÅŸturur.</li>
<li>Kolay Test: Endpoint'leri test etmek iÃ§in yerleÅŸik araÃ§lar sunar.</li>
<li>Ä°stemci Kod Ãœretimi: Ã‡eÅŸitli programlama dilleri iÃ§in otomatik istemci kodu Ã¼retimi saÄŸlar.</li>
</ul>
<hr>
<h2>ğŸ“‹ Gereksinimler</h2>
<p>ğŸ“‹ Åunlara sahip olduÄŸunuzdan emin olun:</p>
<ul>
<li>â˜• Java Development Kit (JDK) 17+</li>
<li>ğŸ“¦ Maven veya Gradle yÃ¼klÃ¼</li>
<li>ğŸ”¤ Bir Java IDE (Ã–rneÄŸin IntelliJ IDEA, Eclipse)</li>
</ul>
<hr>
<h2>ğŸ› ï¸ AdÄ±m 1: BaÄŸÄ±mlÄ±lÄ±klarÄ± Ekleyin</h2>
<p>SpringDoc kullanarak OpenAPI'yi entegre etmek iÃ§in aÅŸaÄŸÄ±daki baÄŸÄ±mlÄ±lÄ±ÄŸÄ± projenize ekleyin:</p>
<ul>
<li>Maven:</li>
</ul>
<pre><code class="language-xml">&#x3C;dependency>
  &#x3C;groupId>org.springdoc&#x3C;/groupId>
  &#x3C;artifactId>springdoc-openapi-starter-webmvc-ui&#x3C;/artifactId>
  &#x3C;version>2.1.0&#x3C;/version>
&#x3C;/dependency>
</code></pre>
<ul>
<li>Gradle:</li>
</ul>
<pre><code class="language-groovy">implementation 'org.springdoc:springdoc-openapi-starter-webmvc-ui:2.1.0'
</code></pre>
<hr>
<h2>ğŸ› ï¸ AdÄ±m 2: OpenAPI'yi YapÄ±landÄ±rÄ±n</h2>
<p>SpringDoc minimal konfigÃ¼rasyon gerektirir. <code>application.properties</code> veya <code>application.yml</code> dosyasÄ± Ã¼zerinden dokÃ¼mantasyonu Ã¶zelleÅŸtirebilirsiniz.</p>
<h3>Ã–rnek KonfigÃ¼rasyon:</h3>
<p>Bu yapÄ±landÄ±rmayÄ± baÅŸlangÄ±Ã§ noktasÄ± olarak alÄ±n, sonra ortamÄ±nÄ±za gÃ¶re deÄŸerleri uyarlayÄ±n.</p>
<pre><code class="language-properties">springdoc.api-docs.path=/api-docs
springdoc.swagger-ui.path=/swagger-ui.html
</code></pre>
<hr>
<h2>ğŸ› ï¸ AdÄ±m 3: REST Kontrollerinizi Anotasyonlarla Belgeleyin</h2>
<p>REST kontrollerinize ve modellerinize anotasyonlar ekleyerek OpenAPI dokÃ¼mantasyonunu otomatik olarak oluÅŸturabilirsiniz.</p>
<h3>Java</h3>
<p>Controller Ã–rneÄŸi</p>
<pre><code class="language-java">package com.example.openapi.controller;

import com.example.openapi.model.User;
import io.swagger.v3.oas.annotations.Operation;
import io.swagger.v3.oas.annotations.media.Content;
import io.swagger.v3.oas.annotations.responses.ApiResponse;
import org.springframework.web.bind.annotation.*;

import java.util.List;

@RestController
@RequestMapping("/users")
public class UserController {

  @Operation(summary = "TÃ¼m kullanÄ±cÄ±larÄ± getir", description = "KullanÄ±cÄ± listesini alÄ±r")
  @ApiResponse(responseCode = "200", description = "BaÅŸarÄ±lÄ± iÅŸlem",
    content = @Content(mediaType = "application/json"))
  @GetMapping
  public List&#x3C;User> getAllUsers() {
    return List.of(new User(1L, "John Doe", "john@example.com"));
  }

  @Operation(summary = "Yeni bir kullanÄ±cÄ± oluÅŸtur", description = "Sisteme yeni bir kullanÄ±cÄ± ekler")
  @ApiResponse(responseCode = "201", description = "KullanÄ±cÄ± baÅŸarÄ±yla oluÅŸturuldu",
    content = @Content(mediaType = "application/json"))
  @PostMapping
  public User createUser(@RequestBody User user) {
    return user;
  }
}
</code></pre>
<p>User Model</p>
<pre><code class="language-java">package com.example.openapi.model;

import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;

@Data
@NoArgsConstructor
@AllArgsConstructor
public class User {

    private Long id;
    private String name;
    private String email;
}
</code></pre>
<h3>Kotlin</h3>
<p>Controller Ã–rneÄŸi</p>
<pre><code class="language-kotlin">package com.example.openapi.controller

import com.example.openapi.model.User
import io.swagger.v3.oas.annotations.*
import io.swagger.v3.oas.annotations.responses.*
import io.swagger.v3.oas.annotations.media.*
import org.springframework.web.bind.annotation.*

@RestController
@RequestMapping("/users")
class UserController {

    @Operation(summary = "TÃ¼m kullanÄ±cÄ±larÄ± getir", description = "KullanÄ±cÄ± listesini alÄ±r")
    @ApiResponse(responseCode = "200", description = "BaÅŸarÄ±lÄ± iÅŸlem",
                 content = [Content(mediaType = "application/json")])
    @GetMapping
    fun getAllUsers(): List&#x3C;User> = listOf(User(1L, "John Doe", "john@example.com"))

    @Operation(summary = "Yeni bir kullanÄ±cÄ± oluÅŸtur", description = "Sisteme yeni bir kullanÄ±cÄ± ekler")
    @ApiResponse(responseCode = "201", description = "KullanÄ±cÄ± baÅŸarÄ±yla oluÅŸturuldu",
                 content = [Content(mediaType = "application/json")])
    @PostMapping
    fun createUser(@RequestBody user: User): User = user
}
</code></pre>
<p>User Model</p>
<pre><code class="language-kotlin">package com.example.openapi.model

data class User(
  val id: Long,
  val name: String,
  val email: String
)
</code></pre>
<hr>
<h2>â–¶ï¸ UygulamayÄ± Ã‡alÄ±ÅŸtÄ±rma</h2>
<p>UygulamayÄ± aÅŸaÄŸÄ±daki komutla Ã§alÄ±ÅŸtÄ±rÄ±n:</p>
<pre><code class="language-bash">./mvnw spring-boot:run
</code></pre>
<p>OpenAPI dokÃ¼mantasyonuna eriÅŸmek iÃ§in:</p>
<ul>
<li>API Docs: <code>http://localhost:8080/api-docs</code></li>
<li>Swagger UI: <code>http://localhost:8080/swagger-ui.html</code></li>
</ul>
<hr>
<h2>ğŸ§ª API'yi Test Etme</h2>
<p>Swagger UI arayÃ¼zÃ¼ne eriÅŸerek oluÅŸturulan API dokÃ¼mantasyonunu test edebilirsiniz:</p>
<ol>
<li>TarayÄ±cÄ±nÄ±zda <code>http://localhost:8080/swagger-ui.html</code> adresine gidin.</li>
<li>Endpoint'leri etkileÅŸimli olarak test etmek iÃ§in giriÅŸler yapÄ±n ve yanÄ±tlarÄ± gÃ¶zlemleyin.</li>
</ol>
<hr>
<h2>ğŸ SonuÃ§</h2>
<p>ArtÄ±k OpenAPI iÃ§in Ã¼retim odaklÄ± bir Spring Boot temeliniz var. Sonraki adÄ±mda ayarlarÄ± kendi domainine uyarlayÄ±p test ve gÃ¶zlemlenebilirlik katmanÄ±nÄ± ekleyerek gerÃ§ek trafik altÄ±nda doÄŸrulayÄ±n.</p>]]></content:encoded>
      <category><![CDATA[Java]]></category>
      <category><![CDATA[Kotlin]]></category>
      <category><![CDATA[Spring Boot]]></category>
      <category><![CDATA[OpenAPI]]></category>
      <category><![CDATA[DokÃ¼mantasyon]]></category>
      <media:thumbnail url="https://suaybsimsek.com/images/spring-boot-openapi-thumbnail.webp" />
    </item>
    <item>
      <title><![CDATA[Spring Boot Temiz Kodlama Pratikleri]]></title>
      <link>https://suaybsimsek.com/tr/posts/spring-boot-clean-coding</link>
      <description><![CDATA[Spring Boot projelerinde temiz kodlama ilkelerini uygulamayÄ± Ã¶ÄŸrenin. En iyi uygulamalar, Ã¶rnekler ve Java'da Lombok ile Kotlin temiz kodlama tekniklerinin faydalarÄ±.]]></description>
      <pubDate>Thu, 19 Dec 2024 00:00:00 GMT</pubDate>
      <atom:updated>2024-12-20T00:00:00.000Z</atom:updated>
      <guid isPermaLink="true">https://suaybsimsek.com/tr/posts/spring-boot-clean-coding</guid>
      <content:encoded><![CDATA[<p>Temiz kodlama pratikleri, Spring Boot uygulamalarÄ±nÄ±zÄ±n bakÄ±mÄ±nÄ± kolaylaÅŸtÄ±rÄ±r, okunabilirliÄŸini artÄ±rÄ±r ve geliÅŸtirilebilirliÄŸini saÄŸlar. Bu rehber, hem Java hem de Kotlin'de daha temiz ve verimli kod yazmanÄ±za yardÄ±mcÄ± olacak temel ipuÃ§larÄ± ve kod Ã¶rneklerini sunar.</p>
<hr>
<h2>ğŸŒŸ Neden Temiz Kodlama?</h2>
<p>Temiz kodlama ilkelerini benimsemek ÅŸu faydalarÄ± saÄŸlar:</p>
<ul>
<li>Kodun okunabilirliÄŸini ve bakÄ±mÄ±nÄ± iyileÅŸtirir.</li>
<li>Teknik borcu azaltÄ±r.</li>
<li>Yeni geliÅŸtiricilerin projeye alÄ±ÅŸmasÄ±nÄ± kolaylaÅŸtÄ±rÄ±r.</li>
<li>GeniÅŸletilebilirlik ve hata ayÄ±klama sÃ¼reÃ§lerini geliÅŸtirir.</li>
</ul>
<hr>
<h2>ğŸ“‹ Gereksinimler</h2>
<p>ğŸ—Œ AÅŸaÄŸÄ±dakilere sahip olduÄŸunuzdan emin olun:</p>
<ul>
<li>â˜• Java Development Kit (JDK) 17+</li>
<li>ğŸ“¦ Maven veya Gradle kurulu</li>
<li>ğŸ”¤ Bir Java IDE (IntelliJ IDEA, Eclipse vb.)</li>
<li>ğŸ› ï¸ Spring Boot temel bilgilerine hakimiyet</li>
</ul>
<hr>
<h2>ğŸ› ï¸ AdÄ±m 1: Projenizi YapÄ±landÄ±rÄ±n</h2>
<p>Spring Boot projenizi daha net bir hale getirmek iÃ§in aÅŸaÄŸÄ±daki gibi organize edin:</p>
<ul>
<li>Controller KatmanÄ±: Gelen HTTP isteklerini yÃ¶netir.</li>
<li>Service KatmanÄ±: Ä°ÅŸ mantÄ±ÄŸÄ±nÄ± iÃ§erir.</li>
<li>Repository KatmanÄ±: VeritabanÄ± ile etkileÅŸir.</li>
</ul>
<h3>Ã–rnek KlasÃ¶r YapÄ±sÄ±:</h3>
<p>Bu klasÃ¶r yapÄ±sÄ±, katmanlar arasÄ± sorumluluklarÄ± ayÄ±rarak bakÄ±m ve geliÅŸtirme hÄ±zÄ±nÄ± artÄ±rÄ±r.</p>
<pre><code class="language-filename=&#x22;snippet.txt&#x22;">src/main/java/com/example/cleanproject
â”œâ”€â”€ controller
â”œâ”€â”€ service
â”œâ”€â”€ repository
â”œâ”€â”€ entity
â””â”€â”€ dto
</code></pre>
<hr>
<h2>ğŸ› ï¸ AdÄ±m 2: Java KodlarÄ±nda Lombok KullanÄ±mÄ±</h2>
<p>Lombok, Java'daki gereksiz kodu azaltarak sÄ±nÄ±flarÄ±nÄ±zÄ± daha kÄ±sa ve okunabilir hale getirir. Ä°ÅŸte Lombok'u etkili bir ÅŸekilde kullanmanÄ±n yÃ¶ntemi:</p>
<h3>Lombok BaÄŸlÄ±lÄ±ÄŸÄ±nÄ± Ekleyin</h3>
<p>Ã–nce Lombok baÄŸÄ±mlÄ±lÄ±ÄŸÄ±nÄ± ekleyerek tekrar eden getter/setter ve constructor kodlarÄ±nÄ± otomatik Ã¼retime bÄ±rakÄ±n.</p>
<ul>
<li>Maven:</li>
</ul>
<pre><code class="language-xml">&#x3C;dependency>
  &#x3C;groupId>org.projectlombok&#x3C;/groupId>
  &#x3C;artifactId>lombok&#x3C;/artifactId>
  &#x3C;scope>provided&#x3C;/scope>
&#x3C;/dependency>
</code></pre>
<ul>
<li>Gradle:</li>
</ul>
<pre><code class="language-groovy">provided 'org.projectlombok:lombok'
annotationProcessor 'org.projectlombok:lombok'
</code></pre>
<h3>Ã–rnek: Lombok ile Entity</h3>
<p>AÅŸaÄŸÄ±daki Ã¶rnek, Ã–rnek: Lombok ile Entity iÃ§in pratik bir baÄŸlam sunar ve doÄŸrudan uygulanabilir.</p>
<pre><code class="language-java">package com.example.cleanproject.entity;

import jakarta.persistence.*;
import lombok.Data;
import lombok.NoArgsConstructor;
import lombok.AllArgsConstructor;

@Data
@NoArgsConstructor
@AllArgsConstructor
@Entity
public class User {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    private String name;

    private String email;
}
</code></pre>
<p>Faydalar:</p>
<ul>
<li><code>@Data</code>, getter, setter, equals, hashCode ve toString metotlarÄ±nÄ± otomatik olarak oluÅŸturur.</li>
<li><code>@NoArgsConstructor</code> ve <code>@AllArgsConstructor</code> yapÄ±cÄ± metotlarÄ± oluÅŸturur.</li>
</ul>
<hr>
<h2>ğŸ› ï¸ AdÄ±m 3: Kotlin'de KÄ±sa ve Okunabilir Kod YazÄ±n</h2>
<p>Kotlin, modern Ã¶zellikleri ile doÄŸal olarak daha temiz kod yazÄ±lmasÄ±nÄ± saÄŸlar:</p>
<h3>Ã–rnek: Kotlin ile Entity</h3>
<p>AÅŸaÄŸÄ±daki Ã¶rnek, Ã–rnek: Kotlin ile Entity iÃ§in pratik bir baÄŸlam sunar ve doÄŸrudan uygulanabilir.</p>
<pre><code class="language-kotlin">package com.example.cleanproject.entity

import jakarta.persistence.*

@Entity
data class User(
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    val id: Long = 0,
    var name: String,
    var email: String
)
</code></pre>
<p>Kotlin'in AvantajlarÄ±:</p>
<ul>
<li><code>data class</code>, <code>toString</code>, <code>equals</code> ve <code>hashCode</code> metotlarÄ±nÄ± otomatik olarak oluÅŸturur.</li>
<li>DeÄŸiÅŸmez Ã¶zellikler (<code>val</code>) daha iyi stabilite saÄŸlar.</li>
</ul>
<hr>
<h2>ğŸ› ï¸ AdÄ±m 4: Dependency Injection Prensiplerini Takip Edin</h2>
<p>BileÅŸenleri ayÄ±rmak ve test edilebilirliÄŸi arttÄ±rmak iÃ§in dependency injectionu kullanÄ±n.</p>
<h3>Ã–rnek: Service KatmanÄ± ile DI</h3>
<p>AÅŸaÄŸÄ±daki Ã¶rnek, Ã–rnek: Service KatmanÄ± ile DI iÃ§in pratik bir baÄŸlam sunar ve doÄŸrudan uygulanabilir.</p>
<h3>Java</h3>
<pre><code class="language-java">package com.example.cleanproject.service;

import com.example.cleanproject.entity.User;
import com.example.cleanproject.repository.UserRepository;
import lombok.RequiredArgsConstructor;
import org.springframework.stereotype.Service;

import java.util.List;

@Service
@RequiredArgsConstructor
public class UserService {

    private final UserRepository userRepository;

    public List&#x3C;User> getAllUsers() {
        return userRepository.findAll();
    }
}
</code></pre>
<h3>Kotlin</h3>
<pre><code class="language-kotlin">package com.example.cleanproject.service

import com.example.cleanproject.entity.User
import com.example.cleanproject.repository.UserRepository
import org.springframework.stereotype.Service

@Service
class UserService(
    private val userRepository: UserRepository
) {
    fun getAllUsers(): List&#x3C;User> = userRepository.findAll()
}
</code></pre>
<hr>
<h2>ğŸ› ï¸ AdÄ±m 5: Veri Transferi Ä°Ã§in DTO'larÄ± KullananÄ±n</h2>
<p>Data Transfer Object (DTO), domain ve API katmanlarÄ±nÄ± ayÄ±rarak daha iyi kapsÃ¼lleme saÄŸlar.</p>
<h3>Ã–rnek: User Ä°Ã§in DTO</h3>
<p>AÅŸaÄŸÄ±daki Ã¶rnek, Ã–rnek: User Ä°Ã§in DTO iÃ§in pratik bir baÄŸlam sunar ve doÄŸrudan uygulanabilir.</p>
<h3>Java</h3>
<pre><code class="language-java">package com.example.cleanproject.dto;

import lombok.Data;

@Data
public class UserDTO {
    private String name;
    private String email;
}
</code></pre>
<h3>Kotlin</h3>
<pre><code class="language-kotlin">package com.example.cleanproject.dto

data class UserDTO(
    val name: String,
    val email: String
)
</code></pre>
<hr>
<h3>Controller KatmanÄ±</h3>
<p>HTTP isteklerini yÃ¶netmek ve service katmanÄ±yla etkileÅŸim saÄŸlamak iÃ§in bir controller uygulayÄ±n.</p>
<h3>Java</h3>
<pre><code class="language-java">package com.example.cleanproject.controller;

import com.example.cleanproject.dto.UserDTO;
import com.example.cleanproject.service.UserService;
import lombok.RequiredArgsConstructor;
import org.springframework.web.bind.annotation.*;

import java.util.List;

@RestController
@RequestMapping("/api/users")
@RequiredArgsConstructor
public class UserController {

    private final UserService userService;

    @GetMapping
    public List&#x3C;UserDTO> getAllUsers() {
        return userService.getAllUsers();
    }
}
</code></pre>
<h3>Kotlin</h3>
<pre><code class="language-kotlin">package com.example.cleanproject.controller

import com.example.cleanproject.dto.UserDTO
import com.example.cleanproject.service.UserService
import org.springframework.web.bind.annotation.*

@RestController
@RequestMapping("/api/users")
class UserController(
    private val userService: UserService
) {

    @GetMapping
    fun getAllUsers(): List&#x3C;UserDTO> = userService.getAllUsers()
}
</code></pre>
<hr>
<h2>â–¶ï¸ UygulamayÄ± Ã‡alÄ±ÅŸtÄ±rma</h2>
<p>UygulamayÄ± aÅŸaÄŸÄ±daki komutla Ã§alÄ±ÅŸtÄ±rÄ±n:</p>
<pre><code class="language-bash">./mvnw spring-boot:run
</code></pre>
<p>Postman veya cURL gibi bir aracÄ± kullanarak endpoint'leri test edin.</p>
<hr>
<h2>ğŸ§ª API'yi Test Edin</h2>
<p>API'yi aÅŸaÄŸÄ±daki cURL komutu ile test edebilirsiniz:</p>
<ul>
<li>TÃ¼m kullanÄ±cÄ±larÄ± getir:</li>
</ul>
<pre><code class="language-bash">curl -X GET http://localhost:8080/api/users
</code></pre>
<hr>
<h2>ğŸ SonuÃ§</h2>
<p>ArtÄ±k Spring Boot Temiz Kodlama Pratikleri iÃ§in Ã¼retim odaklÄ± bir Spring Boot temeliniz var. Sonraki adÄ±mda ayarlarÄ± kendi domainine uyarlayÄ±p test ve gÃ¶zlemlenebilirlik katmanÄ±nÄ± ekleyerek gerÃ§ek trafik altÄ±nda doÄŸrulayÄ±n.</p>]]></content:encoded>
      <category><![CDATA[Java]]></category>
      <category><![CDATA[Kotlin]]></category>
      <category><![CDATA[Spring Boot]]></category>
      <category><![CDATA[Temiz Kodlama]]></category>
      <media:thumbnail url="https://suaybsimsek.com/images/spring-boot-clean-coding-thumbnail.webp" />
    </item>
    <item>
      <title><![CDATA[Spring Boot DevTools]]></title>
      <link>https://suaybsimsek.com/tr/posts/spring-boot-devtools</link>
      <description><![CDATA[Spring Boot DevTools ile hÄ±zlÄ± geliÅŸtirme sÃ¼recinizi nasÄ±l hÄ±zlandÄ±rabileceÄŸinizi keÅŸfedin. CanlÄ± yeniden yÃ¼kleme, Ã¶nbellekleme ve hata ayÄ±klama ipuÃ§larÄ± iÃ§erir.]]></description>
      <pubDate>Thu, 19 Dec 2024 00:00:00 GMT</pubDate>
      <atom:updated>2024-12-20T00:00:00.000Z</atom:updated>
      <guid isPermaLink="true">https://suaybsimsek.com/tr/posts/spring-boot-devtools</guid>
      <content:encoded><![CDATA[<p>Spring Boot DevTools, geliÅŸtirme sÃ¼recinizi hÄ±zlandÄ±rmak isteyen geliÅŸtiriciler iÃ§in olmazsa olmaz bir aracÄ±dÄ±r. Bu kÄ±lavuz, canlÄ± yeniden yÃ¼kleme, Ã¶nbellekleme ve hata ayÄ±klama iyileÅŸtirmeleri dahil olmak Ã¼zere DevTools'Ä±n Ã¶zelliklerini ve kurulumunu anlatmaktadÄ±r.</p>
<hr>
<h2>ğŸŒŸ Neden Spring Boot DevTools KullanÄ±lmalÄ±?</h2>
<p>Spring Boot DevTools geliÅŸtiricilere ÅŸunlarÄ± sunar:</p>
<ul>
<li>CanlÄ± Yeniden YÃ¼kleme: Kod deÄŸiÅŸikliklerinde uygulamayÄ± otomatik olarak yeniden yÃ¼kler.</li>
<li>Ã–nbellekleme Ä°yileÅŸtirmeleri: Daha hÄ±zlÄ± yineleme iÃ§in ÅŸablon Ã¶nbelleklemesini devre dÄ±ÅŸÄ± bÄ±rakÄ±r.</li>
<li>Hata AyÄ±klama AraÃ§larÄ±: GeliÅŸtirme sÃ¼recinde hata ayÄ±klama deneyimini iyileÅŸtirir.</li>
</ul>
<hr>
<h2>ğŸ“‹ Gereksinimler</h2>
<p>ğŸ“‹ Åunlara sahip olduÄŸunuzdan emin olun:</p>
<ul>
<li>â˜• Java GeliÅŸtirme Kiti (JDK) 17+</li>
<li>ğŸ“¦ Maven veya Gradle yÃ¼klenmiÅŸ</li>
<li>ğŸ”¤ Bir Java IDE (IntelliJ IDEA, Eclipse gibi)</li>
</ul>
<hr>
<h2>ğŸ› ï¸ AdÄ±m 1: BaÄŸÄ±mlÄ±lÄ±klarÄ± Ekleyin</h2>
<p>DevTools'u etkinleÅŸtirmek iÃ§in projenize aÅŸaÄŸÄ±daki baÄŸÄ±mlÄ±lÄ±klarÄ± ekleyin:</p>
<ul>
<li>Maven:</li>
</ul>
<pre><code class="language-xml">&#x3C;dependency>
  &#x3C;groupId>org.springframework.boot&#x3C;/groupId>
  &#x3C;artifactId>spring-boot-devtools&#x3C;/artifactId>
  &#x3C;scope>runtime&#x3C;/scope>
&#x3C;/dependency>
</code></pre>
<ul>
<li>Gradle:</li>
</ul>
<pre><code class="language-groovy">runtimeOnly 'org.springframework.boot:spring-boot-devtools'
</code></pre>
<hr>
<h2>ğŸ› ï¸ AdÄ±m 2: DevTools'u YapÄ±landÄ±rÄ±n</h2>
<p>Spring Boot DevTools, minimal yapÄ±landÄ±rma gerektirir ancak bazÄ± Ã¶zelleÅŸtirme seÃ§enekleri sunar. Ä°ÅŸte bazÄ± yaygÄ±n yapÄ±landÄ±rma Ã¶rnekleri:</p>
<h3>CanlÄ± Yeniden YÃ¼kleme</h3>
<p>CanlÄ± yeniden yÃ¼kleme, IntelliJ IDEA veya Eclipse gibi desteklenen IDE'lerle DevTools kullanÄ±lÄ±rken varsayÄ±lan olarak etkindir.</p>
<h3>Ã–nbellekleme</h3>
<p>Åablonlar iÃ§in Ã¶nbellekleme devre dÄ±ÅŸÄ± bÄ±rakÄ±lÄ±r:</p>
<pre><code class="language-properties">spring.thymeleaf.cache=false
spring.freemarker.cache=false
</code></pre>
<h3>Yeniden BaÅŸlatma HariÃ§ TutmalarÄ±</h3>
<p>Belirli dosyalarÄ± veya dizinleri yeniden baÅŸlatmadan hariÃ§ tutun:</p>
<pre><code class="language-properties">spring.devtools.restart.exclude=static/**,public/**
</code></pre>
<hr>
<h2>ğŸ› ï¸ AdÄ±m 3: Hata AyÄ±klama Ä°yileÅŸtirmeleri</h2>
<p>Spring Boot DevTools, hata ayÄ±klamayÄ± ÅŸu ÅŸekilde iyileÅŸtirir:</p>
<ul>
<li>Otomatik Yeniden BaÅŸlatma: Kod deÄŸiÅŸiklikleri algÄ±landÄ±ÄŸÄ±nda uygulama baÄŸlamÄ±nÄ± yeniden baÅŸlatÄ±r.</li>
<li>Uzaktan Hata AyÄ±klama: Uzak sunucularda Ã§alÄ±ÅŸan uygulamalarÄ± hata ayÄ±klama yeteneÄŸi sunar.</li>
</ul>
<p>Uzaktan hata ayÄ±klamayÄ± etkinleÅŸtirmek iÃ§in:</p>
<pre><code class="language-properties">spring.devtools.remote.secret=benimsifre
</code></pre>
<p>BaÄŸlanmak iÃ§in ÅŸu komutu kullanÄ±n:</p>
<pre><code class="language-bash">java -jar myapp.jar -Dspring.devtools.remote.secret=benimsifre
</code></pre>
<hr>
<h2>â–¶ï¸ UygulamayÄ± Ã‡alÄ±ÅŸtÄ±rma</h2>
<p>UygulamayÄ± aÅŸaÄŸÄ±daki komutla Ã§alÄ±ÅŸtÄ±rÄ±n:</p>
<pre><code class="language-bash">./mvnw spring-boot:run
</code></pre>
<p>Kodunuzda deÄŸiÅŸiklik yapÄ±n ve canlÄ± yeniden yÃ¼kleme ile uygulama baÄŸlamÄ±nÄ±n yeniden baÅŸlatÄ±ldÄ±ÄŸÄ±nÄ± gÃ¶zlemleyin.</p>
<hr>
<h2>ğŸ§ª DevTools'u Test Etme</h2>
<p>Spring Boot DevTools Ã¶zelliklerini aÅŸaÄŸÄ±daki ÅŸekilde test edebilirsiniz:</p>
<ul>
<li>CanlÄ± Yeniden YÃ¼kleme: KontrolcÃ¼nÃ¼zde veya ÅŸablonunuzda bir deÄŸiÅŸiklik yapÄ±n ve dosyayÄ± kaydedin. Uygulama otomatik olarak yeniden yÃ¼klenmelidir.</li>
<li>Åablon GÃ¼ncellemeleri: Bir <code>.html</code> dosyasÄ±nÄ± gÃ¼ncelleyerek sunucuyu yeniden baÅŸlatmadan deÄŸiÅŸiklikleri kontrol edin.</li>
<li>Hata AyÄ±klama: IDE'Å„izde kesme noktalarÄ± ekleyin ve <code>DevTools</code> etkin olduÄŸundan emin olarak uzaktan hata ayÄ±klamayÄ± test edin.</li>
</ul>
<hr>
<h2>ğŸ SonuÃ§</h2>
<p>ArtÄ±k Spring Boot DevTools iÃ§in Ã¼retim odaklÄ± bir Spring Boot temeliniz var. Sonraki adÄ±mda ayarlarÄ± kendi domainine uyarlayÄ±p test ve gÃ¶zlemlenebilirlik katmanÄ±nÄ± ekleyerek gerÃ§ek trafik altÄ±nda doÄŸrulayÄ±n.</p>]]></content:encoded>
      <category><![CDATA[Java]]></category>
      <category><![CDATA[Kotlin]]></category>
      <category><![CDATA[Spring Boot]]></category>
      <category><![CDATA[GeliÅŸtirme AraÃ§larÄ±]]></category>
      <media:thumbnail url="https://suaybsimsek.com/images/spring-boot-devtools-thumbnail.webp" />
    </item>
    <item>
      <title><![CDATA[Spring Boot Actuator]]></title>
      <link>https://suaybsimsek.com/tr/posts/spring-boot-actuator</link>
      <description><![CDATA[Spring Boot Actuator kullanarak uygulamalarÄ±nÄ±zÄ± izleme ve yÃ¶netme. Endpointler, Ã¶zelleÅŸtirme ve gÃ¼venlik Ã¶rneklerini iÃ§erir.]]></description>
      <pubDate>Wed, 18 Dec 2024 00:00:00 GMT</pubDate>
      <atom:updated>2024-12-19T00:00:00.000Z</atom:updated>
      <guid isPermaLink="true">https://suaybsimsek.com/tr/posts/spring-boot-actuator</guid>
      <content:encoded><![CDATA[<p>Spring Boot Actuator, uygulamalarÄ±nÄ±zÄ± izlemek ve yÃ¶netmek iÃ§in prodÃ¼ksiyon seviyesinde hazÄ±r Ã¶zellikler sunar. Bu rehber, Actuator'Ä±n yeteneklerini, nasÄ±l etkinleÅŸtirileceÄŸini ve endpointlerin nasÄ±l gÃ¼venlik altÄ±na alÄ±nacaÄŸÄ±nÄ± incelemektedir.</p>
<hr>
<h2>ğŸŒŸ Neden Spring Boot Actuator KullanÄ±lÄ±r?</h2>
<p>Spring Boot Actuator geliÅŸtiricilere ÅŸunlarÄ± saÄŸlar:</p>
<ul>
<li>Uygulama saÄŸlÄ±ÄŸÄ±nÄ± izleme</li>
<li>Metrik ve bilgi toplama</li>
<li>Operasyonel gÃ¶revler iÃ§in yÃ¶netim endpointlerini yayÄ±nlamÄ±ÅŸ olma</li>
</ul>
<hr>
<h2>ğŸ“‹ Gereksinimler</h2>
<p>ğŸ“‹ AÅŸaÄŸÄ±daki ÅŸartlarÄ±n karÅŸÄ±landÄ±ÄŸÄ±ndan emin olun:</p>
<ul>
<li>â˜• Java Development Kit (JDK) 17+</li>
<li>ğŸ“¦ Maven veya Gradle yÃ¼klenmiÅŸ olmalÄ±</li>
<li>ğŸ”¤ Bir Java IDE (IntelliJ IDEA, Eclipse vb.)</li>
</ul>
<hr>
<h2>ğŸ› ï¸ AdÄ±m 1: BaÄŸÄ±mlÄ±lÄ±klarÄ± Ekleyin</h2>
<p>Actuator'Ä± etkinleÅŸtirmek iÃ§in, projenize aÅŸaÄŸÄ±daki baÄŸÄ±mlÄ±lÄ±klarÄ± ekleyin:</p>
<ul>
<li>Maven:</li>
</ul>
<pre><code class="language-xml">&#x3C;dependency>
  &#x3C;groupId>org.springframework.boot&#x3C;/groupId>
  &#x3C;artifactId>spring-boot-starter-actuator&#x3C;/artifactId>
&#x3C;/dependency>
</code></pre>
<ul>
<li>Gradle:</li>
</ul>
<pre><code class="language-groovy">implementation 'org.springframework.boot:spring-boot-starter-actuator'
</code></pre>
<hr>
<h2>ğŸ› ï¸ AdÄ±m 2: Actuator Endpointlerini EtkinleÅŸtirin</h2>
<p>VarsayÄ±lan olarak, Actuator uygulama bilgilerinin saÄŸlanmasÄ± iÃ§in Ã§eÅŸitli endpointler yayÄ±nlar. Bu endpointleri <code>application.properties</code> veya <code>application.yml</code> dosyasÄ±nda etkinleÅŸtirebilirsiniz.</p>
<h3>Ã–rnek KonfigÃ¼rasyon:</h3>
<p>Bu yapÄ±landÄ±rmayÄ± baÅŸlangÄ±Ã§ noktasÄ± olarak alÄ±n, sonra ortamÄ±nÄ±za gÃ¶re deÄŸerleri uyarlayÄ±n.</p>
<pre><code class="language-properties">management.endpoints.web.exposure.include=health,info,metrics
management.endpoint.health.show-details=always
</code></pre>
<hr>
<h2>ğŸ› ï¸ AdÄ±m 3: Actuator Endpointlerini Kullanmaya BaÅŸlayÄ±n</h2>
<p>Ä°ÅŸte sÄ±k kullanÄ±lan Actuator endpointleri:</p>
<ul>
<li><code>/actuator/health</code>: Uygulama saÄŸlÄ±k durumu saÄŸlar.</li>
<li><code>/actuator/info</code>: Uygulama metadatasÄ±nÄ± gÃ¶sterir.</li>
<li><code>/actuator/metrics</code>: Uygulama performans metriklerini sunar.</li>
</ul>
<p>Bu endpointlere bir tarayÄ±cÄ± veya cURL gibi API araÃ§larÄ± kullanarak eriÅŸebilirsiniz.</p>
<p>Ã–rnek:</p>
<pre><code class="language-bash">curl -X GET http://localhost:8080/actuator/health
</code></pre>
<hr>
<h2>ğŸ› ï¸ AdÄ±m 4: Actuator Endpointlerini Ã–zelleÅŸtirin</h2>
<p>Actuator endpointlerini ihtiyaÃ§larÄ±nÄ±za gÃ¶re Ã¶zelleÅŸtirin. Ã–rneÄŸin, <code>/actuator/info</code> endpointi iÃ§in ek metadata tanÄ±mlayabilirsiniz:</p>
<pre><code class="language-properties">info.app.name=Benim Uygulamam
info.app.version=1.0.0
info.app.description=Spring Boot Actuator Ã–rneÄŸi
</code></pre>
<hr>
<h2>ğŸ› ï¸ AdÄ±m 5: Actuator Endpointlerini GÃ¼venli Hale Getirin</h2>
<p>ProdÃ¼ksiyon ortamlarÄ±nda, Actuator endpointlerinin gÃ¼venli hale getirilmesi Ã¶nemlidir. Spring Security kullanarak eriÅŸimi sÄ±nÄ±rlayabilirsiniz.</p>
<h3>Java</h3>
<pre><code class="language-java">package com.example.demo.config;

import org.springframework.context.annotation.Configuration;
import org.springframework.security.config.annotation.web.builders.HttpSecurity;
import org.springframework.security.web.SecurityFilterChain;

@Configuration
public class SecurityConfig {

    public SecurityFilterChain securityFilterChain(HttpSecurity http) throws Exception {
        http
            .authorizeHttpRequests()
                .requestMatchers("/actuator/**").hasRole("ADMIN")
                .anyRequest().authenticated()
            .and()
            .httpBasic();
        return http.build();
    }
}
</code></pre>
<h3>Kotlin</h3>
<pre><code class="language-kotlin">package com.example.demo.config

import org.springframework.context.annotation.Bean
import org.springframework.context.annotation.Configuration
import org.springframework.security.config.annotation.web.builders.HttpSecurity
import org.springframework.security.web.SecurityFilterChain

@Configuration
class SecurityConfig {

    @Bean
    fun securityFilterChain(http: HttpSecurity): SecurityFilterChain {
        http
            .authorizeHttpRequests()
                .requestMatchers("/actuator/**").hasRole("ADMIN")
                .anyRequest().authenticated()
            .and()
            .httpBasic()
        return http.build()
    }
}
</code></pre>
<hr>
<h2>â–¶ï¸ UygulamayÄ± Ã‡alÄ±ÅŸtÄ±rma</h2>
<p>UygulamayÄ± aÅŸaÄŸÄ±daki komutla Ã§alÄ±ÅŸtÄ±rÄ±n:</p>
<pre><code class="language-bash">./mvnw spring-boot:run
</code></pre>
<p>Actuator endpointlerine eriÅŸim saÄŸlamak iÃ§in:</p>
<pre><code class="language-filename=&#x22;snippet.txt&#x22;">http://localhost:8080/actuator/health
</code></pre>
<hr>
<h2>ğŸ§ª API'Ä± Test Edin</h2>
<p>Actuator endpointlerini cURL veya tarayÄ±cÄ± kullanarak test edebilirsiniz:</p>
<ul>
<li>Health Endpoint:</li>
</ul>
<pre><code class="language-bash">curl -X GET http://localhost:8080/actuator/health
</code></pre>
<ul>
<li>Info Endpoint:</li>
</ul>
<pre><code class="language-bash">curl -X GET http://localhost:8080/actuator/info
</code></pre>
<hr>
<h2>ğŸ SonuÃ§</h2>
<p>ArtÄ±k Spring Boot Actuator iÃ§in Ã¼retim odaklÄ± bir Spring Boot temeliniz var. Sonraki adÄ±mda ayarlarÄ± kendi domainine uyarlayÄ±p test ve gÃ¶zlemlenebilirlik katmanÄ±nÄ± ekleyerek gerÃ§ek trafik altÄ±nda doÄŸrulayÄ±n.</p>]]></content:encoded>
      <category><![CDATA[Java]]></category>
      <category><![CDATA[Kotlin]]></category>
      <category><![CDATA[Spring Boot]]></category>
      <category><![CDATA[Actuator]]></category>
      <category><![CDATA[Ä°zleme]]></category>
      <media:thumbnail url="https://suaybsimsek.com/images/spring-boot-actuator-thumbnail.webp" />
    </item>
    <item>
      <title><![CDATA[Spring Boot ile Aspect-Oriented Programming]]></title>
      <link>https://suaybsimsek.com/tr/posts/spring-boot-aop</link>
      <description><![CDATA[Spring Boot ile AOP uygulamasÄ±nÄ± nasÄ±l yapacaÄŸÄ±nÄ±zÄ± Ã¶ÄŸrenin. Java ve Kotlin Ã¶rnekleri ile temel kavramlar ve uygulamalar.]]></description>
      <pubDate>Wed, 18 Dec 2024 00:00:00 GMT</pubDate>
      <atom:updated>2024-12-19T00:00:00.000Z</atom:updated>
      <guid isPermaLink="true">https://suaybsimsek.com/tr/posts/spring-boot-aop</guid>
      <content:encoded><![CDATA[<p>Aspect-Oriented Programming (AOP), logging, transaction management ve gÃ¼venlik gibi birÃ§ok alana yayÄ±lan kesme noktalarÄ±nÄ± modÃ¼ler hale getiren bir yaklaÅŸÄ±mdÄ±r. Bu kÄ±lavuzda, Spring Boot kullanarak AOP uygulamasÄ± yapmayÄ± Java ve Kotlin ile gÃ¶stereceÄŸiz.</p>
<hr>
<h2>ğŸŒŸ Neden AOP KullanmalÄ±sÄ±nÄ±z?</h2>
<p>AOP, bir uygulamanÄ±n birden fazla bÃ¶lÃ¼mÃ¼nÃ¼ etkileyen logging veya gÃ¼venlik gibi konularÄ± tekrar kullanÄ±labilir aspect'ler haline getirmek iÃ§in kullanÄ±lÄ±r. Bu yÃ¶ntem daha temiz kod, geliÅŸtirilmiÅŸ bakÄ±m kolaylÄ±ÄŸÄ± ve azaltÄ±lmÄ±ÅŸ kod tekrarÄ± saÄŸlar.</p>
<hr>
<h2>ğŸ“‹ Gereksinimler</h2>
<p>ğŸ“‹ AÅŸaÄŸÄ±dakilere sahip olduÄŸunuzdan emin olun:</p>
<ul>
<li>â˜• Java Development Kit (JDK) 17+</li>
<li>ğŸ“¦ Maven veya Gradle kurulu</li>
<li>ğŸ”¤ Java IDE (IntelliJ IDEA, Eclipse veya VS Code)</li>
</ul>
<hr>
<h2>ğŸ› ï¸ AdÄ±m 1: BaÄŸlÄ±lÄ±klarÄ± Ekleyin</h2>
<p>Projenize aÅŸaÄŸÄ±daki baÄŸlÄ±lÄ±klarÄ± dahil edin:</p>
<p>Maven:</p>
<pre><code class="language-xml">&#x3C;dependency>
  &#x3C;groupId>org.springframework.boot&#x3C;/groupId>
  &#x3C;artifactId>spring-boot-starter-aop&#x3C;/artifactId>
&#x3C;/dependency>
</code></pre>
<p>Gradle:</p>
<pre><code class="language-groovy">implementation 'org.springframework.boot:spring-boot-starter-aop'
</code></pre>
<hr>
<h2>ğŸ› ï¸ AdÄ±m 2: Bir Servis TanÄ±mlayÄ±n</h2>
<p>AOP'yi gÃ¶stermek iÃ§in basit bir servis oluÅŸturun.</p>
<h3>Java</h3>
<p>Servis</p>
<pre><code class="language-java">package com.example.demo.service;

import org.springframework.stereotype.Service;

@Service
public class UserService {

    public String getUserById(String id) {
        return "ID'ye sahip kullanÄ±cÄ±: " + id;
    }

    public String getAllUsers() {
        return "TÃ¼m kullanÄ±cÄ±lar alÄ±nÄ±yor.";
    }
}
</code></pre>
<h3>Kotlin</h3>
<p>Servis</p>
<pre><code class="language-kotlin">package com.example.demo.service

import org.springframework.stereotype.Service

@Service
class UserService {

    fun getUserById(id: String): String {
        return "ID'ye sahip kullanÄ±cÄ±: $id"
    }

    fun getAllUsers(): String {
        return "TÃ¼m kullanÄ±cÄ±lar alÄ±nÄ±yor."
    }
}
</code></pre>
<hr>
<h2>ğŸ› ï¸ AdÄ±m 3: Bir Aspect OluÅŸturun</h2>
<p>Method Ã§alÄ±ÅŸma detaylarÄ±nÄ± loglamak iÃ§in bir aspect tanÄ±mlayÄ±n.</p>
<h3>Java</h3>
<p>Aspect</p>
<pre><code class="language-java">package com.example.demo.aspect;

import org.aspectj.lang.annotation.Aspect;
import org.aspectj.lang.annotation.Before;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.stereotype.Component;

@Aspect
@Component
public class LoggingAspect {

    private static final Logger logger = LoggerFactory.getLogger(LoggingAspect.class);

    @Before("execution(* com.example.demo.service.UserService.*(..))")
    public void logBefore() {
        logger.info("Method Ã§alÄ±ÅŸtÄ±rÄ±lmaya baÅŸlandÄ±.");
    }
}
</code></pre>
<h3>Kotlin</h3>
<p>Aspect</p>
<pre><code class="language-kotlin">package com.example.demo.aspect

import org.aspectj.lang.annotation.Aspect
import org.aspectj.lang.annotation.Before
import org.slf4j.LoggerFactory
import org.springframework.stereotype.Component

@Aspect
@Component
class LoggingAspect {

    private val logger = LoggerFactory.getLogger(LoggingAspect::class.java)

    @Before("execution(* com.example.demo.service.UserService.*(..))")
    fun logBefore() {
        logger.info("YÃ¶ntem Ã§alÄ±ÅŸtÄ±rÄ±lmaya baÅŸlandÄ±.")
    }
}
</code></pre>
<hr>
<h2>ğŸ› ï¸ AdÄ±m 4: Bir Controller OluÅŸturun</h2>
<p>Servis methodlarÄ±nÄ± bir REST controller Ã¼zerinden sunun.</p>
<h3>Java</h3>
<p>Controller</p>
<pre><code class="language-java">package com.example.demo.controller;

import com.example.demo.service.UserService;
import lombok.RequiredArgsConstructor;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.PathVariable;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;

@RestController
@RequestMapping("/api/users")
@RequiredArgsConstructor
public class UserController {

    private final UserService userService;

    @GetMapping("/{id}")
    public String getUserById(@PathVariable String id) {
        return userService.getUserById(id);
    }

    @GetMapping
    public String getAllUsers() {
        return userService.getAllUsers();
    }
}
</code></pre>
<h3>Kotlin</h3>
<p>Controller</p>
<pre><code class="language-kotlin">package com.example.demo.controller

import com.example.demo.service.UserService
import org.springframework.web.bind.annotation.GetMapping
import org.springframework.web.bind.annotation.PathVariable
import org.springframework.web.bind.annotation.RequestMapping
import org.springframework.web.bind.annotation.RestController

@RestController
@RequestMapping("/api/users")
class UserController(
    private val userService: UserService
) {

    @GetMapping("/{id}")
    fun getUserById(@PathVariable id: String): String = userService.getUserById(id)

    @GetMapping
    fun getAllUsers(): String = userService.getAllUsers()
}
</code></pre>
<hr>
<h2>â–¶ï¸ UygulamayÄ± Ã‡alÄ±ÅŸtÄ±rma</h2>
<p>AÅŸaÄŸÄ±daki komutlarla uygulamayÄ± Ã§alÄ±ÅŸtÄ±rÄ±n:</p>
<p>Spring Boot (Java/Kotlin):
Kurulumun doÄŸru Ã§alÄ±ÅŸtÄ±ÄŸÄ±nÄ± doÄŸrulamak iÃ§in uygulamayÄ± tercih ettiÄŸiniz dil yÄ±ÄŸÄ±nÄ±yla baÅŸlatÄ±n.</p>
<pre><code class="language-bash">./mvnw spring-boot:run
</code></pre>
<p>API'ye ÅŸu adresten eriÅŸebilirsiniz: <code>http://localhost:8080/api/users</code>.</p>
<hr>
<h2>ğŸ§ª API'yi Test Edin</h2>
<p>API'yi aÅŸaÄŸÄ±daki cURL komutlarÄ± ile test edebilirsiniz:</p>
<ul>
<li>TÃ¼m kullanÄ±cÄ±larÄ± getir:</li>
</ul>
<pre><code class="language-bash">curl -X GET http://localhost:8080/api/users
</code></pre>
<ul>
<li>Bir ID'ye gÃ¶re kullanÄ±cÄ± getir:</li>
</ul>
<pre><code class="language-bash">curl -X GET http://localhost:8080/api/users/1
</code></pre>
<hr>
<h2>ğŸ SonuÃ§</h2>
<p>ArtÄ±k Aspect-Oriented Programming iÃ§in Ã¼retim odaklÄ± bir Spring Boot temeliniz var. Sonraki adÄ±mda ayarlarÄ± kendi domainine uyarlayÄ±p test ve gÃ¶zlemlenebilirlik katmanÄ±nÄ± ekleyerek gerÃ§ek trafik altÄ±nda doÄŸrulayÄ±n.</p>]]></content:encoded>
      <category><![CDATA[Java]]></category>
      <category><![CDATA[Kotlin]]></category>
      <category><![CDATA[Spring Boot]]></category>
      <category><![CDATA[AOP]]></category>
      <media:thumbnail url="https://suaybsimsek.com/images/spring-boot-aop-thumbnail.webp" />
    </item>
    <item>
      <title><![CDATA[Spring Boot ile Dependency Injection]]></title>
      <link>https://suaybsimsek.com/tr/posts/spring-boot-di</link>
      <description><![CDATA[Spring Boot ile BaÄŸÄ±mlÄ±lÄ±k Enjeksiyonu (Dependency Injection - DI) nasÄ±l Ã§alÄ±ÅŸÄ±r? Java ve Kotlin Ã¶rnekleriyle temel kavramlar, anotasyonlar ve pratik kullanÄ±m senaryolarÄ±nÄ± Ã¶ÄŸrenin.]]></description>
      <pubDate>Wed, 18 Dec 2024 00:00:00 GMT</pubDate>
      <atom:updated>2024-12-19T00:00:00.000Z</atom:updated>
      <guid isPermaLink="true">https://suaybsimsek.com/tr/posts/spring-boot-di</guid>
      <content:encoded><![CDATA[<p>BaÄŸÄ±mlÄ±lÄ±k Enjeksiyonu (Dependency Injection - DI), Spring Boot'un temel konseptlerinden biridir ve daha gevÅŸek baÄŸlÄ±lÄ±k ve artan test edilebilirlik saÄŸlar. Bu kÄ±lavuz, Java ve Kotlin ile Spring Boot'ta DI kullanÄ±mÄ±nÄ± pratik Ã¶rneklerle aÃ§Ä±klar.</p>
<hr>
<h2>ğŸŒŸ Neden BaÄŸÄ±mlÄ±lÄ±k Enjeksiyonu KullanmalÄ±yÄ±z?</h2>
<p>BaÄŸÄ±mlÄ±lÄ±k Enjeksiyonu, sÄ±nÄ±flara baÄŸÄ±mlÄ±lÄ±klarÄ± manuel olarak oluÅŸturmadan enjekte etmeyi saÄŸlar. Bu, ÅŸu avantajlarÄ± sunar:</p>
<ul>
<li>Daha modÃ¼ler kod</li>
<li>Testlerin kolaylaÅŸtÄ±rÄ±lmasÄ±</li>
<li>Daha kolay bakÄ±m</li>
</ul>
<hr>
<h2>ğŸ“‹ Gereksinimler</h2>
<p>ğŸ“‹ AÅŸaÄŸÄ±dakilere sahip olduÄŸunuzdan emin olun:</p>
<ul>
<li>â˜• Java Development Kit (JDK) 17+</li>
<li>ğŸ“¦ Maven veya Gradle yÃ¼klÃ¼</li>
<li>ğŸ”¤ Bir Java IDE (Ã¶rneÄŸin, IntelliJ IDEA, Eclipse)</li>
</ul>
<hr>
<h2>ğŸ› ï¸ AdÄ±m 1: BaÄŸÄ±mlÄ±lÄ±klarÄ± Ekleyin</h2>
<p>Gerekli Spring Boot baÄŸÄ±mlÄ±lÄ±klarÄ±nÄ± ekleyin:</p>
<p>Maven:</p>
<pre><code class="language-xml">&#x3C;dependency>
  &#x3C;groupId>org.springframework.boot&#x3C;/groupId>
  &#x3C;artifactId>spring-boot-starter&#x3C;/artifactId>
&#x3C;/dependency>
</code></pre>
<p>Gradle:</p>
<pre><code class="language-groovy">implementation 'org.springframework.boot:spring-boot-starter'
</code></pre>
<hr>
<h2>ğŸ› ï¸ AdÄ±m 2: Bir Servis OluÅŸturun</h2>
<p>BaÄŸÄ±mlÄ±lÄ±k Enjeksiyonu'nu gÃ¶stermek iÃ§in basit bir servis tanÄ±mlayÄ±n.</p>
<h3>Java</h3>
<p>Servis</p>
<pre><code class="language-java">package com.example.demo.service;

import org.springframework.stereotype.Service;

@Service
public class UserService {

    public String getUserById(String id) {
        return "ID ile kullanÄ±cÄ±: " + id;
    }

    public String getAllUsers() {
        return "TÃ¼m kullanÄ±cÄ±lar alÄ±nÄ±yor.";
    }
}
</code></pre>
<h3>Kotlin</h3>
<p>Servis</p>
<pre><code class="language-kotlin">package com.example.demo.service

import org.springframework.stereotype.Service

@Service
class UserService {

    fun getUserById(id: String): String {
        return "ID ile kullanÄ±cÄ±: $id"
    }

    fun getAllUsers(): String {
        return "TÃ¼m kullanÄ±cÄ±lar alÄ±nÄ±yor."
    }
}
</code></pre>
<hr>
<h2>ğŸ› ï¸ AdÄ±m 3: BaÄŸÄ±mlÄ±lÄ±klarÄ± Enjekte Edin</h2>
<p>Servisi diÄŸer bileÅŸenlere enjekte etmek iÃ§in anotasyonlarÄ± kullanÄ±n.</p>
<h3>Java</h3>
<p>Controller</p>
<pre><code class="language-java">package com.example.demo.controller;

import com.example.demo.service.UserService;
import lombok.RequiredArgsConstructor;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.PathVariable;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;

@RestController
@RequestMapping("/api/users")
@RequiredArgsConstructor
public class UserController {

    private final UserService userService;

    @GetMapping("/{id}")
    public String getUserById(@PathVariable String id) {
        return userService.getUserById(id);
    }

    @GetMapping
    public String getAllUsers() {
        return userService.getAllUsers();
    }
}
</code></pre>
<h3>Kotlin</h3>
<p>Controller</p>
<pre><code class="language-kotlin">package com.example.demo.controller

import com.example.demo.service.UserService
import org.springframework.web.bind.annotation.GetMapping
import org.springframework.web.bind.annotation.PathVariable
import org.springframework.web.bind.annotation.RequestMapping
import org.springframework.web.bind.annotation.RestController

@RestController
@RequestMapping("/api/users")
class UserController(
    private val userService: UserService
) {

    @GetMapping("/{id}")
    fun getUserById(@PathVariable id: String): String = userService.getUserById(id)

    @GetMapping
    fun getAllUsers(): String = userService.getAllUsers()
}
</code></pre>
<hr>
<h2>â–¶ï¸ UygulamayÄ± Ã‡alÄ±ÅŸtÄ±rÄ±n</h2>
<p>UygulamayÄ± aÅŸaÄŸÄ±daki komutlarla Ã§alÄ±ÅŸtÄ±rÄ±n:</p>
<p>Spring Boot (Java/Kotlin):
Kurulumun doÄŸru Ã§alÄ±ÅŸtÄ±ÄŸÄ±nÄ± doÄŸrulamak iÃ§in uygulamayÄ± tercih ettiÄŸiniz dil yÄ±ÄŸÄ±nÄ±yla baÅŸlatÄ±n.</p>
<pre><code class="language-bash">./mvnw spring-boot:run
</code></pre>
<p>API'ye ÅŸu adresten eriÅŸin: <code>http://localhost:8080/api/users</code>.</p>
<hr>
<h2>ğŸ§ª API'yi Test Edin</h2>
<p>API'yi aÅŸaÄŸÄ±daki cURL komutlarÄ±yla test edebilirsiniz:</p>
<h3>TÃ¼m kullanÄ±cÄ±larÄ± alÄ±n</h3>
<p>Bu istekle liste endpointâ€™inin dÃ¶ndÃ¼rdÃ¼ÄŸÃ¼ temel veri yapÄ±sÄ±nÄ± hÄ±zlÄ±ca doÄŸrulayabilirsiniz.</p>
<pre><code class="language-bash">curl -X GET http://localhost:8080/api/users
</code></pre>
<h3>Belirli bir kullanÄ±cÄ±yÄ± alÄ±n</h3>
<p>Bu istek, path parametresi ile tekil kaynak eriÅŸiminin doÄŸru Ã§alÄ±ÅŸtÄ±ÄŸÄ±nÄ± doÄŸrulamak iÃ§in kullanÄ±lÄ±r.</p>
<pre><code class="language-bash">curl -X GET http://localhost:8080/api/users/1
</code></pre>
<hr>
<h2>ğŸ SonuÃ§</h2>
<p>ArtÄ±k Dependency Injection iÃ§in Ã¼retim odaklÄ± bir Spring Boot temeliniz var. Sonraki adÄ±mda ayarlarÄ± kendi domainine uyarlayÄ±p test ve gÃ¶zlemlenebilirlik katmanÄ±nÄ± ekleyerek gerÃ§ek trafik altÄ±nda doÄŸrulayÄ±n.</p>]]></content:encoded>
      <category><![CDATA[Java]]></category>
      <category><![CDATA[Kotlin]]></category>
      <category><![CDATA[Spring Boot]]></category>
      <category><![CDATA[BaÄŸÄ±mlÄ±lÄ±k Enjeksiyonu]]></category>
      <media:thumbnail url="https://suaybsimsek.com/images/spring-boot-di-thumbnail.webp" />
    </item>
    <item>
      <title><![CDATA[Object-Relational Mapping]]></title>
      <link>https://suaybsimsek.com/tr/posts/object-relational-mapping</link>
      <description><![CDATA[Spring Boot kullanarak Java, Kotlin ve Go (Gin) ile PostgreSQL entegrasyonu ve temel CRUD iÅŸlemlerini iÃ§eren bir ORM tabanlÄ± uygulamanÄ±n nasÄ±l kurulacaÄŸÄ±nÄ± Ã¶ÄŸrenin.]]></description>
      <pubDate>Mon, 16 Dec 2024 00:00:00 GMT</pubDate>
      <atom:updated>2024-12-17T00:00:00.000Z</atom:updated>
      <guid isPermaLink="true">https://suaybsimsek.com/tr/posts/object-relational-mapping</guid>
      <content:encoded><![CDATA[<p>Object-Relational Mapping (ORM), modern uygulamalarda veritabanÄ± iÅŸlemlerini basitleÅŸtirir. Bu kÄ±lavuzda, Spring Boot ve Gin Ã§erÃ§evesini kullanarak PostgreSQL ile ORM nasÄ±l kurulacaÄŸÄ±nÄ± Ã¶ÄŸreneceksiniz.</p>
<hr>
<h2>ğŸŒŸ Neden ORM KullanmalÄ±yÄ±z?</h2>
<p>ORM, nesne yÃ¶nelimli programlama ile iliÅŸkisel veritabanlarÄ± arasÄ±ndaki boÅŸluÄŸu kapatarak nesneleri doÄŸrudan veritabanÄ± tablolarÄ±na eÅŸler. Bu, manuel SQL sorgularÄ±na olan ihtiyacÄ± ortadan kaldÄ±rÄ±r, hatalarÄ± azaltÄ±r ve geliÅŸtiricilerin verimliliÄŸini artÄ±rÄ±r.</p>
<hr>
<h2>ğŸ“‹ Gereksinimler</h2>
<p>ğŸ“œ Åunlara sahip olduÄŸunuzdan emin olun:</p>
<ul>
<li>â˜• Java GeliÅŸtirme Kiti (JDK) 17+</li>
<li>ğŸ“¦ Maven veya Gradle kurulu</li>
<li>ğŸ”¤ Bir Java IDE</li>
<li>ğŸ˜ PostgreSQL kurulu ve Ã§alÄ±ÅŸÄ±r durumda</li>
</ul>
<p>Go iÃ§in:</p>
<ul>
<li>ğŸ”§ Golang 1.17+ kurulu</li>
<li>ğŸ”„ Projenizde go.mod baÅŸlatÄ±lmÄ±ÅŸ</li>
</ul>
<hr>
<h2>ğŸ› ï¸ AdÄ±m 1: BaÄŸÄ±mlÄ±lÄ±klarÄ± Ekleme</h2>
<p>Spring Boot projesi kurmak ve ORM entegrasyonu saÄŸlamak iÃ§in ÅŸu adÄ±mlarÄ± izleyin:</p>
<h3>BaÄŸÄ±mlÄ±lÄ±klarÄ± Ekleme</h3>
<p>Spring Boot projeleri iÃ§in aÅŸaÄŸÄ±daki baÄŸÄ±mlÄ±lÄ±klarÄ± projenize ekleyin:</p>
<ul>
<li>Maven:</li>
</ul>
<pre><code class="language-xml">&#x3C;dependency>
  &#x3C;groupId>org.springframework.boot&#x3C;/groupId>
  &#x3C;artifactId>spring-boot-starter-data-jpa&#x3C;/artifactId>
&#x3C;/dependency>
&#x3C;dependency>
  &#x3C;groupId>org.postgresql&#x3C;/groupId>
  &#x3C;artifactId>postgresql&#x3C;/artifactId>
&#x3C;/dependency>
</code></pre>
<ul>
<li>Gradle:</li>
</ul>
<pre><code class="language-groovy">implementation 'org.springframework.boot:spring-boot-starter-data-jpa'
implementation 'org.postgresql:postgresql'
</code></pre>
<h3>VeritabanÄ±nÄ± YapÄ±landÄ±rma</h3>
<p>PostgreSQL baÄŸlantÄ±nÄ±zÄ± <code>application.properties</code> veya <code>application.yml</code> dosyasÄ±na ÅŸu ÅŸekilde ayarlayÄ±n:</p>
<pre><code class="language-properties">spring.datasource.url=jdbc:postgresql://localhost:5432/demo
spring.datasource.username=kullanici_adiniz
spring.datasource.password=sifreniz
spring.jpa.hibernate.ddl-auto=update
</code></pre>
<h3>Projeyi BaÅŸlatma</h3>
<p>HenÃ¼z yapmadÄ±ysanÄ±z, <a href="https://start.spring.io/">Spring Initializr</a> kullanarak projenizi oluÅŸturun:</p>
<ol>
<li>Spring Web, Spring Data JPA ve PostgreSQL Driver baÄŸÄ±mlÄ±lÄ±klarÄ±nÄ± seÃ§in.</li>
<li>Projeyi indirin ve tercih ettiÄŸiniz IDE'ye aktarÄ±n.</li>
</ol>
<p>Go projeleri iÃ§in:</p>
<ul>
<li>Gin Ã‡erÃ§evesini ve GORM'u Kurun:</li>
</ul>
<pre><code class="language-bash"># Gin Ã§erÃ§evesini kurun
go get -u github.com/gin-gonic/gin

# GORM PostgreSQL sÃ¼rÃ¼cÃ¼sÃ¼nÃ¼ kurun
go get -u gorm.io/driver/postgres

# GORM ORM kÃ¼tÃ¼phanesini kurun
go get -u gorm.io/gorm
</code></pre>
<hr>
<h2>ğŸ› ï¸ AdÄ±m 2: Modeli TanÄ±mlayÄ±n ve REST Controller UygulayÄ±n</h2>
<p>Bu adÄ±m, entity/model, repository ve REST controller oluÅŸturulmasÄ±nÄ± birleÅŸtirir.</p>
<h3>Java</h3>
<p>Entity</p>
<pre><code class="language-java">package com.example.demo.entity;

import jakarta.persistence.*;
import lombok.Data;

@Data
@Entity
public class User {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    private String name;

    private String email;
}
</code></pre>
<p>Repository</p>
<pre><code class="language-java">package com.example.demo.repository;

import com.example.demo.entity.User;
import org.springframework.data.jpa.repository.JpaRepository;

public interface UserRepository extends JpaRepository&#x3C;User, Long> {
}
</code></pre>
<p>REST Controller</p>
<pre><code class="language-java">package com.example.demo.controller;

import com.example.demo.entity.User;
import com.example.demo.repository.UserRepository;
import org.springframework.web.bind.annotation.*;

import java.util.List;

@RestController
@RequestMapping("/api/users")
import lombok.RequiredArgsConstructor;

@RequiredArgsConstructor
public class UserController {

  private final UserRepository userRepository;

  @GetMapping
  public List&#x3C;User> getAllUsers() {
    return userRepository.findAll();
  }

  @PostMapping
  public User createUser(@RequestBody User user) {
    return userRepository.save(user);
  }
}
</code></pre>
<h3>Kotlin</h3>
<p>Entity</p>
<pre><code class="language-kotlin">package com.example.demo.entity

import jakarta.persistence.*

@Entity
class User(
  @Id
  @GeneratedValue(strategy = GenerationType.IDENTITY)
  val id: Long = 0,

  var name: String,

  var email: String
)
</code></pre>
<p>Repository</p>
<pre><code class="language-kotlin">package com.example.demo.repository

import com.example.demo.entity.User
import org.springframework.data.jpa.repository.JpaRepository

interface UserRepository : JpaRepository&#x3C;User, Long>
</code></pre>
<p>REST Controller</p>
<pre><code class="language-kotlin">package com.example.demo.controller

import com.example.demo.entity.User
import com.example.demo.repository.UserRepository
import org.springframework.web.bind.annotation.*

@RestController
@RequestMapping("/api/users")
class UserController(
  private val userRepository: UserRepository
) {

  @GetMapping
  fun getAllUsers(): List&#x3C;User> = userRepository.findAll()

  @PostMapping
  fun createUser(@RequestBody user: User): User = userRepository.save(user)
}
</code></pre>
<h3>Go</h3>
<p>Model ve VeritabanÄ± BaÄŸlantÄ±sÄ±</p>
<pre><code class="language-go">package main

import (
	"gorm.io/driver/postgres"
	"gorm.io/gorm"
)

var DB *gorm.DB

func connectDatabase() {
	dsn := "host=localhost user=kullanici_adiniz password=sifreniz dbname=demo port=5432 sslmode=disable"
	db, err := gorm.Open(postgres.Open(dsn), &#x26;gorm.Config{})
	if err != nil {
		panic("VeritabanÄ±na baÄŸlanÄ±lamadÄ±!")
	}

	DB = db
	DB.AutoMigrate(&#x26;User{})
}

type User struct {
	ID    uint   `json:"id" gorm:"primaryKey"`
	Name  string `json:"name"`
	Email string `json:"email"`
}
</code></pre>
<p>Handlerlar</p>
<pre><code class="language-go">package main

import (
	"github.com/gin-gonic/gin"
)

func getUsers(c *gin.Context) {
	var users []User
	DB.Find(&#x26;users)
	c.JSON(200, users)
}

func createUser(c *gin.Context) {
	var user User
	if err := c.ShouldBindJSON(&#x26;user); err != nil {
		c.JSON(400, gin.H{"error": err.Error()})
		return
	}
	DB.Create(&#x26;user)
	c.JSON(201, user)
}

func main() {
	r := gin.Default()
	connectDatabase()

	r.GET("/api/users", getUsers)
	r.POST("/api/users", createUser)

	r.Run() // 0.0.0.0:8080 Ã¼zerinde dinle ve hizmet et
}
</code></pre>
<hr>
<h2>â–¶ï¸ UygulamalarÄ± Ã‡alÄ±ÅŸtÄ±rma</h2>
<p>Bu bÃ¶lÃ¼mde UygulamalarÄ± Ã‡alÄ±ÅŸtÄ±rma konusunu netleÅŸtirip uygulamada kullanacaÄŸÄ±nÄ±z temel noktalarÄ± Ã¶zetliyoruz.</p>
<ul>
<li>
<p>Spring Boot:</p>
<pre><code class="language-bash">./mvnw spring-boot:run
</code></pre>
</li>
<li>
<p>Gin:</p>
<pre><code class="language-bash">go run main.go
</code></pre>
</li>
</ul>
<hr>
<h2>ğŸ§ª cURL ile Test Etme</h2>
<p>API'yi aÅŸaÄŸÄ±daki cURL komutlarÄ± ile test edebilirsiniz:</p>
<p>TÃ¼m KullanÄ±cÄ±larÄ± Getir:</p>
<pre><code class="language-bash">curl -X GET http://localhost:8080/api/users
</code></pre>
<p>Yeni Bir KullanÄ±cÄ± OluÅŸtur:</p>
<pre><code class="language-bash">curl -X POST http://localhost:8080/api/users \
-H "Content-Type: application/json" \
-d '{"name": "John Doe", "email": "johndoe@example.com"}'
</code></pre>
<hr>
<h2>ğŸ SonuÃ§</h2>
<p>ArtÄ±k Object-Relational Mapping iÃ§in Ã¼retim odaklÄ± bir Spring Boot temeliniz var. Sonraki adÄ±mda ayarlarÄ± kendi domainine uyarlayÄ±p test ve gÃ¶zlemlenebilirlik katmanÄ±nÄ± ekleyerek gerÃ§ek trafik altÄ±nda doÄŸrulayÄ±n.</p>]]></content:encoded>
      <category><![CDATA[Java]]></category>
      <category><![CDATA[Kotlin]]></category>
      <category><![CDATA[Go]]></category>
      <category><![CDATA[Spring Boot]]></category>
      <category><![CDATA[Gin]]></category>
      <category><![CDATA[ORM]]></category>
      <media:thumbnail url="https://suaybsimsek.com/images/orm-thumbnail.webp" />
    </item>
    <item>
      <title><![CDATA[REST APIâ€™lerde Girdi DoÄŸrulama]]></title>
      <link>https://suaybsimsek.com/tr/posts/rest-api-input-validation</link>
      <description><![CDATA[Spring Boot ve Gin ile Java, Kotlin ve Goâ€™da REST API girdi doÄŸrulamasÄ±nÄ± uygulamayÄ± Ã¶ÄŸrenin. Anotasyon, Ã¶zel doÄŸrulama ve hata yÃ¶netimi Ã¶rnekleri iÃ§erir.]]></description>
      <pubDate>Sun, 15 Dec 2024 00:00:00 GMT</pubDate>
      <atom:updated>2024-12-16T00:00:00.000Z</atom:updated>
      <guid isPermaLink="true">https://suaybsimsek.com/tr/posts/rest-api-input-validation</guid>
      <content:encoded><![CDATA[<p>REST APIâ€™lerde girdi doÄŸrulama, gÃ¼venli ve saÄŸlam web servisleri oluÅŸturmak iÃ§in Ã§ok Ã¶nemlidir. Bu makalede, Spring Boot kullanarak Java ve Kotlinâ€™de, Gin frameworkâ€™Ã¼ ile Goâ€™da doÄŸrulamanÄ±n nasÄ±l yapÄ±lacaÄŸÄ±nÄ± adÄ±m adÄ±m inceleyeceÄŸiz.</p>
<hr>
<h2>ğŸŒŸ Girdi DoÄŸrulama Neden Ã–nemlidir?</h2>
<p>DoÄŸrulama, APIâ€™nÄ±za gÃ¶nderilen verilerin beklenen formatlara uygun olmasÄ±nÄ± saÄŸlayarak SQL Enjeksiyonu, XSS ve hatalÄ± veri giriÅŸi gibi potansiyel gÃ¼venlik aÃ§Ä±klarÄ±nÄ± engeller.</p>
<hr>
<h2>ğŸ“‹ Gereksinimler</h2>
<p>DoÄŸrulama katmanÄ±nÄ± uygulamadan Ã¶nce ÅŸunlarÄ±n hazÄ±r olduÄŸundan emin olun:</p>
<ul>
<li>Spring Boot Ã¶rnekleri iÃ§in Java 17+</li>
<li>Gin Ã¶rnekleri iÃ§in Go 1.21+</li>
<li>Ã‡alÄ±ÅŸan bir Spring Boot veya Gin baÅŸlangÄ±Ã§ projesi</li>
<li>DTO, JSON payload ve HTTP durum kodlarÄ± hakkÄ±nda temel bilgi</li>
</ul>
<hr>
<h2>ğŸ§ª AdÄ±m 1: DoÄŸrulama BaÄŸÄ±mlÄ±lÄ±klarÄ±nÄ± Ekleyin</h2>
<p>Bu bÃ¶lÃ¼mde AdÄ±m 1: DoÄŸrulama BaÄŸÄ±mlÄ±lÄ±klarÄ±nÄ± Ekleyin konusunu netleÅŸtirip uygulamada kullanacaÄŸÄ±nÄ±z temel noktalarÄ± Ã¶zetliyoruz.</p>
<h3>Spring Boot Projeleri iÃ§in:</h3>
<p>Ã–nce validation starter baÄŸÄ±mlÄ±lÄ±ÄŸÄ±nÄ± ekleyerek anotasyon tabanlÄ± doÄŸrulama altyapÄ±sÄ±nÄ± aktif hale getirin.</p>
<ul>
<li>Maven:</li>
</ul>
<pre><code class="language-xml">&#x3C;dependency>
    &#x3C;groupId>org.springframework.boot&#x3C;/groupId>
    &#x3C;artifactId>spring-boot-starter-validation&#x3C;/artifactId>
&#x3C;/dependency>
</code></pre>
<ul>
<li>Gradle:</li>
</ul>
<pre><code class="language-groovy">implementation 'org.springframework.boot:spring-boot-starter-validation'
</code></pre>
<h3>Gin Framework (Go) iÃ§in:</h3>
<p>AÅŸaÄŸÄ±daki Ã¶rnek, Gin Framework (Go) iÃ§in iÃ§in pratik bir baÄŸlam sunar ve doÄŸrudan uygulanabilir.</p>
<pre><code class="language-bash"># Gin frameworkÃ¼nÃ¼ yÃ¼kleyin
go get -u github.com/gin-gonic/gin

# DoÄŸrulama paketi ekleyin
go get -u github.com/go-playground/validator/v10
</code></pre>
<hr>
<h2>ğŸ§ª AdÄ±m 2: DoÄŸrulama KurallarÄ± ile Bir DTO TanÄ±mlayÄ±n</h2>
<p>Alanlara doÄŸrulama kurallarÄ±nÄ± tanÄ±mlamak iÃ§in anotasyonlar kullanÄ±n. Ã–rnekler: <code>@NotNull</code>, <code>@Size</code>, <code>@Pattern</code>.</p>
<h3>Java</h3>
<pre><code class="language-java">package com.example.demo.dto;

import jakarta.validation.constraints.NotNull;
import jakarta.validation.constraints.Size;
import lombok.Data;

@Data
public class TodoRequest {

    @NotNull(message = "BaÅŸlÄ±k zorunludur")
    @Size(min = 3, max = 50, message = "BaÅŸlÄ±k 3 ile 50 karakter arasÄ±nda olmalÄ±dÄ±r")
    private String title;

    private boolean completed;
}
</code></pre>
<h3>Kotlin</h3>
<pre><code class="language-kotlin">package com.example.demo.dto

import jakarta.validation.constraints.NotNull
import jakarta.validation.constraints.Size

data class TodoRequest(
    @field:NotNull(message = "BaÅŸlÄ±k zorunludur")
    @field:Size(min = 3, max = 50, message = "BaÅŸlÄ±k 3 ile 50 karakter arasÄ±nda olmalÄ±dÄ±r")
    val title: String?,

    val completed: Boolean = false
)
</code></pre>
<h3>Go</h3>
<pre><code class="language-go">package dto

import (
    "github.com/go-playground/validator/v10"
)

type TodoRequest struct {
    Title     string `validate:"required,min=3,max=50"`
    Completed bool   `validate:""`
}

var validate = validator.New()

func ValidateTodoRequest(todo TodoRequest) error {
    return validate.Struct(todo)
}
</code></pre>
<hr>
<h2>ğŸ§ª AdÄ±m 3: DoÄŸrulama ile Bir Controller OluÅŸturun</h2>
<p>DoÄŸrulamayÄ± REST endpointâ€™lerinize entegre edin.</p>
<h3>Java</h3>
<pre><code class="language-java">package com.example.demo.controller;

import com.example.demo.dto.TodoRequest;
import org.springframework.validation.annotation.Validated;
import org.springframework.web.bind.annotation.*;

@RestController
@RequestMapping("/api/todos")
public class TodoController {

    @PostMapping
    public String createTodo(@Validated @RequestBody TodoRequest request) {
        return "OluÅŸturulan gÃ¶rev: " + request.getTitle();
    }
}
</code></pre>
<h3>Kotlin</h3>
<pre><code class="language-kotlin">package com.example.demo.controller

import com.example.demo.dto.TodoRequest
import org.springframework.validation.annotation.Validated
import org.springframework.web.bind.annotation.*

@RestController
@RequestMapping("/api/todos")
class TodoController {

    @PostMapping
    fun createTodo(@Validated @RequestBody request: TodoRequest): String {
        return "OluÅŸturulan gÃ¶rev: ${request.title}"
    }
}
</code></pre>
<h3>Go</h3>
<pre><code class="language-go">package controller

import (
    "dto"
    "github.com/gin-gonic/gin"
    "net/http"
)

func CreateTodoHandler(c *gin.Context) {
    var todo dto.TodoRequest

    if err := c.ShouldBindJSON(&#x26;todo); err != nil {
        c.JSON(http.StatusBadRequest, gin.H{"error": err.Error()})
        return
    }

    if err := dto.ValidateTodoRequest(todo); err != nil {
        c.JSON(http.StatusBadRequest, gin.H{"error": err.Error()})
        return
    }

    c.JSON(http.StatusOK, gin.H{"message": "OluÅŸturulan gÃ¶rev", "title": todo.Title})
}
</code></pre>
<hr>
<h2>ğŸ› ï¸ AdÄ±m 4: Hata MesajlarÄ±nÄ± YÃ¶netin</h2>
<p>Hata mesajlarÄ±nÄ± daha kullanÄ±cÄ± dostu olacak ÅŸekilde dÃ¼zelleyin.</p>
<h3>Java</h3>
<pre><code class="language-java">package com.example.demo.exception;

import org.springframework.http.HttpStatus;
import org.springframework.web.bind.annotation.ExceptionHandler;
import org.springframework.web.bind.annotation.RestControllerAdvice;
import org.springframework.web.bind.MethodArgumentNotValidException;

import java.util.HashMap;
import java.util.Map;

@RestControllerAdvice
public class GlobalExceptionHandler {

    @ExceptionHandler(MethodArgumentNotValidException.class)
    public Map&#x3C;String, String> handleValidationExceptions(MethodArgumentNotValidException ex) {
        Map&#x3C;String, String> errors = new HashMap&#x3C;>();
        ex.getBindingResult().getFieldErrors().forEach(error -> errors.put(error.getField(), error.getDefaultMessage()));
        return errors;
    }
}
</code></pre>
<h3>Kotlin</h3>
<pre><code class="language-kotlin">package com.example.demo.exception

import org.springframework.http.HttpStatus
import org.springframework.web.bind.annotation.ExceptionHandler
import org.springframework.web.bind.annotation.RestControllerAdvice
import org.springframework.web.bind.MethodArgumentNotValidException

@RestControllerAdvice
class GlobalExceptionHandler {

    @ExceptionHandler(MethodArgumentNotValidException::class)
    fun handleValidationExceptions(ex: MethodArgumentNotValidException): Map&#x3C;String, String> {
        return ex.bindingResult.fieldErrors.associate { it.field to it.defaultMessage.orEmpty() }
    }
}
</code></pre>
<h3>Go</h3>
<pre><code class="language-go">package middleware

import (
    "github.com/gin-gonic/gin"
    "net/http"
)

func ErrorHandler() gin.HandlerFunc {
    return func(c *gin.Context) {
        c.Next()

        if len(c.Errors) > 0 {
            c.JSON(http.StatusBadRequest, gin.H{"errors": c.Errors.JSON()})
        }
    }
}
</code></pre>
<hr>
<p>main.go Ã–rneÄŸi</p>
<p>Gin uygulamasÄ± iÃ§in <code>main.go</code> dosyasÄ±nÄ±n bir Ã¶rneÄŸi:</p>
<pre><code class="language-go">package main

import (
	"controller"
	"github.com/gin-gonic/gin"
)

func main() {
	r := gin.Default()

	r.POST("/api/todos", controller.CreateTodoHandler)

	r.Run() // Sunucu: http://localhost:8080
}
</code></pre>
<hr>
<h2>â–¶ï¸ AdÄ±m 5: UygulamayÄ± Ã‡alÄ±ÅŸtÄ±rÄ±n</h2>
<p>Bu bÃ¶lÃ¼mde AdÄ±m 5: UygulamayÄ± Ã‡alÄ±ÅŸtÄ±rÄ±n konusunu netleÅŸtirip uygulamada kullanacaÄŸÄ±nÄ±z temel noktalarÄ± Ã¶zetliyoruz.</p>
<p>Spring Boot (Java/Kotlin):
Spring Boot uygulamasÄ±nÄ± terminal veya IDEâ€™nizden Ã§alÄ±ÅŸtÄ±rÄ±n:</p>
<pre><code class="language-bash">./mvnw spring-boot:run # Maven projeleri iÃ§in
./gradlew bootRun       # Gradle projeleri iÃ§in
</code></pre>
<p>API adresi: <code>http://localhost:8080/api/todos</code></p>
<h3>Gin (Go)</h3>
<p>Go uygulamasÄ±nÄ± Ã§alÄ±ÅŸtÄ±rÄ±n:</p>
<pre><code class="language-bash">go run main.go
</code></pre>
<p>API adresi: <code>http://localhost:8080/api/todos</code></p>
<hr>
<h2>ğŸ§ª cURL ile Test Etme</h2>
<p>APIâ€™yÄ± test etmek iÃ§in cURL komutlarÄ±:</p>
<ul>
<li>Yeni Bir GÃ¶rev Ekleme:</li>
</ul>
<pre><code class="language-bash">curl -X POST http://localhost:8080/api/todos \
-H "Content-Type: application/json" \
-d '{"title": "Yeni GÃ¶rev", "completed": false}'
</code></pre>
<ul>
<li>TÃ¼m GÃ¶revleri Getirme:</li>
</ul>
<pre><code class="language-bash">curl -X GET http://localhost:8080/api/todos
</code></pre>
<ul>
<li>DoÄŸrulama HatalarÄ±nÄ± Test Etme:</li>
</ul>
<p>GeÃ§ersiz bir istek gÃ¶nderin:</p>
<pre><code class="language-bash">curl -X POST http://localhost:8080/api/todos \
-H "Content-Type: application/json" \
-d '{"title": ""}'
</code></pre>
<hr>
<h2>ğŸ SonuÃ§</h2>
<p>ArtÄ±k REST APIâ€™lerde Girdi DoÄŸrulama iÃ§in Ã¼retim odaklÄ± bir Spring Boot temeliniz var. Sonraki adÄ±mda ayarlarÄ± kendi domainine uyarlayÄ±p test ve gÃ¶zlemlenebilirlik katmanÄ±nÄ± ekleyerek gerÃ§ek trafik altÄ±nda doÄŸrulayÄ±n.</p>]]></content:encoded>
      <category><![CDATA[Java]]></category>
      <category><![CDATA[Kotlin]]></category>
      <category><![CDATA[Go]]></category>
      <category><![CDATA[Spring Boot]]></category>
      <category><![CDATA[Gin]]></category>
      <category><![CDATA[DoÄŸrulama]]></category>
      <media:thumbnail url="https://suaybsimsek.com/images/input-validation-thumbnail.webp" />
    </item>
    <item>
      <title><![CDATA[Spring GraphQL ile API OluÅŸturma]]></title>
      <link>https://suaybsimsek.com/tr/posts/spring-boot-graphql</link>
      <description><![CDATA[Java ve Kotlin kullanarak Spring for GraphQL ile GraphQL API\u201leri nasÄ±l oluÅŸturacaÄŸÄ±nÄ±zÄ± Ã¶ÄŸrenin. Åema oluÅŸturma, sorgu iÅŸleme ve entegrasyonu iÃ§erir.]]></description>
      <pubDate>Sun, 15 Dec 2024 00:00:00 GMT</pubDate>
      <atom:updated>2024-12-16T00:00:00.000Z</atom:updated>
      <guid isPermaLink="true">https://suaybsimsek.com/tr/posts/spring-boot-graphql</guid>
      <content:encoded><![CDATA[<p>Spring for GraphQL, Spring Boot ile entegre Ã§alÄ±ÅŸan GraphQL API'lerinin geliÅŸtirilmesini kolaylaÅŸtÄ±rÄ±r. Bu rehber, Java ve Kotlin kullanarak bir GraphQL API'si oluÅŸturmanÄ±zÄ±, ÅŸema tanÄ±mlamayÄ±, sorgu iÅŸleme ve baÄŸlÄ±mlÄ±klarÄ±n enjekte edilmesini adÄ±m adÄ±m aÃ§Ä±klÄ±yor.</p>
<hr>
<h2>ğŸŒŸ Neden GraphQL KullanÄ±lmalÄ±?</h2>
<p>GraphQL, istemcilerin sadece gerekli olan verileri talep etmesine izin vererek, REST'e gÃ¶re fazla veya eksik veri alma problemini azaltÄ±r. AyrÄ±ca, gÃ¼Ã§lÃ¼ tip desteÄŸi sunar ve verimli veri alma saÄŸlar, modern API'ler iÃ§in popÃ¼ler bir seÃ§enek haline gelir.</p>
<hr>
<h2>ğŸ“‹ Gereksinimler</h2>
<p>ğŸ“‹ AÅŸaÄŸÄ±daki bileÅŸenlerin kurulu olduÄŸundan emin olun:</p>
<ul>
<li>â˜• Java Development Kit (JDK) 17+</li>
<li>ğŸ“¦ Maven veya Gradle kurulu</li>
<li>ğŸ”¤ Bir Java IDE (IntelliJ IDEA, Eclipse vb.)</li>
</ul>
<hr>
<h2>ğŸ› ï¸ AdÄ±m 1: BaÄŸÄ±mlÄ±klarÄ± Ekleme</h2>
<p>Spring for GraphQL'i etkinleÅŸtirmek iÃ§in aÅŸaÄŸÄ±daki baÄŸlÄ±mlÄ±klarÄ± projenize ekleyin.</p>
<p>Maven:</p>
<pre><code class="language-xml">&#x3C;dependency>
  &#x3C;groupId>org.springframework.boot&#x3C;/groupId>
  &#x3C;artifactId>spring-boot-starter-graphql&#x3C;/artifactId>
&#x3C;/dependency>
</code></pre>
<p>Gradle:</p>
<pre><code class="language-groovy">implementation 'org.springframework.boot:spring-boot-starter-graphql'
</code></pre>
<hr>
<h2>ğŸ› ï¸ AdÄ±m 2: GraphQL ÅemasÄ±nÄ± TanÄ±mlama</h2>
<p><code>src/main/resources/graphql</code> dizini altÄ±nda <code>schema.graphqls</code> adlÄ± bir dosya oluÅŸturun.</p>
<pre><code class="language-graphql">type Query {
  getUser(id: ID!): User
  getUsers: [User]
}

type User {
  id: ID!
  name: String!
  email: String!
}
</code></pre>
<hr>
<h2>ğŸ› ï¸ AdÄ±m 3: Veri Modeli ve Servislerin TanÄ±mlanmasÄ±</h2>
<p>SorgularÄ± iÅŸlemek iÃ§in veri modelinizi ve servis katmanÄ±nÄ± tanÄ±mlayÄ±n.</p>
<h3>Java</h3>
<p>Entity</p>
<pre><code class="language-java">package com.example.demo.model;

import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;

@Data
@NoArgsConstructor
@AllArgsConstructor
public class User {
    private String id;
    private String name;
    private String email;
}
</code></pre>
<p>Servis</p>
<pre><code class="language-java">package com.example.demo.service;

import com.example.demo.model.User;
import org.springframework.stereotype.Service;

import java.util.List;
import java.util.Map;
import java.util.stream.Collectors;
import java.util.stream.Stream;

@Service
public class UserService {

    private final Map&#x3C;String, User> userData = Stream.of(
        new User("1", "Alice", "alice@example.com"),
        new User("2", "Bob", "bob@example.com")
    ).collect(Collectors.toMap(User::getId, user -> user));

    public User getUser(String id) {
        return userData.get(id);
    }

    public List&#x3C;User> getUsers() {
        return List.copyOf(userData.values());
    }
}
</code></pre>
<hr>
<h3>Kotlin</h3>
<p>Entity</p>
<pre><code class="language-kotlin">package com.example.demo.model

data class User(
    val id: String,
    val name: String,
    val email: String
)
</code></pre>
<p>Servis</p>
<pre><code class="language-kotlin">package com.example.demo.service

import com.example.demo.model.User
import org.springframework.stereotype.Service

@Service
class UserService {

    private val userData = mapOf(
        "1" to User("1", "Alice", "alice@example.com"),
        "2" to User("2", "Bob", "bob@example.com")
    )

    fun getUser(id: String): User? = userData[id]

    fun getUsers(): List&#x3C;User> = userData.values.toList()
}
</code></pre>
<hr>
<h2>ğŸ› ï¸ AdÄ±m 4: GraphQL Controller'Ä± Uygulama</h2>
<p>GraphQL sorgularÄ±nÄ± ve mutasyonlarÄ±nÄ± iÅŸlemek iÃ§in <code>@Controller</code> anotasyonunu kullanÄ±n.</p>
<h3>Java</h3>
<pre><code class="language-java">package com.example.demo.controller;

import com.example.demo.model.User;
import com.example.demo.service.UserService;
import lombok.RequiredArgsConstructor;
import org.springframework.graphql.data.method.annotation.QueryMapping;
import org.springframework.stereotype.Controller;

import java.util.List;

@Controller
@RequiredArgsConstructor
public class UserController {

    private final UserService userService;

    @QueryMapping
    public User getUser(String id) {
        return userService.getUser(id);
    }

    @QueryMapping
    public List&#x3C;User> getUsers() {
        return userService.getUsers();
    }
}
</code></pre>
<hr>
<h3>Kotlin</h3>
<pre><code class="language-kotlin">package com.example.demo.controller

import com.example.demo.model.User
import com.example.demo.service.UserService
import org.springframework.graphql.data.method.annotation.QueryMapping
import org.springframework.stereotype.Controller

@Controller
class UserController(
    private val userService: UserService
) {

    @QueryMapping
    fun getUser(id: String): User? = userService.getUser(id)

    @QueryMapping
    fun getUsers(): List&#x3C;User> = userService.getUsers()
}
</code></pre>
<hr>
<h2>â–¶ï¸ UygulamayÄ± Ã‡alÄ±ÅŸtÄ±rma</h2>
<p>UygulamayÄ± aÅŸaÄŸÄ±daki komutlarla Ã§alÄ±ÅŸtÄ±rÄ±n:</p>
<p>Spring Boot (Java/Kotlin):
Kurulumun doÄŸru Ã§alÄ±ÅŸtÄ±ÄŸÄ±nÄ± doÄŸrulamak iÃ§in uygulamayÄ± tercih ettiÄŸiniz dil yÄ±ÄŸÄ±nÄ±yla baÅŸlatÄ±n.</p>
<pre><code class="language-bash">./mvnw spring-boot:run
</code></pre>
<p>GraphQL Playground'a eriÅŸim saÄŸlamak iÃ§in <code>http://localhost:8080/graphiql</code> adresine gidin.</p>
<hr>
<h2>ğŸ§ª GraphQL API'sini Test Etme</h2>
<p>API'nizi test etmek iÃ§in aÅŸaÄŸÄ±daki sorgularÄ± kullanabilirsiniz:</p>
<ul>
<li>Bir kullanÄ±cÄ±yÄ± ID'ye gÃ¶re getir:</li>
</ul>
<pre><code class="language-graphql">query {
  getUser(id: "1") {
    id
    name
    email
  }
}
</code></pre>
<ul>
<li>TÃ¼m kullanÄ±cÄ±larÄ± getir:</li>
</ul>
<pre><code class="language-graphql">query {
  getUsers {
    id
    name
    email
  }
}
</code></pre>
<hr>
<h2>ğŸ SonuÃ§</h2>
<p>ArtÄ±k Spring GraphQL ile API OluÅŸturma iÃ§in Ã¼retim odaklÄ± bir Spring Boot temeliniz var. Sonraki adÄ±mda ayarlarÄ± kendi domainine uyarlayÄ±p test ve gÃ¶zlemlenebilirlik katmanÄ±nÄ± ekleyerek gerÃ§ek trafik altÄ±nda doÄŸrulayÄ±n.</p>]]></content:encoded>
      <category><![CDATA[Java]]></category>
      <category><![CDATA[Kotlin]]></category>
      <category><![CDATA[Spring Boot]]></category>
      <category><![CDATA[GraphQL]]></category>
      <media:thumbnail url="https://suaybsimsek.com/images/spring-boot-graphql-thumbnail.webp" />
    </item>
    <item>
      <title><![CDATA[Gin - Ä°lk Uygulama]]></title>
      <link>https://suaybsimsek.com/tr/posts/golang-gin-first-application</link>
      <description><![CDATA[SÄ±fÄ±rdan ilk Golang Gin uygulamanÄ±zÄ± oluÅŸturmanÄ±za yardÄ±mcÄ± olacak, yeni baÅŸlayanlar iÃ§in rehber. Temelleri Ã¶ÄŸrenin ve Gin ile yolculuÄŸunuza baÅŸlayÄ±n.]]></description>
      <pubDate>Sat, 14 Dec 2024 00:00:00 GMT</pubDate>
      <atom:updated>2024-12-15T00:00:00.000Z</atom:updated>
      <guid isPermaLink="true">https://suaybsimsek.com/tr/posts/golang-gin-first-application</guid>
      <content:encoded><![CDATA[<p>Gin, Golang ile yÃ¼ksek performanslÄ± web uygulamalarÄ± oluÅŸturma sÃ¼recini basitleÅŸtirir. Bu rehberde, adÄ±m adÄ±m ilk Gin uygulamanÄ±zÄ± nasÄ±l oluÅŸturacaÄŸÄ±nÄ±zÄ± gÃ¶stereceÄŸiz.</p>
<hr>
<h2>ğŸŒŸ Bu yazÄ±da ne Ã¶ÄŸreneceksin?</h2>
<p>Bu bÃ¶lÃ¼mde Bu yazÄ±da ne Ã¶ÄŸreneceksin? konusunu netleÅŸtirip uygulamada kullanacaÄŸÄ±nÄ±z temel noktalarÄ± Ã¶zetliyoruz.</p>
<ul>
<li>Minimal bir Gin proje yapÄ±sÄ±nÄ± sÄ±fÄ±rdan kurmayÄ±.</li>
<li>Ä°lk JSON endpointâ€™ini yazÄ±p dÄ±ÅŸarÄ± aÃ§mayÄ±.</li>
<li>Servisi lokalde Ã§alÄ±ÅŸtÄ±rÄ±p temel doÄŸrulamayÄ± yapmayÄ±.</li>
</ul>
<hr>
<h2>ğŸ“‹ Gereksinimler</h2>
<p>ğŸ“‹ BaÅŸlamadan Ã¶nce aÅŸaÄŸÄ±daki gereksinimlere sahip olduÄŸunuzdan emin olun:</p>
<ul>
<li>ğŸ”§ Golang 1.17+ kurulu</li>
<li>ğŸ— Bir metin editÃ¶rÃ¼ veya IDE (Ã¶r. Visual Studio Code, GoLand veya Vim)</li>
</ul>
<hr>
<h2>ğŸ› ï¸ AdÄ±m 1: Gin Projenizi OluÅŸturma</h2>
<p>Ä°lk Gin projenizi aÅŸaÄŸÄ±daki adÄ±mlarÄ± izleyerek ayarlayabilirsiniz:</p>
<ol>
<li>Bir Go ModÃ¼lÃ¼ BaÅŸlatÄ±n</li>
</ol>
<pre><code class="language-bash">mkdir gin-first-app
cd gin-first-app
go mod init gin-first-app
</code></pre>
<ol start="2">
<li>Gin Kurulumu</li>
</ol>
<pre><code class="language-bash">go get -u github.com/gin-gonic/gin
</code></pre>
<hr>
<h2>ğŸ› ï¸ AdÄ±m 2: Ä°lk Endpointâ€™inizi Yazma</h2>
<p>Basit bir "hello" mesajÄ± gÃ¶nderen bir endpoint yazalÄ±m:</p>
<p><code>main.go</code> adÄ±nda bir dosya oluÅŸturun ve aÅŸaÄŸÄ±daki iÃ§eriÄŸi ekleyin:</p>
<pre><code class="language-go">package main

import (
	"github.com/gin-gonic/gin"
)

func main() {
	r := gin.Default()

	r.GET("/hello", func(c *gin.Context) {
		c.JSON(200, gin.H{
			"message": "Merhaba, Gin!",
		})
	})

	r.Run() // 0.0.0.0:8080 Ã¼zerinde dinler ve hizmet verir
}
</code></pre>
<hr>
<h2>â–¶ï¸ AdÄ±m 3: UygulamayÄ± Ã‡alÄ±ÅŸtÄ±rma</h2>
<p>Bu bÃ¶lÃ¼mde AdÄ±m 3: UygulamayÄ± Ã‡alÄ±ÅŸtÄ±rma konusunu netleÅŸtirip uygulamada kullanacaÄŸÄ±nÄ±z temel noktalarÄ± Ã¶zetliyoruz.</p>
<ol>
<li>Proje klasÃ¶rÃ¼nÃ¼zde bir terminal aÃ§Ä±n.</li>
<li>UygulamanÄ±zÄ± Ã§alÄ±ÅŸtÄ±rmak iÃ§in aÅŸaÄŸÄ±daki komutu Ã§alÄ±ÅŸtÄ±rÄ±n:</li>
</ol>
<pre><code class="language-bash">go run main.go
</code></pre>
<ol start="3">
<li>Endpoint'e ÅŸu adresten eriÅŸin:
<pre><code class="language-filename=&#x22;snippet.txt&#x22;">http://localhost:8080/hello
</code></pre>
</li>
</ol>
<p>YanÄ±t:</p>
<pre><code class="language-json">{
  "message": "Merhaba, Gin!"
}
</code></pre>
<hr>
<h2>ğŸ SonuÃ§</h2>
<p>ArtÄ±k Gin - Ä°lk Uygulama iÃ§in Ã¼retim odaklÄ± bir temeliniz var. Sonraki adÄ±mda ayarlarÄ± kendi domainine uyarlayÄ±p test ve gÃ¶zlemlenebilirlik katmanÄ±nÄ± ekleyerek gerÃ§ek trafik altÄ±nda doÄŸrulayÄ±n.</p>]]></content:encoded>
      <category><![CDATA[Go]]></category>
      <category><![CDATA[Gin]]></category>
      <category><![CDATA[BaÅŸlangÄ±Ã§ Rehberi]]></category>
      <media:thumbnail url="https://suaybsimsek.com/images/golang-gin-first-app-thumbnail.webp" />
    </item>
    <item>
      <title><![CDATA[Spring Boot ile REST API GeliÅŸtirme]]></title>
      <link>https://suaybsimsek.com/tr/posts/building-a-rest-api-with-spring-boot</link>
      <description><![CDATA[Spring Boot kullanarak REST API nasÄ±l geliÅŸtirilir? HTTP metodlarÄ±, JSON veri iÅŸleme, Lombok entegrasyonu ve curl ile test etme.]]></description>
      <pubDate>Tue, 10 Dec 2024 00:00:00 GMT</pubDate>
      <atom:updated>2024-12-11T00:00:00.000Z</atom:updated>
      <guid isPermaLink="true">https://suaybsimsek.com/tr/posts/building-a-rest-api-with-spring-boot</guid>
      <content:encoded><![CDATA[<p>Spring Boot, RESTful web servislerini hÄ±zlÄ± ve kolay bir ÅŸekilde geliÅŸtirmek iÃ§in mÃ¼kemmel bir araÃ§tÄ±r. Bu yazÄ±da, Spring Boot kullanarak bir REST API'nin nasÄ±l oluÅŸturulacaÄŸÄ±nÄ± adÄ±m adÄ±m gÃ¶receÄŸiz.</p>
<hr>
<h2>ğŸŒŸ REST API Nedir?</h2>
<p>REST (Representational State Transfer), web servisleri tasarlamak iÃ§in kullanÄ±lan bir mimari stilidir. Ä°stemciler ile sunucular arasÄ±ndaki iletiÅŸimde standart HTTP yÃ¶ntemlerini kullanÄ±r.</p>
<h3>HTTP YÃ¶ntemleri</h3>
<p>Bu alt bÃ¶lÃ¼mde HTTP YÃ¶ntemleri iÃ§in, sonraki Ã¶rneÄŸi doÄŸru okumayÄ± kolaylaÅŸtÄ±ran kÄ±sa bir baÄŸlam veriyoruz.</p>






























<table><thead><tr><th>YÃ¶ntem</th><th>AÃ§Ä±klama</th><th>Ã–rnek Endpoint</th></tr></thead><tbody><tr><td>GET</td><td>Bir kaynaÄŸÄ± alÄ±r.</td><td><code>/api/todos</code></td></tr><tr><td>POST</td><td>Yeni bir kaynak oluÅŸturur.</td><td><code>/api/todos</code></td></tr><tr><td>PUT</td><td>KaynaÄŸÄ± gÃ¼nceller veya oluÅŸturur.</td><td><code>/api/todos/1</code></td></tr><tr><td>DELETE</td><td>KaynaÄŸÄ± siler.</td><td><code>/api/todos/1</code></td></tr></tbody></table>
<hr>
<h2>ğŸ“‹ Gereksinimler</h2>
<p>BaÅŸlamadan Ã¶nce aÅŸaÄŸÄ±dakilerin hazÄ±r olduÄŸundan emin olun:</p>
<ul>
<li>Java 17+</li>
<li>Maven veya Gradle</li>
<li>Bir IDE (IntelliJ IDEA, Eclipse, VS Code)</li>
<li>HTTP metodlarÄ± ve JSON payload yapÄ±sÄ± hakkÄ±nda temel bilgi</li>
</ul>
<hr>
<h2>ğŸ› ï¸ AdÄ±m 1: Proje OluÅŸturma</h2>
<p>Spring Boot projesini <a href="https://start.spring.io/">Spring Initializr</a> kullanarak oluÅŸturabilirsiniz. AÅŸaÄŸÄ±daki ayarlarÄ± seÃ§in:</p>
<ul>
<li>Proje: Maven</li>
<li>Dil: Java veya Kotlin</li>
<li>Spring Boot SÃ¼rÃ¼mÃ¼: 3.0.0+</li>
<li>BaÄŸÄ±mlÄ±lÄ±klar: Spring Web, Spring Boot DevTools, Lombok</li>
</ul>
<p>Projeyi indirin, IDE'nizde aÃ§Ä±n ve Ã§alÄ±ÅŸtÄ±rmaya hazÄ±rlanÄ±n.</p>
<hr>
<h2>ğŸ› ï¸ AdÄ±m 2: Model SÄ±nÄ±fÄ± OluÅŸturma</h2>
<p><code>Todo</code> nesnesi iÃ§in bir model sÄ±nÄ±fÄ± oluÅŸturun:</p>
<h3>Java</h3>
<pre><code class="language-java">package com.example.demo.model;

import lombok.Data;

@Data
public class Todo {
    private Long id;
    private String title;
    private boolean completed;
}
</code></pre>
<h3>Kotlin</h3>
<pre><code class="language-kotlin">package com.example.demo.model

data class Todo(
    var id: Long,
    var title: String,
    var completed: Boolean
)
</code></pre>
<hr>
<h2>ğŸ› ï¸ AdÄ±m 3: Controller SÄ±nÄ±fÄ± OluÅŸturma</h2>
<p>CRUD iÅŸlemlerini tanÄ±mlayan bir <code>TodoController</code> sÄ±nÄ±fÄ± ekleyin:</p>
<h3>Java</h3>
<pre><code class="language-java">package com.example.demo.controller;

import com.example.demo.model.Todo;
import org.springframework.web.bind.annotation.*;

import java.util.ArrayList;
import java.util.List;

@RestController
@RequestMapping("/api/todos")
public class TodoController {

    private List&#x3C;Todo> todos = new ArrayList&#x3C;>();

    @GetMapping
    public List&#x3C;Todo> getAllTodos() {
        return todos;
    }

    @PostMapping
    public Todo createTodo(@RequestBody Todo todo) {
        todo.setId((long) (todos.size() + 1));
        todos.add(todo);
        return todo;
    }

    @PutMapping("/{id}")
    public Todo updateTodo(@PathVariable Long id, @RequestBody Todo updatedTodo) {
        Todo todo = todos.stream().filter(t -> t.getId().equals(id)).findFirst().orElse(null);
        if (todo != null) {
            todo.setTitle(updatedTodo.getTitle());
            todo.setCompleted(updatedTodo.isCompleted());
        }
        return todo;
    }

    @DeleteMapping("/{id}")
    public void deleteTodo(@PathVariable Long id) {
        todos.removeIf(todo -> todo.getId().equals(id));
    }
}
</code></pre>
<h3>Kotlin</h3>
<pre><code class="language-kotlin">package com.example.demo.controller

import com.example.demo.model.Todo
import org.springframework.web.bind.annotation.*

@RestController
@RequestMapping("/api/todos")
class TodoController {

    private val todos = mutableListOf&#x3C;Todo>()

    @GetMapping
    fun getAllTodos(): List&#x3C;Todo> = todos

    @PostMapping
    fun createTodo(@RequestBody todo: Todo): Todo {
        todo.id = (todos.size + 1).toLong()
        todos.add(todo)
        return todo
    }

    @PutMapping("/{id}")
    fun updateTodo(@PathVariable id: Long, @RequestBody updatedTodo: Todo): Todo? {
        val todo = todos.find { it.id == id }
        todo?.apply {
            title = updatedTodo.title
            completed = updatedTodo.completed
        }
        return todo
    }

    @DeleteMapping("/{id}")
    fun deleteTodo(@PathVariable id: Long) {
        todos.removeIf { it.id == id }
    }
}
</code></pre>
<hr>
<h2>ğŸ§ª AdÄ±m 4: API'yi Test Etme</h2>
<p>API'nizi test etmek iÃ§in <code>curl</code> komutlarÄ±nÄ± kullanÄ±n:</p>
<ul>
<li>GET TÃ¼m Todos:</li>
</ul>
<pre><code class="language-bash">curl -X GET http://localhost:8080/api/todos
</code></pre>
<ul>
<li>POST Yeni Todo:</li>
</ul>
<pre><code class="language-bash">curl -X POST http://localhost:8080/api/todos -H "Content-Type: application/json" -d '{"title": "New Todo", "completed": false}'
</code></pre>
<ul>
<li>PUT Todo GÃ¼ncelleme:</li>
</ul>
<pre><code class="language-bash">curl -X PUT http://localhost:8080/api/todos/1 -H "Content-Type: application/json" -d '{"title": "Updated Todo", "completed": true}'
</code></pre>
<ul>
<li>DELETE Todo Silme:</li>
</ul>
<pre><code class="language-bash">curl -X DELETE http://localhost:8080/api/todos/1
</code></pre>
<hr>
<h2>ğŸ SonuÃ§</h2>
<p>ArtÄ±k REST API GeliÅŸtirme iÃ§in Ã¼retim odaklÄ± bir Spring Boot temeliniz var. Sonraki adÄ±mda ayarlarÄ± kendi domainine uyarlayÄ±p test ve gÃ¶zlemlenebilirlik katmanÄ±nÄ± ekleyerek gerÃ§ek trafik altÄ±nda doÄŸrulayÄ±n.</p>]]></content:encoded>
      <category><![CDATA[Java]]></category>
      <category><![CDATA[Kotlin]]></category>
      <category><![CDATA[Spring Boot]]></category>
      <category><![CDATA[REST API]]></category>
      <media:thumbnail url="https://suaybsimsek.com/images/spring-boot-rest-api-thumbnail.webp" />
    </item>
    <item>
      <title><![CDATA[Spring Boot - Ä°lk Uygulama]]></title>
      <link>https://suaybsimsek.com/tr/posts/spring-boot-first-application</link>
      <description><![CDATA[Spring Boot ile ilk uygulamanÄ±zÄ± sÄ±fÄ±rdan oluÅŸturmak iÃ§in baÅŸlangÄ±Ã§ seviyesinde bir rehber. Temel bilgileri Ã¶ÄŸrenin ve Spring Boot ile yolculuÄŸunuza baÅŸlayÄ±n.]]></description>
      <pubDate>Tue, 10 Dec 2024 00:00:00 GMT</pubDate>
      <atom:updated>2024-12-11T00:00:00.000Z</atom:updated>
      <guid isPermaLink="true">https://suaybsimsek.com/tr/posts/spring-boot-first-application</guid>
      <content:encoded><![CDATA[<p>Spring Boot, Spring Framework ile Ã¼retim iÃ§in hazÄ±r uygulamalar oluÅŸturmayÄ± kolaylaÅŸtÄ±rÄ±r. Bu rehberde, adÄ±m adÄ±m ilk Spring Boot uygulamanÄ±zÄ± oluÅŸturmayÄ± Ã¶ÄŸreneceksiniz.</p>
<hr>
<h2>ğŸŒŸ Bu yazÄ±da ne Ã¶ÄŸreneceksin?</h2>
<p>Bu bÃ¶lÃ¼mde Bu yazÄ±da ne Ã¶ÄŸreneceksin? konusunu netleÅŸtirip uygulamada kullanacaÄŸÄ±nÄ±z temel noktalarÄ± Ã¶zetliyoruz.</p>
<ul>
<li>Java veya Kotlin ile temel bir Spring Boot projesi baÅŸlatmayÄ±.</li>
<li>Ä°lk HTTP endpointâ€™ini yazÄ±p hÄ±zlÄ±ca doÄŸrulamayÄ±.</li>
<li>UygulamayÄ± lokalde Ã§alÄ±ÅŸtÄ±rÄ±p sonraki Ã¶zellikler iÃ§in temiz bir temel kurmayÄ±.</li>
</ul>
<hr>
<h2>ğŸ“‹ Gereksinimler</h2>
<p>ğŸ“‹ BaÅŸlamadan Ã¶nce aÅŸaÄŸÄ±daki araÃ§larÄ±n kurulu olduÄŸundan emin olun:</p>
<ul>
<li>â˜• Java GeliÅŸtirme Kiti (JDK) 17+</li>
<li>ğŸ“¦ Maven veya Gradle</li>
<li>ğŸ–¥ï¸ Bir Java IDE'si (Ã–rneÄŸin IntelliJ IDEA, Eclipse veya Visual Studio Code)</li>
</ul>
<hr>
<h2>ğŸ› ï¸ AdÄ±m 1: Spring Boot Projesi OluÅŸturma</h2>
<p>Ä°lk Spring Boot projenizi iki ÅŸekilde oluÅŸturabilirsiniz:</p>
<ol>
<li>Spring Initializr Kullanarak ğŸ–±ï¸</li>
</ol>
<ul>
<li><a href="https://start.spring.io/">Spring Initializr</a> adresini ziyaret edin.</li>
<li>AÅŸaÄŸÄ±daki gibi yapÄ±landÄ±rÄ±n:
<ul>
<li>ğŸ“‚ Proje: <code>Maven</code></li>
<li>ğŸ‘¨â€ğŸ’» Dil: <code>Java</code> veya <code>Kotlin</code></li>
<li>ğŸ”„ Spring Boot SÃ¼rÃ¼mÃ¼: <code>3.0.0</code> (veya en gÃ¼ncel sÃ¼rÃ¼m).</li>
<li>ğŸ“œ BaÄŸÄ±mlÄ±lÄ±klar: <code>Spring Web</code></li>
</ul>
</li>
<li>Generate dÃ¼ÄŸmesine tÄ±klayarak proje dosyalarÄ±nÄ± indirin.</li>
</ul>
<ol start="2">
<li>IntelliJ IDEA Kullanarak ğŸ’»</li>
</ol>
<ul>
<li>IntelliJ IDEAâ€™yÄ± aÃ§Ä±n.</li>
<li><code>New Project > Spring Initializr</code> bÃ¶lÃ¼mÃ¼ne gidin.</li>
<li>YukarÄ±da belirtilen parametrelerle benzer ÅŸekilde yapÄ±landÄ±rÄ±n.</li>
</ul>
<hr>
<h2>ğŸ› ï¸ AdÄ±m 2: Ä°lk Endpointâ€™inizi Yazma</h2>
<p>Bir "hello" mesajÄ± dÃ¶nen basit bir endpoint yazalÄ±m:</p>
<h3>Java</h3>
<pre><code class="language-java">package com.example.demo;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RestController;

@SpringBootApplication
@RestController
public class DemoApplication {
    public static void main(String[] args) {
        SpringApplication.run(DemoApplication.class, args);
    }

    @GetMapping("/hello")
    public String sayHello() {
        return "Merhaba, Spring Boot!";
    }
}
</code></pre>
<h3>Kotlin</h3>
<pre><code class="language-kotlin">package com.example.demo

import org.springframework.boot.autoconfigure.SpringBootApplication
import org.springframework.boot.runApplication
import org.springframework.web.bind.annotation.GetMapping
import org.springframework.web.bind.annotation.RestController

@SpringBootApplication
@RestController
class DemoApplication

fun main(args: Array&#x3C;String>) {
    runApplication&#x3C;DemoApplication>(*args)
}

@GetMapping("/hello")
fun sayHello(): String {
    return "Merhaba, Spring Boot!"
}
</code></pre>
<hr>
<h2>â–¶ï¸ AdÄ±m 3: UygulamayÄ± Ã‡alÄ±ÅŸtÄ±rma</h2>
<p>Bu bÃ¶lÃ¼mde AdÄ±m 3: UygulamayÄ± Ã‡alÄ±ÅŸtÄ±rma konusunu netleÅŸtirip uygulamada kullanacaÄŸÄ±nÄ±z temel noktalarÄ± Ã¶zetliyoruz.</p>
<ol>
<li>Proje klasÃ¶rÃ¼nde bir terminal aÃ§Ä±n.</li>
<li>UygulamanÄ±zÄ± Ã§alÄ±ÅŸtÄ±rmak iÃ§in ÅŸu komutu yÃ¼rÃ¼tÃ¼n:</li>
</ol>
<pre><code class="language-bash">./mvnw spring-boot:run
</code></pre>
<ol start="3">
<li>Endpointâ€™e ÅŸu adresten eriÅŸebilirsiniz:
<pre><code class="language-filename=&#x22;snippet.txt&#x22;">http://localhost:8080/hello
</code></pre>
</li>
</ol>
<p>YanÄ±t:</p>
<pre><code class="language-filename=&#x22;snippet.txt&#x22;">Merhaba, Spring Boot!
</code></pre>
<hr>
<h2>ğŸ SonuÃ§</h2>
<p>ArtÄ±k Spring Boot - Ä°lk Uygulama iÃ§in Ã¼retim odaklÄ± bir Spring Boot temeliniz var. Sonraki adÄ±mda ayarlarÄ± kendi domainine uyarlayÄ±p test ve gÃ¶zlemlenebilirlik katmanÄ±nÄ± ekleyerek gerÃ§ek trafik altÄ±nda doÄŸrulayÄ±n.</p>]]></content:encoded>
      <category><![CDATA[Java]]></category>
      <category><![CDATA[Kotlin]]></category>
      <category><![CDATA[Spring Boot]]></category>
      <category><![CDATA[BaÅŸlangÄ±Ã§ Rehberi]]></category>
      <media:thumbnail url="https://suaybsimsek.com/images/spring-boot-first-app-thumbnail.webp" />
    </item>
  </channel>
</rss>
