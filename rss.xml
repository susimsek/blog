<?xml version="1.0" encoding="UTF-8"?><rss xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:atom="http://www.w3.org/2005/Atom" version="2.0">
    <channel>
        <title><![CDATA[≈ûuayb ≈ûim≈üek's Blog (EN)]]></title>
        <description><![CDATA[A blog about backend, fullstack development, and DevOps (English)]]></description>
        <link>https://susimsek.github.io/blog</link>
        <generator>RSS for Node</generator>
        <lastBuildDate>Wed, 01 Jan 2025 18:05:24 GMT</lastBuildDate>
        <atom:link href="https://susimsek.github.io/blog/rss.xml" rel="self" type="application/rss+xml"/>
        <language><![CDATA[en]]></language>
        <item>
            <title><![CDATA[Building a REST API with Spring Boot]]></title>
            <description><![CDATA[Learn how to create a REST API using Spring Boot. Includes HTTP methods, JSON handling, Lombok integration, and curl for testing.]]></description>
            <link>https://susimsek.github.io/blog/posts/building-a-rest-api-with-spring-boot</link>
            <guid isPermaLink="false">https://susimsek.github.io/blog/posts/building-a-rest-api-with-spring-boot</guid>
            <pubDate>Wed, 11 Dec 2024 00:00:00 GMT</pubDate>
            <enclosure url="https://susimsek.github.io/blog/images/spring-boot-rest-api-thumbnail.jpg" length="0" type="image/jpeg"/>
            <content:encoded>&lt;![CDATA[&lt;div&gt;
Spring Boot is an excellent tool for quickly developing RESTful web services. In this article, we‚Äôll walk through creating a REST API step by step using Spring Boot.

---

## üåü What is a REST API?

REST (Representational State Transfer) is an architectural style for designing web services. It uses standard HTTP methods for communication between clients and servers.

### **HTTP Methods**

| **Method** | **Description**                | **Example Endpoint** |
| ---------- | ------------------------------ | -------------------- |
| **GET**    | Retrieves a resource.          | `/api/todos`         |
| **POST**   | Creates a new resource.        | `/api/todos`         |
| **PUT**    | Updates or creates a resource. | `/api/todos/1`       |
| **DELETE** | Deletes a resource.            | `/api/todos/1`       |

---

## üõ†Ô∏è Step 1: Create a Project

You can create a Spring Boot project using [Spring Initializr](https://start.spring.io/). Select the following settings:

- **Project:** Maven
- **Language:** Java or Kotlin
- **Spring Boot Version:** 3.0.0+
- **Dependencies:** Spring Web, Spring Boot DevTools, Lombok

Download the project, open it in your IDE, and get ready to run it.

---

## üìñ Step 2: Create a Model Class

Create a model class for a `Todo` object:

:::tabs
@tab Java [icon=java]

```java
package com.example.demo.model;

import lombok.Data;

@Data
public class Todo {
    private Long id;
    private String title;
    private boolean completed;
}
```

@tab Kotlin [icon=kotlin]

```kotlin
package com.example.demo.model

data class Todo(
    var id: Long,
    var title: String,
    var completed: Boolean
)
```

:::

---

## üìò Step 3: Create a Controller Class

Add a `TodoController` class to define CRUD operations as REST endpoints:

:::tabs
@tab Java [icon=java]

```java
package com.example.demo.controller;

import com.example.demo.model.Todo;
import org.springframework.web.bind.annotation.*;

import java.util.ArrayList;
import java.util.List;

@RestController
@RequestMapping(&quot;/api/todos&quot;)
public class TodoController {

    private List&lt;Todo&gt; todos = new ArrayList&lt;&gt;();

    @GetMapping
    public List&lt;Todo&gt; getAllTodos() {
        return todos;
    }

    @PostMapping
    public Todo createTodo(@RequestBody Todo todo) {
        todo.setId((long) (todos.size() + 1));
        todos.add(todo);
        return todo;
    }

    @PutMapping(&quot;/{id}&quot;)
    public Todo updateTodo(@PathVariable Long id, @RequestBody Todo updatedTodo) {
        Todo todo = todos.stream().filter(t -&gt; t.getId().equals(id)).findFirst().orElse(null);
        if (todo != null) {
            todo.setTitle(updatedTodo.getTitle());
            todo.setCompleted(updatedTodo.isCompleted());
        }
        return todo;
    }

    @DeleteMapping(&quot;/{id}&quot;)
    public void deleteTodo(@PathVariable Long id) {
        todos.removeIf(todo -&gt; todo.getId().equals(id));
    }
}
```

@tab Kotlin [icon=kotlin]

```kotlin
package com.example.demo.controller

import com.example.demo.model.Todo
import org.springframework.web.bind.annotation.*

@RestController
@RequestMapping(&quot;/api/todos&quot;)
class TodoController {

    private val todos = mutableListOf&lt;Todo&gt;()

    @GetMapping
    fun getAllTodos(): List&lt;Todo&gt; = todos

    @PostMapping
    fun createTodo(@RequestBody todo: Todo): Todo {
        todo.id = (todos.size + 1).toLong()
        todos.add(todo)
        return todo
    }

    @PutMapping(&quot;/{id}&quot;)
    fun updateTodo(@PathVariable id: Long, @RequestBody updatedTodo: Todo): Todo? {
        val todo = todos.find { it.id == id }
        todo?.apply {
            title = updatedTodo.title
            completed = updatedTodo.completed
        }
        return todo
    }

    @DeleteMapping(&quot;/{id}&quot;)
    fun deleteTodo(@PathVariable id: Long) {
        todos.removeIf { it.id == id }
    }
}
```

:::

---

## ‚ñ∂Ô∏è Step 4: Test the API

Test your API using `curl` commands:

- **GET All Todos:**

```bash
curl -X GET http://localhost:8080/api/todos
```

- **POST New Todo:**

```bash
curl -X POST http://localhost:8080/api/todos -H &quot;Content-Type: application/json&quot; -d &apos;{&quot;title&quot;: &quot;New Todo&quot;, &quot;completed&quot;: false}&apos;
```

- **PUT Update Todo:**

```bash
curl -X PUT http://localhost:8080/api/todos/1 -H &quot;Content-Type: application/json&quot; -d &apos;{&quot;title&quot;: &quot;Updated Todo&quot;, &quot;completed&quot;: true}&apos;
```

- **DELETE Delete Todo:**

```bash
curl -X DELETE http://localhost:8080/api/todos/1
```

---

By following these steps, you‚Äôll have built a REST API with Spring Boot.
&lt;/div&gt;]]&gt;</content:encoded>
        </item>
        <item>
            <title><![CDATA[Gin - First Application]]></title>
            <description><![CDATA[A beginner-friendly guide to creating your first Golang Gin application from scratch. Learn the basics and start your journey with Gin.]]></description>
            <link>https://susimsek.github.io/blog/posts/golang-gin-first-application</link>
            <guid isPermaLink="false">https://susimsek.github.io/blog/posts/golang-gin-first-application</guid>
            <pubDate>Sat, 14 Dec 2024 00:00:00 GMT</pubDate>
            <enclosure url="https://susimsek.github.io/blog/images/golang-gin-first-app-thumbnail.jpg" length="0" type="image/jpeg"/>
            <content:encoded>&lt;![CDATA[&lt;div&gt;
Gin simplifies the process of building high-performance web applications with Golang. In this guide, we‚Äôll walk through creating your first Gin application step by step.

---

## üåü Prerequisites

üìã Before starting, ensure you have the following:

- üîß **Golang** 1.17+ installed
- üóç **A text editor or IDE** (e.g., Visual Studio Code, GoLand, or Vim)

---

## üõ†Ô∏è Step 1: Set Up Your Gin Project

You can set up your first Gin project by following these steps:

1. **Initialize a Go Module**

```bash
mkdir gin-first-app
cd gin-first-app
go mod init gin-first-app
```

2. **Install Gin**

```bash
go get -u github.com/gin-gonic/gin
```

---

## üìñ Step 2: Writing Your First Endpoint

Let‚Äôs write a simple endpoint to say hello:

Create a file named `main.go` with the following content:

```go
package main

import (
	&quot;github.com/gin-gonic/gin&quot;
)

func main() {
	r := gin.Default()

	r.GET(&quot;/hello&quot;, func(c *gin.Context) {
		c.JSON(200, gin.H{
			&quot;message&quot;: &quot;Hello, Gin!&quot;,
		})
	})

	r.Run() // Listen and serve on 0.0.0.0:8080
}
```

---

## ‚ñ∂Ô∏è Step 3: Run the Application

1. Open a terminal in the project folder.
2. Execute the following command to run your application:

```bash
go run main.go
```

3. Access the endpoint at:
   ```
   http://localhost:8080/hello
   ```

**Response:**

```json
{
  &quot;message&quot;: &quot;Hello, Gin!&quot;
}
```

---

This post covers the basics of creating a Gin project, writing an endpoint, and running it successfully.
&lt;/div&gt;]]&gt;</content:encoded>
        </item>
        <item>
            <title><![CDATA[Object-Relational Mapping (ORM)]]></title>
            <description><![CDATA[Learn how to set up an ORM-based application with Spring Boot using Java, Kotlin, and Go (Gin). Includes PostgreSQL integration and basic CRUD operations.]]></description>
            <link>https://susimsek.github.io/blog/posts/object-relational-mapping</link>
            <guid isPermaLink="false">https://susimsek.github.io/blog/posts/object-relational-mapping</guid>
            <pubDate>Mon, 16 Dec 2024 00:00:00 GMT</pubDate>
            <enclosure url="https://susimsek.github.io/blog/images/orm-thumbnail.jpg" length="0" type="image/jpeg"/>
            <content:encoded>&lt;![CDATA[&lt;div&gt;
Object-Relational Mapping (ORM) simplifies database operations in modern applications. This guide will show you how to set up ORM with PostgreSQL using Spring Boot and the Gin framework.

---

## üåü Why Use ORM?

ORM bridges the gap between object-oriented programming and relational databases by mapping objects directly to database tables. This eliminates the need for manual SQL queries, reducing errors and increasing productivity for developers.

---

## üåü Prerequisites

üìã Ensure you have the following:

- ‚òï **Java Development Kit (JDK)** 17+
- üì¶ **Maven or Gradle** installed
- üñ•Ô∏è A **Java IDE**
- üêò **PostgreSQL** installed and running

For **Go**:

- üîß **Golang** 1.17+ installed
- üîÑ **go.mod** initialized in your project

---

## üõ†Ô∏è Step 1: Add Dependencies

To set up a Spring Boot project and integrate ORM, follow these steps:

### Add Dependencies

For Spring Boot projects, include the following dependencies in your project:

- **Maven:**

```xml
&lt;dependency&gt;
  &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
  &lt;artifactId&gt;spring-boot-starter-data-jpa&lt;/artifactId&gt;
&lt;/dependency&gt;
&lt;dependency&gt;
  &lt;groupId&gt;org.postgresql&lt;/groupId&gt;
  &lt;artifactId&gt;postgresql&lt;/artifactId&gt;
&lt;/dependency&gt;
```

- **Gradle:**

```groovy
implementation &apos;org.springframework.boot:spring-boot-starter-data-jpa&apos;
implementation &apos;org.postgresql:postgresql&apos;
```

### Configure the Database

Set up your PostgreSQL connection in the `application.properties` or `application.yml` file:

```properties
spring.datasource.url=jdbc:postgresql://localhost:5432/demo
spring.datasource.username=your_username
spring.datasource.password=your_password
spring.jpa.hibernate.ddl-auto=update
```

### Initialize the Project

If you haven&apos;t already, create your Spring Boot project using [Spring Initializr](https://start.spring.io/):

1. Choose **Spring Web**, **Spring Data JPA**, and **PostgreSQL Driver** as dependencies.
2. Download the project and import it into your preferred IDE.

For Go projects:

- **Install Gin Framework and GORM:**

```bash
# Install the Gin framework
go get -u github.com/gin-gonic/gin

# Install the GORM PostgreSQL driver
go get -u gorm.io/driver/postgres

# Install the GORM ORM library
go get -u gorm.io/gorm
```

---

## üìã Step 2: Define the Model and Implement the REST Controller

This step combines creating the entity/model, repository, and REST controllers.

:::tabs
@tab Java [icon=java]

### Entity

```java
package com.example.demo.entity;

import jakarta.persistence.*;
import lombok.Data;

@Data
@Entity
public class User {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    private String name;

    private String email;
}
```

### Repository

```java
package com.example.demo.repository;

import com.example.demo.entity.User;
import org.springframework.data.jpa.repository.JpaRepository;

public interface UserRepository extends JpaRepository&lt;User, Long&gt; {
}
```

### REST Controller

```java
package com.example.demo.controller;

import com.example.demo.entity.User;
import com.example.demo.repository.UserRepository;
import org.springframework.web.bind.annotation.*;

import java.util.List;

@RestController
@RequestMapping(&quot;/api/users&quot;)
import lombok.RequiredArgsConstructor;

@RequiredArgsConstructor
public class UserController {

  private final UserRepository userRepository;

  @GetMapping
  public List&lt;User&gt; getAllUsers() {
    return userRepository.findAll();
  }

  @PostMapping
  public User createUser(@RequestBody User user) {
    return userRepository.save(user);
  }
}
```

@tab Kotlin [icon=kotlin]

### Entity

```kotlin
package com.example.demo.entity

import jakarta.persistence.*

@Entity
class User(
  @Id
  @GeneratedValue(strategy = GenerationType.IDENTITY)
  val id: Long = 0,

  var name: String,

  var email: String
)
```

### Repository

```kotlin
package com.example.demo.repository

import com.example.demo.entity.User
import org.springframework.data.jpa.repository.JpaRepository

interface UserRepository : JpaRepository&lt;User, Long&gt;
```

### REST Controller

```kotlin
package com.example.demo.controller

import com.example.demo.entity.User
import com.example.demo.repository.UserRepository
import org.springframework.web.bind.annotation.*

@RestController
@RequestMapping(&quot;/api/users&quot;)
class UserController(
  private val userRepository: UserRepository
) {

  @GetMapping
  fun getAllUsers(): List&lt;User&gt; = userRepository.findAll()

  @PostMapping
  fun createUser(@RequestBody user: User): User = userRepository.save(user)
}
```

@tab Go [icon=go]

### Model and Database Connection

```go
package main

import (
	&quot;gorm.io/driver/postgres&quot;
	&quot;gorm.io/gorm&quot;
)

var DB *gorm.DB

func connectDatabase() {
	dsn := &quot;host=localhost user=your_username password=your_password dbname=demo port=5432 sslmode=disable&quot;
	db, err := gorm.Open(postgres.Open(dsn), &amp;gorm.Config{})
	if err != nil {
		panic(&quot;Failed to connect to database!&quot;)
	}

	DB = db
	DB.AutoMigrate(&amp;User{})
}

type User struct {
	ID    uint   `json:&quot;id&quot; gorm:&quot;primaryKey&quot;`
	Name  string `json:&quot;name&quot;`
	Email string `json:&quot;email&quot;`
}
```

### Handlers

```go
package main

import (
	&quot;github.com/gin-gonic/gin&quot;
)

func getUsers(c *gin.Context) {
	var users []User
	DB.Find(&amp;users)
	c.JSON(200, users)
}

func createUser(c *gin.Context) {
	var user User
	if err := c.ShouldBindJSON(&amp;user); err != nil {
		c.JSON(400, gin.H{&quot;error&quot;: err.Error()})
		return
	}
	DB.Create(&amp;user)
	c.JSON(201, user)
}

func main() {
	r := gin.Default()
	connectDatabase()

	r.GET(&quot;/api/users&quot;, getUsers)
	r.POST(&quot;/api/users&quot;, createUser)

	r.Run() // Listen and serve on 0.0.0.0:8080
}
```

:::

---

## ‚ñ∂Ô∏è Running the Applications

- **Spring Boot:**

  ```bash
  ./mvnw spring-boot:run
  ```

- **Gin:**

  ```bash
  go run main.go
  ```

---

## üß™ Testing with cURL

You can test the API using the following cURL commands:

**Fetch All Users:**

```bash
curl -X GET http://localhost:8080/api/users
```

**Create a New User:**

```bash
curl -X POST http://localhost:8080/api/users \
-H &quot;Content-Type: application/json&quot; \
-d &apos;{&quot;name&quot;: &quot;John Doe&quot;, &quot;email&quot;: &quot;johndoe@example.com&quot;}&apos;
```

---

This guide demonstrates how to use ORM for PostgreSQL in Spring Boot with Java, Kotlin, and Gin.
&lt;/div&gt;]]&gt;</content:encoded>
        </item>
        <item>
            <title><![CDATA[Input Validation in REST APIs]]></title>
            <description><![CDATA[Learn how to implement input validation in REST APIs using Java, Kotlin, and Go with frameworks like Spring Boot and Gin. Covers annotations, custom validators, and error handling.]]></description>
            <link>https://susimsek.github.io/blog/posts/rest-api-input-validation</link>
            <guid isPermaLink="false">https://susimsek.github.io/blog/posts/rest-api-input-validation</guid>
            <pubDate>Sun, 15 Dec 2024 00:00:00 GMT</pubDate>
            <enclosure url="https://susimsek.github.io/blog/images/input-validation-thumbnail.jpg" length="0" type="image/jpeg"/>
            <content:encoded>&lt;![CDATA[&lt;div&gt;
Input validation is crucial for building secure and robust REST APIs. In this article, we will explore how to implement input validation in Spring Boot using Java, Kotlin, and Go (with Gin).

---

## üåü Why Validate Input?

Validation ensures the data sent to your API adheres to expected formats and prevents potential vulnerabilities like SQL Injection, XSS, and bad data entries.

---

## üõ†Ô∏è Step 1: Add Validation Dependencies

For Spring Boot projects, include the following dependencies:

- **Maven:**

```xml
&lt;dependency&gt;
  &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
  &lt;artifactId&gt;spring-boot-starter-validation&lt;/artifactId&gt;
&lt;/dependency&gt;
```

- **Gradle:**

```groovy
implementation &apos;org.springframework.boot:spring-boot-starter-validation&apos;
```

For Go projects with Gin, use the following:

```bash
# Install the Gin framework
go get -u github.com/gin-gonic/gin

# Install the validator package
go get -u github.com/go-playground/validator/v10
```

---

## üìñ Step 2: Define a DTO with Validation Rules

Use annotations to define validation constraints on fields. Examples include `@NotNull`, `@Size`, and `@Pattern`.

:::tabs
@tab Java [icon=java]

```java
package com.example.demo.dto;

import jakarta.validation.constraints.NotNull;
import jakarta.validation.constraints.Size;
import lombok.Data;

@Data
public class TodoRequest {

    @NotNull(message = &quot;Title is required&quot;)
    @Size(min = 3, max = 50, message = &quot;Title must be between 3 and 50 characters&quot;)
    private String title;

    private boolean completed;
}
```

@tab Kotlin [icon=kotlin]

```kotlin
package com.example.demo.dto

import jakarta.validation.constraints.NotNull
import jakarta.validation.constraints.Size

data class TodoRequest(
    @field:NotNull(message = &quot;Title is required&quot;)
    @field:Size(min = 3, max = 50, message = &quot;Title must be between 3 and 50 characters&quot;)
    val title: String?,

    val completed: Boolean = false
)
```

@tab Go [icon=go]

```go
package dto

import (
    &quot;github.com/go-playground/validator/v10&quot;
)

type TodoRequest struct {
    Title     string `validate:&quot;required,min=3,max=50&quot;`
    Completed bool   `validate:&quot;&quot;`
}

var validate = validator.New()

func ValidateTodoRequest(todo TodoRequest) error {
    return validate.Struct(todo)
}
```

:::

---

## üìò Step 3: Create a Controller with Validation

Integrate validation into your REST endpoints.

:::tabs
@tab Java [icon=java]

```java
package com.example.demo.controller;

import com.example.demo.dto.TodoRequest;
import org.springframework.validation.annotation.Validated;
import org.springframework.web.bind.annotation.*;

@RestController
@RequestMapping(&quot;/api/todos&quot;)
public class TodoController {

    @PostMapping
    public String createTodo(@Validated @RequestBody TodoRequest request) {
        return &quot;Todo created: &quot; + request.getTitle();
    }
}
```

@tab Kotlin [icon=kotlin]

```kotlin
package com.example.demo.controller

import com.example.demo.dto.TodoRequest
import org.springframework.validation.annotation.Validated
import org.springframework.web.bind.annotation.*

@RestController
@RequestMapping(&quot;/api/todos&quot;)
class TodoController {

    @PostMapping
    fun createTodo(@Validated @RequestBody request: TodoRequest): String {
        return &quot;Todo created: ${request.title}&quot;
    }
}
```

@tab Go [icon=go]

```go
package controller

import (
    &quot;dto&quot;
    &quot;github.com/gin-gonic/gin&quot;
    &quot;net/http&quot;
)

func CreateTodoHandler(c *gin.Context) {
    var todo dto.TodoRequest

    if err := c.ShouldBindJSON(&amp;todo); err != nil {
        c.JSON(http.StatusBadRequest, gin.H{&quot;error&quot;: err.Error()})
        return
    }

    if err := dto.ValidateTodoRequest(todo); err != nil {
        c.JSON(http.StatusBadRequest, gin.H{&quot;error&quot;: err.Error()})
        return
    }

    c.JSON(http.StatusOK, gin.H{&quot;message&quot;: &quot;Todo created&quot;, &quot;title&quot;: todo.Title})
}
```

:::

---

## üìã Step 4: Handle Validation Errors

Customize error handling to return user-friendly responses.

:::tabs
@tab Java [icon=java]

```java
package com.example.demo.exception;

import org.springframework.http.HttpStatus;
import org.springframework.web.bind.annotation.ExceptionHandler;
import org.springframework.web.bind.annotation.RestControllerAdvice;
import org.springframework.web.bind.MethodArgumentNotValidException;

import java.util.HashMap;
import java.util.Map;

@RestControllerAdvice
public class GlobalExceptionHandler {

    @ExceptionHandler(MethodArgumentNotValidException.class)
    public Map&lt;String, String&gt; handleValidationExceptions(MethodArgumentNotValidException ex) {
        Map&lt;String, String&gt; errors = new HashMap&lt;&gt;();
        ex.getBindingResult().getFieldErrors().forEach(error -&gt; errors.put(error.getField(), error.getDefaultMessage()));
        return errors;
    }
}
```

@tab Kotlin [icon=kotlin]

```kotlin
package com.example.demo.exception

import org.springframework.http.HttpStatus
import org.springframework.web.bind.annotation.ExceptionHandler
import org.springframework.web.bind.annotation.RestControllerAdvice
import org.springframework.web.bind.MethodArgumentNotValidException

@RestControllerAdvice
class GlobalExceptionHandler {

    @ExceptionHandler(MethodArgumentNotValidException::class)
    fun handleValidationExceptions(ex: MethodArgumentNotValidException): Map&lt;String, String&gt; {
        return ex.bindingResult.fieldErrors.associate { it.field to it.defaultMessage.orEmpty() }
    }
}
```

@tab Go [icon=go]

```go
package middleware

import (
    &quot;github.com/gin-gonic/gin&quot;
    &quot;net/http&quot;
)

func ErrorHandler() gin.HandlerFunc {
    return func(c *gin.Context) {
        c.Next()

        if len(c.Errors) &gt; 0 {
            c.JSON(http.StatusBadRequest, gin.H{&quot;errors&quot;: c.Errors.JSON()})
        }
    }
}
```

:::

---

## üåê main.go Example

Here is an example of the `main.go` file for setting up a Gin application:

```go
package main

import (
	&quot;controller&quot;
	&quot;github.com/gin-gonic/gin&quot;
)

func main() {
	r := gin.Default()

	r.POST(&quot;/api/todos&quot;, controller.CreateTodoHandler)

	r.Run() // Start the server on http://localhost:8080
}
```

---

## ‚ñ∂Ô∏è Step 5: Run the Application

To run the application:

### Spring Boot (Java/Kotlin)

Run the Spring Boot application from your IDE or terminal:

```bash
./mvnw spring-boot:run # For Maven projects
./gradlew bootRun       # For Gradle projects
```

Access the API at `http://localhost:8080/api/todos`.

### Gin (Go)

Run the Go application:

```bash
go run main.go
```

Access the API at `http://localhost:8080/api/todos`.

## üß™ Testing with cURL

Here are some example cURL commands to test the API:

- **POST a new Todo:**

```bash
curl -X POST http://localhost:8080/api/todos \
-H &quot;Content-Type: application/json&quot; \
-d &apos;{&quot;title&quot;: &quot;New Task&quot;, &quot;completed&quot;: false}&apos;
```

- **GET all Todos:**

```bash
curl -X GET http://localhost:8080/api/todos
```

- **Handle Validation Errors:**

Send an invalid request:

```bash
curl -X POST http://localhost:8080/api/todos \
-H &quot;Content-Type: application/json&quot; \
-d &apos;{&quot;title&quot;: &quot;&quot;}&apos;
```

You should receive validation error messages as part of the response.
&lt;/div&gt;]]&gt;</content:encoded>
        </item>
        <item>
            <title><![CDATA[Spring Boot Actuator]]></title>
            <description><![CDATA[Learn how to use Spring Boot Actuator to monitor and manage your applications with ease. Includes endpoints, customization, and security examples.]]></description>
            <link>https://susimsek.github.io/blog/posts/spring-boot-actuator</link>
            <guid isPermaLink="false">https://susimsek.github.io/blog/posts/spring-boot-actuator</guid>
            <pubDate>Wed, 18 Dec 2024 00:00:00 GMT</pubDate>
            <enclosure url="https://susimsek.github.io/blog/images/spring-boot-actuator-thumbnail.jpg" length="0" type="image/jpeg"/>
            <content:encoded>&lt;![CDATA[&lt;div&gt;
Spring Boot Actuator provides production-ready features to monitor and manage your applications. This guide explores Actuator&apos;s capabilities, how to enable it, and secure its endpoints.

---

## üåü Why Use Spring Boot Actuator?

Spring Boot Actuator allows developers to:

- Monitor application health
- Gather metrics and information
- Expose management endpoints for operational tasks

---

## üåü Prerequisites

üìã Ensure you have the following:

- ‚òï **Java Development Kit (JDK)** 17+
- üíº **Maven or Gradle** installed
- üÑÑ A **Java IDE** (e.g., IntelliJ IDEA, Eclipse)

---

## üõ†Ô∏è Step 1: Add Dependencies

To enable Actuator, add the following dependency to your Spring Boot project:

- **Maven:**

```xml
&lt;dependency&gt;
  &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
  &lt;artifactId&gt;spring-boot-starter-actuator&lt;/artifactId&gt;
&lt;/dependency&gt;
```

- **Gradle:**

```groovy
implementation &apos;org.springframework.boot:spring-boot-starter-actuator&apos;
```

---

## üìú Step 2: Enable Actuator Endpoints

By default, Actuator exposes several endpoints to provide application insights. You can enable these endpoints in your `application.properties` or `application.yml` file.

### Configuration Example:

```properties
management.endpoints.web.exposure.include=health,info,metrics
management.endpoint.health.show-details=always
```

---

## üìñ Step 3: Using Actuator Endpoints

Here are some commonly used Actuator endpoints:

- **`/actuator/health`**: Provides application health status.
- **`/actuator/info`**: Displays application metadata.
- **`/actuator/metrics`**: Offers application performance metrics.

You can access these endpoints via a browser or API tools like cURL.

Example:

```bash
curl -X GET http://localhost:8080/actuator/health
```

---

## üìò Step 4: Customize Actuator Endpoints

You can customize Actuator endpoints to suit your needs. For example, you can define additional metadata in the `application.properties` file for the `/actuator/info` endpoint:

```properties
info.app.name=My Application
info.app.version=1.0.0
info.app.description=Spring Boot Actuator Example
```

---

## üîí Step 5: Secure Actuator Endpoints

For production environments, it&apos;s essential to secure Actuator endpoints. Use Spring Security to restrict access.

:::tabs
@tab Java [icon=java]

### Example Security Configuration

```java
package com.example.demo.config;

import org.springframework.context.annotation.Configuration;
import org.springframework.security.config.annotation.web.builders.HttpSecurity;
import org.springframework.security.web.SecurityFilterChain;

@Configuration
public class SecurityConfig {

    public SecurityFilterChain securityFilterChain(HttpSecurity http) throws Exception {
        http
            .authorizeHttpRequests()
                .requestMatchers(&quot;/actuator/**&quot;).hasRole(&quot;ADMIN&quot;)
                .anyRequest().authenticated()
            .and()
            .httpBasic();
        return http.build();
    }
}
```

@tab Kotlin [icon=kotlin]

### Example Security Configuration

```kotlin
package com.example.demo.config

import org.springframework.context.annotation.Bean
import org.springframework.context.annotation.Configuration
import org.springframework.security.config.annotation.web.builders.HttpSecurity
import org.springframework.security.web.SecurityFilterChain

@Configuration
class SecurityConfig {

    @Bean
    fun securityFilterChain(http: HttpSecurity): SecurityFilterChain {
        http
            .authorizeHttpRequests()
                .requestMatchers(&quot;/actuator/**&quot;).hasRole(&quot;ADMIN&quot;)
                .anyRequest().authenticated()
            .and()
            .httpBasic()
        return http.build()
    }
}
```

:::

---

## ‚ñ∂Ô∏è Running the Application

Run the application using the following command:

```bash
./mvnw spring-boot:run
```

Access the Actuator endpoints at:

```
http://localhost:8080/actuator/health
```

---

## üß™ Test the API

You can test the Actuator endpoints using cURL or browser:

- **Health Endpoint:**

```bash
curl -X GET http://localhost:8080/actuator/health
```

- **Info Endpoint:**

```bash
curl -X GET http://localhost:8080/actuator/info
```

---

Spring Boot Actuator simplifies monitoring and managing your application. This guide covered enabling, customizing, and securing Actuator endpoints to improve your Spring Boot project.
&lt;/div&gt;]]&gt;</content:encoded>
        </item>
        <item>
            <title><![CDATA[Aspect-Oriented Programming (AOP) in Spring Boot]]></title>
            <description><![CDATA[Learn how to implement Aspect-Oriented Programming (AOP) in Spring Boot using Java and Kotlin. Covers core concepts, use cases, and practical examples.]]></description>
            <link>https://susimsek.github.io/blog/posts/spring-boot-aop</link>
            <guid isPermaLink="false">https://susimsek.github.io/blog/posts/spring-boot-aop</guid>
            <pubDate>Wed, 18 Dec 2024 00:00:00 GMT</pubDate>
            <enclosure url="https://susimsek.github.io/blog/images/spring-boot-aop-thumbnail.jpg" length="0" type="image/jpeg"/>
            <content:encoded>&lt;![CDATA[&lt;div&gt;
Aspect-Oriented Programming (AOP) provides a way to modularize cross-cutting concerns, such as logging, transaction management, and security. This guide demonstrates how to implement AOP in Spring Boot with examples in Java and Kotlin.

---

## üåü Why Use AOP?

AOP enables developers to separate concerns that affect multiple parts of an application, like logging or security, into reusable aspects. This approach promotes cleaner code, improved maintainability, and reduced redundancy.

---

## üåü Prerequisites

üìã Ensure you have the following:

- ‚òï **Java Development Kit (JDK)** 17+
- üì¶ **Maven or Gradle** installed
- üî§ A **Java IDE** (e.g., IntelliJ IDEA, Eclipse)

---

## üõ†Ô∏è Step 1: Add Dependencies

Include the following dependencies in your project:

- **Maven:**

```xml
&lt;dependency&gt;
  &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
  &lt;artifactId&gt;spring-boot-starter-aop&lt;/artifactId&gt;
&lt;/dependency&gt;
```

- **Gradle:**

```groovy
implementation &apos;org.springframework.boot:spring-boot-starter-aop&apos;
```

---

## üìã Step 2: Define a Service

Create a simple service to demonstrate AOP.

:::tabs
@tab Java [icon=java]

### Service

```java
package com.example.demo.service;

import org.springframework.stereotype.Service;

@Service
public class UserService {

    public String getUserById(String id) {
        return &quot;User with ID: &quot; + id;
    }

    public String getAllUsers() {
        return &quot;Fetching all users.&quot;;
    }
}
```

@tab Kotlin [icon=kotlin]

### Service

```kotlin
package com.example.demo.service

import org.springframework.stereotype.Service

@Service
class UserService {

    fun getUserById(id: String): String {
        return &quot;User with ID: $id&quot;
    }

    fun getAllUsers(): String {
        return &quot;Fetching all users.&quot;
    }
}
```

:::

---

## üìñ Step 3: Create an Aspect

Define an aspect to log method execution details.

:::tabs
@tab Java [icon=java]

### Aspect

```java
package com.example.demo.aspect;

import org.aspectj.lang.annotation.Aspect;
import org.aspectj.lang.annotation.Before;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.stereotype.Component;

@Aspect
@Component
public class LoggingAspect {

    private static final Logger logger = LoggerFactory.getLogger(LoggingAspect.class);

    @Before(&quot;execution(* com.example.demo.service.UserService.*(..))&quot;)
    public void logBefore() {
        logger.info(&quot;Method execution started.&quot;);
    }
}
```

@tab Kotlin [icon=kotlin]

### Aspect

```kotlin
package com.example.demo.aspect

import org.aspectj.lang.annotation.Aspect
import org.aspectj.lang.annotation.Before
import org.slf4j.LoggerFactory
import org.springframework.stereotype.Component

@Aspect
@Component
class LoggingAspect {

    private val logger = LoggerFactory.getLogger(LoggingAspect::class.java)

    @Before(&quot;execution(* com.example.demo.service.UserService.*(..))&quot;)
    fun logBefore() {
        logger.info(&quot;Method execution started.&quot;)
    }
}
```

:::

---

## üìò Step 4: Create a Controller

Expose the service methods through a REST controller.

:::tabs
@tab Java [icon=java]

### Controller

```java
package com.example.demo.controller;

import com.example.demo.service.UserService;
import lombok.RequiredArgsConstructor;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.PathVariable;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;

@RestController
@RequestMapping(&quot;/api/users&quot;)
@RequiredArgsConstructor
public class UserController {

    private final UserService userService;

    @GetMapping(&quot;/{id}&quot;)
    public String getUserById(@PathVariable String id) {
        return userService.getUserById(id);
    }

    @GetMapping
    public String getAllUsers() {
        return userService.getAllUsers();
    }
}
```

@tab Kotlin [icon=kotlin]

### Controller

```kotlin
package com.example.demo.controller

import com.example.demo.service.UserService
import org.springframework.web.bind.annotation.GetMapping
import org.springframework.web.bind.annotation.PathVariable
import org.springframework.web.bind.annotation.RequestMapping
import org.springframework.web.bind.annotation.RestController

@RestController
@RequestMapping(&quot;/api/users&quot;)
class UserController(
    private val userService: UserService
) {

    @GetMapping(&quot;/{id}&quot;)
    fun getUserById(@PathVariable id: String): String = userService.getUserById(id)

    @GetMapping
    fun getAllUsers(): String = userService.getAllUsers()
}
```

:::

---

## ‚ñ∂Ô∏è Running the Application

Run the application using the following commands:

- **Spring Boot (Java/Kotlin):**

  ```bash
  ./mvnw spring-boot:run
  ```

Access the API at `http://localhost:8080/api/users`.

---

## üß™ Testing the API

You can test the API using the following cURL commands:

- **Fetch all users:**

```bash
curl -X GET http://localhost:8080/api/users
```

- **Fetch a user by ID:**

```bash
curl -X GET http://localhost:8080/api/users/1
```

---

This guide demonstrates how to implement AOP in Spring Boot with Java and Kotlin, showcasing logging aspects and REST API integration.
&lt;/div&gt;]]&gt;</content:encoded>
        </item>
        <item>
            <title><![CDATA[Clean Coding Practices in Spring Boot]]></title>
            <description><![CDATA[Learn how to apply clean coding principles in Spring Boot projects. Includes best practices, examples, and benefits of using Lombok in Java and Kotlin clean code techniques.]]></description>
            <link>https://susimsek.github.io/blog/posts/spring-boot-clean-coding</link>
            <guid isPermaLink="false">https://susimsek.github.io/blog/posts/spring-boot-clean-coding</guid>
            <pubDate>Thu, 19 Dec 2024 00:00:00 GMT</pubDate>
            <enclosure url="https://susimsek.github.io/blog/images/spring-boot-clean-coding-thumbnail.jpg" length="0" type="image/jpeg"/>
            <content:encoded>&lt;![CDATA[&lt;div&gt;
Clean coding practices ensure that your Spring Boot applications are maintainable, readable, and scalable. This guide provides essential tips and code examples to help you write cleaner and more efficient code in both Java and Kotlin.

---

## üåü Why Focus on Clean Coding?

Adopting clean coding principles helps to:

- Improve code readability and maintainability.
- Reduce technical debt.
- Make onboarding new developers easier.
- Enhance scalability and debugging processes.

---

## üåü Prerequisites

üìã Ensure you have the following:

- ‚òï **Java Development Kit (JDK)** 17+
- üì¶ **Maven or Gradle** installed
- üî§ A **Java IDE** (e.g., IntelliJ IDEA, Eclipse)
- üõ†Ô∏è Familiarity with Spring Boot basics

---

## üõ†Ô∏è Step 1: Structure Your Project

Organize your Spring Boot project for better clarity:

- **Controller Layer:** Handles incoming HTTP requests.
- **Service Layer:** Contains business logic.
- **Repository Layer:** Interacts with the database.

### Example Folder Structure:

```
src/main/java/com/example/cleanproject
‚îú‚îÄ‚îÄ controller
‚îú‚îÄ‚îÄ service
‚îú‚îÄ‚îÄ repository
‚îú‚îÄ‚îÄ entity
‚îî‚îÄ‚îÄ dto
```

---

## üìã Step 2: Use Lombok for Cleaner Java Code

Lombok reduces boilerplate code in Java, making your classes more concise and readable. Here&apos;s how to use Lombok effectively:

### Add Lombok Dependency

- **Maven:**

```xml
&lt;dependency&gt;
  &lt;groupId&gt;org.projectlombok&lt;/groupId&gt;
  &lt;artifactId&gt;lombok&lt;/artifactId&gt;
  &lt;scope&gt;provided&lt;/scope&gt;
&lt;/dependency&gt;
```

- **Gradle:**

```groovy
provided &apos;org.projectlombok:lombok&apos;
annotationProcessor &apos;org.projectlombok:lombok&apos;
```

### Example: Entity with Lombok

```java
package com.example.cleanproject.entity;

import jakarta.persistence.*;
import lombok.Data;
import lombok.NoArgsConstructor;
import lombok.AllArgsConstructor;

@Data
@NoArgsConstructor
@AllArgsConstructor
@Entity
public class User {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    private String name;

    private String email;
}
```

**Benefits:**

- `@Data` generates getters, setters, equals, hashCode, and toString methods.
- `@NoArgsConstructor` and `@AllArgsConstructor` create constructors.

---

## üìñ Step 3: Write Concise and Readable Code in Kotlin

Kotlin offers modern features that naturally lead to cleaner code:

### Example: Entity in Kotlin

```kotlin
package com.example.cleanproject.entity

import jakarta.persistence.*

@Entity
data class User(
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    val id: Long = 0,
    var name: String,
    var email: String
)
```

**Advantages of Kotlin:**

- `data class` automatically generates `toString`, `equals`, and `hashCode` methods.
- Immutable properties (`val`) ensure better stability.

---

## üìò Step 4: Follow Dependency Injection Principles

Use dependency injection to decouple components and improve testability.

### Example: Service Layer with DI

:::tabs
@tab Java [icon=java]

```java
package com.example.cleanproject.service;

import com.example.cleanproject.entity.User;
import com.example.cleanproject.repository.UserRepository;
import lombok.RequiredArgsConstructor;
import org.springframework.stereotype.Service;

import java.util.List;

@Service
@RequiredArgsConstructor
public class UserService {

    private final UserRepository userRepository;

    public List&lt;User&gt; getAllUsers() {
        return userRepository.findAll();
    }
}
```

@tab Kotlin [icon=kotlin]

```kotlin
package com.example.cleanproject.service

import com.example.cleanproject.entity.User
import com.example.cleanproject.repository.UserRepository
import org.springframework.stereotype.Service

@Service
class UserService(
    private val userRepository: UserRepository
) {
    fun getAllUsers(): List&lt;User&gt; = userRepository.findAll()
}
```

:::

---

## üîí Step 5: Use DTOs for Data Transfer

Data Transfer Objects (DTOs) separate your domain and API layers, promoting better encapsulation.

### Example: DTO for User

:::tabs
@tab Java [icon=java]

```java
package com.example.cleanproject.dto;

import lombok.Data;

@Data
public class UserDTO {
    private String name;
    private String email;
}
```

@tab Kotlin [icon=kotlin]

```kotlin
package com.example.cleanproject.dto

data class UserDTO(
    val name: String,
    val email: String
)
```

:::

---

## üìñ Controller Layer

Implement a controller to handle HTTP requests and interact with the service layer.

:::tabs
@tab Java [icon=java]

```java
package com.example.cleanproject.controller;

import com.example.cleanproject.dto.UserDTO;
import com.example.cleanproject.service.UserService;
import lombok.RequiredArgsConstructor;
import org.springframework.web.bind.annotation.*;

import java.util.List;

@RestController
@RequestMapping(&quot;/api/users&quot;)
@RequiredArgsConstructor
public class UserController {

    private final UserService userService;

    @GetMapping
    public List&lt;UserDTO&gt; getAllUsers() {
        return userService.getAllUsers();
    }
}
```

@tab Kotlin [icon=kotlin]

```kotlin
package com.example.cleanproject.controller

import com.example.cleanproject.dto.UserDTO
import com.example.cleanproject.service.UserService
import org.springframework.web.bind.annotation.*

@RestController
@RequestMapping(&quot;/api/users&quot;)
class UserController(
    private val userService: UserService
) {

    @GetMapping
    fun getAllUsers(): List&lt;UserDTO&gt; = userService.getAllUsers()
}
```

:::

---

## ‚ñ∂Ô∏è Running the Application

Run the application using the following command:

```bash
./mvnw spring-boot:run
```

Test endpoints using a tool like Postman or cURL.

---

## üß™ Testing the API

You can test the API using the following cURL command:

- **Fetch all users:**

```bash
curl -X GET http://localhost:8080/api/users
```

---

Clean coding practices are essential for building maintainable and scalable Spring Boot applications. By leveraging tools like Lombok and Kotlin&apos;s features, you can write concise and readable code that adheres to modern development standards.
&lt;/div&gt;]]&gt;</content:encoded>
        </item>
        <item>
            <title><![CDATA[Spring Boot DevTools]]></title>
            <description><![CDATA[Learn how to utilize Spring Boot DevTools for rapid development. Includes live reload, caching, and debugging tips.]]></description>
            <link>https://susimsek.github.io/blog/posts/spring-boot-devtools</link>
            <guid isPermaLink="false">https://susimsek.github.io/blog/posts/spring-boot-devtools</guid>
            <pubDate>Thu, 19 Dec 2024 00:00:00 GMT</pubDate>
            <enclosure url="https://susimsek.github.io/blog/images/spring-boot-devtools-thumbnail.jpg" length="0" type="image/jpeg"/>
            <content:encoded>&lt;![CDATA[&lt;div&gt;
Spring Boot DevTools is a must-have tool for developers looking to speed up their development process. This guide will walk you through the features and setup of DevTools, including live reload, caching, and debugging enhancements.

---

## üåü Why Use Spring Boot DevTools?

Spring Boot DevTools provides features such as:

- **Live Reload**: Automatically reloads the application on code changes.
- **Enhanced Caching**: Disables template caching for faster iteration.
- **Debugging Tools**: Improves development-time debugging experience.

---

## üåü Prerequisites

üìã Ensure you have the following:

- ‚òï **Java Development Kit (JDK)** 17+
- üì¶ **Maven or Gradle** installed
- üî§ A **Java IDE** (e.g., IntelliJ IDEA, Eclipse)

---

## üõ†Ô∏è Step 1: Add Dependencies

To enable DevTools, add the following dependency to your Spring Boot project:

- **Maven:**

```xml
&lt;dependency&gt;
  &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
  &lt;artifactId&gt;spring-boot-devtools&lt;/artifactId&gt;
  &lt;scope&gt;runtime&lt;/scope&gt;
&lt;/dependency&gt;
```

- **Gradle:**

```groovy
runtimeOnly &apos;org.springframework.boot:spring-boot-devtools&apos;
```

---

## üìã Step 2: Configure DevTools

Spring Boot DevTools requires minimal configuration but offers some customization options. Here are some common configurations:

### Enable Live Reload

Live reload is enabled by default when using DevTools with supported IDEs like IntelliJ IDEA or Eclipse.

### Disable Caching

Disable caching for templates to see changes instantly:

```properties
spring.thymeleaf.cache=false
spring.freemarker.cache=false
```

### Restart Exclusions

Exclude specific files or directories from triggering a restart:

```properties
spring.devtools.restart.exclude=static/**,public/**
```

---

## üìñ Step 3: Debugging Enhancements

Spring Boot DevTools improves debugging by:

- **Automatic Restart**: Restarts the application context when code changes are detected.
- **Remote Debugging**: Provides the ability to debug applications running on remote servers.

To enable remote debugging:

```properties
spring.devtools.remote.secret=mysecretkey
```

Use the following command to connect:

```bash
java -jar myapp.jar -Dspring.devtools.remote.secret=mysecretkey
```

---

## ‚ñ∂Ô∏è Running the Application

Run the application using the following command:

```bash
./mvnw spring-boot:run
```

Make changes to your code, and observe live reload and application context restarts.

---

## üß™ Test DevTools

You can test Spring Boot DevTools features as follows:

- **Live Reload**: Make a change in your controller or template and save the file. The application should reload automatically.
- **Template Updates**: Update a `.html` file and verify the changes without restarting the server.
- **Debugging**: Add breakpoints in your IDE and test remote debugging with `DevTools` enabled.

---

Spring Boot DevTools enhances the developer experience by providing tools for faster iteration and better debugging. By enabling live reload, disabling template caching, and using the debugging features, you can streamline your development workflow.
&lt;/div&gt;]]&gt;</content:encoded>
        </item>
        <item>
            <title><![CDATA[Dependency Injection in Spring Boot]]></title>
            <description><![CDATA[Learn how Dependency Injection (DI) works in Spring Boot, including examples in Java and Kotlin. Covers key concepts, annotations, and practical use cases.]]></description>
            <link>https://susimsek.github.io/blog/posts/spring-boot-di</link>
            <guid isPermaLink="false">https://susimsek.github.io/blog/posts/spring-boot-di</guid>
            <pubDate>Wed, 18 Dec 2024 00:00:00 GMT</pubDate>
            <enclosure url="https://susimsek.github.io/blog/images/spring-boot-di-thumbnail.jpg" length="0" type="image/jpeg"/>
            <content:encoded>&lt;![CDATA[&lt;div&gt;
Dependency Injection (DI) is a fundamental concept in Spring Boot that helps achieve loose coupling and increased testability. This guide demonstrates how to use DI in Spring Boot with practical examples in Java and Kotlin.

---

## üåü Why Use Dependency Injection?

Dependency Injection allows developers to manage and inject dependencies into classes without manually instantiating them. This leads to:

- Better code modularity
- Simplified testing
- Easier maintenance

---

## üåü Prerequisites

üìã Ensure you have the following:

- ‚òï **Java Development Kit (JDK)** 17+
- üì¶ **Maven or Gradle** installed
- üî§ A **Java IDE** (e.g., IntelliJ IDEA, Eclipse)

---

## üõ†Ô∏è Step 1: Add Dependencies

Include the necessary Spring Boot dependencies:

- **Maven:**

```xml
&lt;dependency&gt;
  &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
  &lt;artifactId&gt;spring-boot-starter&lt;/artifactId&gt;
&lt;/dependency&gt;
```

- **Gradle:**

```groovy
implementation &apos;org.springframework.boot:spring-boot-starter&apos;
```

---

## üìã Step 2: Create a Service

Define a simple service to demonstrate DI.

:::tabs
@tab Java [icon=java]

### Service

```java
package com.example.demo.service;

import org.springframework.stereotype.Service;

@Service
public class UserService {

    public String getUserById(String id) {
        return &quot;User with ID: &quot; + id;
    }

    public String getAllUsers() {
        return &quot;Fetching all users.&quot;;
    }
}
```

@tab Kotlin [icon=kotlin]

### Service

```kotlin
package com.example.demo.service

import org.springframework.stereotype.Service

@Service
class UserService {

    fun getUserById(id: String): String {
        return &quot;User with ID: $id&quot;
    }

    fun getAllUsers(): String {
        return &quot;Fetching all users.&quot;
    }
}
```

:::

---

## üìñ Step 3: Inject Dependencies

Use annotations to inject the service into other components.

:::tabs
@tab Java [icon=java]

### Controller

```java
package com.example.demo.controller;

import com.example.demo.service.UserService;
import lombok.RequiredArgsConstructor;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.PathVariable;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;

@RestController
@RequestMapping(&quot;/api/users&quot;)
@RequiredArgsConstructor
public class UserController {

    private final UserService userService;

    @GetMapping(&quot;/{id}&quot;)
    public String getUserById(@PathVariable String id) {
        return userService.getUserById(id);
    }

    @GetMapping
    public String getAllUsers() {
        return userService.getAllUsers();
    }
}
```

@tab Kotlin [icon=kotlin]

### Controller

```kotlin
package com.example.demo.controller

import com.example.demo.service.UserService
import org.springframework.web.bind.annotation.GetMapping
import org.springframework.web.bind.annotation.PathVariable
import org.springframework.web.bind.annotation.RequestMapping
import org.springframework.web.bind.annotation.RestController

@RestController
@RequestMapping(&quot;/api/users&quot;)
class UserController(
    private val userService: UserService
) {

    @GetMapping(&quot;/{id}&quot;)
    fun getUserById(@PathVariable id: String): String = userService.getUserById(id)

    @GetMapping
    fun getAllUsers(): String = userService.getAllUsers()
}
```

:::

---

## ‚ñ∂Ô∏è Running the Application

Run the application using the following commands:

- **Spring Boot (Java/Kotlin):**

  ```bash
  ./mvnw spring-boot:run
  ```

Access the API at `http://localhost:8080/api/users`.

---

## üß™ Test the API

You can test the API using the following cURL commands:

- **Fetch all users:**

```bash
curl -X GET http://localhost:8080/api/users
```

- **Fetch a user by ID:**

```bash
curl -X GET http://localhost:8080/api/users/1
```

---

This guide demonstrates how to implement Dependency Injection in Spring Boot with Java and Kotlin, showcasing service injection and REST API integration.
&lt;/div&gt;]]&gt;</content:encoded>
        </item>
        <item>
            <title><![CDATA[Spring Boot - First Application]]></title>
            <description><![CDATA[A beginner-friendly guide to creating your first Spring Boot application from scratch. Learn the basics and start your journey with Spring Boot.]]></description>
            <link>https://susimsek.github.io/blog/posts/spring-boot-first-application</link>
            <guid isPermaLink="false">https://susimsek.github.io/blog/posts/spring-boot-first-application</guid>
            <pubDate>Tue, 10 Dec 2024 00:00:00 GMT</pubDate>
            <enclosure url="https://susimsek.github.io/blog/images/spring-boot-first-app-thumbnail.jpg" length="0" type="image/jpeg"/>
            <content:encoded>&lt;![CDATA[&lt;div&gt;
Spring Boot simplifies the process of building production-ready applications with the Spring Framework. In this guide, we‚Äôll walk through creating your first Spring Boot application step by step.

---

## üåü Prerequisites

üìã Before starting, ensure you have the following:

- ‚òï **Java Development Kit (JDK)** 17+ installed
- üì¶ **Maven or Gradle** installed
- üñ•Ô∏è A **Java IDE** (e.g., IntelliJ IDEA, Eclipse, or Visual Studio Code)

---

## üõ†Ô∏è Step 1: Create a Spring Boot Project

You can create your first Spring Boot project in two ways:

1. **Using Spring Initializr üñ±Ô∏è**

- Visit [Spring Initializr](https://start.spring.io/).
- Configure the following:
  - üìÇ Project: `Maven`
  - üë®‚Äçüíª Language: `Java` or `Kotlin`
  - üîÑ Spring Boot Version: `3.0.0` (or the latest version).
  - üìú Add dependencies: `Spring Web`
- Click **Generate** to download the project files.

2. **Using IntelliJ IDEA üíª**

- Open IntelliJ IDEA.
- Go to `New Project &gt; Spring Initializr`.
- Configure similar parameters as mentioned above.

---

## üìñ Step 2: Writing Your First Endpoint

Let‚Äôs write a simple endpoint to say hello:

:::tabs  
@tab Java [icon=java]

```java
package com.example.demo;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RestController;

@SpringBootApplication
@RestController
public class DemoApplication {
    public static void main(String[] args) {
        SpringApplication.run(DemoApplication.class, args);
    }

    @GetMapping(&quot;/hello&quot;)
    public String sayHello() {
        return &quot;Hello, Spring Boot!&quot;;
    }
}
```

@tab Kotlin [icon=kotlin]

```kotlin
package com.example.demo

import org.springframework.boot.autoconfigure.SpringBootApplication
import org.springframework.boot.runApplication
import org.springframework.web.bind.annotation.GetMapping
import org.springframework.web.bind.annotation.RestController

@SpringBootApplication
@RestController
class DemoApplication

fun main(args: Array&lt;String&gt;) {
    runApplication&lt;DemoApplication&gt;(*args)
}

@GetMapping(&quot;/hello&quot;)
fun sayHello(): String {
    return &quot;Hello, Spring Boot!&quot;
}
```

:::

---

## ‚ñ∂Ô∏è Step 3: Run the Application

1. Open a terminal in the project folder.
2. Execute the command to run your application:

```bash
./mvnw spring-boot:run
```

3. Access the endpoint at:
   ```
   http://localhost:8080/hello
   ```

**Response:**

```
Hello, Spring Boot!
```

---

This post covers the basics of creating a Spring Boot project, writing an endpoint, and running it successfully.
&lt;/div&gt;]]&gt;</content:encoded>
        </item>
        <item>
            <title><![CDATA[Spring Boot GraalVM Native Application]]></title>
            <description><![CDATA[Learn how to build and deploy a Spring Boot application as a GraalVM native image for improved startup time and reduced resource usage.]]></description>
            <link>https://susimsek.github.io/blog/posts/spring-boot-graalvm</link>
            <guid isPermaLink="false">https://susimsek.github.io/blog/posts/spring-boot-graalvm</guid>
            <pubDate>Sat, 28 Dec 2024 00:00:00 GMT</pubDate>
            <enclosure url="https://susimsek.github.io/blog/images/spring-boot-graalvm-thumbnail.jpg" length="0" type="image/jpeg"/>
            <content:encoded>&lt;![CDATA[&lt;div&gt;
Spring Boot with GraalVM Native enables developers to create applications that offer lightning-fast startup times, reduced memory consumption, and enhanced security. With native image support, your Spring Boot applications can efficiently run in resource-constrained environments, making them ideal for modern cloud-native architectures.

---

## üåü Why Build a Native Application with GraalVM?

- **Faster Startup Times**: Native images start much faster compared to JVM-based applications.
- **Reduced Resource Usage**: Native images consume less memory, making them ideal for cloud and containerized environments.
- **Enhanced Security**: Smaller runtime and reduced attack surface.

---

## üåü Prerequisites

Ensure you have the following:

- ‚òï **Java Development Kit (JDK)** 17+
- üõ† **GraalVM** installed with native-image support
- üïù **Maven** or **Gradle**
- üê≥ **Docker** for building container images (optional)

---

## üõ†Ô∏è Step 1: Add Dependencies

Add the GraalVM Native Build Tools plugin to your `pom.xml` or `build.gradle` file.

**Maven:**

```xml
&lt;plugin&gt;
    &lt;groupId&gt;org.graalvm.buildtools&lt;/groupId&gt;
    &lt;artifactId&gt;native-maven-plugin&lt;/artifactId&gt;
    &lt;version&gt;0.9.20&lt;/version&gt;
&lt;/plugin&gt;
```

**Gradle:**

```groovy
plugins {
    id &apos;org.graalvm.buildtools.native&apos; version &apos;0.9.20&apos;
}
```

---

## üìã Step 2: Write a REST Controller

Create a simple REST endpoint to test the native image functionality.

:::tabs
@tab Java [icon=java]

```java
package com.example.graalvmnative;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RestController;

@SpringBootApplication
@RestController
public class MyApplication {

    public static void main(String[] args) {
        SpringApplication.run(MyApplication.class, args);
    }

    @GetMapping(&quot;/greeting&quot;)
    public String greeting() {
        return &quot;Hello from GraalVM Native!&quot;;
    }
}
```

@tab Kotlin [icon=kotlin]

```kotlin
package com.example.graalvmnative

import org.springframework.boot.autoconfigure.SpringBootApplication
import org.springframework.boot.runApplication
import org.springframework.web.bind.annotation.GetMapping
import org.springframework.web.bind.annotation.RestController

@SpringBootApplication
@RestController
class MyApplication {

    @GetMapping(&quot;/greeting&quot;)
    fun greeting(): String = &quot;Hello from GraalVM Native!&quot;
}

fun main(args: Array&lt;String&gt;) {
    runApplication&lt;MyApplication&gt;(*args)
}
```

:::

---

## üìñ Step 3: Build a Native Image

### Using Maven

Run the following command to create a native image:

```bash
mvn -Pnative package
```

### Using Gradle

Run the following command:

```bash
gradle nativeCompile
```

---

## üê≥ Step 4: Build a Docker Image

Spring Boot provides built-in support for creating Docker images with native executables.

### Maven Command:

```bash
mvn -Pnative spring-boot:build-image
```

### Gradle Command:

```bash
gradle bootBuildImage
```

The Docker image will be available locally and can be run using:

```bash
docker run --rm -p 8080:8080 myproject:0.0.1-SNAPSHOT
```

---

## ‚ñ∂Ô∏è Running the Application

### Running Locally

You can run the native image directly:

```bash
./target/myproject
```

### Running in Docker

If you built the Docker image, run it using:

```bash
docker run --rm -p 8080:8080 myproject:0.0.1-SNAPSHOT
```

---

## üß™ Testing the API

Test the REST endpoint using cURL or Postman:

```bash
curl -X GET http://localhost:8080/greeting
```

Expected output:

```plaintext
Hello from GraalVM Native!
```

---

Spring Boot with GraalVM Native offers significant performance improvements and resource savings, making it an excellent choice for cloud-native and containerized applications.
&lt;/div&gt;]]&gt;</content:encoded>
        </item>
        <item>
            <title><![CDATA[Building APIs with Spring for GraphQL]]></title>
            <description><![CDATA[Learn how to build GraphQL APIs using Spring for GraphQL with Java and Kotlin. Includes schema creation, query handling, and integration.]]></description>
            <link>https://susimsek.github.io/blog/posts/spring-boot-graphql</link>
            <guid isPermaLink="false">https://susimsek.github.io/blog/posts/spring-boot-graphql</guid>
            <pubDate>Sun, 15 Dec 2024 00:00:00 GMT</pubDate>
            <enclosure url="https://susimsek.github.io/blog/images/spring-boot-graphql-thumbnail.jpg" length="0" type="image/jpeg"/>
            <content:encoded>&lt;![CDATA[&lt;div&gt;
Spring for GraphQL simplifies the development of GraphQL APIs by integrating with Spring Boot. This guide demonstrates how to create a GraphQL API using Java and Kotlin, with examples for schema definition, query handling, and dependency injection.

---

## üåü Why Use GraphQL?

GraphQL allows clients to request specific data, reducing over-fetching and under-fetching compared to REST. It also supports strong typing and facilitates efficient data fetching, making it a popular choice for modern APIs.

---

## üåü Prerequisites

üìã Ensure you have the following:

- ‚òï **Java Development Kit (JDK)** 17+
- üì¶ **Maven or Gradle** installed
- üî§ A **Java IDE** (e.g., IntelliJ IDEA, Eclipse)

---

## üõ†Ô∏è Step 1: Add Dependencies

Include the following dependencies in your project to enable Spring for GraphQL.

- **Maven:**

```xml
&lt;dependency&gt;
  &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
  &lt;artifactId&gt;spring-boot-starter-graphql&lt;/artifactId&gt;
&lt;/dependency&gt;
```

- **Gradle:**

```groovy
implementation &apos;org.springframework.boot:spring-boot-starter-graphql&apos;
```

---

## üìã Step 2: Define the GraphQL Schema

Create a schema file named `schema.graphqls` under the `src/main/resources/graphql` directory.

```graphql
type Query {
  getUser(id: ID!): User
  getUsers: [User]
}

type User {
  id: ID!
  name: String!
  email: String!
}
```

---

## üìñ Step 3: Implement the Data Model and Services

Define the data model and service layer for handling queries.

:::tabs
@tab Java [icon=java]

### Entity

```java
package com.example.demo.model;

import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;

@Data
@NoArgsConstructor
@AllArgsConstructor
public class User {
    private String id;
    private String name;
    private String email;
}
```

### Service

```java
package com.example.demo.service;

import com.example.demo.model.User;
import org.springframework.stereotype.Service;

import java.util.List;
import java.util.Map;
import java.util.stream.Collectors;
import java.util.stream.Stream;

@Service
public class UserService {

    private final Map&lt;String, User&gt; userData = Stream.of(
        new User(&quot;1&quot;, &quot;Alice&quot;, &quot;alice@example.com&quot;),
        new User(&quot;2&quot;, &quot;Bob&quot;, &quot;bob@example.com&quot;)
    ).collect(Collectors.toMap(User::getId, user -&gt; user));

    public User getUser(String id) {
        return userData.get(id);
    }

    public List&lt;User&gt; getUsers() {
        return List.copyOf(userData.values());
    }
}
```

---

@tab Kotlin [icon=kotlin]

### Entity

```kotlin
package com.example.demo.model

data class User(
    val id: String,
    val name: String,
    val email: String
)
```

### Service

```kotlin
package com.example.demo.service

import com.example.demo.model.User
import org.springframework.stereotype.Service

@Service
class UserService {

    private val userData = mapOf(
        &quot;1&quot; to User(&quot;1&quot;, &quot;Alice&quot;, &quot;alice@example.com&quot;),
        &quot;2&quot; to User(&quot;2&quot;, &quot;Bob&quot;, &quot;bob@example.com&quot;)
    )

    fun getUser(id: String): User? = userData[id]

    fun getUsers(): List&lt;User&gt; = userData.values.toList()
}
```

:::

---

## üìò Step 4: Implement GraphQL Controllers

Controllers handle GraphQL queries and mutations. Use the `@Controller` annotation in Spring for GraphQL.

:::tabs
@tab Java [icon=java]

```java
package com.example.demo.controller;

import com.example.demo.model.User;
import com.example.demo.service.UserService;
import lombok.RequiredArgsConstructor;
import org.springframework.graphql.data.method.annotation.QueryMapping;
import org.springframework.stereotype.Controller;

import java.util.List;

@Controller
@RequiredArgsConstructor
public class UserController {

    private final UserService userService;

    @QueryMapping
    public User getUser(String id) {
        return userService.getUser(id);
    }

    @QueryMapping
    public List&lt;User&gt; getUsers() {
        return userService.getUsers();
    }
}
```

---

@tab Kotlin [icon=kotlin]

```kotlin
package com.example.demo.controller

import com.example.demo.model.User
import com.example.demo.service.UserService
import org.springframework.graphql.data.method.annotation.QueryMapping
import org.springframework.stereotype.Controller

@Controller
class UserController(
    private val userService: UserService
) {

    @QueryMapping
    fun getUser(id: String): User? = userService.getUser(id)

    @QueryMapping
    fun getUsers(): List&lt;User&gt; = userService.getUsers()
}
```

:::

---

## ‚ñ∂Ô∏è Running the Application

Run the application using the following commands:

- **Spring Boot (Java/Kotlin):**

  ```bash
  ./mvnw spring-boot:run
  ```

Access the GraphQL Playground at `http://localhost:8080/graphiql` to test your API.

---

## üß™ Testing the GraphQL API

Here are some example queries to test your API:

- **Fetch a user by ID:**

```graphql
query {
  getUser(id: &quot;1&quot;) {
    id
    name
    email
  }
}
```

- **Fetch all users:**

```graphql
query {
  getUsers {
    id
    name
    email
  }
}
```

---

This guide demonstrates how to build powerful and flexible GraphQL APIs using Spring for GraphQL with Java and Kotlin. Leverage GraphQL‚Äôs advantages to make your project more efficient and user-friendly.
&lt;/div&gt;]]&gt;</content:encoded>
        </item>
        <item>
            <title><![CDATA[Spring Boot Kafka Integration]]></title>
            <description><![CDATA[Learn how to integrate Apache Kafka with Spring Boot to send and consume JSON messages through Kafka topics.]]></description>
            <link>https://susimsek.github.io/blog/posts/spring-boot-kafka</link>
            <guid isPermaLink="false">https://susimsek.github.io/blog/posts/spring-boot-kafka</guid>
            <pubDate>Wed, 25 Dec 2024 00:00:00 GMT</pubDate>
            <enclosure url="https://susimsek.github.io/blog/images/spring-boot-kafka-thumbnail.jpg" length="0" type="image/jpeg"/>
            <content:encoded>&lt;![CDATA[&lt;div&gt;
Apache Kafka is a distributed event streaming platform that facilitates real-time data processing. This guide demonstrates how to send and consume JSON messages in a Spring Boot application using Kafka.

---

## üåü Why Use Kafka?

- **Scalable Messaging:** Handle large volumes of data seamlessly.
- **Fault Tolerance:** Ensure data durability and high availability.
- **Real-Time Processing:** Process and analyze data in real time.
- **Integration:** Easily integrate Kafka with Spring Boot for efficient development.

---

## üåü Prerequisites

üïä Ensure you have the following:

- ‚òï **Java Development Kit (JDK)** 17+
- üì¶ **Maven or Gradle** installed
- üî† A **Java IDE** (e.g., IntelliJ IDEA, Eclipse)
- üî† **Apache Kafka** installed and running

---

## üõ†Ô∏è Step 1: Add Dependencies

To integrate Kafka into your Spring Boot project, add the following dependencies:

- **Maven:**

```xml
&lt;dependency&gt;
  &lt;groupId&gt;org.springframework.kafka&lt;/groupId&gt;
  &lt;artifactId&gt;spring-kafka&lt;/artifactId&gt;
&lt;/dependency&gt;
```

- **Gradle:**

```groovy
implementation &apos;org.springframework.kafka:spring-kafka&apos;
```

---

## üìã Step 2: Configure Kafka

Set up Kafka connection in your `application.properties` or `application.yml` file:

```properties
spring.kafka.bootstrap-servers=localhost:9092
spring.kafka.consumer.group-id=my-group
spring.kafka.consumer.auto-offset-reset=earliest
spring.kafka.producer.key-serializer=org.apache.kafka.common.serialization.StringSerializer
spring.kafka.producer.value-serializer=org.springframework.kafka.support.serializer.JsonSerializer
spring.kafka.consumer.value-deserializer=org.springframework.kafka.support.serializer.JsonDeserializer
spring.kafka.consumer.properties.spring.json.trusted.packages=*
```

---

## üìñ Step 3: Create a Model for JSON Messages

### Model Class

:::tabs
@tab Java [icon=java]

```java
package com.example.kafka.model;

import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;

@Data
@NoArgsConstructor
@AllArgsConstructor
public class Message {
    private String id;
    private String content;
}
```

@tab Kotlin [icon=kotlin]

```kotlin
package com.example.kafka.model

data class Message(
    val id: String,
    val content: String
)
```

:::

---

## üìò Step 4: Implement Kafka Producer and Consumer

### Producer Example

:::tabs
@tab Java [icon=java]

```java
package com.example.kafka.producer;

import com.example.kafka.model.Message;
import lombok.RequiredArgsConstructor;
import org.springframework.kafka.core.KafkaTemplate;
import org.springframework.stereotype.Service;

@Service
@RequiredArgsConstructor
public class KafkaProducer {

    private final KafkaTemplate&lt;String, Message&gt; kafkaTemplate;

    public void sendMessage(String topic, Message message) {
        kafkaTemplate.send(topic, message);
    }
}
```

@tab Kotlin [icon=kotlin]

```kotlin
package com.example.kafka.producer

import com.example.kafka.model.Message
import org.springframework.kafka.core.KafkaTemplate
import org.springframework.stereotype.Service

@Service
class KafkaProducer(private val kafkaTemplate: KafkaTemplate&lt;String, Message&gt;) {

    fun sendMessage(topic: String, message: Message) {
        kafkaTemplate.send(topic, message)
    }
}
```

:::

### Consumer Example

:::tabs
@tab Java [icon=java]

```java
package com.example.kafka.consumer;

import com.example.kafka.model.Message;
import org.springframework.kafka.annotation.KafkaListener;
import org.springframework.stereotype.Service;

@Service
public class KafkaConsumer {

    @KafkaListener(topics = &quot;my-topic&quot;, groupId = &quot;my-group&quot;)
    public void consumeMessage(Message message) {
        System.out.println(&quot;Received message: &quot; + message);
    }
}
```

@tab Kotlin [icon=kotlin]

```kotlin
package com.example.kafka.consumer

import com.example.kafka.model.Message
import org.springframework.kafka.annotation.KafkaListener
import org.springframework.stereotype.Service

@Service
class KafkaConsumer {

    @KafkaListener(topics = [&quot;my-topic&quot;], groupId = &quot;my-group&quot;)
    fun consumeMessage(message: Message) {
        println(&quot;Received message: $message&quot;)
    }
}
```

:::

---

## üîÑ Controller Example

:::tabs
@tab Java [icon=java]

```java
package com.example.kafka.controller;

import com.example.kafka.model.Message;
import com.example.kafka.producer.KafkaProducer;
import lombok.RequiredArgsConstructor;
import org.springframework.web.bind.annotation.*;

@RestController
@RequestMapping(&quot;/kafka&quot;)
@RequiredArgsConstructor
public class KafkaController {

    private final KafkaProducer kafkaProducer;

    @PostMapping(&quot;/publish&quot;)
    public String publishMessage(@RequestParam String topic, @RequestBody Message message) {
        kafkaProducer.sendMessage(topic, message);
        return &quot;Message sent to topic: &quot; + topic;
    }
}
```

@tab Kotlin [icon=kotlin]

```kotlin
package com.example.kafka.controller

import com.example.kafka.model.Message
import com.example.kafka.producer.KafkaProducer
import org.springframework.web.bind.annotation.*

@RestController
@RequestMapping(&quot;/kafka&quot;)
class KafkaController(private val kafkaProducer: KafkaProducer) {

    @PostMapping(&quot;/publish&quot;)
    fun publishMessage(@RequestParam topic: String, @RequestBody message: Message): String {
        kafkaProducer.sendMessage(topic, message)
        return &quot;Message sent to topic: $topic&quot;
    }
}
```

:::

---

## ‚ñ∂Ô∏è Running the Application

Run the application using the following command:

```bash
./mvnw spring-boot:run
```

---

## üß™ Testing the API

You can test the Kafka Producer endpoint using cURL or Postman:

```bash
curl -X POST &quot;http://localhost:8080/kafka/publish&quot; \
-H &quot;Content-Type: application/json&quot; \
-d &apos;{&quot;id&quot;: &quot;123&quot;, &quot;content&quot;: &quot;Hello Kafka!&quot;}&apos;
```

Check the Kafka Consumer logs to verify that the message was received and processed.

---

Integrating Kafka with Spring Boot simplifies the development of event-driven and messaging systems. With Kafka&apos;s robust features and Spring Boot&apos;s ease of use, you can build scalable, real-time applications efficiently.
&lt;/div&gt;]]&gt;</content:encoded>
        </item>
        <item>
            <title><![CDATA[Spring Boot with OpenAPI]]></title>
            <description><![CDATA[Learn how to integrate OpenAPI into your Spring Boot application for API documentation and testing using SpringDoc.]]></description>
            <link>https://susimsek.github.io/blog/posts/spring-boot-openapi</link>
            <guid isPermaLink="false">https://susimsek.github.io/blog/posts/spring-boot-openapi</guid>
            <pubDate>Fri, 20 Dec 2024 00:00:00 GMT</pubDate>
            <enclosure url="https://susimsek.github.io/blog/images/spring-boot-openapi-thumbnail.jpg" length="0" type="image/jpeg"/>
            <content:encoded>&lt;![CDATA[&lt;div&gt;
OpenAPI simplifies API documentation and testing by providing an interactive interface and machine-readable documentation. This guide will show you how to integrate OpenAPI into your Spring Boot application using SpringDoc.

---

## üåü Why Use OpenAPI?

- **Interactive Documentation**: Offers a user-friendly interface for exploring APIs.
- **Standardized Format**: Generates machine-readable API definitions.
- **Ease of Testing**: Provides built-in tools for testing endpoints.
- **Client Code Generation**: Allows automatic generation of client code for various programming languages.

---

## üåü Prerequisites

üìã Ensure you have the following:

- ‚òï **Java Development Kit (JDK)** 17+
- üì¶ **Maven or Gradle** installed
- üî§ A **Java IDE** (e.g., IntelliJ IDEA, Eclipse)

---

## üõ†Ô∏è Step 1: Add Dependencies

To integrate OpenAPI using SpringDoc, add the following dependency to your Spring Boot project:

- **Maven:**

```xml
&lt;dependency&gt;
  &lt;groupId&gt;org.springdoc&lt;/groupId&gt;
  &lt;artifactId&gt;springdoc-openapi-starter-webmvc-ui&lt;/artifactId&gt;
  &lt;version&gt;2.1.0&lt;/version&gt;
&lt;/dependency&gt;
```

- **Gradle:**

```groovy
implementation &apos;org.springdoc:springdoc-openapi-starter-webmvc-ui:2.1.0&apos;
```

---

## üìã Step 2: Configure OpenAPI

SpringDoc requires minimal configuration. You can customize your OpenAPI documentation using the `application.properties` or `application.yml` file.

### Example Configuration:

```properties
springdoc.api-docs.path=/api-docs
springdoc.swagger-ui.path=/swagger-ui.html
```

---

## üìñ Step 3: Annotate Your REST Controllers

Add annotations to your REST controllers and models to generate OpenAPI documentation automatically.

:::tabs
@tab Java [icon=java]

### Controller Example

```java
package com.example.openapi.controller;

import com.example.openapi.model.User;
import io.swagger.v3.oas.annotations.Operation;
import io.swagger.v3.oas.annotations.media.Content;
import io.swagger.v3.oas.annotations.responses.ApiResponse;
import org.springframework.web.bind.annotation.*;

import java.util.List;

@RestController
@RequestMapping(&quot;/users&quot;)
public class UserController {

  @Operation(summary = &quot;Get all users&quot;, description = &quot;Retrieve a list of users&quot;)
  @ApiResponse(responseCode = &quot;200&quot;, description = &quot;Successful operation&quot;,
    content = @Content(mediaType = &quot;application/json&quot;))
  @GetMapping
  public List&lt;User&gt; getAllUsers() {
    return List.of(new User(1L, &quot;John Doe&quot;, &quot;john@example.com&quot;));
  }

  @Operation(summary = &quot;Create a new user&quot;, description = &quot;Add a new user to the system&quot;)
  @ApiResponse(responseCode = &quot;201&quot;, description = &quot;User created successfully&quot;,
    content = @Content(mediaType = &quot;application/json&quot;))
  @PostMapping
  public User createUser(@RequestBody User user) {
    return user;
  }
}
```

### User Model

```java
package com.example.openapi.model;

import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;

@Data
@NoArgsConstructor
@AllArgsConstructor
public class User {

    private Long id;
    private String name;
    private String email;
}
```

@tab Kotlin [icon=kotlin]

### Controller Example

```kotlin
package com.example.openapi.controller

import com.example.openapi.model.User
import io.swagger.v3.oas.annotations.*
import io.swagger.v3.oas.annotations.responses.*
import io.swagger.v3.oas.annotations.media.*
import org.springframework.web.bind.annotation.*

@RestController
@RequestMapping(&quot;/users&quot;)
class UserController {

    @Operation(summary = &quot;Get all users&quot;, description = &quot;Retrieve a list of users&quot;)
    @ApiResponse(responseCode = &quot;200&quot;, description = &quot;Successful operation&quot;,
                 content = [Content(mediaType = &quot;application/json&quot;)])
    @GetMapping
    fun getAllUsers(): List&lt;User&gt; = listOf(User(1L, &quot;John Doe&quot;, &quot;john@example.com&quot;))

    @Operation(summary = &quot;Create a new user&quot;, description = &quot;Add a new user to the system&quot;)
    @ApiResponse(responseCode = &quot;201&quot;, description = &quot;User created successfully&quot;,
                 content = [Content(mediaType = &quot;application/json&quot;)])
    @PostMapping
    fun createUser(@RequestBody user: User): User = user
}
```

### User Model

```kotlin
package com.example.openapi.model

data class User(
  val id: Long,
  val name: String,
  val email: String
)
```

:::

---

## ‚ñ∂Ô∏è Running the Application

Run the application using the following command:

```bash
./mvnw spring-boot:run
```

Access the OpenAPI documentation at:

- **API Docs:** `http://localhost:8080/api-docs`
- **Swagger UI:** `http://localhost:8080/swagger-ui.html`

---

## üß™ Testing the API

You can test the generated API documentation by exploring the Swagger UI interface:

1. Navigate to `http://localhost:8080/swagger-ui.html` in your browser.
2. Test endpoints interactively by providing inputs and observing responses.

---

Integrating OpenAPI with Spring Boot streamlines API documentation and testing. Using SpringDoc, you can effortlessly generate and explore interactive documentation, making your APIs easier to understand and consume.
&lt;/div&gt;]]&gt;</content:encoded>
        </item>
        <item>
            <title><![CDATA[Spring Boot Redis Caching]]></title>
            <description><![CDATA[Learn how to implement Redis caching in your Spring Boot application to improve performance and efficiency.]]></description>
            <link>https://susimsek.github.io/blog/posts/spring-boot-redis-caching</link>
            <guid isPermaLink="false">https://susimsek.github.io/blog/posts/spring-boot-redis-caching</guid>
            <pubDate>Sun, 22 Dec 2024 00:00:00 GMT</pubDate>
            <enclosure url="https://susimsek.github.io/blog/images/spring-boot-redis-thumbnail.jpg" length="0" type="image/jpeg"/>
            <content:encoded>&lt;![CDATA[&lt;div&gt;
Redis is a powerful in-memory data store often used for caching, messaging, and real-time data management. This guide explains how to integrate Redis into a Spring Boot application using both Java and Kotlin.

---

## üåü Why Use Redis?

- **High Performance**: Redis provides extremely low latency for read and write operations.
- **Versatile Data Structures**: Supports strings, hashes, lists, sets, and more.
- **Scalability**: Ideal for distributed caching and real-time analytics.
- **Integration**: Easily integrates with Spring Boot for seamless development.

---

## üåü Prerequisites

üóà Ensure you have the following:

- ‚òï **Java Development Kit (JDK)** 17+
- üì¶ **Maven or Gradle** installed
- üî§ A **Java IDE** (e.g., IntelliJ IDEA, Eclipse)
- üí† **Redis Server** installed and running locally or accessible via a network

---

## üõ†Ô∏è Step 1: Add Dependencies

To integrate Redis into your Spring Boot project, add the following dependencies:

- **Maven:**

```xml
&lt;dependency&gt;
  &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
  &lt;artifactId&gt;spring-boot-starter-data-redis&lt;/artifactId&gt;
&lt;/dependency&gt;
```

- **Gradle:**

```groovy
implementation &apos;org.springframework.boot:spring-boot-starter-data-redis&apos;
```

---

## üìã Step 2: Configure Redis

Set up the Redis connection in your `application.properties` or `application.yml` file.

### Example Configuration:

```properties
spring.redis.host=localhost
spring.redis.port=6379
```

For advanced setups, such as password authentication or SSL, add these properties:

```properties
spring.redis.password=yourpassword
spring.redis.ssl=true
```

---

## üîí Step 3: Enable Caching

Add the `@EnableCaching` annotation to your main application class to enable Spring&apos;s caching abstraction.

:::tabs
@tab Java [icon=java]

```java
package com.example.redis;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;
import org.springframework.cache.annotation.EnableCaching;

@SpringBootApplication
@EnableCaching
public class RedisApplication {
  public static void main(String[] args) {
    SpringApplication.run(RedisApplication.class, args);
  }
}
```

@tab Kotlin [icon=kotlin]

```kotlin
package com.example.redis

import org.springframework.boot.autoconfigure.SpringBootApplication
import org.springframework.boot.runApplication
import org.springframework.cache.annotation.EnableCaching

@SpringBootApplication
@EnableCaching
class RedisApplication

fun main(args: Array&lt;String&gt;) {
  runApplication&lt;RedisApplication&gt;(*args)
}
```

:::

---

## üîñ Step 4: Service Layer Example with Caching

:::tabs
@tab Java [icon=java]

```java
package com.example.redis.service;

import org.springframework.cache.annotation.Cacheable;
import org.springframework.stereotype.Service;

@Service
public class UserService {

  @Cacheable(&quot;users&quot;)
  public String getUserById(String id) {
    simulateSlowService();
    return &quot;User with ID: &quot; + id;
  }

  private void simulateSlowService() {
    try {
      Thread.sleep(3000L);
    } catch (InterruptedException e) {
      throw new IllegalStateException(e);
    }
  }
}
```

@tab Kotlin [icon=kotlin]

```kotlin
package com.example.redis.service

import org.springframework.cache.annotation.Cacheable
import org.springframework.stereotype.Service

@Service
class UserService {

  @Cacheable(&quot;users&quot;)
  fun getUserById(id: String): String {
    simulateSlowService()
    return &quot;User with ID: $id&quot;
  }

  private fun simulateSlowService() {
    Thread.sleep(3000L)
  }
}
```

:::

---

## üî¢ Configuring TTL (Time-To-Live)

Set the cache expiration time in your `application.properties` file:

```properties
spring.cache.redis.time-to-live=600000
```

This sets the TTL to 10 minutes (600,000 milliseconds).

---

## üî¢ Controller Example

Create a REST controller to expose the caching functionality.

:::tabs
@tab Java [icon=java]

```java
package com.example.redis.controller;

import com.example.redis.service.UserService;
import lombok.RequiredArgsConstructor;
import org.springframework.web.bind.annotation.*;

@RestController
@RequestMapping(&quot;/users&quot;)
@RequiredArgsConstructor
public class UserController {

  private final UserService userService;

  @GetMapping(&quot;/{id}&quot;)
  public String getUser(@PathVariable String id) {
    return userService.getUserById(id);
  }
}
```

@tab Kotlin [icon=kotlin]

```kotlin
package com.example.redis.controller

import com.example.redis.service.UserService
import org.springframework.web.bind.annotation.*

@RestController
@RequestMapping(&quot;/users&quot;)
class UserController(
  private val userService: UserService
) {
  @GetMapping(&quot;/{id}&quot;)
  fun getUser(@PathVariable id: String): String = userService.getUserById(id)
}
```

:::

---

## ‚ñ∂Ô∏è Running the Application

Run the application using the following command:

```bash
./mvnw spring-boot:run
```

---

## üß™ Testing the API

You can test the API using cURL or Postman:

- **Fetch a User (cached):**

```bash
curl -X GET http://localhost:8080/users/1
```

Make subsequent requests to observe faster responses due to caching.

---

Integrating Redis with Spring Boot enables high-performance caching and efficient resource management. By using Spring‚Äôs caching abstraction and configuring TTL, you can optimize your application‚Äôs performance effectively.
&lt;/div&gt;]]&gt;</content:encoded>
        </item>
    </channel>
</rss>