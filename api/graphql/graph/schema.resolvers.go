package graph

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.81

import (
	"context"
	"fmt"
	"strings"

	"suaybsimsek.com/blog-api/api/graphql/graph/generated"
	"suaybsimsek.com/blog-api/api/graphql/graph/model"
	postsapi "suaybsimsek.com/blog-api/internal/posts"
	topicsapi "suaybsimsek.com/blog-api/internal/topics"
)

// Posts is the resolver for the posts field.
func (r *queryResolver) Posts(ctx context.Context, locale string, input *model.PostsQueryInput) (*model.PostConnection, error) {
	normalizedLocale := strings.TrimSpace(locale)
	if normalizedLocale == "" {
		return nil, fmt.Errorf("locale is required")
	}

	queryInput := postsapi.ContentQueryInput{
		Locale: normalizedLocale,
	}
	if input != nil {
		if input.Q != nil {
			queryInput.Query = strings.TrimSpace(*input.Q)
		}
		if input.Page != nil {
			queryInput.Page = input.Page
		}
		if input.Size != nil {
			queryInput.Size = input.Size
		}
		if sortOrder := mapSortOrder(input.Sort); sortOrder != "" {
			queryInput.Sort = sortOrder
		}
		if sourceFilter := mapSourceFilter(input.Source); sourceFilter != "" {
			queryInput.Source = sourceFilter
		}
		if readingTime := mapReadingTime(input.ReadingTime); readingTime != "" {
			queryInput.ReadingTime = readingTime
		}
		if input.StartDate != nil {
			queryInput.StartDate = strings.TrimSpace(*input.StartDate)
		}
		if input.EndDate != nil {
			queryInput.EndDate = strings.TrimSpace(*input.EndDate)
		}
		queryInput.Topics = append([]string{}, input.Topics...)
		queryInput.ScopeIDs = append([]string{}, input.ScopeIds...)
	}

	payload := postsapi.QueryContent(ctx, queryInput)
	status := strings.TrimSpace(payload.Status)
	if status == "" {
		status = "success"
	}

	total := payload.Total
	if total < 0 {
		total = 0
	}

	page := payload.Page
	if page <= 0 {
		page = 1
	}

	size := payload.Size
	if size <= 0 {
		size = len(payload.Posts)
		if size <= 0 {
			size = 1
		}
	}

	return &model.PostConnection{
		Status:      status,
		Locale:      toOptionalString(payload.Locale),
		Nodes:       mapPosts(payload.Posts),
		Engagement:  mapEngagement(payload.LikesByPostID, payload.HitsByPostID),
		Total:       total,
		Page:        page,
		Size:        size,
		Sort:        toOptionalString(payload.Sort),
		SearchQuery: toOptionalString(payload.Query),
	}, nil
}

// Topics is the resolver for the topics field.
func (r *queryResolver) Topics(ctx context.Context, locale string) (*model.TopicConnection, error) {
	normalizedLocale := strings.TrimSpace(locale)
	if normalizedLocale == "" {
		return nil, fmt.Errorf("locale is required")
	}

	payload := topicsapi.QueryTopics(ctx, normalizedLocale)
	status := strings.TrimSpace(payload.Status)
	if status == "" {
		status = "success"
	}

	return &model.TopicConnection{
		Status: status,
		Locale: toOptionalString(payload.Locale),
		Nodes:  mapTopicsFromTopicRecords(payload.Topics),
	}, nil
}

// IncrementPostLike is the resolver for the incrementPostLike field.
func (r *mutationResolver) IncrementPostLike(ctx context.Context, postID string) (*model.PostMetricResult, error) {
	payload := postsapi.IncrementLike(ctx, postID)
	resolvedPostID := strings.TrimSpace(payload.PostID)
	if resolvedPostID == "" {
		resolvedPostID = strings.TrimSpace(postID)
	}

	result := &model.PostMetricResult{
		Status: strings.TrimSpace(payload.Status),
		PostID: resolvedPostID,
	}
	if result.Status == "" {
		result.Status = "failed"
	}
	if payload.Likes > 0 || result.Status == "success" {
		likes := toGraphQLInt(payload.Likes)
		result.Likes = &likes
	}
	if payload.Hits > 0 || result.Status == "success" {
		hits := toGraphQLInt(payload.Hits)
		result.Hits = &hits
	}

	return result, nil
}

// IncrementPostHit is the resolver for the incrementPostHit field.
func (r *mutationResolver) IncrementPostHit(ctx context.Context, postID string) (*model.PostMetricResult, error) {
	payload := postsapi.IncrementHit(ctx, postID)
	resolvedPostID := strings.TrimSpace(payload.PostID)
	if resolvedPostID == "" {
		resolvedPostID = strings.TrimSpace(postID)
	}

	result := &model.PostMetricResult{
		Status: strings.TrimSpace(payload.Status),
		PostID: resolvedPostID,
	}
	if result.Status == "" {
		result.Status = "failed"
	}
	if payload.Likes > 0 || result.Status == "success" {
		likes := toGraphQLInt(payload.Likes)
		result.Likes = &likes
	}
	if payload.Hits > 0 || result.Status == "success" {
		hits := toGraphQLInt(payload.Hits)
		result.Hits = &hits
	}

	return result, nil
}

// Mutation returns generated.MutationResolver implementation.
func (r *Resolver) Mutation() generated.MutationResolver { return &mutationResolver{r} }

// Query returns generated.QueryResolver implementation.
func (r *Resolver) Query() generated.QueryResolver { return &queryResolver{r} }

type mutationResolver struct{ *Resolver }
type queryResolver struct{ *Resolver }
